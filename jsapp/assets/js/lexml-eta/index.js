/**
 * Collection of shared Symbol objects for internal component communication.
 *
 * The shared `Symbol` objects in this module let mixins and a component
 * internally communicate without exposing these internal properties and methods
 * in the component's public API. They also help avoid unintentional name
 * collisions, as a component developer must specifically import the `internal`
 * module and reference one of its symbols.
 *
 * To use these `Symbol` objects in your own component, include this module and
 * then create a property or method whose key is the desired Symbol. E.g.,
 * [ShadowTemplateMixin](ShadowTemplateMixin) expects a component to define
 * a property called [template](#template):
 *
 *     import { template } from 'elix/src/core/internal.js';
 *     import { templateFrom } from 'elix/src/core/htmlLiterals.js'
 *     import ShadowTemplateMixin from 'elix/src/core/ShadowTemplateMixin.js';
 *
 *     class MyElement extends ShadowTemplateMixin(HTMLElement) {
 *       [template]() {
 *         return templateFrom.html`Hello, <em>world</em>.`;
 *       }
 *     }
 *
 * The above use of the internal `template` member lets the mixin find the
 * component's template in a way that will not pollute the component's public
 * API or interfere with other component logic. For example, if for some reason
 * the component wants to define a separate property with the plain string name,
 * "template", it can do so without affecting the above property setter.
 *
 * @module internal
 */

/**
 * Symbol for the default state for this element.
 */
const defaultState$1 = Symbol("defaultState");

/**
 * Symbol for the `delegatesFocus` property.
 *
 * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property, returning
 * true to indicate that the focus is being delegated, even in browsers that
 * don't support that natively. Mixins like [KeyboardMixin](KeyboardMixin) use
 * this to accommodate focus delegation.
 */
const delegatesFocus$1 = Symbol("delegatesFocus");

/**
 * Symbol for the `firstRender` property.
 *
 * [ReactiveMixin](ReactiveMixin) sets the property to `true` during the
 * element's first `render` and `rendered` callback, then `false` in subsequent
 * callbacks.
 *
 * You can inspect this property in your own `rendered` callback handler to do
 * work like wiring up events that should only happen once.
 */
const firstRender$1 = Symbol("firstRender");

/**
 * Symbol for the `focusTarget` property.
 *
 * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property as either:
 * 1) the element itself, in browsers that support native focus delegation or,
 * 2) the shadow root's first focusable element.
 */
const focusTarget$1 = Symbol("focusTarget");

/**
 * Symbol for the `hasDynamicTemplate` property.
 *
 * If your component class does not always use the same template, define a
 * static class property getter with this symbol and have it return `true`.
 * This will disable template caching for your component.
 */
const hasDynamicTemplate$1 = Symbol("hasDynamicTemplate");

/**
 * Symbol for the `ids` property.
 *
 * [ShadowTemplateMixin](ShadowTemplateMixin) defines a shorthand function
 * `internal.ids` that can be used to obtain a reference to a shadow element with
 * a given ID.
 *
 * Example: if component's template contains a shadow element
 * `<button id="foo">`, you can use the reference `this[ids].foo` to obtain
 * the corresponding button in the component instance's shadow tree.
 * The `ids` function is simply a shorthand for `getElementById`, so
 * `this[ids].foo` is the same as `this.shadowRoot.getElementById('foo')`.
 */
const ids$1 = Symbol("ids");

/**
 * Symbol for access to native HTML element internals.
 */
const nativeInternals$1 = Symbol("nativeInternals");

/**
 * Symbol for the `raiseChangeEvents` property.
 *
 * This property is used by mixins to determine whether they should raise
 * property change events. The standard HTML pattern is to only raise such
 * events in response to direct user interactions. For a detailed discussion
 * of this point, see the Gold Standard checklist item for
 * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).
 *
 * The above article describes a pattern for using a flag to track whether
 * work is being performed in response to internal component activity, and
 * whether the component should therefore raise property change events.
 * This `raiseChangeEvents` symbol is a shared flag used for that purpose by
 * all Elix mixins and components. Sharing this flag ensures that internal
 * activity (e.g., a UI event listener) in one mixin can signal other mixins
 * handling affected properties to raise change events.
 *
 * All UI event listeners (and other forms of internal handlers, such as
 * timeouts and async network handlers) should set `raiseChangeEvents` to
 * `true` at the start of the event handler, then `false` at the end:
 *
 *     this.addEventListener('click', event => {
 *       this[raiseChangeEvents] = true;
 *       // Do work here, possibly setting properties, like:
 *       this.foo = 'Hello';
 *       this[raiseChangeEvents] = false;
 *     });
 *
 * Elsewhere, property setters that raise change events should only do so it
 * this property is `true`:
 *
 *     set foo(value) {
 *       // Save foo value here, do any other work.
 *       if (this[raiseChangeEvents]) {
 *         export const event = new CustomEvent('foochange');
 *         this.dispatchEvent(event);
 *       }
 *     }
 *
 * In this way, programmatic attempts to set the `foo` property will not trigger
 * the `foochange` event, but UI interactions that update that property will
 * cause those events to be raised.
 */
const raiseChangeEvents$1 = Symbol("raiseChangeEvents");

/**
 * Symbol for the `render` method.
 *
 * [ReactiveMixin](ReactiveMixin) invokes this `internal.render` method to give
 * the component a chance to render recent changes in component state.
 */
const render$1 = Symbol("render");

/**
 * Symbol for the `renderChanges` method.
 *
 * [ReactiveMixin](ReactiveMixin) invokes this method in response to a
 * `setState` call; you should generally not invoke this method yourself.
 */
const renderChanges$1 = Symbol("renderChanges");

/**
 * Symbol for the `rendered` method.
 *
 * [ReactiveMixin](ReactiveMixin) will invoke this method after your
 * element has completely finished rendering.
 *
 * If you only want to do work the first time rendering happens (for example, if
 * you want to wire up event handlers), your `internal.rendered` implementation
 * can inspect the `internal.firstRender` flag.
 */
const rendered$1 = Symbol("rendered");

/**
 * Symbol for the `rendering` property.
 *
 * [ReactiveMixin](ReactiveMixin) sets this property to true during rendering,
 * at other times it will be false.
 */
const rendering$1 = Symbol("rendering");

/**
 * Symbol for the `setState` method.
 *
 * A component using [ReactiveMixin](ReactiveMixin) can invoke this method to
 * apply changes to the element's current state.
 */
const setState$1 = Symbol("setState");

/**
 * Symbol for the `shadowRoot` property.
 *
 * This property holds a reference to an element's shadow root, like
 * `this.shadowRoot`. This propery exists because `this.shadowRoot` is not
 * available for components with closed shadow roots.
 * [ShadowTemplateMixin](ShadowTemplateMixin) creates open shadow roots by
 * default, but you can opt into creating closed shadow roots; see
 * [shadowRootMode](internal#internal.shadowRootMode).
 */
const shadowRoot$1 = Symbol("shadowRoot");

/**
 * Symbol for the `shadowRootMode` property.
 *
 * If true (the default), then [ShadowTemplateMixin](ShadowTemplateMixin) will
 * create an open shadow root when the component is instantiated. Set this to
 * false if you want to programmatically hide component internals in a closed
 * shadow root.
 */
const shadowRootMode$1 = Symbol("shadowRootMode");

/**
 * Symbol for the element's current state.
 *
 * This is managed by [ReactiveMixin](ReactiveMixin).
 */
const state$1 = Symbol("state");

/**
 * Symbol for the `stateEffects` method.
 *
 * See [stateEffects](ReactiveMixin#stateEffects).
 */
const stateEffects$1 = Symbol("stateEffects");

/**
 * Symbol for the `template` method.
 *
 * [ShadowTemplateMixin](ShadowTemplateMixin) uses this property to obtain a
 * component's template, which it will clone into a component's shadow root.
 */
const template$1 = Symbol("template");

/**
 * Given a string value for a named boolean attribute, return `true` if the
 * value is either: a) the empty string, or b) a case-insensitive match for the
 * name.
 *
 * This is native HTML behavior; see the MDN documentation on [boolean
 * attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes#Boolean_Attributes)
 * for the reasoning.
 *
 * Given a null value, this return `false`.
 * Given a boolean value, this return the value as is.
 *
 * @param {string} name
 * @param {string|boolean|null} value
 */
function booleanAttributeValue(name, value) {
  return typeof value === "boolean"
    ? value
    : typeof value === "string"
    ? value === "" || name.toLowerCase() === value.toLowerCase()
    : false;
}

/**
 * Return the closest focusable node that's either the node itself (if it's
 * focusable), or the closest focusable ancestor in the *composed* tree.
 *
 * If no focusable node is found, this returns null.
 *
 * @param {Node} node
 * @returns {HTMLElement|null}
 */
function closestFocusableNode(node) {
  for (const current of selfAndComposedAncestors(node)) {
    // If the current element defines a focusTarget (e.g., via
    // DelegateFocusMixin), use that, otherwise use the element itself.
    const target = current[focusTarget$1] || current;
    // We want an element that has a tabIndex of 0 or more. We ignore disabled
    // elements, and slot elements (which oddly have a tabIndex of 0).
    /** @type {any} */ const cast = target;
    const focusable =
      target instanceof HTMLElement &&
      target.tabIndex >= 0 &&
      !cast.disabled &&
      !(target instanceof HTMLSlotElement);
    if (focusable) {
      return target;
    }
  }
  return null;
}

/**
 * Return the ancestors of the given node in the composed tree.
 *
 * In the composed tree, the ancestor of a node assigned to a slot is that slot,
 * not the node's DOM ancestor. The ancestor of a shadow root is its host.
 *
 * @param {Node} node
 * @returns {Iterable<Node>}
 */
function* composedAncestors(node) {
  /** @type {Node|null} */
  let current = node;
  while (true) {
    current =
      current instanceof HTMLElement && current.assignedSlot
        ? current.assignedSlot
        : current instanceof ShadowRoot
        ? current.host
        : current.parentNode;
    if (current) {
      yield current;
    } else {
      break;
    }
  }
}

/**
 * Returns true if the first node contains the second, even if the second node
 * is in a shadow tree.
 *
 * The standard Node.contains() function does not account for Shadow DOM, and
 * returns false if the supplied target node is sitting inside a shadow tree
 * within the container.
 *
 * @param {Node} container - The container to search within.
 * @param {Node} target - The node that may be inside the container.
 * @returns {boolean} - True if the container contains the target node.
 */
function deepContains(container, target) {
  /** @type {any} */
  let current = target;
  while (current) {
    const parent = current.assignedSlot || current.parentNode || current.host;
    if (parent === container) {
      return true;
    }
    current = parent;
  }
  return false;
}

/**
 * Return the first focusable element in the composed tree below the given root.
 * The composed tree includes nodes assigned to slots.
 *
 * This heuristic considers only the document order of the elements below the
 * root and whether a given element is focusable. It currently does not respect
 * the tab sort order defined by tabindex values greater than zero.
 *
 * @param {Node} root - the root of the tree in which to search
 * @returns {HTMLElement|null} - the first focusable element, or null if none
 * was found
 */
function firstFocusableElement(root) {
  // CSS selectors for focusable elements from
  // https://stackoverflow.com/a/30753870/76472
  const focusableQuery =
    'a[href],area[href],button:not([disabled]),details,iframe,input:not([disabled]),select:not([disabled]),textarea:not([disabled]),[contentEditable="true"],[tabindex]';
  // Walk the tree looking for nodes that match the above selectors.
  const walker = walkComposedTree(
    root,
    (/** @type {Node} */ node) =>
      node instanceof HTMLElement &&
      node.matches(focusableQuery) &&
      node.tabIndex >= 0
  );
  // We only actually need the first matching value.
  const { value } = walker.next();
  // value, if defined, will always be an HTMLElement, but we do the following
  // check to pass static type checking.
  return value instanceof HTMLElement ? value : null;
}

/**
 * Search a list element for the item that contains the specified target.
 *
 * When dealing with UI events (e.g., mouse clicks) that may occur in
 * subelements inside a list item, you can use this routine to obtain the
 * containing list item.
 *
 * @param {NodeList|Node[]} items - A list element containing a set of items
 * @param {Node} target - A target element that may or may not be an item in the
 * list.
 * @returns {number} - The index of the list child that is or contains the
 * indicated target node. Returns -1 if not found.
 */
function indexOfItemContainingTarget(items, target) {
  return Array.prototype.findIndex.call(
    items,
    (/** @type Node */ item) => item === target || deepContains(item, target)
  );
}

/**
 * Return true if the event came from within the node (or from the node itself);
 * false otherwise.
 *
 * @param {Node} node - The node to consider in relation to the event
 * @param {Event} event - The event which may have been raised within/by the
 * node
 * @returns {boolean} - True if the event was raised within or by the node
 */
function ownEvent(node, event) {
  /** @type {any} */
  const cast = event;
  const eventSource = cast.composedPath()[0];
  return node === eventSource || deepContains(node, eventSource);
}

/**
 * Returns the set that includes the given node and all of its ancestors in the
 * composed tree. See [composedAncestors](#composedAncestors) for details on the
 * latter.
 *
 * @param {Node} node
 * @returns {Iterable<Node>}
 */
function* selfAndComposedAncestors(node) {
  if (node) {
    yield node;
    yield* composedAncestors(node);
  }
}

/**
 * Set an internal state for browsers that support the `:state` selector, as
 * well as an attribute of the same name to permit state-based styling on older
 * browsers.
 *
 * When all browsers support that, we'd like to deprecate use of attributes.
 *
 * @param {Element} element
 * @param {string} name
 * @param {boolean} value
 */
function setInternalState(element, name, value) {
  element.toggleAttribute(name, value);
  if (element[nativeInternals$1] && element[nativeInternals$1].states) {
    element[nativeInternals$1].states.toggle(name, value);
  }
}

/** @type {IndexedObject<boolean>} */
const standardBooleanAttributes = {
  checked: true,
  defer: true,
  disabled: true,
  hidden: true,
  ismap: true,
  multiple: true,
  noresize: true,
  readonly: true,
  selected: true,
};

/**
 * Adds or removes the element's `childNodes` as necessary to match the nodes
 * indicated in the `childNodes` parameter.
 *
 * This operation is useful in cases where you maintain your own set of nodes
 * which should be rendered as the children of some element. When you insert or
 * remove nodes in that set, you can invoke this function to efficiently apply
 * the new set as a delta to the existing children. Only the items in the set
 * that have actually changed will be added or removed.
 *
 * @param {Element} element - the element to update
 * @param {(NodeList|Node[])} childNodes - the set of nodes to apply
 */
function updateChildNodes(element, childNodes) {
  // If the childNodes parameter is the actual childNodes of an element, then as
  // we append those nodes to the indicated target element, they'll get removed
  // from the original set. To keep the list stable, we make a copy.
  const copy = [...childNodes];

  const oldLength = element.childNodes.length;
  const newLength = copy.length;
  const length = Math.max(oldLength, newLength);
  for (let i = 0; i < length; i++) {
    const oldChild = element.childNodes[i];
    const newChild = copy[i];
    if (i >= oldLength) {
      // Add new item not in old set.
      element.append(newChild);
    } else if (i >= newLength) {
      // Remove old item past end of new set.
      element.removeChild(element.childNodes[newLength]);
    } else if (oldChild !== newChild) {
      if (copy.indexOf(oldChild, i) >= i) {
        // Old node comes later in final set. Insert the new node rather than
        // replacing it so that we don't detach the old node only to have to
        // reattach it later.
        element.insertBefore(newChild, oldChild);
      } else {
        // Replace old item with new item.
        element.replaceChild(newChild, oldChild);
      }
    }
  }
}

/**
 * Walk the composed tree at the root for elements that pass the given filter.
 *
 * Note: the jsDoc types required for the filter function are too complex for
 * the current jsDoc parser to support strong type-checking.
 *
 * @private
 * @param {Node} node
 * @param {function} filter
 * @returns {IterableIterator<Node>}
 */
function* walkComposedTree(node, filter) {
  if (filter(node)) {
    yield node;
  }
  let children;
  if (node instanceof HTMLElement && node.shadowRoot) {
    // Walk the shadow instead of the light DOM.
    children = node.shadowRoot.children;
  } else {
    const assignedNodes =
      node instanceof HTMLSlotElement
        ? node.assignedNodes({ flatten: true })
        : [];
    children =
      assignedNodes.length > 0
        ? // Walk light DOM nodes assigned to this slot.
          assignedNodes
        : // Walk light DOM children.
          node.childNodes;
  }
  if (children) {
    for (let i = 0; i < children.length; i++) {
      yield* walkComposedTree(children[i], filter);
    }
  }
}

/**
 * JavaScript template literals for constructing DOM nodes from HTML
 *
 * @module html
 */

/**
 * A JavaScript template string literal that returns an HTML document fragment.
 *
 * Example:
 *
 *     const fragment = fragmentFrom.html`Hello, <em>world</em>.`
 *
 * returns a `DocumentFragment` whose `innerHTML` is `Hello, <em>world</em>.`
 *
 * This function is called `html` so that it can be easily used with HTML
 * syntax-highlighting extensions for various popular code editors.
 *
 * See also [templateFrom.html](template#html), which returns a similar result but
 * as an HTMLTemplateElement.
 *
 * @param {TemplateStringsArray} strings - the strings passed to the JavaScript template
 * literal
 * @param {string[]} substitutions - the variable values passed to the
 * JavaScript template literal
 * @returns {DocumentFragment}
 */
const fragmentFrom = {
  html(strings, ...substitutions) {
    return templateFrom.html(strings, ...substitutions).content;
  },
};

/**
 * A JavaScript template string literal that returns an HTML template.
 *
 * Example:
 *
 *     const myTemplate = templateFrom.html`Hello, <em>world</em>.`
 *
 * returns an `HTMLTemplateElement` whose `innerHTML` is `Hello, <em>world</em>.`
 *
 * This function is called `html` so that it can be easily used with HTML
 * syntax-highlighting extensions for various popular code editors.
 *
 * See also [html](html), a helper which returns a similar result but as an
 * DocumentFragment.
 *
 * @param {TemplateStringsArray} strings - the strings passed to the JavaScript template
 * literal
 * @param {string[]} substitutions - the variable values passed to the
 * JavaScript template literal
 * @returns {HTMLTemplateElement}
 */
const templateFrom = {
  html(strings, ...substitutions) {
    const template = document.createElement("template");
    template.innerHTML = String.raw(strings, ...substitutions);
    return template;
  },
};

/**
 * Helpers for dynamically creating and patching component templates.
 *
 * The [ShadowTemplateMixin](ShadowTemplateMixin) lets you define a component
 * template that will be used to popuplate the shadow subtree of new component
 * instances. These helpers, especially the [html](#html) function, are intended
 * to simplify the creation of such templates.
 *
 * In particular, these helpers can be useful in [patching
 * templates](customizing#template-patching) inherited from a base class.
 *
 * Some of these functions take _descriptors_ that can either be a class, a tag
 * name, or an HTML template. These are generally used to fill specific roles in
 * an element's template; see [element roles](customizing#element-part-types).
 *
 * @module template
 */

// Used by registerCustomElement.
const mapBaseTagToCount = new Map();

/**
 * Create an element from a role descriptor (a component class constructor or
 * an HTML tag name).
 *
 * If the descriptor is an HTML template, and the resulting document fragment
 * contains a single top-level node, that node is returned directly (instead of
 * the fragment).
 *
 * @param {PartDescriptor} descriptor - the descriptor that will be used to
 * create the element
 * @returns {Element} the new element
 */
function createElement(descriptor) {
  if (typeof descriptor === "function") {
    // Instantiable component class constructor
    let element;
    try {
      element = new descriptor();
    } catch (e) {
      if (e.name === "TypeError") {
        // Most likely this error results from the fact that the indicated
        // component class hasn't been registered. Register it now with a random
        // name and try again.
        registerCustomElement(descriptor);
        element = new descriptor();
      } else {
        // The exception was for some other reason.
        throw e;
      }
    }
    return element;
    // @ts-ignore
  } else {
    // String tag name: e.g., 'div'
    return document.createElement(descriptor);
  }
}

/**
 * Register the indicated constructor as a custom element class.
 *
 * This function generates a suitable string tag for the class. If the
 * constructor is a named function (which is typical for hand-authored code),
 * the function's `name` will be used as the base for the tag. If the
 * constructor is an anonymous function (which often happens in
 * generated/minified code), the tag base will be "custom-element".
 *
 * In either case, this function adds a uniquifying number to the end of the
 * base to produce a complete tag.
 *
 * @private
 * @param {Constructor<HTMLElement>} classFn
 */
function registerCustomElement(classFn) {
  let baseTag;
  // HTML places more restrictions on the first character in a tag than
  // JavaScript places on the first character of a class name. We apply this
  // more restrictive condition to the class names we'll convert to tags. Class
  // names that fail this check -- often generated class names -- will result in
  // a base tag name of "custom-element".
  const classNameRegex = /^[A-Za-z][A-Za-z0-9_$]*$/;
  const classNameMatch = classFn.name && classFn.name.match(classNameRegex);
  if (classNameMatch) {
    // Given the class name `FooBar`, calculate the base tag name `foo-bar`.
    const className = classNameMatch[0];
    const uppercaseRegEx = /([A-Z])/g;
    const hyphenated = className.replace(
      uppercaseRegEx,
      (match, letter, offset) => (offset > 0 ? `-${letter}` : letter)
    );
    baseTag = hyphenated.toLowerCase();
  } else {
    baseTag = "custom-element";
  }
  // Add a uniquifying number to the end of the tag until we find a tag
  // that hasn't been registered yet.
  let count = mapBaseTagToCount.get(baseTag) || 0;
  let tag;
  for (; ; count++) {
    tag = `${baseTag}-${count}`;
    if (!customElements.get(tag)) {
      // Not in use.
      break;
    }
  }
  // Register with the generated tag.
  customElements.define(tag, /** @type {any} */ classFn);
  // Bump number and remember it. If we see the same base tag again later, we'll
  // start counting at that number in our search for a uniquifying number.
  mapBaseTagToCount.set(baseTag, count + 1);
}

/**
 * Replace an original node in a tree or document fragment with the indicated
 * replacement node. The attributes, classes, styles, and child nodes of the
 * original node will be moved to the replacement.
 *
 * @param {Node} original - an existing node to be replaced
 * @param {Node} replacement - the node to replace the existing node with
 * @returns {Node} the updated replacement node
 */
function replace(original, replacement) {
  const parent = original.parentNode;
  if (!parent) {
    throw "An element must have a parent before it can be substituted.";
  }
  if (
    (original instanceof HTMLElement || original instanceof SVGElement) &&
    (replacement instanceof HTMLElement || replacement instanceof SVGElement)
  ) {
    // Merge attributes from original to replacement, letting replacement win
    // conflicts. Handle classes and styles separately (below).
    Array.prototype.forEach.call(original.attributes, (
      /** @type {Attr} */ attribute
    ) => {
      if (
        !replacement.getAttribute(attribute.name) &&
        attribute.name !== "class" &&
        attribute.name !== "style"
      ) {
        replacement.setAttribute(attribute.name, attribute.value);
      }
    });
    // Copy classes/styles from original to replacement, letting replacement win
    // conflicts.
    Array.prototype.forEach.call(original.classList, (
      /** @type {string} */ className
    ) => {
      replacement.classList.add(className);
    });
    Array.prototype.forEach.call(original.style, (
      /** @type {number} */ key
    ) => {
      if (!replacement.style[key]) {
        replacement.style[key] = original.style[key];
      }
    });
  }
  // Copy over children.
  // @ts-ignore
  replacement.append(...original.childNodes);

  parent.replaceChild(replacement, original);
  return replacement;
}

/**
 * Replace a node with a new element, transferring all attributes, classes,
 * styles, and child nodes from the original(s) to the replacement(s).
 *
 * The descriptor used for the replacements can be a 1) component class
 * constructor, 2) an HTML tag name, or 3) an HTML template. For #1 and #2, if
 * the existing elements that match the selector are already of the desired
 * class/tag name, the replacement operation is skipped.
 *
 * @param {Element} original - the node to replace
 * @param {PartDescriptor} descriptor - the descriptor used to generate the
 * replacement element
 * @returns {Element} the replacement node(s)
 */
function transmute(original, descriptor) {
  if (
    (typeof descriptor === "function" && original.constructor === descriptor) ||
    (typeof descriptor === "string" &&
      original instanceof Element &&
      original.localName === descriptor)
  ) {
    // Already correct type of element, no transmutation necessary.
    return original;
  } else {
    // Transmute the single node.
    const replacement = createElement(descriptor);
    replace(original, replacement);
    return replacement;
  }
}

// Memoized maps of attribute to property names and vice versa.
// We initialize this with the special case of the tabindex (lowercase "i")
// attribute, which is mapped to the tabIndex (capital "I") property.
/** @type {IndexedObject<string>} */
const attributeToPropertyNames = {
  tabindex: "tabIndex",
};
/** @type {IndexedObject<string>} */
const propertyNamesToAttributes = {
  tabIndex: "tabindex",
};

/**
 * Sets properties when the corresponding attributes change
 *
 * If your component exposes a setter for a property, it's generally a good
 * idea to let devs using your component be able to set that property in HTML
 * via an element attribute. You can code that yourself by writing an
 * `attributeChangedCallback`, or you can use this mixin to get a degree of
 * automatic support.
 *
 * This mixin implements an `attributeChangedCallback` that will attempt to
 * convert a change in an element attribute into a call to the corresponding
 * property setter. Attributes typically follow hyphenated names ("foo-bar"),
 * whereas properties typically use camelCase names ("fooBar"). This mixin
 * respects that convention, automatically mapping the hyphenated attribute
 * name to the corresponding camelCase property name.
 *
 * Example: You define a component using this mixin:
 *
 *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {
 *       get fooBar() { return this._fooBar; }
 *       set fooBar(value) { this._fooBar = value; }
 *     }
 *
 * If someone then instantiates your component in HTML:
 *
 *     <my-element foo-bar="Hello"></my-element>
 *
 * Then, after the element has been upgraded, the `fooBar` setter will
 * automatically be invoked with the initial value "Hello".
 *
 * Attributes can only have string values. If you'd like to convert string
 * attributes to other types (numbers, booleans), you must implement parsing
 * yourself.
 *
 * @module AttributeMarshallingMixin
 * @param {Constructor<CustomElement>} Base
 */
function AttributeMarshallingMixin(Base) {
  // The class prototype added by the mixin.
  class AttributeMarshalling extends Base {
    /**
     * Handle a change to the attribute with the given name.
     *
     * @ignore
     * @param {string} attributeName
     * @param {string} oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attributeName, oldValue, newValue) {
      if (super.attributeChangedCallback) {
        super.attributeChangedCallback(attributeName, oldValue, newValue);
      }

      // Sometimes this callback is invoked when there's not actually any
      // change, in which we skip invoking the property setter.
      //
      // We also skip setting properties if we're rendering. A component may
      // want to reflect property values to attributes during rendering, but
      // such attribute changes shouldn't trigger property updates.
      if (newValue !== oldValue && !this[rendering$1]) {
        const propertyName = attributeToPropertyName(attributeName);
        // If the attribute name corresponds to a property name, set the property.
        if (propertyName in this) {
          // Parse standard boolean attributes.
          const parsed = standardBooleanAttributes[attributeName]
            ? booleanAttributeValue(attributeName, newValue)
            : newValue;
          this[propertyName] = parsed;
        }
      }
    }

    // Because maintaining the mapping of attributes to properties is tedious,
    // this provides a default implementation for `observedAttributes` that
    // assumes that your component will want to expose all public properties in
    // your component's API as properties.
    //
    // You can override this default implementation of `observedAttributes`. For
    // example, if you have a system that can statically analyze which
    // properties are available to your component, you could hand-author or
    // programmatically generate a definition for `observedAttributes` that
    // avoids the minor run-time performance cost of inspecting the component
    // prototype to determine your component's public properties.
    static get observedAttributes() {
      return attributesForClass(this);
    }
  }

  return AttributeMarshalling;
}

/**
 * Return the custom attributes for the given class.
 *
 * E.g., if the supplied class defines a `fooBar` property, then the resulting
 * array of attribute names will include the "foo-bar" attribute.
 *
 * @private
 * @param {Constructor<HTMLElement>} classFn
 * @returns {string[]}
 */
function attributesForClass(classFn) {
  // We treat the HTMLElement base class as if it has no attributes, since we
  // don't want to receive attributeChangedCallback for it (or anything further
  // up the protoype chain).
  if (classFn === HTMLElement) {
    return [];
  }

  // Get attributes for parent class.
  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;

  // See if parent class defines observedAttributes manually.
  let baseAttributes = baseClass.observedAttributes;
  if (!baseAttributes) {
    // Calculate parent class attributes ourselves.
    baseAttributes = attributesForClass(baseClass);
  }

  // Get the properties for this particular class.
  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);
  const setterNames = propertyNames.filter((propertyName) => {
    const descriptor = Object.getOwnPropertyDescriptor(
      classFn.prototype,
      propertyName
    );
    return descriptor && typeof descriptor.set === "function";
  });

  // Map the property names to attribute names.
  const attributes = setterNames.map((setterName) =>
    propertyNameToAttribute(setterName)
  );

  // Merge the attribute for this class and its base class.
  const diff = attributes.filter(
    (attribute) => baseAttributes.indexOf(attribute) < 0
  );
  const result = baseAttributes.concat(diff);

  return result;
}

/**
 * Convert hyphenated foo-bar attribute name to camel case fooBar property name.
 *
 * @private
 * @param {string} attributeName
 */
function attributeToPropertyName(attributeName) {
  let propertyName = attributeToPropertyNames[attributeName];
  if (!propertyName) {
    // Convert and memoize.
    const hyphenRegEx = /-([a-z])/g;
    propertyName = attributeName.replace(hyphenRegEx, (match) =>
      match[1].toUpperCase()
    );
    attributeToPropertyNames[attributeName] = propertyName;
  }
  return propertyName;
}

/**
 * Convert a camel case fooBar property name to a hyphenated foo-bar attribute.
 *
 * @private
 * @param {string} propertyName
 */
function propertyNameToAttribute(propertyName) {
  let attribute = propertyNamesToAttributes[propertyName];
  if (!attribute) {
    // Convert and memoize.
    const uppercaseRegEx = /([A-Z])/g;
    attribute = propertyName.replace(uppercaseRegEx, "-$1").toLowerCase();
    propertyNamesToAttributes[propertyName] = attribute;
  }
  return attribute;
}

/** @type {any} */
const stateKey = Symbol("state");
/** @type {any} */
const raiseChangeEventsInNextRenderKey = Symbol(
  "raiseChangeEventsInNextRender"
);
// Tracks total set of changes made to elements since their last render.
/** @type {any} */
const changedSinceLastRenderKey = Symbol("changedSinceLastRender");

/**
 * Manages component state and renders changes in state
 *
 * This is modeled after React/Preact's state management, and is adapted for
 * use with web components. Applying this mixin to a component will give it
 * FRP behavior comparable to React's.
 *
 * This model is very basic. It's key aspects are:
 * * an immutable `state` property updated via `setState` calls.
 * * a `render` method that will be invoked asynchronously when state changes.
 *
 * @module ReactiveMixin
 * @param {Constructor<CustomElement>} Base
 */
function ReactiveMixin(Base) {
  class Reactive extends Base {
    constructor() {
      super();

      // Components can inspect `firstRender` during rendering to do special
      // work the first time (like wire up event handlers). Until the first
      // render actually happens, we set that flag to be undefined so we have a
      // way of distinguishing between a component that has never rendered and
      // one that is being rendered for the nth time.
      this[firstRender$1] = undefined;

      // We want to support the standard HTML pattern of only raising events in
      // response to direct user interactions. For a detailed discussion of this
      // point, see the Gold Standard checklist item for [Propery Change
      // Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).
      //
      // To support this pattern, we define a flag indicating whether change
      // events should be raised. By default, we want the flag to be false. In
      // UI event handlers, a component can temporarily set the flag to true. If
      // a setState call is made while the flag is true, then that fact will be
      // remembered and passed the subsequent render/rendered methods. That will
      // let the methods know whether they should raise property change events.
      this[raiseChangeEvents$1] = false;

      // Maintain a change log of all fields which have changed since the
      // component was last rendered.
      this[changedSinceLastRenderKey] = null;

      // Set the initial state from the default state defined by the component
      // and its mixins/base classes.
      this[setState$1](this[defaultState$1]);
    }

    // When the component is attached to the document (or upgraded), we will
    // generally render the component for the first time. That operation will
    // include rendering of the default state and any state changes that
    // happened between constructor time and this connectedCallback.
    connectedCallback() {
      if (super.connectedCallback) {
        super.connectedCallback();
      }

      // Render the component.
      //
      // If the component was forced to render before this point, and the state
      // hasn't changed, this call will be a no-op.
      this[renderChanges$1]();
    }

    /**
     * The default state for the component. This can be extended by mixins and
     * classes to provide additional default state.
     *
     * @type {PlainObject}
     */
    // @ts-ignore
    get [defaultState$1]() {
      // Defer to base implementation if defined.
      return super[defaultState$1] || {};
    }

    /**
     * Render the indicated changes in state to the DOM.
     *
     * The default implementation of this method does nothing. Override this
     * method in your component to update your component's host element and
     * any shadow elements to reflect the component's new state. See the
     * [rendering example](ReactiveMixin#rendering).
     *
     * Be sure to call `super` in your method implementation so that your
     * component's base classes and mixins have a chance to perform their own
     * render work.
     *
     * @param {ChangedFlags} changed - dictionary of flags indicating which state
     * members have changed since the last render
     */
    [render$1](changed) {
      if (super[render$1]) {
        super[render$1](changed);
      }
    }

    /**
     * Render any pending component changes to the DOM.
     *
     * This method does nothing if the state has not changed since the last
     * render call.
     *
     * ReactiveMixin will invoke this method following a `setState` call;
     * you should not need to invoke this method yourself.
     *
     * This method invokes the internal `render` method, then invokes the
     * `rendered` method.
     */
    [renderChanges$1]() {
      if (this[firstRender$1] === undefined) {
        // First render.
        this[firstRender$1] = true;
      }

      // Get the log of which fields have changed since the last render.
      const changed = this[changedSinceLastRenderKey];

      // We only render if this is the first render, or state has changed since
      // the last render.
      if (this[firstRender$1] || changed) {
        // If at least one of the[setState] calls was made in response
        // to user interaction or some other component-internal event, set the
        // raiseChangeEvents flag so that render/rendered methods know whether
        // to raise property change events. See the comments in the component
        // constructor where we initialize this flag for details.
        const saveRaiseChangeEvents = this[raiseChangeEvents$1];
        this[raiseChangeEvents$1] = this[raiseChangeEventsInNextRenderKey];

        // We set a flag to indicate that rendering is happening. The component
        // may use this to avoid triggering other updates during the render.
        this[rendering$1] = true;

        // Invoke any internal render implementations.
        this[render$1](changed);

        this[rendering$1] = false;

        // Since we've now rendered all changes, clear the change log. If other
        // async render calls are queued up behind this call, they'll see an
        // empty change log, and so skip unnecessary render work.
        this[changedSinceLastRenderKey] = null;

        // Let the component know it was rendered.
        this[rendered$1](changed);

        // We've now rendered for the first time.
        this[firstRender$1] = false;

        // Restore state of event flags.
        this[raiseChangeEvents$1] = saveRaiseChangeEvents;
        this[raiseChangeEventsInNextRenderKey] = saveRaiseChangeEvents;
      }
    }

    /**
     * Perform any work that must happen after state changes have been rendered
     * to the DOM.
     *
     * The default implementation of this method does nothing. Override this
     * method in your component to perform work that requires the component to
     * be fully rendered, such as setting focus on a shadow element or
     * inspecting the computed style of an element. If such work should result
     * in a change in component state, you can safely call `setState` during the
     * `rendered` method.
     *
     * Be sure to call `super` in your method implementation so that your
     * component's base classes and mixins have a chance to perform their own
     * post-render work.
     *
     * @param {ChangedFlags} changed
     */
    [rendered$1](changed) {
      if (super[rendered$1]) {
        super[rendered$1](changed);
      }
    }

    /**
     * Update the component's state by merging the specified changes on
     * top of the existing state. If the component is connected to the document,
     * and the new state has changed, this returns a promise to asynchronously
     * render the component. Otherwise, this returns a resolved promise.
     *
     * @param {PlainObject} changes - the changes to apply to the element's state
     * @returns {Promise} - resolves when the new state has been rendered
     */
    async [setState$1](changes) {
      // There's no good reason to have a render method update state.
      if (this[rendering$1]) {
        /* eslint-disable no-console */
        console.warn(
          `${this.constructor.name} called [setState] during rendering, which you should avoid.\nSee https://elix.org/documentation/ReactiveMixin.`
        );
      }

      // Apply the changes to a copy of the component's current state to produce
      // a new, updated state and a dictionary of flags indicating which fields
      // actually changed.
      const { state, changed } = copyStateWithChanges(this, changes);

      // We only need to apply the changes to the component state if: a) the
      // current state is undefined (this is the first time setState has been
      // called), or b) the supplied changes parameter actually contains
      // substantive changes.
      if (this[stateKey] && Object.keys(changed).length === 0) {
        // No need to update state.
        return;
      }

      // Freeze the new state so it's immutable. This prevents accidental
      // attempts to set state without going through setState.
      Object.freeze(state);

      // Set this as the component's new state.
      this[stateKey] = state;

      // If setState was called with the raiseChangeEvents flag set, record that
      // fact for use in rendering. See the comments in the component
      // constructor for details.
      if (this[raiseChangeEvents$1]) {
        this[raiseChangeEventsInNextRenderKey] = true;
      }

      // Look to see whether the component is already set up to render.
      const willRender =
        this[firstRender$1] === undefined ||
        this[changedSinceLastRenderKey] !== null;

      // Add this round of changed fields to the complete log of fields that
      // have changed since the component was last rendered.
      this[changedSinceLastRenderKey] = Object.assign(
        this[changedSinceLastRenderKey] || {},
        changed
      );

      // We only need to queue a render if we're in the document and a render
      // operation hasn't already been queued for this component. If we're not
      // in the document yet, when the component is eventually added to the
      // document, the connectedCallback will ensure we render at that point.
      const needsRender = this.isConnected && !willRender;
      if (needsRender) {
        // Yield with promise timing. This lets any *synchronous* setState calls
        // that happen after this current setState call complete first. Their
        // effects on the state will be batched up, and accumulate in the change
        // log stored under this[changedSinceLastRenderKey].
        await Promise.resolve();

        // Now that the above promise has resolved, render the component. By the
        // time this line is reached, the complete log of batched changes can be
        // applied in a single render call.
        this[renderChanges$1]();
      }
    }

    /**
     * The component's current state.
     *
     * The returned state object is immutable. To update it, invoke
     * `internal.setState`.
     *
     * It's extremely useful to be able to inspect component state while
     * debugging. If you append `?elixdebug=true` to a page's URL, then
     * ReactiveMixin will conditionally expose a public `state` property that
     * returns the component's state. You can then access the state in your
     * browser's debug console.
     *
     * @type {PlainObject}
     */
    get [state$1]() {
      return this[stateKey];
    }

    /**
     * Ask the component whether a state with a set of recently-changed fields
     * implies that additional second-order changes should be applied to that
     * state to make it consistent.
     *
     * This method is invoked during a call to `internal.setState` to give all
     * of a component's mixins and classes a chance to respond to changes in
     * state. If one mixin/class updates state that it controls, another
     * mixin/class may want to respond by updating some other state member that
     * *it* controls.
     *
     * This method should return a dictionary of changes that should be applied
     * to the state. If the dictionary object is not empty, the
     * `internal.setState` method will apply the changes to the state, and
     * invoke this `stateEffects` method again to determine whether there are
     * any third-order effects that should be applied. This process repeats
     * until all mixins/classes report that they have no additional changes to
     * make.
     *
     * See an example of how `ReactiveMixin` invokes the `stateEffects` to
     * [ensure state consistency](ReactiveMixin#ensuring-state-consistency).
     *
     * @param {PlainObject} state - a proposal for a new state
     * @param {ChangedFlags} changed - the set of fields changed in this
     * latest proposal for the new state
     * @returns {PlainObject}
     */
    [stateEffects$1](state, changed) {
      return super[stateEffects$1] ? super[stateEffects$1](state, changed) : {};
    }
  }

  // Expose state when debugging; see note for `[state]` getter.
  const elixdebug = new URLSearchParams(location.search).get("elixdebug");
  if (elixdebug === "true") {
    Object.defineProperty(Reactive.prototype, "state", {
      get() {
        return this[state$1];
      },
    });
  }

  return Reactive;
}

/**
 * Create a copy of the component's state with the indicated changes applied.
 * Ask the component whether the new state implies any second-order effects. If
 * so, apply those and loop again until the state has stabilized. Return the new
 * state and a dictionary of flags indicating which fields were actually
 * changed.
 *
 * @private
 * @param {Element} element
 * @param {PlainObject} changes
 */
function copyStateWithChanges(element, changes) {
  // Start with a copy of the current state.
  /** @type {PlainObject} */
  const state = Object.assign({}, element[stateKey]);
  /** @type {ChangedFlags} */
  const changed = {};
  // Take the supplied changes as the first round of effects.
  let effects = changes;
  // Loop until there are no effects to apply.
  /* eslint-disable no-constant-condition */
  while (true) {
    // See whether the effects actually changed anything in state.
    const changedByEffects = fieldsChanged(state, effects);
    if (Object.keys(changedByEffects).length === 0) {
      // No more effects to apply; we're done.
      break;
    }
    // Apply the effects.
    Object.assign(state, effects);
    Object.assign(changed, changedByEffects);
    // Ask the component if there are any second- (or third-, etc.) order
    // effects that should be applied.
    effects = element[stateEffects$1](state, changedByEffects);
  }
  return { state, changed };
}

/**
 * Return true if the two values are equal.
 *
 * @private
 * @param {any} value1
 * @param {any} value2
 * @returns {boolean}
 */
function equal(value1, value2) {
  if (value1 instanceof Date && value2 instanceof Date) {
    return value1.getTime() === value2.getTime();
  }
  return value1 === value2;
}

/**
 * Return a dictionary of flags indicating which of the indicated changes to the
 * state are actually substantive changes.
 *
 * @private
 * @param {PlainObject} state
 * @param {PlainObject} changes
 */
function fieldsChanged(state, changes) {
  /** @type {ChangedFlags} */
  const changed = {};
  for (const field in changes) {
    if (!equal(changes[field], state[field])) {
      changed[field] = true;
    }
  }
  return changed;
}

// A cache of processed templates, indexed by element class.
const classTemplateMap = new Map();

// A Proxy that maps shadow element IDs to shadow elements.
// This will be return as the element's `this[ids]` property;
// see comments in that property below.
/** @type {any} */
const shadowIdProxyKey = Symbol("shadowIdProxy");

// A reference stored on the shadow element proxy target to get to the actual
// element. We use a Symbol here instead of a string name to avoid naming
// conflicts with the element's internal shadow element IDs.
const proxyElementKey = Symbol("proxyElement");

// A handler used for the shadow element ID proxy.
const shadowIdProxyHandler = {
  get(target, id) {
    // From this proxy, obtain a reference to the original component.
    const element = target[proxyElementKey];

    // Get a reference to the component's open or closed shadow root.
    const root = element[shadowRoot$1];

    // Look for a shadow element with the indicated ID.
    return root && typeof id === "string" ? root.getElementById(id) : null;
  },
};

/**
 * Stamps a template into a component's Shadow DOM when instantiated
 *
 * To use this mixin, define a `template` method that returns a string or HTML
 * `<template>` element:
 *
 *     import { createElement, replace, transmute } from 'elix/src/template.js';
 *
 *     class MyElement extends ShadowTemplateMixin(HTMLElement) {
 *       get [template]() {
 *         return templateFrom.html`Hello, <em>world</em>.`;
 *       }
 *     }
 *
 * When your component class is instantiated, a shadow root will be created on
 * the instance, and the contents of the template will be cloned into the
 * shadow root. If your component does not define a `template` method, this
 * mixin has no effect.
 *
 * This adds a member on the component called `this[ids]` that can be used to
 * reference shadow elements with IDs. E.g., if component's shadow contains an
 * element `<button id="foo">`, then this mixin will create a member
 * `this[ids].foo` that points to that button.
 *
 * @module ShadowTemplateMixin
 * @param {Constructor<HTMLElement>} Base
 */
function ShadowTemplateMixin(Base) {
  // The class prototype added by the mixin.
  class ShadowTemplate extends Base {
    /**
     * A convenient shortcut for looking up an element by ID in the component's
     * Shadow DOM subtree.
     *
     * Example: if component's template contains a shadow element `<button
     * id="foo">`, you can use the reference `this[ids].foo` to obtain
     * the corresponding button in the component instance's shadow tree. The
     * `ids` property is simply a shorthand for `getElementById`, so
     * `this[ids].foo` is the same as
     * `this[shadowRoot].getElementById('foo')`.
     *
     * @type {object} - a dictionary mapping shadow element IDs to elements
     */
    get [ids$1]() {
      if (!this[shadowIdProxyKey]) {
        // Construct a proxy that maps to getElementById.
        const target = {
          // Give the proxy a means of refering to this element via the target.
          [proxyElementKey]: this,
        };
        this[shadowIdProxyKey] = new Proxy(target, shadowIdProxyHandler);
      }
      return this[shadowIdProxyKey];
    }

    /*
     * If the component defines a template, a shadow root will be created on the
     * component instance, and the template stamped into it.
     */
    [render$1](/** @type {ChangedFlags} */ changed) {
      if (super[render$1]) {
        super[render$1](changed);
      }

      // We populate the shadow root if the component doesn't have a shadow;
      // i.e., the first time the component is rendered. For this check, we use
      // an internal reference we maintain for the shadow root; see below.
      if (!this[shadowRoot$1]) {
        // If this type of element defines a template, prepare it for use.
        const template = getTemplate(this);

        if (template) {
          // Stamp the template into a new shadow root.
          const root = this.attachShadow({
            delegatesFocus: this[delegatesFocus$1],
            mode: this[shadowRootMode$1],
          });
          const clone = document.importNode(template.content, true);
          root.append(clone);

          // After this call, we won't be able to rely on being able to access
          // the shadow root via `this.shadowRoot`, because the component may
          // have asked for a closed shadow root. We save a reference to the
          // shadow root now so that the component always has a consistent means
          // to reference its own shadow root.
          this[shadowRoot$1] = root;
        } else {
          // No template. Set shadow root to null (instead of undefined) so we
          // won't try to render shadow on next render.
          this[shadowRoot$1] = null;
        }
      }
    }

    /**
     * @type {ShadowRootMode}
     * @default "open"
     */
    get [shadowRootMode$1]() {
      return "open";
    }
  }

  return ShadowTemplate;
}

/**
 * Return the template for the element being instantiated.
 *
 * If this is the first time we're creating this type of element, or the
 * component has indicated that its template is dynamic (and should be retrieved
 * each time), ask the component class for the template and cache the result.
 * Otherwise, immediately return the cached template.
 *
 * @private
 * @param {HTMLElement} element
 * @returns {HTMLTemplateElement}
 */
function getTemplate(element) {
  let t = element[hasDynamicTemplate$1]
    ? undefined // Always retrieve template
    : classTemplateMap.get(element.constructor); // See if we've cached it
  if (t === undefined) {
    // Ask the component for its template.
    t = element[template$1];
    // A component using this mixin isn't required to supply a template --
    // if they don't, they simply won't end up with a shadow root.
    if (t) {
      // But if the component does supply a template, it needs to be an
      // HTMLTemplateElement instance.
      if (!(t instanceof HTMLTemplateElement)) {
        throw `Warning: the [template] property for ${element.constructor.name} must return an HTMLTemplateElement.`;
      }
    }
    if (!element[hasDynamicTemplate$1]) {
      // Store prepared template for next creation of same type of element.
      // If the component didn't define a template, store null so that we skip
      // the template retrieval next time.
      classTemplateMap.set(element.constructor, t || null);
    }
  }
  return t;
}

/**
 * General-purpose base for writing components in functional-reactive style
 *
 * This base class lets you create web components in a functional-reactive
 * programming (FRP) style. It simply bundles a small set of mixins:
 *
 *     const ReactiveElement =
 *       AttributeMarshallingMixin(
 *       ReactiveMixin(
 *       ShadowTemplateMixin(
 *         HTMLElement
 *       )))));
 *
 * `ReactiveElement` is provided as a convenience. You can achieve the same
 * result by applying the mixins yourself to `HTMLElement`.
 *
 * @inherits HTMLElement
 * @mixes AttributeMarshallingMixin
 * @mixes ReactiveMixin
 * @mixes ShadowTemplateMixin
 */
const ReactiveElement = AttributeMarshallingMixin(
  ReactiveMixin(ShadowTemplateMixin(HTMLElement))
);

/**
 * Collection of shared Symbol objects for internal component communication.
 *
 * The shared `Symbol` objects in this module let mixins and a component
 * internally communicate without exposing these internal properties and methods
 * in the component's public API. They also help avoid unintentional name
 * collisions, as a component developer must specifically import the `internal`
 * module and reference one of its symbols.
 *
 * To use these `Symbol` objects in your own component, include this module and
 * then create a property or method whose key is the desired Symbol. E.g.,
 * [ShadowTemplateMixin](ShadowTemplateMixin) expects a component to define
 * a property called [template](#template):
 *
 *     import { template } from 'elix/src/core/internal.js';
 *     import { templateFrom } from 'elix/src/core/htmlLiterals.js'
 *     import ShadowTemplateMixin from 'elix/src/core/ShadowTemplateMixin.js';
 *
 *     class MyElement extends ShadowTemplateMixin(HTMLElement) {
 *       [template]() {
 *         return templateFrom.html`Hello, <em>world</em>.`;
 *       }
 *     }
 *
 * The above use of the internal `template` member lets the mixin find the
 * component's template in a way that will not pollute the component's public
 * API or interfere with other component logic. For example, if for some reason
 * the component wants to define a separate property with the plain string name,
 * "template", it can do so without affecting the above property setter.
 *
 * @module internal
 */

/**
 * Symbol for the `checkSize` method.
 *
 * If defined, this method will be invoked by [ResizeMixin](ResizeMixin)
 * when an element's size may have changed. The default implementation of
 * this method compares the element's current `clientHeight` and `clientWidth`
 * properties against the last known values of those properties (saved in
 * `state.clienHeight` and `state.clientWidth`).
 *
 * Components should override this method if they contain elements that may need
 * to know about size changes as well. For example, when an [Overlay](Overlay)
 * mixin opens, it invokes this method on any content elements that define it.
 * This gives the contents a chance to resize in response to being displayed.
 */
const checkSize = Symbol("checkSize");

/**
 * Symbol for the `closestAvailableItemIndex` method.
 *
 * This method is defined by [ItemsCursorMixin](ItemsCursorMixin). You can call
 * this if you want to find an item at a particular location, but may need to
 * account for the fact that the item at that position is not available, and
 * would like to find the closest item that is available.
 */
const closestAvailableItemIndex = Symbol("closestAvailableItemIndex");

/**
 * Symbol for the `contentSlot` property.
 *
 * [SlotContentMixin](SlotContentMixin) uses this to identify which slot
 * element in the component's shadow tree that holds the component's content.
 * By default, this is the first slot element with no "name" attribute. You
 * can override this to return a different slot.
 */
const contentSlot = Symbol("contentSlot");

/**
 * The default state for this element.
 */
const defaultState = defaultState$1;

/**
 * Symbol for the `defaultTabIndex` property.
 *
 * [KeyboardMixin](KeyboardMixin) uses this if it is unable to successfully
 * parse a string tabindex attribute.
 */
const defaultTabIndex = Symbol("defaultTabIndex");

/**
 * Symbol for the `delegatesFocus` property.
 *
 * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property, returning
 * true to indicate that the focus is being delegated, even in browsers that
 * don't support that natively. Mixins like [KeyboardMixin](KeyboardMixin) use
 * this to accommodate focus delegation.
 */
const delegatesFocus = delegatesFocus$1;

/**
 * Symbol for the `effectEndTarget` property.
 *
 * [TransitionEffectMixin](TransitionEffectMixin) inspects this property to
 * determine which element's `transitionend` event will signal the end of a
 * transition effect.
 */
const effectEndTarget = Symbol("effectEndTarget");

/**
 * Symbol for the `firstRender` property.
 *
 * [ReactiveMixin](ReactiveMixin) sets the property to `true` during the
 * element's first `connectedCallback`, then `false` in subsequent callbacks.
 *
 * You can inspect this property in your own `connectedCallback` handler
 * to do work like wiring up events that should only happen once.
 */
const firstRender = firstRender$1;

/**
 * Symbol for the `focusTarget` property.
 *
 * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property as either:
 * 1) the element itself, in browsers that support native focus delegation or,
 * 2) the shadow root's first focusable element.
 */
const focusTarget = focusTarget$1;

/**
 * Symbol for the `getItemText` method.
 *
 * This method can be applied to an item to return its text.
 * [KeyboardPrefixCursorMixin](KeyboardPrefixCursorMixin) uses this to
 * obtain the text for each item in a list, then matches keypresses again that
 * text.
 *
 * This method takes a single parameter: the `HTMLElement` of the item from
 * which text should be extracted.
 */
const getItemText = Symbol("getItemText");

/**
 * Symbol for the `goDown` method.
 *
 * This method is invoked when the user wants to go/navigate down.
 */
const goDown = Symbol("goDown");

/**
 * Symbol for the `goEnd` method.
 *
 * This method is invoked when the user wants to go/navigate to the end (e.g.,
 * of a list).
 */
const goEnd = Symbol("goEnd");

/**
 * Symbol for the `goFirst` method.
 *
 * This method is invoked when the user wants to go to the first item in a list.
 */
const goFirst = Symbol("goFirst");

/**
 * Symbol for the `goLast` method.
 *
 * This method is invoked when the user wants to go to the last item in a list.
 */
const goLast = Symbol("goLast");

/**
 * Symbol for the `goLeft` method.
 *
 * This method is invoked when the user wants to go/navigate left. Mixins that
 * make use of this method include
 * [KeyboardDirectionMixin](KeyboardDirectionMixin) and
 * [SwipeDirectionMixin](SwipeDirectionMixin).
 */
const goLeft = Symbol("goLeft");

/**
 * Symbol for the `goNext` method.
 *
 * This method is invoked when the user wants to go/navigate to the next item.
 */
const goNext = Symbol("goNext");

/**
 * Symbol for the `goPrevious` method.
 *
 * This method is invoked when the user wants to go/navigate to the previous item.
 */
const goPrevious = Symbol("goPrevious");

/**
 * Symbol for the `goRight` method.
 *
 * This method is invoked when the user wants to go/navigate right. Mixins
 * that make use of this method include
 * [KeyboardDirectionMixin](KeyboardDirectionMixin) and
 * [SwipeDirectionMixin](SwipeDirectionMixin).
 */
const goRight = Symbol("goRight");

/**
 * Symbol for the `goStart` method.
 *
 * This method is invoked when the user wants to go/navigate to the start
 * (e.g., of a list).
 */
const goStart = Symbol("goStart");

/**
 * Symbol for the `goToItemWithPrefix` method.
 *
 * This method is invoked by
 * [KeyboardPrefixCursorMixin](KeyboardPrefixCursorMixin) when the user types
 * text characters.
 */
const goToItemWithPrefix = Symbol("goToItemWithPrefix");

/**
 * Symbol for the `goUp` method.
 *
 * This method is invoked when the user wants to go/navigate up.
 */
const goUp = Symbol("goUp");

/**
 * Symbol for the `hasDynamicTemplate` property.
 *
 * If your component class does not always use the same template, define a
 * static class property getter with this symbol and have it return `true`.
 * This will disable template caching for your component.
 */
const hasDynamicTemplate = hasDynamicTemplate$1;

/**
 * Symbol for the `ids` property.
 *
 * [ShadowTemplateMixin](ShadowTemplateMixin) defines a shorthand function
 * `internal.ids` that can be used to obtain a reference to a shadow element with
 * a given ID.
 *
 * Example: if component's template contains a shadow element
 * `<button id="foo">`, you can use the reference `this[ids].foo` to obtain
 * the corresponding button in the component instance's shadow tree.
 * The `ids` function is simply a shorthand for `getElementById`, so
 * `this[ids].foo` is the same as `this.shadowRoot.getElementById('foo')`.
 */
const ids = ids$1;

/**
 * Symbol for the `inputDelegate` property.
 *
 * [DelegateInputSelectionMixin](DelegateInputSelectionMixin) uses this property
 * to indicate which shadow element is the input-type element to which text
 * selection methods and properties should be delegated.
 */
const inputDelegate = Symbol("inputDelegate");

/**
 * Symbol for the `itemsDelegate` property.
 *
 * A component using [DelegateItemsMixin](DelegateItemsMixin) uses this property
 * to indicate which one of its shadow elements is the one whose `items`
 * property will be treated as the component's own `items`.
 */
const itemsDelegate = Symbol("itemsDelegate");

/**
 * Symbol for the `keydown` method.
 *
 * This method is invoked when an element receives a `keydown` event.
 *
 * An implementation of `internal.keydown` should return `true` if it handled
 * the event, and `false` otherwise. If `true` is returned (the event was
 * handled), `KeyboardMixin` invokes the event's `preventDefault` and
 * `stopPropagation` methods to let the browser know the event was handled.
 *
 * The convention for handling `internal.keydown` is that the last mixin
 * applied wins. That is, if an implementation of `internal.keydown` *did*
 * handle the event, it can return immediately. If it did not, it should
 * invoke `super` to let implementations further up the prototype chain have
 * their chance.
 *
 * This method takes a `KeyboardEvent` parameter that contains the event being
 * processed.
 */
const keydown = Symbol("keydown");

/**
 * Symbol for the `mouseenter` method.
 *
 * [HoverMixin](HoverMixin) invokes this method when the user moves the
 * mouse over a component. That mixin provides a base implementation of this
 * method, but you can extend it to do additional work on `mouseenter`.
 *
 * This method takes a `MouseEvent` parameter that contains the event being
 * processed.
 */
const mouseenter = Symbol("mouseenter");

/**
 * Symbol for the `mouseleave` method.
 *
 * [HoverMixin](HoverMixin) invokes this method when the user moves off a
 * component. That mixin provides a base implementation of this method, but
 * you can extend it to do additional work on `mouseleave`.
 *
 * This method takes a `MouseEvent` parameter that contains the event being
 * processed.
 */
const mouseleave = Symbol("mouseleave");

/**
 * Symbol for access to native HTML element internals.
 */
const nativeInternals = nativeInternals$1;

/**
 * Symbol for the `raiseChangeEvents` property.
 *
 * This property is used by mixins to determine whether they should raise
 * property change events. The standard HTML pattern is to only raise such
 * events in response to direct user interactions. For a detailed discussion
 * of this point, see the Gold Standard checklist item for
 * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).
 *
 * The above article describes a pattern for using a flag to track whether
 * work is being performed in response to internal component activity, and
 * whether the component should therefore raise property change events.
 * This `raiseChangeEvents` symbol is a shared flag used for that purpose by
 * all Elix mixins and components. Sharing this flag ensures that internal
 * activity (e.g., a UI event listener) in one mixin can signal other mixins
 * handling affected properties to raise change events.
 *
 * All UI event listeners (and other forms of internal handlers, such as
 * timeouts and async network handlers) should set `raiseChangeEvents` to
 * `true` at the start of the event handler, then `false` at the end:
 *
 *     this.addEventListener('click', event => {
 *       this[raiseChangeEvents] = true;
 *       // Do work here, possibly setting properties, like:
 *       this.foo = 'Hello';
 *       this[raiseChangeEvents] = false;
 *     });
 *
 * Elsewhere, property setters that raise change events should only do so it
 * this property is `true`:
 *
 *     set foo(value) {
 *       // Save foo value here, do any other work.
 *       if (this[raiseChangeEvents]) {
 *         export const event = new CustomEvent('foochange');
 *         this.dispatchEvent(event);
 *       }
 *     }
 *
 * In this way, programmatic attempts to set the `foo` property will not trigger
 * the `foochange` event, but UI interactions that update that property will
 * cause those events to be raised.
 */
const raiseChangeEvents = raiseChangeEvents$1;

/**
 * Symbol for the `render` method.
 *
 * [ReactiveMixin](ReactiveMixin) invokes this `internal.render` method to give
 * the component a chance to render recent changes in component state.
 */
const render = render$1;

/**
 * Symbol for the `renderChanges` method.
 *
 * [ReactiveMixin](ReactiveMixin) invokes this method in response to a
 * `setState` call; you should generally not invoke this method yourself.
 */
const renderChanges = renderChanges$1;

/**
 * Symbol for the `renderDataToElement` method.
 *
 * [DataItemsMixin](DataItemsMixin) invokes this method to render data to an
 * element being used as an item in a list.
 */
const renderDataToElement = Symbol("renderDataToElement");

/**
 * Symbol for the `rendered` method.
 *
 * [ReactiveMixin](ReactiveMixin) will invoke this method after your
 * element has completely finished rendering.
 */
const rendered = rendered$1;

/**
 * Symbol for the `rendering` property.
 *
 * [ReactiveMixin](ReactiveMixin) sets this property to true during rendering,
 * at other times it will be false.
 */
const rendering = rendering$1;

/**
 * Symbol for the `scrollTarget` property.
 *
 * This property indicates which element in a component's shadow subtree
 * should be scrolled. [CursorInViewMixin](CursorInViewMixin) can use
 * this property to determine which element should be scrolled to keep the
 * selected item in view.
 */
const scrollTarget = Symbol("scrollTarget");

/**
 * Symbol for the `setState` method.
 *
 * A component using [ReactiveMixin](ReactiveMixin) can invoke this method to
 * apply changes to the element's current state.
 */
const setState = setState$1;

/**
 * Symbol for the `shadowRoot` property.
 *
 * This property holds a reference to an element's shadow root, like
 * `this.shadowRoot`. This propery exists because `this.shadowRoot` is not
 * available for components with closed shadow roots.
 * [ShadowTemplateMixin](ShadowTemplateMixin) creates open shadow roots by
 * default, but you can opt into creating closed shadow roots; see
 * [shadowRootMode](internal#internal.shadowRootMode).
 */
const shadowRoot = shadowRoot$1;

/**
 * Symbol for the `shadowRootMode` property.
 *
 * If true (the default), then [ShadowTemplateMixin](ShadowTemplateMixin) will
 * create an open shadow root when the component is instantiated. Set this to
 * false if you want to programmatically hide component internals in a closed
 * shadow root.
 */
const shadowRootMode = shadowRootMode$1;

/**
 * Symbol for the `startEffect` method.
 *
 * A component using [TransitionEffectMixin](TransitionEffectMixin) can invoke
 * this method to trigger the application of a named, asynchronous CSS
 * transition effect.
 *
 * This method takes a single `string` parameter giving the name of the effect
 * to start.
 */
const startEffect = Symbol("startEffect");

/**
 * The element's current state.
 *
 * This is managed by [ReactiveMixin](ReactiveMixin).
 */
const state = state$1;

const stateEffects = stateEffects$1;

/**
 * Symbol for the `swipeDown` method.
 *
 * The swipe mixin [TouchSwipeMixin](TouchSwipeMixin) invokes this method when
 * the user finishes a gesture to swipe down.
 */
const swipeDown = Symbol("swipeDown");

/**
 * Symbol for the `swipeDownComplete` method.
 *
 * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any
 * animated transition associated with a swipe down has completed.
 */
const swipeDownComplete = Symbol("swipeDownComplete");

/**
 * Symbol for the `swipeLeft` method.
 *
 * The swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and
 * [TrackpadSwipeMixin](TrackpadSwipeMixin) invoke this method when the user
 * finishes a gesture to swipe left.
 */
const swipeLeft = Symbol("swipeLeft");

/**
 * Symbol for the `swipeLeftTransitionEnd` method.
 *
 * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any
 * animated transition associated with a swipe left has completed.
 */
const swipeLeftTransitionEnd = Symbol("swipeLeftTransitionEnd");

/**
 * Symbol for the `swipeRight` method.
 *
 * The swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and
 * [TrackpadSwipeMixin](TrackpadSwipeMixin) invoke this method when the user
 * finishes a gesture to swipe right.
 */
const swipeRight = Symbol("swipeRight");

/**
 * Symbol for the `swipeRightTransitionEnd` method.
 *
 * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any
 * animated transition associated with a swipe right has completed.
 */
const swipeRightTransitionEnd = Symbol("swipeRightTransitionEnd");

/**
 * Symbol for the `swipeUp` method.
 *
 * The swipe mixin [TouchSwipeMixin](TouchSwipeMixin) invokes this method when
 * the user finishes a gesture to swipe up.
 */
const swipeUp = Symbol("swipeUp");

/**
 * Symbol for the `swipeUpComplete` method.
 *
 * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any
 * animated transition associated with a swipe up has completed.
 */
const swipeUpComplete = Symbol("swipeUpComplete");

/**
 * Symbol for the `swipeStart` method.
 *
 * [TouchSwipeMixin](TouchSwipeMixin) and
 * [TrackpadSwipeMixin](TrackpadSwipeMixin) invoke this method when a swipe
 * is starting, passing in the starting (x, y) client coordinate.
 */
const swipeStart = Symbol("swipeStart");

/**
 * Symbol for the `swipeTarget` property.
 *
 * By default, the swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and
 * [TrackpadSwipeMixin](TrackpadSwipeMixin) assume that the element the user
 * is swiping the top-level element. In some cases (e.g., [Drawer](Drawer)),
 * the component wants to let the user swipe a shadow element. In such cases,
 * this property should return the element that should be swiped.
 *
 * The swipe target's `offsetWidth` is used by the mixin to calculate the
 * `state.swipeFraction` member when the user drags their finger. The
 * `swipeFraction` is the distance the user has dragged in the current drag
 * operation over that `offsetWidth`.
 */
const swipeTarget = Symbol("swipeTarget");

/**
 * Symbol for the `tap` method.
 *
 * This method is invoked when an element receives an operation that should
 * be interpreted as a tap. [TapCursorMixin](TapCursorMixin)
 * invokes this when the element receives a `mousedown` event, for example.
 */
const tap = Symbol("tap");

/**
 * Symbol for the `template` method.
 *
 * [ShadowTemplateMixin](ShadowTemplateMixin) uses this property to obtain a
 * component's template, which it will clone into a component's shadow root.
 */
const template = template$1;

/**
 * Symbol for the `toggleSelectedFlag` method.
 *
 * [ItemsMultiSelectMixin](ItemsMultiSelectMixin) exposes this method to let
 * other mixins like [MultiSelectAPIMixin](MultiSelectAPIMixin) toggle the
 * selected state of an individual item.
 */
const toggleSelectedFlag = Symbol("toggleSelectedFlag");

// Expose internals as a global when debugging.
const elixdebug = new URLSearchParams(location.search).get("elixdebug");
if (elixdebug === "true") {
  /** @type {any} */ (window).elix = {
    internal: {
      checkSize,
      closestAvailableItemIndex,
      contentSlot,
      defaultState,
      defaultTabIndex,
      delegatesFocus,
      effectEndTarget,
      firstRender,
      focusTarget,
      getItemText,
      goDown,
      goEnd,
      goFirst,
      goLast,
      goLeft,
      goNext,
      goPrevious,
      goRight,
      goStart,
      goToItemWithPrefix,
      goUp,
      hasDynamicTemplate,
      ids,
      inputDelegate,
      itemsDelegate,
      keydown,
      mouseenter,
      mouseleave,
      nativeInternals,
      event,
      raiseChangeEvents,
      render,
      renderChanges,
      renderDataToElement,
      rendered,
      rendering,
      scrollTarget,
      setState,
      shadowRoot,
      shadowRootMode,
      startEffect,
      state,
      stateEffects,
      swipeDown,
      swipeDownComplete,
      swipeLeft,
      swipeLeftTransitionEnd,
      swipeRight,
      swipeRightTransitionEnd,
      swipeUp,
      swipeUpComplete,
      swipeStart,
      swipeTarget,
      tap,
      template,
      toggleSelectedFlag,
    },
  };
}

// Symbols for private data members.
/** @type {any} */
const previousBodyOverflowKey = Symbol("previousBodyStyleOverflow");
/** @type {any} */
const previousDocumentMarginRightKey = Symbol("previousDocumentMarginRight");

/**
 * Gives an overlay modal behavior.
 *
 * This blocks various user interactions to make an overlay behave like a modal
 * dialog:
 *
 * * Disables scrolling on the background document. **This is a global
 *   side-effect of opening the component.**
 * * A default ARIA role of `dialog`.
 * * Closes the element if user presses the Esc key.
 *
 * For modeless overlays, see `PopupModalityMixin` instead.
 *
 * @module DialogModalityMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function DialogModalityMixin(Base) {
  return class DialogModality extends Base {
    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        role: "dialog",
      });
    }

    [keydown](/** @type {KeyboardEvent} */ event) {
      let handled = false;

      switch (event.key) {
        case "Escape":
          // Close on Esc key.
          this.close({
            canceled: "Escape",
          });
          handled = true;
          break;
      }

      // Prefer mixin result if it's defined, otherwise use base result.
      return handled || (super[keydown] && super[keydown](event)) || false;
    }

    [render](/** @type {ChangedFlags} */ changed) {
      if (super[render]) {
        super[render](changed);
      }
      if (changed.opened) {
        if (this[state].opened && document.documentElement) {
          // Disable body scrolling to absorb space bar keypresses and other
          // means of scrolling the top-level document.
          const documentWidth = document.documentElement.clientWidth;
          const scrollBarWidth = window.innerWidth - documentWidth;
          this[previousBodyOverflowKey] = document.body.style.overflow;
          this[previousDocumentMarginRightKey] =
            scrollBarWidth > 0
              ? document.documentElement.style.marginRight
              : null;
          document.body.style.overflow = "hidden";
          if (scrollBarWidth > 0) {
            document.documentElement.style.marginRight = `${scrollBarWidth}px`;
          }
        } else {
          // Reenable body scrolling.
          if (this[previousBodyOverflowKey] != null) {
            document.body.style.overflow = this[previousBodyOverflowKey];
            this[previousBodyOverflowKey] = null;
          }
          if (this[previousDocumentMarginRightKey] != null) {
            document.documentElement.style.marginRight = this[
              previousDocumentMarginRightKey
            ];
            this[previousDocumentMarginRightKey] = null;
          }
        }
      }
      if (changed.role) {
        // Apply top-level role.
        const { role } = this[state];
        this.setAttribute("role", role);
      }
    }

    // Setting the standard role attribute will invoke this property setter,
    // which will allow us to update our state.
    get role() {
      return super.role;
    }
    set role(role) {
      super.role = role;
      if (!this[rendering]) {
        this[setState]({ role });
      }
    }
  };
}

// Symbols for private data members on an element.
const wrap = Symbol("wrap");
/** @type {any} */
const wrappingFocusKey = Symbol("wrappingFocus");

/**
 * Allows Tab and Shift+Tab operations to cycle the focus within the component.
 *
 * This mixin expects the component to provide:
 *
 * * A template-stamping mechanism compatible with `ShadowTemplateMixin`.
 *
 * The mixin provides these features to the component:
 *
 * * Template elements and event handlers that will cause the keyboard focus to wrap.
 *
 * This mixin [contributes to a component's template](mixins#mixins-that-contribute-to-a-component-s-template).
 * See that discussion for details on how to use such a mixin.
 *
 * @module FocusCaptureMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function FocusCaptureMixin(Base) {
  class FocusCapture extends Base {
    [keydown](/** @type {KeyboardEvent} */ event) {
      const firstElement = firstFocusableElement(this[shadowRoot]);
      // We need to check both the document active element (to handle case where
      // the user is tabbing through light DOM nodes assigned to a slot) and the
      // shadow active element (to handle case where the user is tabbing through
      // shadow nodes).
      if (firstElement) {
        const firstElementIsDocumentActive =
          document.activeElement &&
          (document.activeElement === firstElement ||
            document.activeElement.contains(firstElement));
        const shadowActiveElement = this[shadowRoot].activeElement;
        const firstElementIsShadowActive =
          shadowActiveElement &&
          (shadowActiveElement === firstElement ||
            deepContains(shadowActiveElement, firstElement));
        const firstElementIsActive =
          firstElementIsDocumentActive || firstElementIsShadowActive;
        if (firstElementIsActive && event.key === "Tab" && event.shiftKey) {
          // Set focus to focus catcher.
          // The Shift+Tab keydown event should continue bubbling, and the default
          // behavior should cause it to end up on the last focusable element.
          this[wrappingFocusKey] = true;
          this[ids].focusCatcher.focus();
          this[wrappingFocusKey] = false;
          // Don't mark the event as handled, since we want it to keep bubbling up.
        }
      }

      // Prefer mixin result if it's defined, otherwise use base result.
      return (super[keydown] && super[keydown](event)) || false;
    }

    [render](/** @type {ChangedFlags} */ changed) {
      if (super[render]) {
        super[render](changed);
      }
      if (this[firstRender]) {
        this[ids].focusCatcher.addEventListener("focus", () => {
          if (!this[wrappingFocusKey]) {
            // Wrap focus back to the first focusable element.
            const focusElement = firstFocusableElement(this[shadowRoot]);
            if (focusElement) {
              focusElement.focus();
            }
          }
        });
      }
    }

    /**
     * Destructively wrap a node with elements necessary to capture focus.
     *
     * Call this method in a components `internal.template` property.
     * Invoke this method as `this[FocusCaptureMixin.wrap](element)`.
     *
     * @param {Element} target - the element within which focus should wrap
     */
    [wrap](target) {
      const focusCapture = fragmentFrom.html`
        <style>
          #focusCapture {
            display: flex;
            height: 100%;
            overflow: hidden;
            width: 100%;
          }

          #focusCaptureContainer {
            align-items: center;
            display: flex;
            flex: 1;
            flex-direction: column;
            justify-content: center;
            position: relative;
          }
        </style>
        <div id="focusCapture">
          <div id="focusCaptureContainer"></div>
          <div id="focusCatcher" tabindex="0"></div>
        </div>
      `;

      // Wrap the target with the focus capture elements.
      const container = focusCapture.getElementById("focusCaptureContainer");
      if (container) {
        target.replaceWith(focusCapture);
        container.append(target);
      }
    }
  }

  return FocusCapture;
}

FocusCaptureMixin.wrap = wrap;

/**
 * Manages keyboard handling for a component.
 *
 * This mixin handles several keyboard-related features.
 *
 * First, it wires up a single keydown event handler that can be shared by
 * multiple mixins on a component. The event handler will invoke a `keydown`
 * method with the event object, and any mixin along the prototype chain that
 * wants to handle that method can do so.
 *
 * If a mixin wants to indicate that keyboard event has been handled, and that
 * other mixins should *not* handle it, the mixin's `keydown` handler should
 * return a value of true. The convention that seems to work well is that a
 * mixin should see if it wants to handle the event and, if not, then ask the
 * superclass to see if it wants to handle the event. This has the effect of
 * giving the mixin that was applied last the first chance at handling a
 * keyboard event.
 *
 * Example:
 *
 *     [keydown](event) {
 *       let handled;
 *       switch (event.key) {
 *         // Handle the keys you want, setting handled = true if appropriate.
 *       }
 *       // Prefer mixin result if it's defined, otherwise use base result.
 *       return handled || (super[keydown] && super[keydown](event));
 *     }
 *
 * A second feature provided by this mixin is that it implicitly makes the
 * component a tab stop if it isn't already, by setting `tabindex` to 0. This
 * has the effect of adding the component to the tab order in document order.
 *
 * @module KeyboardMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function KeyboardMixin(Base) {
  // The class prototype added by the mixin.
  class Keyboard extends Base {
    constructor() {
      // @ts-ignore
      super();
      this.addEventListener("keydown", async (event) => {
        this[raiseChangeEvents] = true;
        // For use with FocusVisibleMixin.
        if (!this[state].focusVisible) {
          // The user may have begun interacting with this element using the
          // mouse/touch, but has now begun using the keyboard, so show focus.
          this[setState]({
            focusVisible: true,
          });
        }
        const handled = this[keydown](event);
        if (handled) {
          event.preventDefault();
          event.stopImmediatePropagation();
        }
        await Promise.resolve();
        this[raiseChangeEvents] = false;
      });
    }

    attributeChangedCallback(name, oldValue, newValue) {
      if (name === "tabindex") {
        // Parse the passed value, which could be a string or null.
        let parsed;
        if (newValue === null) {
          // tabindex attribute was removed.
          parsed = -1;
        } else {
          parsed = Number(newValue);
          if (isNaN(parsed)) {
            // Non-numeric tabindex falls back to default value (if defined).
            parsed = this[defaultTabIndex] ? this[defaultTabIndex] : 0;
          }
        }
        this.tabIndex = parsed;
      } else {
        super.attributeChangedCallback(name, oldValue, newValue);
      }
    }

    // @ts-ignore
    get [defaultState]() {
      // If we're using DelegateFocusMixin, we don't need or want to set a
      // tabindex on the host; we'll rely on the inner shadow elements to take
      // the focus and raise keyboard events. Otherwise, we do set a tabindex on
      // the host, so that we can get keyboard events.
      const tabIndex = this[delegatesFocus] ? -1 : 0;
      const state = Object.assign(super[defaultState] || {}, {
        tabIndex,
      });

      return state;
    }

    /**
     * See the [symbols](internal#internal.keydown) documentation for details.
     */
    [keydown](/** @type {KeyboardEvent} */ event) {
      if (super[keydown]) {
        return super[keydown](event);
      }
      return false;
    }

    [render](/** @type {ChangedFlags} */ changed) {
      if (super[render]) {
        super[render](changed);
      }
      if (changed.tabIndex) {
        this.tabIndex = this[state].tabIndex;
      }
    }

    // Record our own notion of the state of the tabIndex property so we can
    // rerender if necessary.
    get tabIndex() {
      return super.tabIndex;
    }
    set tabIndex(tabIndex) {
      // If value has changed, invoke the super setter.
      if (super.tabIndex !== tabIndex) {
        super.tabIndex = tabIndex;
      }

      // The tabIndex setter can get called during rendering when we render our
      // own notion of the tabIndex state, in which case we don't need or want
      // to set state again.
      if (!this[rendering]) {
        // Record the new tabIndex in our state.
        this[setState]({
          tabIndex,
        });
      }
    }
  }

  return Keyboard;
}

/**
 * Lets a component define its ARIA role through a `role` state member
 *
 * Among other things, this allows a class or mixin to define a default
 * role through the component's `defaultState`.
 *
 * Some mixins come with identicial support for managing an ARIA role. Those
 * mixins include [AriaListMixin](AriaListMixin),
 * [AriaMenuMixin](AriaMenuMixin), [DialogModalityMixin](DialogModalityMixin),
 * and [PopupModalityMixin](PopupModalityMixin). If you're using one of those
 * mixins, you do *not* need to use this mixin.
 *
 * @module AriaRoleMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function AriaRoleMixin(Base) {
  // The class prototype added by the mixin.
  class AriaRole extends Base {
    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        role: null,
      });
    }

    [render](/** @type {ChangedFlags} */ changed) {
      if (super[render]) {
        super[render](changed);
      }
      if (changed.role) {
        // Apply top-level role.
        const { role } = this[state];
        if (role) {
          this.setAttribute("role", role);
        } else {
          this.removeAttribute("role");
        }
      }
    }

    // Setting the standard role attribute will invoke this property setter,
    // which will allow us to update our state.
    get role() {
      return super.role;
    }
    set role(role) {
      const s = String(role);
      super.role = s;
      if (!this[rendering]) {
        this[setState]({ s });
      }
    }
  }

  return AriaRole;
}

const Base$b = AriaRoleMixin(ReactiveElement);

/**
 * Background element shown behind an overlay's primary content
 *
 * The backdrop is transparent by default, suggesting to the user that the
 * overlay is modeless, and they can click through it to reach the background
 * elements. For a modal variant, see [ModalBackdrop](ModalBackdrop).
 *
 * @inherits ReactiveElement
 * @mixes AriaRoleMixin
 */
class Backdrop extends Base$b {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      role: "none",
    });
  }

  get [template]() {
    return templateFrom.html`
      <style>
        :host {
          display: inline-block;
          height: 100%;
          left: 0;
          position: fixed;
          top: 0;
          touch-action: manipulation;
          width: 100%;
        }
      </style>
      <slot></slot>
    `;
  }
}

/**
 * Semi-transparent backdrop for a modal overlay
 *
 * This type of backdrop is used by [Dialog](Dialog) and [Drawer](Drawer). The
 * backdrop slightly obscures the background elements, focusing the user's
 * attention on the overlay.
 *
 * @inherits Backdrop
 */
class ModalBackdrop extends Backdrop {
  constructor() {
    super();

    // As of Sep 2018, Mobile Safari allows the user to drag on the backdrop to
    // scroll the page behind it, which violates the modality. To correct this,
    // we prevent touchmove events with one touch from performing the default
    // page scrolling.
    //
    // Android Chrome already correctly prevents drags from reaching the page,
    // so we only engage this workaround if we don't see support for pointer
    // events -- in which case we assume we're in Safari.
    if (!("PointerEvent" in window)) {
      this.addEventListener("touchmove", (event) => {
        if (event.touches.length === 1) {
          event.preventDefault();
        }
      });
    }
  }
}

/** @type {any} */
const closePromiseKey = Symbol("closePromise");
/** @type {any} */
const closeResolveKey = Symbol("closeResolve");

/**
 * Tracks the open/close state of a component.
 *
 * @module OpenCloseMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function OpenCloseMixin(Base) {
  // The class prototype added by the mixin.
  class OpenClose extends Base {
    attributeChangedCallback(name, oldValue, newValue) {
      if (name === "opened") {
        const value = booleanAttributeValue(name, newValue);
        if (this.opened !== value) {
          this.opened = value;
        }
      } else {
        super.attributeChangedCallback(name, oldValue, newValue);
      }
    }

    /**
     * Close the component (if not already closed).
     *
     * Some components like [AlertDialog](AlertDialog) want to indicate why or
     * how they were closed. To support such scenarios, you can supply a value
     * to the optional `closeResult` parameter. This closeResult will be made
     * available in the `whenClosed` promise and the `state.closeResult` member.
     *
     * @param {object} [closeResult] - an indication of how or why the element closed
     */
    async close(closeResult) {
      if (super.close) {
        await super.close();
      }
      this[setState]({ closeResult });
      await this.toggle(false);
    }

    /**
     * True if the element is currently closed.
     *
     * This read-only property is provided as a convenient inverse of `opened`.
     *
     * @type {boolean}
     */
    get closed() {
      return this[state] && !this[state].opened;
    }

    /**
     * True if the element has completely closed.
     *
     * For components not using asynchronous open/close effects, this property
     * returns the same value as the `closed` property. For elements that have a
     * true value of `state.openCloseEffects` (e.g., elements using
     * [TransitionEffectMixin](TransitionEffectMixin)), this property returns
     * true only if `state.effect` is "close" and `state.effectPhase` is
     * "after".
     *
     * @type {boolean}
     */
    get closeFinished() {
      return this[state].closeFinished;
    }

    get closeResult() {
      return this[state].closeResult;
    }

    // @ts-ignore
    get [defaultState]() {
      const defaults = {
        closeResult: null,
        opened: false,
      };
      // If this component defines a `startEffect` method (e.g., by using
      // TransitionEffectMixin), include default state for open/close effects.
      // Since the component is closed by default, the default effect state is
      // after the close effect has completed.
      if (this[startEffect]) {
        Object.assign(defaults, {
          closeFinished: true,
          effect: "close",
          effectPhase: "after",
          openCloseEffects: true,
        });
      }
      return Object.assign(super[defaultState] || {}, defaults);
    }

    /**
     * Open the element (if not already opened).
     */
    async open() {
      if (super.open) {
        await super.open();
      }
      this[setState]({ closeResult: undefined });
      await this.toggle(true);
    }

    /**
     * True if the element is currently opened.
     *
     * This property can be set as a boolean attribute
     *
     * @type {boolean}
     * @default false
     */
    get opened() {
      return this[state] && this[state].opened;
    }
    set opened(opened) {
      this[setState]({ closeResult: undefined });
      this.toggle(opened);
    }

    [render](changed) {
      super[render](changed);

      // Reflect opened state.
      if (changed.opened) {
        const { opened } = this[state];
        setInternalState(this, "opened", opened);
      }

      // Reflect closed state. To handle asynchronous close effects, we reflect
      // the inverse of closeFinished instead of reflecting closed.
      if (changed.closeFinished) {
        const { closeFinished } = this[state];
        setInternalState(this, "closed", closeFinished);
      }
    }

    [rendered](/** @type {ChangedFlags} */ changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }

      if (changed.opened && this[raiseChangeEvents]) {
        const oldEvent = new CustomEvent("opened-changed", {
          bubbles: true,
          detail: {
            closeResult: this[state].closeResult,
            opened: this[state].opened,
          },
        });
        this.dispatchEvent(oldEvent);
        /**
         * Raised when the opened/closed state of the component changes.
         *
         * @event openedchange
         */
        const openedChangeEvent = new CustomEvent("openedchange", {
          bubbles: true,
          detail: {
            closeResult: this[state].closeResult,
            opened: this[state].opened,
          },
        });
        this.dispatchEvent(openedChangeEvent);

        if (this[state].opened) {
          const oldOpenedEvent = new CustomEvent("opened", {
            bubbles: true,
          });
          this.dispatchEvent(oldOpenedEvent);
          /**
           * Raised when the component opens.
           *
           * @event open
           */
          const openEvent = new CustomEvent("open", {
            bubbles: true,
          });
          this.dispatchEvent(openEvent);
        } else {
          const oldClosedEvent = new CustomEvent("closed", {
            bubbles: true,
            detail: {
              closeResult: this[state].closeResult,
            },
          });
          this.dispatchEvent(oldClosedEvent);
          /**
           * Raised when the component closes.
           *
           * @event close
           */
          const closeEvent = new CustomEvent("close", {
            bubbles: true,
            detail: {
              closeResult: this[state].closeResult,
            },
          });
          this.dispatchEvent(closeEvent);
        }
      }

      // If someone's waiting for the component to close, and it's completely
      // finished closing, then resolve the close promise.
      const closeResolve = this[closeResolveKey];
      if (this.closeFinished && closeResolve) {
        this[closeResolveKey] = null;
        this[closePromiseKey] = null;
        closeResolve(this[state].closeResult);
      }
    }

    [stateEffects](state, changed) {
      const effects = super[stateEffects]
        ? super[stateEffects](state, changed)
        : {};

      // Update our notion of closeFinished to track the closed state for
      // components with synchronous open/close effects and components with
      // asynchronous open/close effects.
      if (
        changed.openCloseEffects ||
        changed.effect ||
        changed.effectPhase ||
        changed.opened
      ) {
        const { effect, effectPhase, openCloseEffects, opened } = state;
        const closeFinished = openCloseEffects
          ? effect === "close" && effectPhase === "after"
          : !opened;
        Object.assign(effects, { closeFinished });
      }

      return effects;
    }

    /**
     * Toggle the open/close state of the element.
     *
     * @param {boolean} [opened] - true if the element should be opened, false
     * if closed.
     */
    async toggle(opened = !this.opened) {
      if (super.toggle) {
        await super.toggle(opened);
      }
      const changed = opened !== this[state].opened;
      if (changed) {
        /** @type {PlainObject} */ const changes = { opened };
        if (this[state].openCloseEffects) {
          changes.effect = opened ? "open" : "close";
          if (this[state].effectPhase === "after") {
            changes.effectPhase = "before";
          }
        }
        await this[setState](changes);
      }
    }

    /**
     * This method can be used as an alternative to listening to the
     * "openedchange" event, particularly in situations where you want to only
     * handle the next time the component is closed.
     *
     * @returns {Promise} A promise that resolves when the element has
     * completely closed, including the completion of any asynchronous opening
     * effect.
     */
    whenClosed() {
      if (!this[closePromiseKey]) {
        this[closePromiseKey] = new Promise((resolve) => {
          this[closeResolveKey] = resolve;
        });
      }
      return this[closePromiseKey];
    }
  }

  return OpenClose;
}

/**
 * A simple frame for overlay content.
 *
 * The default appearance of `OverlayFrame` uses a simple drop-shadow to let the
 * user see the framed content as being on top of the background page content.
 *
 * @inherits ReactiveElement
 */
class OverlayFrame extends ReactiveElement {
  get [template]() {
    return templateFrom.html`
      <style>
        :host {
          display: inline-block;
          position: relative;
        }
      </style>
      <slot></slot>
    `;
  }
}

/** @type {any} */
const appendedToDocumentKey = Symbol("appendedToDocument");
/** @type {any} */
const defaultZIndexKey = Symbol("assignedZIndex");
/** @type {any} */
const restoreFocusToElementKey = Symbol("restoreFocusToElement");

/**
 * Displays an opened element on top of other page elements.
 *
 * This mixin handles showing and hiding an overlay element. It, together with
 * [OpenCloseMixin](OpenCloseMixin), form the core behavior for [Overlay](Overlay),
 * which in turn forms the basis of Elix's overlay components.
 *
 * @module OverlayMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function OverlayMixin(Base) {
  // The class prototype added by the mixin.
  class Overlay extends Base {
    // TODO: Document
    get autoFocus() {
      return this[state].autoFocus;
    }
    set autoFocus(autoFocus) {
      this[setState]({ autoFocus });
    }

    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        autoFocus: true,
        persistent: false,
      });
    }

    async open() {
      if (!this[state].persistent && !this.isConnected) {
        // Overlay isn't in document yet.
        this[appendedToDocumentKey] = true;
        document.body.append(this);
      }
      if (super.open) {
        await super.open();
      }
    }

    [render](/** @type {ChangedFlags} */ changed) {
      if (super[render]) {
        super[render](changed);
      }

      if (this[firstRender]) {
        this.addEventListener("blur", (event) => {
          // What has the focus now?
          const newFocusedElement =
            event.relatedTarget || document.activeElement;
          /** @type {any} */
          const node = this;
          if (newFocusedElement instanceof HTMLElement) {
            const focusInside = deepContains(node, newFocusedElement);
            if (!focusInside) {
              if (this.opened) {
                // The user has most likely clicked on something in the background
                // of a modeless overlay. Remember that element, and restore focus
                // to it when the overlay finishes closing.
                this[restoreFocusToElementKey] = newFocusedElement;
              } else {
                // A blur event fired, but the overlay closed itself before the blur
                // event could be processed. In closing, we may have already
                // restored the focus to the element that originally invoked the
                // overlay. Since the user has clicked somewhere else to close the
                // overlay, put the focus where they wanted it.
                newFocusedElement.focus();
                this[restoreFocusToElementKey] = null;
              }
            }
          }
        });
      }

      if (changed.effectPhase || changed.opened || changed.persistent) {
        if (!this[state].persistent) {
          // Temporary overlay
          const closed =
            typeof this.closeFinished === "undefined"
              ? this.closed
              : this.closeFinished;

          if (closed) {
            if (this[defaultZIndexKey]) {
              // Remove default z-index.
              this.style.zIndex = "";
              this[defaultZIndexKey] = null;
            }
          } else if (this[defaultZIndexKey]) {
            this.style.zIndex = this[defaultZIndexKey];
          } else {
            if (!hasZIndex(this)) {
              bringToFront(this);
            }
          }
        }
      }
    }

    [rendered](/** @type {ChangedFlags} */ changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }

      if (this[firstRender]) {
        // Perform one-time check to see if component needs a default z-index.
        if (this[state].persistent && !hasZIndex(this)) {
          bringToFront(this);
        }
      }

      if (changed.opened) {
        if (this[state].autoFocus) {
          if (this[state].opened) {
            // Opened
            if (
              !this[restoreFocusToElementKey] &&
              document.activeElement !== document.body
            ) {
              // Remember which element had the focus before we were opened.
              this[restoreFocusToElementKey] = document.activeElement;
            }
            // Focus on the element itself (if it's focusable), or the first focusable
            // element inside it.
            // TODO: We'd prefer to require that overlays (like the Overlay base
            // class) make use of delegatesFocus via DelegateFocusMixin, which would
            // let us drop the need for this mixin here to do anything special with
            // focus. However, an initial trial of this revealed an issue in
            // MenuButton, where invoking the menu did not put the focus on the first
            // menu item as expected. Needs more investigation.
            const focusElement = firstFocusableElement(this);
            if (focusElement) {
              focusElement.focus();
            }
          } else {
            // Closed
            if (this[restoreFocusToElementKey]) {
              // Restore focus to the element that had the focus before the overlay was
              // opened.
              this[restoreFocusToElementKey].focus();
              this[restoreFocusToElementKey] = null;
            }
          }
        }
      }

      // If we're finished closing an overlay that was automatically added to the
      // document, remove it now. Note: we only do this when the component
      // updates, not when it mounts, because we don't want an automatically-added
      // element to be immediately removed during its connectedCallback.
      if (
        !this[firstRender] &&
        !this[state].persistent &&
        this.closeFinished &&
        this[appendedToDocumentKey]
      ) {
        this[appendedToDocumentKey] = false;
        if (this.parentNode) {
          this.parentNode.removeChild(this);
        }
      }
    }

    get [template]() {
      const result = super[template] || templateFrom.html``;

      // We'd like to just use the `hidden` attribute, but a side-effect of
      // styling with the hidden attribute is that naive styling of the
      // component from the outside (to change to display: flex, say) will
      // override the display: none implied by hidden. To work around this
      // problem, we use display: none when the overlay is closed.
      result.content.append(fragmentFrom.html`
        <style>
          :host([closed]) {
            display: none;
          }
        </style>
      `);

      return result;
    }
  }

  return Overlay;
}

// Pick a default z-index, remember it, and apply it.
function bringToFront(element) {
  const defaultZIndex = maxZIndexInUse() + 1;
  element[defaultZIndexKey] = defaultZIndex;
  element.style.zIndex = defaultZIndex.toString();
}

/**
 * If the element has or inherits an explicit numeric z-index, return true.
 * Otherwise, return false.
 *
 * @private
 * @param {HTMLElement} element
 * @returns {boolean}
 */
function hasZIndex(element) {
  const computedZIndex = getComputedStyle(element).zIndex;
  const explicitZIndex = element.style.zIndex;
  const isExplicitZIndexNumeric = !isNaN(parseInt(explicitZIndex));
  if (computedZIndex === "auto") {
    return isExplicitZIndexNumeric;
  }
  if (computedZIndex === "0" && !isExplicitZIndexNumeric) {
    // Might be on Safari, which reports a computed z-index of zero even in
    // cases where no z-index has been inherited but the element creates a
    // stacking context. Inspect the composed tree parent to infer whether the
    // element is really inheriting a z-index.
    const parent =
      element.assignedSlot ||
      (element instanceof ShadowRoot ? element.host : element.parentNode);
    if (!(parent instanceof HTMLElement)) {
      // Theoretical edge case, assume zero z-index is real.
      return true;
    }
    if (!hasZIndex(parent)) {
      // The parent doesn't have a numeric z-index, and the element itself
      // doesn't have a numeric z-index, so the "0" value for the computed
      // z-index is simulated, not a real assigned numeric z-index.
      return false;
    }
  }
  // Element has a non-zero numeric z-index.
  return true;
}

/*
 * Return the highest z-index currently in use in the document's light DOM.
 *
 * This calculation looks at all light DOM elements, so is theoretically
 * expensive. That said, it only runs when an overlay is opening, and is only used
 * if an overlay doesn't have a z-index already. In cases where performance is
 * an issue, this calculation can be completely circumvented by manually
 * applying a z-index to an overlay.
 */
function maxZIndexInUse() {
  const elements = document.body.querySelectorAll("*");
  const zIndices = Array.from(elements, (element) => {
    const style = getComputedStyle(element);
    let zIndex = 0;
    if (style.position !== "static" && style.zIndex !== "auto") {
      const parsed = style.zIndex ? parseInt(style.zIndex) : 0;
      zIndex = !isNaN(parsed) ? parsed : 0;
    }
    return zIndex;
  });
  return Math.max(...zIndices);
}

/**
 * Defines a component's content as the flattened set of nodes assigned to a
 * slot.
 *
 * This mixin defines a component's `content` state member as the flattened
 * set of nodes assigned to a slot, typically the default slot.
 *
 * If the set of assigned nodes changes, the `content` state will be updated.
 * This helps a component satisfy the Gold Standard checklist item for
 * monitoring
 * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).
 *
 * By default, the mixin looks in the component's shadow subtree for a default
 * (unnamed) `slot` element. You can specify that a different slot should be
 * used by overriding the `internal.contentSlot` property.
 *
 * Most Elix [elements](elements) use `SlotContentMixin`, including
 * [ListBox](ListBox), [Modes](Modes), and [Tabs](Tabs).
 *
 * @module SlotContentMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function SlotContentMixin(Base) {
  // The class prototype added by the mixin.
  class SlotContent extends Base {
    /**
     * See [contentSlot](internal#internal.contentSlot).
     */
    get [contentSlot]() {
      /** @type {HTMLSlotElement|null} */ const slot =
        this[shadowRoot] && this[shadowRoot].querySelector("slot:not([name])");
      if (!this[shadowRoot] || !slot) {
        /* eslint-disable no-console */
        console.warn(
          `SlotContentMixin expects ${this.constructor.name} to define a shadow tree that includes a default (unnamed) slot.\nSee https://elix.org/documentation/SlotContentMixin.`
        );
      }
      return slot;
    }

    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        content: null,
      });
    }

    [rendered](/** @type {ChangedFlags} */ changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }

      if (this[firstRender]) {
        // Listen to changes on the default slot.
        const slot = this[contentSlot];
        if (slot) {
          slot.addEventListener("slotchange", async () => {
            // Although slotchange isn't generally a user-driven event, it's
            // impossible for us to know whether a change in slot content is going
            // to result in effects that the host of this element can predict.
            // To be on the safe side, we raise any change events that come up
            // during the processing of this event.
            this[raiseChangeEvents] = true;

            // The nodes assigned to the given component have changed.
            // Update the component's state to reflect the new content.
            const content = slot.assignedNodes({ flatten: true });
            Object.freeze(content);
            this[setState]({ content });

            await Promise.resolve();
            this[raiseChangeEvents] = false;
          });
        }
      }
    }
  }

  return SlotContent;
}

// TODO: We'd like to use DelegateFocusMixin in this component, but see the note
// at OverlayMixin's openedChanged function.
const Base$a = OpenCloseMixin(OverlayMixin(SlotContentMixin(ReactiveElement)));

/**
 * An element that appears over other page elements
 *
 * The main overlay content is presented within a frame on top of an optional
 * backdrop.
 *
 * The overlay logic is provided by [OverlayMixin](OverlayMixin). `Overlay` adds
 * the definition of customizable element tags: [frameTag](#frameTag) for the
 * frame around the overlay content, and [backdropTag](#backdropTag) (if
 * defined) for the optional element covering the page elements behind the
 * overlay.
 *
 * As a convenience, the `open` method of `Overlay` will automatically add the
 * overlay to the end of the document body if the overlay isn't already in the
 * document. If the overlay is automatically attached in this way, then when it
 * closes, it will automatically be removed.
 *
 * See [Dialog](Dialog) and [Popup](Popup) for modal and modeless subclasses,
 * respectively.
 *
 * @inherits ReactiveElement
 * @mixes OpenCloseMixin
 * @mixes OverlayMixin
 * @mixes SlotContentMixin
 * @part {Backdrop} backdrop - the backdrop behind the overlay
 * @part {OverlayFrame} frame - the frame around the overlay
 */
class Overlay extends Base$a {
  get backdrop() {
    return this[ids] && this[ids].backdrop;
  }

  /**
   * The class or tag used for the `backdrop` part - the optional
   * element shown behind the overlay.
   *
   * This can help focus the user's attention on the overlay content.
   * Additionally, a backdrop can be used to absorb clicks on background page
   * elements. For example, [Dialog](Dialog) uses [ModalBackdrop](ModalBackdrop)
   * as an overlay backdrop in such a way.
   *
   * @type {PartDescriptor}
   * @default Backdrop
   */
  get backdropPartType() {
    return this[state].backdropPartType;
  }
  set backdropPartType(backdropPartType) {
    this[setState]({ backdropPartType });
  }

  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      backdropPartType: Backdrop,
      framePartType: OverlayFrame,
    });
  }

  get frame() {
    return this[ids].frame;
  }

  /**
   * The class or tag used to create the `frame` part – the overlay's
   * primary content.
   *
   * The frame element can be used to provide a border around the overlay
   * content, and to provide visual effects such as a drop-shadow to help
   * distinguish overlay content from background page elements.
   *
   * @type {PartDescriptor}
   * @default OverlayFrame
   */
  get framePartType() {
    return this[state].framePartType;
  }
  set framePartType(framePartType) {
    this[setState]({ framePartType });
  }

  [render](/** @type {ChangedFlags} */ changed) {
    super[render](changed);
    renderParts$3(this[shadowRoot], this[state], changed);
  }

  [rendered](/** @type {ChangedFlags} */ changed) {
    super[rendered](changed);

    if (changed.opened && this[state].content) {
      // If contents know how to size themselves, ask them to check their size.
      this[state].content.forEach((element) => {
        if (element[checkSize]) {
          element[checkSize]();
        }
      });
    }
  }

  get [template]() {
    const result = super[template];

    // TODO: Consider moving frameContent div to Drawer.
    result.content.append(fragmentFrom.html`
      <style>
        :host {
          display: inline-grid;
          /* Constrain content if overlay's height is constrained. */
          grid-template: minmax(0, 1fr) / minmax(0, 1fr);
          max-height: 100vh;
          max-width: 100vw;
          outline: none;
          position: fixed;
          -webkit-tap-highlight-color: transparent;
        }

        [part~="frame"] {
          box-sizing: border-box;
          display: grid;
          overscroll-behavior: contain;
          pointer-events: initial;
          position: relative;
        }

        #frameContent {
          display: grid;
          grid-template: minmax(0, 1fr) / minmax(0, 1fr);
          overflow: hidden;
        }
      </style>
      <div id="backdrop" part="backdrop" tabindex="-1"></div>
      <div id="frame" part="frame" role="none">
        <div id="frameContent">
          <slot></slot>
        </div>
      </div>
    `);

    renderParts$3(result.content, this[state]);

    return result;
  }
}

/**
 * Render parts for the template or an instance.
 *
 * @private
 * @param {DocumentFragment} root
 * @param {PlainObject} state
 * @param {ChangedFlags} [changed]
 */
function renderParts$3(root, state, changed) {
  if (!changed || changed.backdropPartType) {
    const { backdropPartType } = state;
    const backdrop = root.getElementById("backdrop");
    if (backdrop) {
      transmute(backdrop, backdropPartType);
    }
  }
  if (!changed || changed.framePartType) {
    const { framePartType } = state;
    const frame = root.getElementById("frame");
    if (frame) {
      transmute(frame, framePartType);
    }
  }
}

const Base$9 = DialogModalityMixin(FocusCaptureMixin(KeyboardMixin(Overlay)));

/**
 * Basic modal overlay that the user typically dismisses with an explicit action.
 *
 * This component presents its children as a basic modal dialog which appears on
 * top of the main page content and which the user must interact with before
 * they can return to the page.
 *
 * @inherits Overlay
 * @mixes DialogModalityMixin
 * @mixes FocusCaptureMixin
 * @mixes KeyboardMixin
 * @part {ModalBackdrop} backdrop
 */
class Dialog extends Base$9 {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      backdropPartType: ModalBackdrop,
      tabIndex: -1,
    });
  }

  get [template]() {
    const result = super[template];

    const frame = result.content.querySelector("#frame");
    /** @type {any} */ const cast = this;
    cast[FocusCaptureMixin.wrap](frame);

    result.content.append(
      fragmentFrom.html`
        <style>
          :host {
            height: 100%;
            left: 0;
            pointer-events: initial;
            top: 0;
            width: 100%;
          }
        </style>
      `
    );

    return result;
  }
}

/**
 * Asks a single question the user can answer with choice buttons
 *
 * @inherits Dialog
 * @part {button} choice-button - a button representing a choice
 * @part {div} choice-button-container - the container for the choice buttons
 */
class AlertDialog extends Dialog {
  /**
   * The buttons created by the component to represent the choices in the
   * [choices](#choices) property.
   *
   * @type {HTMLElement[]}
   */
  get choiceButtons() {
    return this[state].choiceButtons;
  }

  /**
   * The class or tag used to create the `choice-button` parts —
   * the set of choices shown to the user.
   *
   * @type {PartDescriptor}
   * @default 'button'
   */
  get choiceButtonPartType() {
    return this[state].choiceButtonPartType;
  }
  set choiceButtonPartType(choiceButtonPartType) {
    this[setState]({ choiceButtonPartType });
  }

  /**
   * An array of strings indicating the choices the `AlertDialog` will present
   * to the user as responses to the alert. For each string in the array, the
   * `AlertDialog` displays a button labeled with that string.
   *
   * By default, this is an array with a single choice, "OK".
   *
   * @type {string[]}
   */
  get choices() {
    return this[state].choices;
  }
  set choices(choices) {
    this[setState]({ choices });
  }

  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      choiceButtonPartType: "button",
      choiceButtons: [],
      choices: ["OK"],
    });
  }

  // Let the user select a choice by pressing its initial letter.
  [keydown](/** @type {KeyboardEvent} */ event) {
    let handled = false;

    const key = event.key.length === 1 && event.key.toLowerCase();
    if (key) {
      // See if one of the choices starts with the key.
      const choice = this.choices.find(
        (choice) => choice[0].toLowerCase() === key
      );
      if (choice) {
        this.close({
          choice,
        });
        handled = true;
      }
    }

    // Prefer mixin result if it's defined, otherwise use base result.
    return handled || (super[keydown] && super[keydown](event)) || false;
  }

  [render](/** @type {ChangedFlags} */ changed) {
    super[render](changed);

    if (this[firstRender]) {
      this[ids].choiceButtonContainer.addEventListener(
        "click",
        async (event) => {
          // TODO: Ignore clicks on choiceButtonContainer background.
          const button = event.target;
          if (button instanceof HTMLElement) {
            const choice = button.textContent;
            this[raiseChangeEvents] = true;
            await this.close({ choice });
            this[raiseChangeEvents] = false;
          }
        }
      );
    }

    if (changed.choiceButtons) {
      updateChildNodes(
        this[ids].choiceButtonContainer,
        this[state].choiceButtons
      );
    }
  }

  [stateEffects](state, changed) {
    const effects = super[stateEffects](state, changed);

    // When choices or choice button part type changes, regenerate buttons.
    if (changed.choiceButtonPartType || changed.choices) {
      /** @type {string[]} */ const choices = state.choices;
      const choiceButtons = choices.map((choice) => {
        const button = createElement(state.choiceButtonPartType);
        if ("part" in button) {
          /** @type {any} */ (button).part = "choice-button";
        }
        button.textContent = choice;
        return button;
      });
      Object.freeze(choiceButtons);
      Object.assign(effects, {
        choiceButtons,
      });
    }

    return effects;
  }

  get [template]() {
    const result = super[template];
    // Replace the default slot with a new default slot and a button container.
    const defaultSlot = result.content.querySelector("slot:not([name])");
    if (defaultSlot) {
      defaultSlot.replaceWith(fragmentFrom.html`
        <div id="alertDialogContent">
          <slot></slot>
          <div id="choiceButtonContainer" part="choice-button-container"></div>
        </div>
      `);
    }
    return result;
  }
}

// Quick detection of whether we'll need to handle focus.
// As of February 2019, we don't need to handle this in Chrome, perhaps because
// they already support delegatesFocus (which handles related focus issues).
const focusTest = document.createElement("div");
focusTest.attachShadow({ mode: "open", delegatesFocus: true });
/** @type {any} */
const focusTestShadowRoot = focusTest.shadowRoot;
const nativeDelegatesFocus = focusTestShadowRoot.delegatesFocus;

/**
 * Normalizes focus treatment for custom elements with Shadow DOM
 *
 * This mixin exists because the default behavior for mousedown should set the
 * focus to the closest ancestor of the clicked element that can take the focus.
 * As of Nov 2018, Chrome and Safari don't handle this as expected when the
 * clicked element is reassigned across more than one slot to end up inside a
 * focusable element. In such cases, the focus will end up on the body. Firefox
 * exhibits the behavior we want. See
 * https://github.com/w3c/webcomponents/issues/773.
 *
 * This mixin normalizes behavior to provide what Firefox does. When the user
 * mouses down inside anywhere inside the component's light DOM or Shadow DOM,
 * we walk up the composed tree to find the first element that can take the
 * focus and put the focus on it.
 *
 * @module ComposedFocusMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function ComposedFocusMixin(Base) {
  // The class prototype added by the mixin.
  class ComposedFocus extends Base {
    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        composeFocus: !nativeDelegatesFocus,
      });
    }

    [render](/** @type {ChangedFlags} */ changed) {
      if (super[render]) {
        super[render](changed);
      }
      if (this[firstRender]) {
        this.addEventListener("mousedown", (event) => {
          if (!this[state].composeFocus) {
            return;
          }
          // Only process events for the main (usually left) button.
          if (event.button !== 0) {
            return;
          }
          if (event.target instanceof Element) {
            const target = closestFocusableNode(event.target);
            if (target) {
              target.focus();
              event.preventDefault();
            }
          }
        });
      }
    }
  }

  return ComposedFocus;
}

/**
 * Delegates its ARIA label property to an inner input-type element.
 *
 * This helps ensure that elements built around an inner input element provide a
 * proper accessible label for assistive technologies like screen readers.
 *
 * You can identify which inner input element selection should be delegated to
 * by defining an `internal.inputDelegate` property and returning the desired
 * inner input.
 *
 * @module DelegateInputLabelMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function DelegateInputLabelMixin(Base) {
  // The class prototype added by the mixin.
  class DelegateInputLabel extends Base {
    // Forward any ARIA label to the input element.
    get ariaLabel() {
      return this[state].ariaLabel;
    }
    set ariaLabel(ariaLabel) {
      if (!this[state].removingAriaAttribute) {
        this[setState]({
          ariaLabel: String(ariaLabel),
        });
      }
    }

    // Forward ARIA labelledby as an aria-label to the input element.
    // Note the lowercase "b" in the name, necessary to support the actual
    // attribute name "aria-labelledby", which has no hyphen before the "by".
    get ariaLabelledby() {
      return this[state].ariaLabelledby;
    }
    set ariaLabelledby(ariaLabelledby) {
      if (!this[state].removingAriaAttribute) {
        this[setState]({
          ariaLabelledby: String(ariaLabelledby),
        });
      }
    }

    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        ariaLabel: null,
        ariaLabelledby: null,
        inputLabel: null,
        removingAriaAttribute: false,
      });
    }

    [render](changed) {
      if (super[render]) {
        super[render](changed);
      }

      if (this[firstRender]) {
        // Refresh the input label on focus. This refresh appears to happen fast
        // enough that the screen reader will announce the refreshed label.
        this.addEventListener("focus", () => {
          this[raiseChangeEvents] = true;
          const inputLabel = refreshInputLabel(this, this[state]);
          this[setState]({ inputLabel });
          this[raiseChangeEvents] = false;
        });
      }

      // Apply the latest input label to the input delegate.
      if (changed.inputLabel) {
        const { inputLabel } = this[state];
        if (inputLabel) {
          this[inputDelegate].setAttribute("aria-label", inputLabel);
        } else {
          this[inputDelegate].removeAttribute("aria-label");
        }
      }
    }

    [rendered](changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }

      if (this[firstRender]) {
        // Refresh the label on first render. This is not guaranteed to pick up
        // labels defined by another element, as that element (or elements) may
        // not be in the DOM yet. For that reason, we'll also refresh the label
        // on focus. The reason to do it now is to handle the common cases where
        // the element defining the label does exist so that accessibility
        // testing tools can confirm that the input delegate does have a label.
        // Because this refresh can entail multiple searches of the tree, we
        // defer the refresh to idle time.
        // @ts-ignore
        const idleCallback = window.requestIdleCallback || setTimeout;
        idleCallback(() => {
          const inputLabel = refreshInputLabel(this, this[state]);
          this[setState]({ inputLabel });
        });
      }

      // Once we've obtained an aria-label or aria-labelledby from the host, we
      // remove those attirbutes so that the labels don't get announced twice.
      // We use a flag to distinguish between us removing our own ARIA
      // attributes (which should not update state), and someone removing
      // those attributes from the outside (which should update state).
      const { ariaLabel, ariaLabelledby } = this[state];
      if (changed.ariaLabel && !this[state].removingAriaAttribute) {
        if (this.getAttribute("aria-label")) {
          this.setAttribute("delegated-label", ariaLabel);
          this[setState]({ removingAriaAttribute: true });
          this.removeAttribute("aria-label");
        }
      }
      if (changed.ariaLabelledby && !this[state].removingAriaAttribute) {
        if (this.getAttribute("aria-labelledby")) {
          this.setAttribute("delegated-labelledby", ariaLabelledby);
          this[setState]({ removingAriaAttribute: true });
          this.removeAttribute("aria-labelledby");
        }
      }

      if (changed.removingAriaAttribute && this[state].removingAriaAttribute) {
        // We've done whatever removal we needed, and can now reset our flag.
        this[setState]({ removingAriaAttribute: false });
      }
    }

    [stateEffects](state, changed) {
      const effects = super[stateEffects]
        ? super[stateEffects](state, changed)
        : {};

      // If the ariaLabel changes, we can update our inputLabel state
      // immediately. Among other things, this facilitates scenarios where we
      // have nested elements using DelegateInputLabelMixin: the outermost
      // element can use whatever label approach it wants, the inner elements
      // will all use ariaLabel.
      //
      // We also update the label if we're focused, using ariaLabelledby, and
      // the selectedText changes. One pattern with select-like elements is to
      // have them include their own ID in the IDs specified by aria-labelledby.
      // This can incorporate the element's own `selectedText` in the announced
      // label. That `selectedText` can change while the element has focus, in
      // which case we'll refresh.
      if (
        (changed.ariaLabel && state.ariaLabel) ||
        (changed.selectedText &&
          state.ariaLabelledby &&
          this.matches(":focus-within"))
      ) {
        const inputLabel = refreshInputLabel(this, state);
        Object.assign(effects, { inputLabel });
      }

      return effects;
    }
  }

  return DelegateInputLabel;
}

// Given an element that is being used as a label, extract its label text.
function getLabelFromElement(element) {
  // We use innerText here instead of textContent because we want the rendered
  // text. If, e.g., a text node includes a span with `display: none`,
  // textContent would include that hidden text, but innerText would leave it
  // out -- which is what we want here.
  if ("selectedText" in element) {
    // Element (most likely Elix) with selectedText property
    return element.selectedText;
  } else if ("value" in element && "options" in element) {
    // select or select-like element
    const value = element.value;
    const option = element.options.find((option) => option.value === value);
    return option ? option.innerText : "";
  } else if ("value" in element) {
    // Other input element
    return element.value;
  } else {
    // Other
    return element.innerText;
  }
}

/**
 * Calculate an appropriate label for the component's delegated input element.
 * When the element gets the focus, we refresh its label. This is done because
 * three of the labeling strategies (`aria-labelledby` attribute, `for`
 * attribute, and wrapping `label`) reference other elements in the tree -- and
 * the contents of those elements can change dynamically.
 *
 * @private
 * @param {HTMLElement} element
 * @param {PlainObject} state
 */
function refreshInputLabel(element, state) {
  const { ariaLabel, ariaLabelledby } = state;
  /** @type {any} */ const rootNode = element.isConnected
    ? element.getRootNode()
    : null;
  let inputLabel = null;

  // Prefer aria-labelledby over aria-label, per
  // https://developers.google.com/web/fundamentals/accessibility/semantics-aria/aria-labels-and-relationships.
  // After that, we prefer a `label` element with a `for` attribute, and finally
  // a wrapping `label` element.
  //
  // There do not appear to be consistent cross-browser rules for handling
  // multiple forms of label assignment on the same component. E.g., if you
  // place an element in a wrapping label *and* point a `label` element at that
  // element with a `for` attribute, as of August 2020 Chrome and Firefox will
  // announce both, but Safari will only announce the `for` label.
  //
  // Since people are probably not relying upon specific results for multiple
  // forms of label assignment, we don't attempt to construct a combined label
  // in those cases.
  if (ariaLabelledby && rootNode) {
    // Collect labels from elements with the indicated IDs.
    const ids = ariaLabelledby.split(" ");
    const labels = ids.map((id) => {
      const elementWithId = rootNode.getElementById(id);
      // Get a label from the indicated element.
      // Special case: if the element is providing its own label, we return its
      // current `selectedText` state.
      const label = !elementWithId
        ? ""
        : elementWithId === element && state.value !== null
        ? state.selectedText
        : getLabelFromElement(elementWithId);
      return label;
    });
    inputLabel = labels.join(" ");
  } else if (ariaLabel) {
    // Use ariaLabel property as input label.
    inputLabel = ariaLabel;
  } else if (rootNode) {
    const id = element.id;
    if (id) {
      // Look for labelling element with `for` attribute.
      const elementWithFor = rootNode.querySelector(`[for="${id}"]`);
      if (elementWithFor instanceof HTMLElement) {
        // Obtain label from wrapping label element.
        inputLabel = getLabelFromElement(elementWithFor);
      }
    }
    if (inputLabel === null) {
      // Last option is to look for closest wrapping label element.
      const labelElement = element.closest("label");
      if (labelElement) {
        inputLabel = getLabelFromElement(labelElement);
      }
    }
  }

  if (inputLabel) {
    inputLabel = inputLabel.trim();
  }

  return inputLabel;
}

// We consider the keyboard to be active if the window has received a keydown
// event since the last mousedown event.
let keyboardActive = false;

/** @type {any} */
const focusVisibleChangedListenerKey = Symbol("focusVisibleChangedListener");

/**
 * Shows a focus indication if and only if the keyboard is active.
 *
 * The keyboard is considered to be active if a keyboard event has occurred
 * since the last mousedown event.
 *
 * This is loosely modeled after the proposed
 * [focus-visible](https://github.com/WICG/focus-visible) feature for CSS.
 *
 * @module FocusVisibleMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function FocusVisibleMixin(Base) {
  // The class prototype added by the mixin.
  return class FocusVisible extends Base {
    constructor() {
      // @ts-ignore
      super();

      // We listen to focusin/focusout instead of focus/blur because components
      // like Menu want to handle focus visiblity for the items they contain,
      // and those contained items can get the focus. Using focusin/focusout
      // lets us know whether this element *or any element it contains* has the
      // focus.
      //
      // Focus events are problematic in that they can occur during rendering:
      // if an element with the focus is updated so that its tabindex is
      // removed, it will lose focus. Since these focus handlers need to set
      // state, this could lead to setting state during rendering, which is bad.
      // To avoid this problem, we use promise timing to defer the setting of
      // state.
      this.addEventListener("focusout", (event) => {
        Promise.resolve().then(() => {
          // What has the focus now?
          /** @type {any} */ const cast = event;
          const newFocusedElement =
            cast.relatedTarget || document.activeElement;
          const isFocusedElement = this === newFocusedElement;
          const containsFocus = deepContains(this, newFocusedElement);
          const lostFocus = !isFocusedElement && !containsFocus;
          if (lostFocus) {
            this[setState]({
              focusVisible: false,
            });
            // No longer need to listen for changes in focus visibility.
            document.removeEventListener(
              "focusvisiblechange",
              this[focusVisibleChangedListenerKey]
            );
            this[focusVisibleChangedListenerKey] = null;
          }
        });
      });
      this.addEventListener("focusin", () => {
        Promise.resolve().then(() => {
          if (this[state].focusVisible !== keyboardActive) {
            // Show the element as focused if the keyboard has been used.
            this[setState]({
              focusVisible: keyboardActive,
            });
          }
          if (!this[focusVisibleChangedListenerKey]) {
            // Listen to subsequent changes in focus visibility.
            this[focusVisibleChangedListenerKey] = () => refreshFocus(this);
            document.addEventListener(
              "focusvisiblechange",
              this[focusVisibleChangedListenerKey]
            );
          }
        });
      });
    }

    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        focusVisible: false,
      });
    }

    [render](/** @type {ChangedFlags} */ changed) {
      if (super[render]) {
        super[render](changed);
      }

      // Suppress the component's normal `outline` style unless we know the
      // focus should be visible.
      if (changed.focusVisible) {
        const { focusVisible } = this[state];
        this.toggleAttribute("focus-visible", focusVisible);
      }
    }

    get [template]() {
      const result = super[template] || templateFrom.html``;
      result.content.append(fragmentFrom.html`
        <style>
          :host {
            outline: none;
          }

          :host([focus-visible]:focus-within) {
            outline-color: Highlight; /* Firefox */
            outline-color: -webkit-focus-ring-color; /* All other browsers */
            outline-style: auto;
          }
        </style>
      `);
      return result;
    }
  };
}

function refreshFocus(/** @type {ReactiveElement} */ element) {
  element[setState]({
    focusVisible: keyboardActive,
  });
}

function updateKeyboardActive(/** @type {boolean} */ newKeyboardActive) {
  if (keyboardActive !== newKeyboardActive) {
    keyboardActive = newKeyboardActive;
    const oldEvent = new CustomEvent("focus-visible-changed", {
      detail: {
        focusVisible: keyboardActive,
      },
    });
    document.dispatchEvent(oldEvent);
    const event = new CustomEvent("focusvisiblechange", {
      detail: {
        focusVisible: keyboardActive,
      },
    });
    document.dispatchEvent(event);
  }
}

// Listen for top-level keydown and mousedown events.
// Use capture phase so we detect events even if they're handled.
window.addEventListener(
  "keydown",
  () => {
    updateKeyboardActive(true);
  },
  { capture: true }
);

window.addEventListener(
  "mousedown",
  () => {
    updateKeyboardActive(false);
  },
  { capture: true }
);

/**
 * Delegates a component's focus to its first focusable shadow element.
 *
 * This mixin serves as a polyfill for the standard `delegatesFocus` shadow root
 * property. As of June 2020, that property is still only natively supported in
 * Chrome. The Chrome delegatesFocus implementation has some subtle issues;
 * until additional implementations are available, it's hard to know whether the
 * issues are with the definition of delegatesFocus, with Chrome's
 * implementation, or with Elix component code. Accordingly, for the time being
 * this polyfill is used even on Chrome.
 *
 * @module DelegateFocusMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function DelegateFocusMixin(Base) {
  // The class prototype added by the mixin.
  class DelegateFocus extends Base {
    /**
     * Returns true if the component is delegating its focus.
     *
     * A component using `DelegateFocusMixin` will always have this property be
     * true unless a class takes measures to override it.
     *
     * @type {boolean}
     * @default true
     */
    get [delegatesFocus]() {
      return true;
    }

    /**
     * If someone tries to put the focus on us, delegate the focus to the first
     * focusable element in the composed tree below our shadow root.
     *
     * @ignore
     * @param {FocusOptions=} focusOptions
     */
    focus(focusOptions) {
      // On browsers that support delegatesFocus natively, we should just be
      // able to let the browser handle the focus method. However, we hit a bug
      // in June 2020 where the native focus method in Chrome did not always
      // produce the expected results if delegatesFocus is set.
      //
      // Specific bug: a PopupButton would like to delegates focus to its source
      // button. Tabbing to a PopupButton focused on the source button as
      // expected. Moreover, programmatically setting focus on the button also
      // worked. However, when a PopupButton's popup was closed with the Escape
      // key, OverlayMixin attemped to set programmatically focus to the
      // PopupButton. This did *not* work as expecte, and focus ended up on the
      // body. Until we have a second native implementation to compare against,
      // it's difficult to determine whether this is a bug in the definition of
      // delegatesFocus, Chrome's implementation, or our code.

      // /** @type {any} */ const cast = this[shadowRoot];
      // if (cast.delegatesFocus) {
      //   // Native support for delegatesFocus, so don't need to do anything.
      //   super.focus(focusOptions);
      //   return;
      // }
      const focusElement = this[focusTarget];
      if (focusElement) {
        focusElement.focus(focusOptions);
      }
    }

    get [focusTarget]() {
      // HACK: The commented-out code lets us rely on the browser to indicate
      // which element should be focused on in browsers that don't support
      // native delegatesFocus. However, this code creates subtle focus problems
      // in components like AutoCompleteListBox: if the user clicks the toggle
      // button, the focus won't be placed on the top-level AutoCompleteComboBox
      // as expected; that element will be returned as the focus target, but if
      // it doesn't have a non-negative tabindex, forwardFocus won't think it's
      // focusable. A more correct solution would be for all components that are
      // focusable to give themselves a tabIndex of 0 by default or define a new
      // public `focusable` that components could use to indicate that they're
      // focusable. Until we have time to fully explore that, we workaround the
      // bug by providing the polyfill behavior even in browsers that have
      // delegatesFocus.

      // /** @type {any} */ const cast = this[shadowRoot];
      // return cast.delegatesFocus
      //   ? this
      //   : firstFocusableElement(this[shadowRoot]);
      return firstFocusableElement(this[shadowRoot]);
    }
  }

  return DelegateFocus;
}

const extendsKey = Symbol("extends");

const delegatedPropertySettersKey = Symbol("delegatedPropertySetters");

/* True if a standard element is focusable by default. */
/** @type {IndexedObject<boolean>} */
const focusableByDefault = {
  a: true,
  area: true,
  button: true,
  details: true,
  iframe: true,
  input: true,
  select: true,
  textarea: true,
};

/*
 * A set of events which, if fired by the inner standard element, should be
 * re-raised by the custom element.
 *
 * These are events which are spec'ed to NOT get retargetted across a Shadow DOM
 * boundary, organized by which element(s) raise the events. To properly
 * simulate these, we will need to listen for the real events, then re-raise a
 * simulation of the original event. For more information, see
 * https://www.w3.org/TR/shadow-dom/#h-events-that-are-not-leaked-into-ancestor-trees.
 *
 * It appears that we do *not* need to re-raise the non-bubbling "focus" and
 * "blur" events. These appear to be automatically re-raised as expected -- but
 * it's not clear why that happens.
 *
 * The list below is reasonably complete. It omits elements that cannot be
 * wrapped (see class notes above). Also, we haven't actually tried wrapping
 * every element in this list; some of the more obscure ones might not actually
 * work as expected, but it was easier to include them for completeness than
 * to actually verify whether or not the element can be wrapped.
 */
/** @type {IndexedObject<string[]>} */
const reraiseEvents = {
  address: ["scroll"],
  blockquote: ["scroll"],
  caption: ["scroll"],
  center: ["scroll"],
  dd: ["scroll"],
  dir: ["scroll"],
  div: ["scroll"],
  dl: ["scroll"],
  dt: ["scroll"],
  fieldset: ["scroll"],
  form: ["reset", "scroll"],
  frame: ["load"],
  h1: ["scroll"],
  h2: ["scroll"],
  h3: ["scroll"],
  h4: ["scroll"],
  h5: ["scroll"],
  h6: ["scroll"],
  iframe: ["load"],
  img: ["abort", "error", "load"],
  input: ["abort", "change", "error", "select", "load"],
  li: ["scroll"],
  link: ["load"],
  menu: ["scroll"],
  object: ["error", "scroll"],
  ol: ["scroll"],
  p: ["scroll"],
  script: ["error", "load"],
  select: ["change", "scroll"],
  tbody: ["scroll"],
  tfoot: ["scroll"],
  thead: ["scroll"],
  textarea: ["change", "select", "scroll"],
};

/*
 * Mouse events that should be disabled if the inner component is disabled.
 */
const mouseEventNames = [
  "click",
  "dblclick",
  "mousedown",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "wheel",
];

// Keep track of which re-raised events should bubble.
/** @type {IndexedObject<boolean>} */
const eventBubbles = {
  abort: true,
  change: true,
  reset: true,
};

// Elements which are display: block by default.
// Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
const blockElements = [
  "address",
  "article",
  "aside",
  "blockquote",
  "canvas",
  "dd",
  "div",
  "dl",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "hr",
  "li",
  "main",
  "nav",
  "noscript",
  "ol",
  "output",
  "p",
  "pre",
  "section",
  "table",
  "tfoot",
  "ul",
  "video",
];

// Standard attributes that don't have corresponding properties.
// These need to be delegated from the wrapper to the inner element.
const attributesWithoutProperties = [
  "accept-charset",
  "autoplay",
  "buffered",
  "challenge",
  "codebase",
  "colspan",
  "contenteditable",
  "controls",
  "crossorigin",
  "datetime",
  "dirname",
  "for",
  "formaction",
  "http-equiv",
  "icon",
  "ismap",
  "itemprop",
  "keytype",
  "language",
  "loop",
  "manifest",
  "maxlength",
  "minlength",
  "muted",
  "novalidate",
  "preload",
  "radiogroup",
  "readonly",
  "referrerpolicy",
  "rowspan",
  "scoped",
  "usemap",
];

const Base$8 = DelegateFocusMixin(ReactiveElement);

/**
 * Wraps a standard HTML element so it can be extended
 *
 * The typical way to use this class is via its static `wrap` method.
 *
 * @inherits ReactiveElement
 * @mixes DelegateFocusMixin
 * @part inner - the inner standard HTML element
 */
class WrappedStandardElement extends Base$8 {
  constructor() {
    super();
    /** @type {any} */ const cast = this;
    if (!this[nativeInternals] && cast.attachInternals) {
      this[nativeInternals] = cast.attachInternals();
    }
  }

  /**
   *
   * Wrapped standard elements need to forward some attributes to the inner
   * element in cases where the attribute does not have a corresponding
   * property. These attributes include those prefixed with "aria-", and some
   * unusual standard attributes like contenteditable. To handle those, this
   * class defines its own attributeChangedCallback.
   *
   * @ignore
   * @param {string} name
   * @param {string} oldValue
   * @param {string} newValue
   */
  attributeChangedCallback(name, oldValue, newValue) {
    const forwardAttribute = attributesWithoutProperties.indexOf(name) >= 0;
    if (forwardAttribute) {
      const innerAttributes = Object.assign({}, this[state].innerAttributes, {
        [name]: newValue,
      });
      this[setState]({ innerAttributes });
    } else {
      // Rely on the base attributeChangedCallback provided by
      // AttributeMarshallingMixin.
      super.attributeChangedCallback(name, oldValue, newValue);
    }
  }

  // Delegate method defined by HTMLElement.
  blur() {
    this.inner.blur();
  }

  // One HTMLElement we *don't* delegate is `click`. Generally speaking, a click
  // on the outer wrapper should behave the same as a click on the inner
  // element. Also, we want to ensure outside event listeners get a click event
  // when the click method is invoked. But a click on the inner element will
  // raise a click event that won't be re-raised by default across the shadow
  // boundary. The precise behavior seems to be slightly different in Safari
  // than other browsers, but it seems safer to not delegate click.
  //
  // click() {}

  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      innerAttributes: {},
    });
  }

  get [defaultTabIndex]() {
    return focusableByDefault[this.extends] ? 0 : -1;
  }

  /**
   * The tag name of the standard HTML element extended by this class.
   *
   * @returns {string}
   */
  get extends() {
    return this.constructor[extendsKey];
  }

  /**
   * Returns a reference to the inner standard HTML element.
   *
   * @type {HTMLElement}
   */
  get inner() {
    /** @type {any} */
    const result = this[ids] && this[ids].inner;
    if (!result) {
      /* eslint-disable no-console */
      console.warn(
        "Attempted to get an inner standard element before it was instantiated."
      );
    }
    return result;
  }

  static get observedAttributes() {
    // For our custom attributeChangedCallback to work, we need to observe
    // the attributes we want to forward.
    // @ts-ignore
    return [...super.observedAttributes, ...attributesWithoutProperties];
  }

  [render](/** @type {ChangedFlags} */ changed) {
    super[render](changed);

    const inner = this.inner;
    if (this[firstRender]) {
      // Listen for any events raised by the inner element which will not
      // automatically be retargetted across the Shadow DOM boundary, and
      // re-raise those events when they happen.
      const eventNames = reraiseEvents[this.extends] || [];
      eventNames.forEach((eventName) => {
        inner.addEventListener(eventName, () => {
          const event = new Event(eventName, {
            bubbles: eventBubbles[eventName] || false,
          });
          this.dispatchEvent(event);
        });
      });

      // If inner element can be disabled, then listen to mouse events on the
      // *outer* element and absorb them if the inner element is disabled.
      // Without this, a mouse event like a click on the inner disabled element
      // would be treated as a click on the outer element. Someone listening to
      // clicks on the outer element would get a click event, even though the
      // overall element is supposed to be disabled.
      if ("disabled" in inner) {
        mouseEventNames.forEach((eventName) => {
          this.addEventListener(eventName, (event) => {
            if (/** @type {any} */ (inner).disabled) {
              event.stopImmediatePropagation();
            }
          });
        });
      }
    }

    if (changed.tabIndex) {
      inner.tabIndex = this[state].tabIndex;
    }

    if (changed.innerAttributes) {
      // Forward attributes to the inner element.
      // See notes at attributeChangedCallback.
      const { innerAttributes } = this[state];
      for (const name in innerAttributes) {
        applyAttribute(inner, name, innerAttributes[name]);
      }
    }

    // Forward delegated properties to the inner element.
    this.constructor[delegatedPropertySettersKey].forEach((property) => {
      if (changed[property]) {
        const value = this[state][property];

        // Inner selection properties needed to be handled specially.
        // See TrackTextSelectionMixin.
        const specialCase =
          (property === "selectionEnd" || property === "selectionStart") &&
          value === null;
        if (!specialCase) {
          inner[property] = value;
        }
      }
    });
  }

  [rendered](/** @type {ChangedFlags} */ changed) {
    super[rendered](changed);

    // Apply disabled state.
    if (changed.disabled) {
      const { disabled } = this[state];
      if (disabled !== undefined) {
        setInternalState(this, "disabled", disabled);
      }
    }
  }

  /**
   * The template copied into the shadow tree of new instances of this element.
   *
   * The default value of this property is a template that includes an instance
   * the standard element being wrapped, with a `<slot>` element inside that
   * to pick up the element's light DOM content. For example, if you wrap an
   * `<a>` element, then the default template will look like:
   *
   *     <template>
   *       <style>
   *       :host {
   *         display: inline-block;
   *       }
   *       </style>
   *       <a id="inner">
   *         <slot></slot>
   *       </a>
   *     </template>
   *
   * The `display` styling applied to the host will be `block` for elements that
   * are block elements by default, and `inline-block` (not `inline`) for other
   * elements.
   *
   * If you'd like the template to include other elements, then override this
   * property and return a template of your own. The template should include an
   * instance of the standard HTML element you are wrapping, and the ID of that
   * element should be "inner".
   *
   * @type {(string|HTMLTemplateElement)}
   */
  get [template]() {
    const display = blockElements.includes(this.extends)
      ? "block"
      : "inline-block";
    const tag = this.extends;
    return templateFrom.html`
      <style>
        :host {
          display: ${display}
        }
        
        [part~="inner"] {
          box-sizing: border-box;
          height: 100%;
          width: 100%;
        }
      </style>
      <${tag} id="inner" part="inner ${tag}">
        <slot></slot>
      </${tag}>
    `;
  }

  /**
   * Creates a class that wraps a standard HTML element.
   *
   * Note that the resulting class is a subclass of WrappedStandardElement, not
   * the standard class being wrapped. E.g., if you call
   * `WrappedStandardElement.wrap('a')`, you will get a class whose shadow tree
   * will include an anchor element, but the class will *not* inherit from
   * HTMLAnchorElement.
   *
   * @static
   * @param {string} extendsTag - the standard HTML element tag to extend
   */
  static wrap(extendsTag) {
    // Create the new class.
    /** @type {Constructor<WrappedStandardElement>} */
    class Wrapped extends WrappedStandardElement {}

    // Indicate which tag it wraps.
    /** @type {any} */ (Wrapped)[extendsKey] = extendsTag;

    // Create getter/setters that delegate to the wrapped element.
    const element = document.createElement(extendsTag);
    defineDelegates(Wrapped, Object.getPrototypeOf(element));

    return Wrapped;
  }
}

/**
 * Update the given attribute on an element.
 *
 * Passing a non-null `value` acts like a call to `setAttribute(name, value)`.
 * If the supplied `value` is nullish, this acts like a call to
 * `removeAttribute(name)`.
 *
 * @private
 * @param {HTMLElement} element
 * @param {string} name
 * @param {string} value
 */
function applyAttribute(element, name, value) {
  if (standardBooleanAttributes[name]) {
    // Boolean attribute
    if (typeof value === "string") {
      element.setAttribute(name, "");
    } else if (value === null) {
      element.removeAttribute(name);
    }
  } else {
    // Regular string-valued attribute
    if (value != null) {
      element.setAttribute(name, value.toString());
    } else {
      element.removeAttribute(name);
    }
  }
}

/**
 * Create a delegate for the method or property identified by the descriptor.
 *
 * @private
 * @param {string} name
 * @param {PropertyDescriptor} descriptor
 */
function createDelegate(name, descriptor) {
  if (typeof descriptor.value === "function") {
    if (name !== "constructor") {
      return createMethodDelegate(name, descriptor);
    }
  } else if (
    typeof descriptor.get === "function" ||
    typeof descriptor.set === "function"
  ) {
    return createPropertyDelegate(name, descriptor);
  }
  return null;
}

/**
 * Create a delegate for the method identified by the descriptor.
 *
 * @private
 * @param {string} name
 * @param {PropertyDescriptor} descriptor
 */
function createMethodDelegate(name, descriptor) {
  const value = function (/** @type {any[]} */ ...args) {
    // @ts-ignore
    this.inner[name](...args);
  };
  const delegate = {
    configurable: descriptor.configurable,
    enumerable: descriptor.enumerable,
    value,
    writable: descriptor.writable,
  };
  return delegate;
}

/**
 * Create a delegate for the property identified by the descriptor.
 *
 * @private
 * @param {string} name
 * @param {PropertyDescriptor} descriptor
 */
function createPropertyDelegate(name, descriptor) {
  /** @type {PlainObject} */
  const delegate = {
    configurable: descriptor.configurable,
    enumerable: descriptor.enumerable,
  };
  if (descriptor.get) {
    delegate.get = function () {
      return getInnerProperty(/** @type {any} */ (this), name);
    };
  }
  if (descriptor.set) {
    delegate.set = function (/** @type {any} */ value) {
      setInnerProperty(/** @type {any} */ (this), name, value);
    };
  }
  if (descriptor.writable) {
    delegate.writable = descriptor.writable;
  }
  return delegate;
}

/**
 * Define delegates for the given class for each property/method on the
 * indicated prototype.
 *
 * @private
 * @param {Constructor<Object>} cls
 * @param {Object} prototype
 */
function defineDelegates(cls, prototype) {
  const names = Object.getOwnPropertyNames(prototype);
  cls[delegatedPropertySettersKey] = [];
  names.forEach((name) => {
    const descriptor = Object.getOwnPropertyDescriptor(prototype, name);
    if (!descriptor) {
      return;
    }
    const delegate = createDelegate(name, descriptor);
    if (delegate) {
      Object.defineProperty(cls.prototype, name, delegate);
      if (delegate.set) {
        cls[delegatedPropertySettersKey].push(name);
      }
    }
  });
}

/**
 * Return the value of the named property on the inner standard element.
 *
 * @private
 * @param {ReactiveElement} element
 * @param {string} name
 */
function getInnerProperty(element, name) {
  // If we haven't rendered yet, use internal state value. Once we've
  // rendered, we get the value from the wrapped element itself. Return our
  // concept of the current property value from state. If the property hasn't
  // been defined, however, get the current value of the property from the
  // inner element.
  //
  // This is intended to support cases like an anchor element. If someone sets
  // `href` on a wrapped anchor, we'll know the value of `href` from state,
  // but we won't know the value of href-dependent calculated properties like
  // `protocol`. Using two sources of truth (state and the inner element)
  // seems fragile, but it's unclear how else to handle this without
  // reimplementing all HTML property interactions ourselves.
  //
  // This arrangement also means that, if an inner element property can change
  // in response to user interaction (e.g., an input element's value changes
  // as the user types), the component must listen to suitable events on the
  // inner element and update its state accordingly.
  const value = element[state][name];
  return value || (element[shadowRoot] && element.inner[name]);
}

/**
 * Set the named property on the inner standard element.
 *
 * @private
 * @param {ReactiveElement} element
 * @param {string} name
 * @param {any} value
 */
function setInnerProperty(element, name, value) {
  // We normally don't check an existing state value before calling[setState],
  // relying instead on[setState] to do that check for us. However, we have
  // dangers in this particular component of creating infinite loops.
  //
  // E.g., setting the tabindex attibute will call attributeChangedCallback,
  // which will set the tabIndex property, which will want to set state, which
  // will cause a render, which will try to reflect the current value of the
  // tabIndex property to the tabindex attribute, causing a loop.
  //
  // To avoid this, we check the existing value before updating our state.
  if (element[state][name] !== value) {
    element[setState]({ [name]: value });
  }
}

const Base$7 = ComposedFocusMixin(
  DelegateInputLabelMixin(
    FocusVisibleMixin(WrappedStandardElement.wrap("button"))
  )
);

/**
 * Base class for custom buttons.
 *
 * `Button` wraps a standard HTML `button` element, allowing for custom styling
 * and behavior while ensuring standard keyboard and focus behavior.
 *
 * @inherits WrappedStandardElement
 * @mixes ComposedFocusMixin
 * @mixes DelegateInputLabelMixin
 * @mixes KeyboardMixin
 * @part button - the inner standard HTML button
 */
class Button extends Base$7 {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      role: "button",
    });
  }

  get [inputDelegate]() {
    return this[ids].inner;
  }

  // Respond to a simulated click.
  [tap]() {
    const clickEvent = new MouseEvent("click", {
      bubbles: true,
      cancelable: true,
    });
    this.dispatchEvent(clickEvent);
  }

  get [template]() {
    const result = super[template];
    result.content.append(
      fragmentFrom.html`
        <style>
          :host {
            display: inline-flex;
            outline: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
          }

          [part~="button"] {
            align-items: center;
            background: none;
            border: none;
            color: inherit;
            flex: 1;
            font: inherit;
            outline: none;
            padding: 0;
          }
        </style>
      `
    );
    return result;
  }
}

/**
 * Button styles in the Plain reference design system
 *
 * @module PlainButtonMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function PlainButtonMixin(Base) {
  return class PlainButton extends Base {
    get [template]() {
      const result = super[template];
      result.content.append(fragmentFrom.html`
        <style>
          :host([disabled]) ::slotted(*) {
            opacity: 0.5;
          }

          [part~="button"] {
            display: inline-flex;
            justify-content: center;
            margin: 0;
            position: relative;
          }
        </style>
      `);
      return result;
    }
  };
}

/**
 * Button component in the Plain reference design system
 *
 * @inherits Button
 */
class PlainButton extends PlainButtonMixin(Button) {}

/**
 * Button with a border in the Plain reference design system
 *
 * @inherits PlainButton
 */
class PlainBorderButton extends PlainButton {
  get [template]() {
    const result = super[template];
    result.content.append(
      fragmentFrom.html`
        <style>
          [part~="button"] {
            background: #eee;
            border: 1px solid #ccc;
            padding: 0.25em 0.5em;
          }
        </style>
      `
    );
    return result;
  }
}

/**
 * ModalBackdrop component in the Plain reference design system
 *
 * @inherits ModalBackdrop
 */
class PlainModalBackdrop extends ModalBackdrop {
  get [template]() {
    const result = super[template];
    result.content.append(
      fragmentFrom.html`
        <style>
          :host {
            background: rgba(0, 0, 0, 0.2);
          }
        </style>
      `
    );
    return result;
  }
}

/**
 * OverlayFrame component in the Plain reference design system
 *
 * The default appearance of `OverlayFrame` uses a simple drop-shadow to let the
 * user see the framed content as being on top of the background page content.
 *
 * @inherits OverlayFrame
 */
class PlainOverlayFrame extends OverlayFrame {
  get [template]() {
    const result = super[template];
    result.content.append(
      fragmentFrom.html`
        <style>
          :host {
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow: 0 0px 10px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
          }
        </style>
      `
    );
    return result;
  }
}

/**
 * Modal overlay styles for the Plain reference design system
 *
 * @module PlainModalOverlayMixin
 * @part {PlainModalBackdrop} backdrop
 * @part {PlainOverlayFrame} frame
 * @param {Constructor<ReactiveElement>} Base
 */
function PlainModalOverlayMixin(Base) {
  return class PlainModalOverlay extends Base {
    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        backdropPartType: PlainModalBackdrop,
        framePartType: PlainOverlayFrame,
      });
    }
  };
}

/**
 * AlertDialog component in the Plain reference design system
 *
 * @inherits AlertDialog
 * @mixes PlainModalOverlayMixin
 * @part {PlainBorderButton} choice-button
 */
class PlainAlertDialog extends PlainModalOverlayMixin(AlertDialog) {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      choiceButtonPartType: PlainBorderButton,
    });
  }

  get [template]() {
    const result = super[template];
    result.content.append(
      fragmentFrom.html`
        <style>
          [part~="frame"] {
            padding: 1em;
          }

          [part~="choice-button-container"] {
            margin-top: 1em;
          }

          [part~="choice-button"]:not(:first-child) {
            margin-left: 0.5em;
          }
        </style>
      `
    );
    return result;
  }
}

class ElixAlertDialog extends PlainAlertDialog {}
customElements.define("elix-alert-dialog", ElixAlertDialog);

/**
 * Dialog component in the Plain reference design system
 *
 * @inherits Dialog
 * @mixes PlainModalOverlayMixin
 */
class PlainDialog extends PlainModalOverlayMixin(Dialog) {}

class ElixDialog extends PlainDialog {}
customElements.define("elix-dialog", ElixDialog);

/**
 * Helpers related to universal accessibility
 *
 * Universal accessibility is a core goal of the Elix project. These helpers are
 * used by mixins like [AriaListMixin](AriaListMixin) and
 * [AriaMenuMixin](AriaMenuMixin) to support accessibility via ARIA.
 *
 * @module accessibility
 */

/**
 * A dictionary mapping built-in HTML elements to their default ARIA role.
 *
 * Example: `defaultAriaRole.ol` returns "list", since the default ARIA role
 * for an `ol` (ordered list) element is "list".
 */
const defaultAriaRole = {
  a: "link",
  article: "region",
  button: "button",
  h1: "sectionhead",
  h2: "sectionhead",
  h3: "sectionhead",
  h4: "sectionhead",
  h5: "sectionhead",
  h6: "sectionhead",
  hr: "sectionhead",
  iframe: "region",
  link: "link",
  menu: "menu",
  ol: "list",
  option: "option",
  output: "liveregion",
  progress: "progressbar",
  select: "select",
  table: "table",
  td: "td",
  textarea: "textbox",
  th: "th",
  ul: "list",
};

/**
 * Tells assistive technologies to describe a list's items as a menu of choices.
 *
 * @module AriaMenuMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function AriaMenuMixin(Base) {
  // The class prototype added by the mixin.
  class AriaMenu extends Base {
    // @ts-ignore
    get [defaultState]() {
      const base = super[defaultState];
      return Object.assign(base, {
        itemRole: base.itemRole || "menuitem",
        role: base.role || "menu",
      });
    }

    get itemRole() {
      return this[state].itemRole;
    }
    set itemRole(itemRole) {
      this[setState]({ itemRole });
    }

    [render](/** @type {ChangedFlags} */ changed) {
      if (super[render]) {
        super[render](changed);
      }

      /** @type {ListItemElement[]} */ const items = this[state].items;
      if ((changed.items || changed.itemRole) && items) {
        // Give each item a role.
        const { itemRole } = this[state];
        items.forEach((item) => {
          if (itemRole === defaultAriaRole[item.localName]) {
            item.removeAttribute("role");
          } else {
            item.setAttribute("role", itemRole);
          }
        });
      }

      if (changed.role) {
        // Apply top-level role.
        const { role } = this[state];
        this.setAttribute("role", role);
      }
    }

    // Setting the standard role attribute will invoke this property setter,
    // which will allow us to update our state.
    get role() {
      return super.role;
    }
    set role(role) {
      super.role = role;
      if (!this[rendering]) {
        this[setState]({ role });
      }
    }
  }

  return AriaMenu;
}

/**
 * Exposes a public API for navigating a cursor over a set of items
 *
 * This mixin expects a component to provide an `items` Array of all elements in
 * the list. This mixin also expects the component to apply
 * [ItemsCursorMixin](ItemsCursorMixin) or otherwise define a compatible
 * `currentIndex` state and other state members for navigating the current item.
 *
 * Given the above, this mixin exposes a consistent public API for reading and
 * manipulating the cursor.
 *
 * @module CursorAPIMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function CursorAPIMixin(Base) {
  // The class prototype added by the mixin.
  class CursorAPI extends Base {
    attributeChangedCallback(name, oldValue, newValue) {
      if (name === "current-index") {
        this.currentIndex = Number(newValue);
      } else if (name === "current-item-required") {
        const value = booleanAttributeValue(name, newValue);
        if (this.currentItemRequired !== value) {
          this.currentItemRequired = value;
        }
      } else if (name === "cursor-operations-wrap") {
        const value = booleanAttributeValue(name, newValue);
        if (this.cursorOperationsWrap !== value) {
          this.cursorOperationsWrap = value;
        }
      } else {
        super.attributeChangedCallback(name, oldValue, newValue);
      }
    }

    /**
     * The index of the current item, or -1 if no item is current.
     *
     * @type {number}
     */
    get currentIndex() {
      const { items, currentIndex } = this[state];
      return items && items.length > 0 ? currentIndex : -1;
    }
    set currentIndex(currentIndex) {
      if (!isNaN(currentIndex)) {
        this[setState]({ currentIndex });
      }
    }

    /**
     * The current item, or null if no item is current.
     *
     * @type {Element}
     */
    get currentItem() {
      const { items, currentIndex } = this[state];
      return items && items[currentIndex];
    }
    set currentItem(currentItem) {
      const { items } = this[state];
      if (!items) {
        return;
      }
      const currentIndex = items.indexOf(currentItem);
      this[setState]({ currentIndex });
    }

    /**
     * True if the list should always have a current item (if it has items).
     *
     * @type {boolean}
     * @default false
     */
    get currentItemRequired() {
      return this[state].currentItemRequired;
    }
    set currentItemRequired(currentItemRequired) {
      this[setState]({ currentItemRequired });
    }

    /**
     * True if cursor operations wrap from last to first, and vice versa.
     *
     * @type {boolean}
     * @default false
     */
    get cursorOperationsWrap() {
      return this[state].cursorOperationsWrap;
    }
    set cursorOperationsWrap(cursorOperationsWrap) {
      this[setState]({ cursorOperationsWrap });
    }

    /**
     * Moves to the first item in the list.
     *
     * @returns {Boolean} True if the current item changed, false if not.
     */
    goFirst() {
      if (super.goFirst) {
        super.goFirst();
      }
      return this[goFirst]();
    }

    /**
     * Move to the last item in the list.
     *
     * @returns {Boolean} True if the current item changed
     */
    goLast() {
      if (super.goLast) {
        super.goLast();
      }
      return this[goLast]();
    }

    /**
     * Move to the next item in the list.
     *
     * If the list has no current item, the first item will become current.
     *
     * @returns {Boolean} True if the current item changed
     */
    goNext() {
      if (super.goNext) {
        super.goNext();
      }
      return this[goNext]();
    }

    /**
     * Moves to the previous item in the list.
     *
     * If the list has no current item, the last item will become current.
     *
     * @returns {Boolean} True if the current item changed
     */
    goPrevious() {
      if (super.goPrevious) {
        super.goPrevious();
      }
      return this[goPrevious]();
    }

    [rendered](/** @type {ChangedFlags} */ changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }
      if (changed.currentIndex && this[raiseChangeEvents]) {
        const { currentIndex } = this[state];
        const oldEvent = new CustomEvent("current-index-changed", {
          bubbles: true,
          detail: { currentIndex },
        });
        this.dispatchEvent(oldEvent);
        /**
         * Raised when the `currentIndex` property changes.
         *
         * @event currentindexchanged
         */
        const event = new CustomEvent("currentindexchange", {
          bubbles: true,
          detail: { currentIndex },
        });
        this.dispatchEvent(event);
      }
    }
  }

  return CursorAPI;
}

/**
 * This helper returns a guess as to what portion of the given element can be
 * scrolled. This is used by [CursorInViewMixin](CursorInViewMixin) to
 * provide a default implementation of [scrollTarget].
 *
 * If the element has a shadow root containing a default (unnamed) slot, this
 * returns the first ancestor of that slot that has either `overflow-x` or
 * `overflow-y` styled as `auto` or `scroll`. If the element has no default
 * slot, or no scrolling ancestor is found, the element itself is returned.
 *
 * @param {Element} element – the component to examine for a scrolling
 * element
 * @returns {Element}
 */
function defaultScrollTarget(element) {
  const root = element[shadowRoot];
  const slot = root && root.querySelector("slot:not([name])");
  const scrollingParent =
    slot &&
    slot.parentNode instanceof Element &&
    getScrollableElement(slot.parentNode);
  return scrollingParent || element;
}

/**
 * Return true if the given element can be scrolled.
 *
 * @private
 * @param {HTMLElement} element
 */
function isElementScrollable(element) {
  const style = getComputedStyle(element);
  const overflowX = style.overflowX;
  const overflowY = style.overflowY;
  return (
    overflowX === "scroll" ||
    overflowX === "auto" ||
    overflowY === "scroll" ||
    overflowY === "auto"
  );
}

/**
 * If the given element can be scrolled, return that. If not, return the closest
 * ancestor that can be scrolled. If no such ancestor is found, return null.
 *
 * @param {Element} node
 * @returns {Element|null}
 */
function getScrollableElement(node) {
  for (const ancestor of selfAndComposedAncestors(node)) {
    if (ancestor instanceof HTMLElement && isElementScrollable(ancestor)) {
      return ancestor;
    }
  }
  return null;
}

/**
 * Scrolls to ensure the current item is visible
 *
 * When the current item in a list-like component changes, the current item
 * should be brought into view so that the user can confirm their selection.
 *
 * This mixin expects an `items` collection, such as that provided by
 * [ContentItemsMixin](ContentItemsMixin). It also expects a
 * `state.currentItem` member indicating which item is current. You
 * can supply that yourself, or use
 * [ItemsCursorMixin](ItemsCursorMixin).
 *
 * @module CursorInViewMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function CursorInViewMixin(Base) {
  // The class prototype added by the mixin.
  class CursorInView extends Base {
    [rendered](/** @type {ChangedFlags} */ changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }

      if (changed.currentItem) {
        this.scrollCurrentItemIntoView();
      }
    }

    /**
     * Scroll the current item completely into view, minimizing the degree of
     * scrolling performed.
     *
     * Blink has a `scrollIntoViewIfNeeded()` function that does something
     * similar, but unfortunately it's non-standard, and in any event often ends
     * up scrolling more than is absolutely necessary.
     *
     * This scrolls the containing element defined by the `scrollTarget`
     * property. By default, it will scroll the element itself.
     */
    scrollCurrentItemIntoView() {
      if (super.scrollCurrentItemIntoView) {
        super.scrollCurrentItemIntoView();
      }

      const { currentItem, items } = this[state];
      if (!currentItem || !items) {
        return;
      }

      // Determine the bounds of the scroll target and item. We use
      // getBoundingClientRect instead of .offsetTop, etc., because the latter
      // round values, and we want to handle fractional values.
      const scrollTargetRect = this[scrollTarget].getBoundingClientRect();
      const itemRect = currentItem.getBoundingClientRect();

      // Determine how far the item is outside the viewport.
      const bottomDelta = itemRect.bottom - scrollTargetRect.bottom;
      const leftDelta = itemRect.left - scrollTargetRect.left;
      const rightDelta = itemRect.right - scrollTargetRect.right;
      const topDelta = itemRect.top - scrollTargetRect.top;

      // Scroll the target as necessary to bring the item into view.
      // If an `orientation` state member is defined, only scroll along that
      // axis. Otherwise, assume the orientation is "both".
      const orientation = this[state].orientation || "both";
      if (orientation === "horizontal" || orientation === "both") {
        if (rightDelta > 0) {
          this[scrollTarget].scrollLeft += rightDelta; // Scroll right
        } else if (leftDelta < 0) {
          this[scrollTarget].scrollLeft += Math.ceil(leftDelta); // Scroll left
        }
      }
      if (orientation === "vertical" || orientation === "both") {
        if (bottomDelta > 0) {
          this[scrollTarget].scrollTop += bottomDelta; // Scroll down
        } else if (topDelta < 0) {
          this[scrollTarget].scrollTop += Math.ceil(topDelta); // Scroll up
        }
      }
    }

    /**
     * The element that should be scrolled to get the selected item into view.
     *
     * By default, this uses the [defaultScrollTarget](defaultScrollTarget)
     * helper to find the most likely candidate for scrolling. You can override
     * this property to directly identify which element should be scrolled.
     *
     * See also [scrollTarget](internal#internal.scrollTarget).
     */
    get [scrollTarget]() {
      const base = super[scrollTarget];
      /** @type {any} */
      const element = this;
      return base || defaultScrollTarget(element);
    }
  }

  return CursorInView;
}

/**
 * Maps direction semantics to cursor semantics.
 *
 * This turns a movement in a direction (go left, go right) into a cursor
 * operation (go previous, go next).
 *
 * This mixin can be used in conjunction with
 * [KeyboardDirectionMixin](KeyboardDirectionMixin) (which maps keyboard events
 * to directions) and a mixin that handles cursor operations like
 * [ItemsCursorMixin](ItemsCursorMixin).
 *
 * @module DirectionCursorMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function DirectionCursorMixin(Base) {
  // The class prototype added by the mixin.
  class DirectionCursor extends Base {
    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        canGoDown: null,
        canGoLeft: null,
        canGoRight: null,
        canGoUp: null,
      });
    }

    /**
     * Interprets `goDown` to mean "move to the next item".
     */
    [goDown]() {
      if (super[goDown]) {
        super[goDown]();
      }
      return this[goNext]();
    }

    /**
     * Interprets `goEnd` to mean "move to the last item".
     */
    [goEnd]() {
      if (super[goEnd]) {
        super[goEnd]();
      }
      return this[goLast]();
    }

    /**
     * Interprets `goLeft` to mean "move to the previous item".
     *
     * If the element has a `rightToLeft` property and it is true, then this
     * moves to the _next_ item.
     */
    [goLeft]() {
      if (super[goLeft]) {
        super[goLeft]();
      }
      return this[state] && this[state].rightToLeft
        ? this[goNext]()
        : this[goPrevious]();
    }

    /**
     * Interprets `goRight` to mean "move to the next item".
     *
     * If the element has a `rightToLeft` property and it is true, then this
     * moves to the _previous_ item.
     */
    [goRight]() {
      if (super[goRight]) {
        super[goRight]();
      }
      return this[state] && this[state].rightToLeft
        ? this[goPrevious]()
        : this[goNext]();
    }

    /**
     * Interprets `goStart` to mean "move to the first item".
     */
    [goStart]() {
      if (super[goStart]) {
        super[goStart]();
      }
      return this[goFirst]();
    }

    /**
     * Interprets `goUp` to mean "move to the previous item".
     */
    [goUp]() {
      if (super[goUp]) {
        super[goUp]();
      }
      return this[goPrevious]();
    }

    [stateEffects](state, changed) {
      const effects = super[stateEffects]
        ? super[stateEffects](state, changed)
        : {};

      // Update computed state members to track whether we can go
      // down/left/right/up.
      if (
        changed.canGoNext ||
        changed.canGoPrevious ||
        changed.languageDirection ||
        changed.orientation ||
        changed.rightToLeft
      ) {
        const { canGoNext, canGoPrevious, orientation, rightToLeft } = state;
        const horizontal =
          orientation === "horizontal" || orientation === "both";
        const vertical = orientation === "vertical" || orientation === "both";
        const canGoDown = vertical && canGoNext;
        const canGoLeft = !horizontal
          ? false
          : rightToLeft
          ? canGoNext
          : canGoPrevious;
        const canGoRight = !horizontal
          ? false
          : rightToLeft
          ? canGoPrevious
          : canGoNext;
        const canGoUp = vertical && canGoPrevious;
        Object.assign(effects, {
          canGoDown,
          canGoLeft,
          canGoRight,
          canGoUp,
        });
      }

      return effects;
    }
  }

  return DirectionCursor;
}

/**
 * Exposes a public API for the set of items in a list-like element
 *
 * @module ItemsAPIMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function ItemsAPIMixin(Base) {
  // The class prototype added by the mixin.
  class ItemsAPI extends Base {
    /**
     * The current set of items drawn from the element's current state.
     *
     * @type {ListItemElement[]} the element's current items
     */
    get items() {
      return this[state] ? this[state].items : null;
    }

    [rendered](/** @type {ChangedFlags} */ changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }

      // Raise items-changed if items changed after the initial render. We'll
      // see changed.items on initial render, and raiseChangeEvents will be true
      // if we're using SlotContentMixin, but we don't want to actually raise
      // the event then because the items didn't change in response to user
      // activity.
      if (!this[firstRender] && changed.items && this[raiseChangeEvents]) {
        const oldEvent = new CustomEvent("items-changed", {
          bubbles: true,
        });
        this.dispatchEvent(oldEvent);
        /**
         * Raised when the `items` property changes.
         *
         * @event itemschange
         */
        const event = new CustomEvent("itemschange", {
          bubbles: true,
        });
        this.dispatchEvent(event);
      }
    }
  }

  return ItemsAPI;
}

/**
 * Tracks and navigates the current item in a set of items
 *
 * @module ItemsCursorMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function ItemsCursorMixin(Base) {
  // The class prototype added by the mixin.
  class ItemsCursor extends Base {
    /**
     * Look for an item which is available in the given state..
     *
     * The `options` parameter can accept options for:
     *
     * * `direction`: 1 to move forward, -1 to move backward
     * * `index`: the index to start at, defaults to `state.currentIndex`
     * * `wrap`: whether to wrap around the ends of the `items` array, defaults
     *   to `state.cursorOperationsWrap`.
     *
     * If an available item was found, this returns its index. If no item was
     * found, this returns -1.
     *
     * @param {PlainObject} state
     * @param {PlainObject} options
     * @returns {number}
     */
    [closestAvailableItemIndex](state, options = {}) {
      const direction = options.direction !== undefined ? options.direction : 1;
      const index =
        options.index !== undefined ? options.index : state.currentIndex;
      const wrap =
        options.wrap !== undefined ? options.wrap : state.cursorOperationsWrap;

      const { items } = state;
      const count = items ? items.length : 0;

      if (count === 0) {
        // No items
        return -1;
      }

      if (wrap) {
        // Search with wrapping.

        // Modulus taking into account negative numbers.
        let i = ((index % count) + count) % count;
        const end = (((i - direction) % count) + count) % count;
        while (i !== end) {
          const available = state.availableItemFlags
            ? state.availableItemFlags[i]
            : true;
          if (available) {
            return i;
          }
          // See modulus note above.
          i = (((i + direction) % count) + count) % count;
        }
      } else {
        // Search without wrapping.
        for (let i = index; i >= 0 && i < count; i += direction) {
          const available = state.availableItemFlags
            ? state.availableItemFlags[i]
            : true;
          if (available) {
            return i;
          }
        }
      }

      return -1; // No item found
    }

    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        currentIndex: -1,
        desiredCurrentIndex: null,
        currentItem: null,
        currentItemRequired: false,
        cursorOperationsWrap: false,
      });
    }

    /**
     * Move to the first item in the set.
     *
     * @protected
     * @returns {Boolean} True if the current item changed, false if not.
     */
    [goFirst]() {
      if (super[goFirst]) {
        super[goFirst]();
      }
      return moveToIndex(this, 0, 1);
    }

    /**
     * Move to the last item in the set.
     *
     * @protected
     * @returns {Boolean} True if the current item changed, false if not.
     */
    [goLast]() {
      if (super[goLast]) {
        super[goLast]();
      }
      return moveToIndex(this, this[state].items.length - 1, -1);
    }

    /**
     * Move to the next item in the set.
     *
     * If no item is current, move to the first item.
     *
     * @protected
     * @returns {Boolean} True if the current item changed, false if not.
     */
    [goNext]() {
      if (super[goNext]) {
        super[goNext]();
      }
      const { currentIndex, items } = this[state];
      const start = currentIndex < 0 && items ? 0 : currentIndex + 1;
      return moveToIndex(this, start, 1);
    }

    /**
     * Move to the previous item in the set.
     *
     * If no item is current, move to the last item.
     *
     * @protected
     * @returns {Boolean} True if the current item changed, false if not.
     */
    [goPrevious]() {
      if (super[goPrevious]) {
        super[goPrevious]();
      }
      const { currentIndex, items } = this[state];
      const start =
        currentIndex < 0 && items ? items.length - 1 : currentIndex - 1;
      return moveToIndex(this, start, -1);
    }

    [stateEffects](state, changed) {
      const effects = super[stateEffects]
        ? super[stateEffects](state, changed)
        : {};

      // Ensure currentIndex is valid.
      if (
        changed.availableItemFlags ||
        changed.items ||
        changed.currentIndex ||
        changed.currentItemRequired
      ) {
        const {
          currentIndex,
          desiredCurrentIndex,
          currentItem,
          currentItemRequired,
          items,
        } = state;

        const count = items ? items.length : 0;

        // Determine the desired index: the one we want irrespective of whether
        // we have items or their availability.
        // Assume we'll stick with the same desired index we already have.
        let newDesiredIndex = desiredCurrentIndex;
        if (
          changed.items &&
          !changed.currentIndex &&
          currentItem &&
          count > 0 &&
          items[currentIndex] !== currentItem
        ) {
          // The items changed, and the item at the cursor is no longer the
          // same. See if we can find that item again in the list of items.
          const newItemIndex = items.indexOf(currentItem);
          if (newItemIndex >= 0) {
            // Found the item again; try to use its index.
            newDesiredIndex = newItemIndex;
          }
        } else if (
          changed.currentIndex &&
          ((currentIndex < 0 && currentItem !== null) ||
            (currentIndex >= 0 &&
              (count === 0 || items[currentIndex] !== currentItem)) ||
            desiredCurrentIndex === null)
        ) {
          // Someone explicitly moved the cursor, which trumps any previously
          // desired index.
          newDesiredIndex = currentIndex;
        }

        // If an item is required and there's no selection, we'll implicitly try
        // to get the first available item.
        if (currentItemRequired && newDesiredIndex < 0) {
          newDesiredIndex = 0;
        }

        // Now that we know what index we want, see how close we can get to it.
        let newIndex;
        if (newDesiredIndex < 0) {
          // All negative indices are equivalent to -1.
          newDesiredIndex = -1;
          newIndex = -1;
        } else if (count === 0) {
          // No items yet.
          newIndex = -1;
        } else {
          // See how close we can get to the desired index.
          // First clamp index to existing array bounds.
          newIndex = Math.max(Math.min(count - 1, newDesiredIndex), 0);
          // Look for an available item going forward.
          newIndex = this[closestAvailableItemIndex](state, {
            direction: 1,
            index: newIndex,
            wrap: false,
          });
          if (newIndex < 0) {
            // Next best: look for an available item going backward.
            newIndex = this[closestAvailableItemIndex](state, {
              direction: -1,
              index: newIndex - 1,
              wrap: false,
            });
          }
        }

        const newItem = (items && items[newIndex]) || null;
        Object.assign(effects, {
          currentIndex: newIndex,
          desiredCurrentIndex: newDesiredIndex,
          currentItem: newItem,
        });
      }

      return effects;
    }
  }

  return ItemsCursor;
}

/**
 * Update currentIndex and return true if it changed.
 *
 * @private
 * @param {Element} element
 * @param {number} index
 * @param {number} direction
 */
function moveToIndex(element, index, direction) {
  const newIndex = element[closestAvailableItemIndex](element[state], {
    direction,
    index,
  });
  if (newIndex < 0) {
    // Couldn't find an item to move to.
    return false;
  }
  // Normally we don't check to see if state is going to change before setting
  // state, but the methods defined by this mixin want to be able to return true
  // if the index is actually going to change.
  const changed = element[state].currentIndex !== newIndex;
  if (changed) {
    element[setState]({
      currentIndex: newIndex,
    });
  }
  return changed;
}

/**
 * Helpers for working with element content.
 *
 * @module content
 */

// These are tags for elements that can appear in the document body, but do not
// seem to have any user-visible manifestation.
// See https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const auxiliarycustomTags = [
  "applet", // deprecated
  "basefont", // deprecated
  "embed",
  "font", // deprecated
  "frame", // deprecated
  "frameset", // deprecated
  "isindex", // deprecated
  "keygen", // deprecated
  "link",
  "multicol", // deprecated
  "nextid", // deprecated
  "noscript",
  "object",
  "param",
  "script",
  "style",
  "template",
  "noembed", // deprecated
];

/**
 * Use a heuristic to extract text from the given item.
 *
 * This looks, in order, at: the `aria-label` attribute, the `alt` attribute,
 * `innerText`, or `textContent`.
 *
 * This function is used as the default implementation of the
 * [getItemText](internal#getItemText) function in several mixins.
 *
 * @param {Element} element
 * @returns {string}
 */
function getDefaultText(element) {
  return (
    element.getAttribute("aria-label") ||
    element.getAttribute("alt") ||
    /** @type {any} */ (element).innerText ||
    element.textContent ||
    ""
  );
}

/**
 * Return true if the given node is likely to be useful as component content.
 *
 * This will be `true` for nodes that are: a) instances of `Element`
 * (`HTMLElement` or `SVGElement`), and b) not on a blacklist of normally
 * invisible elements (such as `style` or `script`). Among other things, this
 * returns `false` for Text nodes.
 *
 * This is used by [ContentItemsMixin](ContentItemsMixin) to filter out nodes
 * which are unlikely to be interesting as list items. This is intended to
 * satisfy the Gold Standard checklist criteria [Auxiliary
 * Content](https://github.com/webcomponents/gold-standard/wiki/Auxiliary-Content),
 * so that a component does not inadvertently treat `<style>` and other invisible
 * items as element content.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function isSubstantiveElement(node) {
  return (
    node instanceof Element &&
    (!node.localName || auxiliarycustomTags.indexOf(node.localName) < 0)
  );
}

/**
 * Exposes the text content of a list's items as an array of strings.
 *
 * @module ItemsTextMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function ItemsTextMixin(Base) {
  // The class prototype added by the mixin.
  class ItemsText extends Base {
    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        texts: null,
      });
    }

    /**
     * Extract the text from the given item.
     *
     * The default implementation returns an item's `aria-label`, `alt`
     * attribute, `innerText`, or `textContent`, in that order. You can override
     * this to return the text that should be used.
     *
     * @param {Element} item
     * @returns {string}
     */
    [getItemText](item) {
      return super[getItemText]
        ? super[getItemText](item)
        : getDefaultText(item);
    }

    [stateEffects](state, changed) {
      const effects = super[stateEffects]
        ? super[stateEffects](state, changed)
        : {};

      // Regenerate texts when items change.
      if (changed.items) {
        const { items } = state;
        const texts = getTextsFromItems(items, this[getItemText]);
        if (texts) {
          Object.freeze(texts);
          Object.assign(effects, { texts });
        }
      }

      return effects;
    }
  }

  return ItemsText;
}

/**
 * Extract the text from the given items.
 *
 * @private
 * @param {Element[]} items
 */
function getTextsFromItems(items, getText) {
  return items ? Array.from(items, (item) => getText(item)) : null;
}

/**
 * Maps direction keys to direction semantics.
 *
 * This mixin is useful for components that want to map direction keys (Left,
 * Right, etc.) to movement in the indicated direction (go left, go right,
 * etc.).
 *
 * This mixin expects the component to invoke a `keydown` method when a key is
 * pressed. You can use [KeyboardMixin](KeyboardMixin) for that
 * purpose, or wire up your own keyboard handling and call `keydown` yourself.
 *
 * This mixin calls methods such as `goLeft` and `goRight`. You can define
 * what that means by implementing those methods yourself. If you want to use
 * direction keys to navigate a selection, use this mixin with
 * [DirectionCursorMixin](DirectionCursorMixin).
 *
 * If the component defines a property called `orientation`, the value of that
 * property will constrain navigation to the horizontal or vertical axis.
 *
 * @module KeyboardDirectionMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function KeyboardDirectionMixin(Base) {
  // The class prototype added by the mixin.
  class KeyboardDirection extends Base {
    /**
     * Invoked when the user wants to go/navigate down.
     * The default implementation of this method does nothing.
     */
    [goDown]() {
      if (super[goDown]) {
        return super[goDown]();
      }
    }

    /**
     * Invoked when the user wants to go/navigate to the end (e.g., of a list).
     * The default implementation of this method does nothing.
     */
    [goEnd]() {
      if (super[goEnd]) {
        return super[goEnd]();
      }
    }

    /**
     * Invoked when the user wants to go/navigate left.
     * The default implementation of this method does nothing.
     */
    [goLeft]() {
      if (super[goLeft]) {
        return super[goLeft]();
      }
    }

    /**
     * Invoked when the user wants to go/navigate right.
     * The default implementation of this method does nothing.
     */
    [goRight]() {
      if (super[goRight]) {
        return super[goRight]();
      }
    }

    /**
     * Invoked when the user wants to go/navigate to the start (e.g., of a
     * list). The default implementation of this method does nothing.
     */
    [goStart]() {
      if (super[goStart]) {
        return super[goStart]();
      }
    }

    /**
     * Invoked when the user wants to go/navigate up.
     * The default implementation of this method does nothing.
     */
    [goUp]() {
      if (super[goUp]) {
        return super[goUp]();
      }
    }

    [keydown](/** @type {KeyboardEvent} */ event) {
      let handled = false;

      // Direction keys generally are low-priority keys: if a shadow element
      // like an input has focus, we want to let that focused element handle
      // direction keys. So we only handle the event if we're the target.
      //
      // (We'd really like to be able to provide direction key handling as a
      // default — i.e., if the focused element doesn't handle a key, then we
      // would handle it here. Unfortunately, there doesn't seem to be any
      // general way for us to do that.)
      if (event.target === this) {
        // Respect orientation state if defined, otherwise assume "both".
        const orientation = this[state].orientation || "both";
        const horizontal =
          orientation === "horizontal" || orientation === "both";
        const vertical = orientation === "vertical" || orientation === "both";

        // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,
        // as the user may be trying to navigate back or forward in the browser.
        switch (event.key) {
          case "ArrowDown":
            if (vertical) {
              handled = event.altKey ? this[goEnd]() : this[goDown]();
            }
            break;

          case "ArrowLeft":
            if (horizontal && !event.metaKey && !event.altKey) {
              handled = this[goLeft]();
            }
            break;

          case "ArrowRight":
            if (horizontal && !event.metaKey && !event.altKey) {
              handled = this[goRight]();
            }
            break;

          case "ArrowUp":
            if (vertical) {
              handled = event.altKey ? this[goStart]() : this[goUp]();
            }
            break;

          case "End":
            handled = this[goEnd]();
            break;

          case "Home":
            handled = this[goStart]();
            break;
        }
      }

      // Prefer mixin result if it's defined, otherwise use base result.
      return handled || (super[keydown] && super[keydown](event)) || false;
    }
  }

  return KeyboardDirection;
}

/**
 * Maps the Page Up and Page Down keys to item cursor operations.
 *
 * The keyboard interaction model generally follows that of Microsoft Windows'
 * list boxes instead of those in OS X:
 *
 * * The Page Up/Down and Home/End keys actually move the item cursor, rather
 *   than just scrolling. The former behavior seems more generally useful for
 *   keyboard users.
 *
 * * Pressing Page Up/Down will first move the cursor to the topmost/bottommost
 *   visible item if the cursor is not already there. Thereafter, the key
 *   will move the cursor up/down by a page, and (per the above point) make
 *   the current item visible.
 *
 * To ensure the current item is in view following use of Page Up/Down, use
 * the related [CursorInViewMixin](CursorInViewMixin).
 *
 * This mixin expects the component to provide:
 *
 * * A `[keydown]` method invoked when a key is pressed. You can use
 *   [KeyboardMixin](KeyboardMixin) for that purpose, or wire up your own
 *   keyboard handling and call `[keydown]` yourself.
 * * A `currentIndex` state member updatable via [setState]`.
 *
 * @module KeyboardPagedCursorMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function KeyboardPagedCursorMixin(Base) {
  // The class prototype added by the mixin.
  class KeyboardPagedCursor extends Base {
    [keydown](/** @type {KeyboardEvent} */ event) {
      let handled = false;
      const orientation = this.orientation;
      if (orientation !== "horizontal") {
        switch (event.key) {
          case "PageDown":
            handled = this.pageDown();
            break;

          case "PageUp":
            handled = this.pageUp();
            break;
        }
      }

      // Prefer mixin result if it's defined, otherwise use base result.
      return handled || (super[keydown] && super[keydown](event));
    }

    // Default orientation implementation defers to super,
    // but if not found, looks in state.
    get orientation() {
      return (
        super.orientation || (this[state] && this[state].orientation) || "both"
      );
    }

    /**
     * Scroll down one page.
     */
    pageDown() {
      if (super.pageDown) {
        super.pageDown();
      }
      return scrollOnePage(this, true);
    }

    /**
     * Scroll up one page.
     */
    pageUp() {
      if (super.pageUp) {
        super.pageUp();
      }
      return scrollOnePage(this, false);
    }

    /**
     * The element that will be scrolled when the user presses Page Up or
     * Page Down. The default value is calculated by
     * [defaultScrollTarget](defaultScrollTarget#defaultScrollTarget).
     *
     * See [scrollTarget](internal#internal.scrollTarget).
     *
     * @type {HTMLElement}
     */
    get [scrollTarget]() {
      /** @type {any} */
      const element = this;
      return super[scrollTarget] || defaultScrollTarget(element);
    }
  }

  return KeyboardPagedCursor;
}

/**
 * Return the item whose content spans the given y position (relative to the
 * top of the list's scrolling client area), or null if not found.
 *
 * If downward is true, move down the list of items to find the first item
 * found at the given y position; if downward is false, move up the list of
 * items to find the last item at that position.
 *
 * @private
 * @param {ReactiveElement} element
 * @param {number} y
 * @param {boolean} downward
 */
function getIndexOfItemAtY(element, y, downward) {
  const items = element[state].items;
  const start = downward ? 0 : items.length - 1;
  const end = downward ? items.length : 0;
  const step = downward ? 1 : -1;

  // Find the item spanning the indicated y coordinate.
  let index;
  /** @type {HTMLElement|SVGElement|null} */ let item = null;
  let itemRect;
  const { availableItemFlags } = element[state];
  for (index = start; index !== end; index += step) {
    // Only consider items available in the element's current state.
    const available = availableItemFlags ? availableItemFlags[index] : true;
    if (available) {
      itemRect = items[index].getBoundingClientRect();
      if (itemRect.top <= y && y <= itemRect.bottom) {
        // Item spans the indicated y coordinate.
        item = items[index];
        break;
      }
    }
  }

  if (!item || !itemRect) {
    return null;
  }

  // We may have found an item whose padding spans the given y coordinate,
  // but whose content is actually above/below that point.
  // TODO: If the item has a border, then padding should be included in
  // considering a hit.
  const itemStyle = getComputedStyle(item);
  const itemPaddingTop = itemStyle.paddingTop
    ? parseFloat(itemStyle.paddingTop)
    : 0;
  const itemPaddingBottom = itemStyle.paddingBottom
    ? parseFloat(itemStyle.paddingBottom)
    : 0;
  const contentTop = itemRect.top + itemPaddingTop;
  const contentBottom =
    contentTop + item.clientHeight - itemPaddingTop - itemPaddingBottom;
  if ((downward && contentTop <= y) || (!downward && contentBottom >= y)) {
    // The indicated coordinate hits the actual item content.
    return index;
  } else {
    // The indicated coordinate falls within the item's padding. Back up to
    // the item below/above the item we found and return that.
    return index - step;
  }
}

/**
 * Move by one page downward (if downward is true), or upward (if false).
 * Return true if we ended up moving the cursor, false if not.
 *
 * @private
 * @param {ReactiveElement} element
 * @param {boolean} downward
 */
function scrollOnePage(element, downward) {
  const items = element[state].items;
  const currentIndex = element[state].currentIndex;

  // Determine the item visible just at the edge of direction we're heading.
  // We'll move to that item if it's not already current.
  const targetRect = element[scrollTarget].getBoundingClientRect();
  const edge = downward ? targetRect.bottom : targetRect.top;
  const indexOfItemAtEdge = getIndexOfItemAtY(element, edge, downward);

  let newIndex;
  if (indexOfItemAtEdge && currentIndex === indexOfItemAtEdge) {
    // The item at the edge was already current, so scroll in the indicated
    // direction by one page, measuring from the bounds of the current item.
    // Leave the new item at that edge current.
    const currentItem = items[currentIndex];
    const currentRect = currentItem.getBoundingClientRect();
    const pageHeight = element[scrollTarget].clientHeight;
    const y = downward
      ? currentRect.bottom + pageHeight
      : currentRect.top - pageHeight;
    newIndex = getIndexOfItemAtY(element, y, downward);
  } else {
    // The item at the edge wasn't current yet. Instead of scrolling, we'll just
    // move to that item. That is, the first attempt to page up/down usually
    // just moves the cursor to the edge in that direction.
    newIndex = indexOfItemAtEdge;
  }

  if (!newIndex) {
    // We went past the first/last item without finding an item. Move to the
    // last item (if moving downward) or first item (if moving upward).
    const index = downward ? items.length - 1 : 0;
    newIndex = element[closestAvailableItemIndex]
      ? element[closestAvailableItemIndex](element[state], {
          direction: downward ? -1 /* Work up */ : 1 /* Work down */,
          index,
        })
      : index;
  }

  const changed = newIndex !== currentIndex;
  if (changed) {
    // If external code causes an operation that scrolls the page, it's
    // impossible for it to predict where the currentIndex is going to end up.
    // Accordingly, we raise change events.
    const saveRaiseChangesEvents = element[raiseChangeEvents];
    element[raiseChangeEvents] = true;
    element[setState]({
      currentIndex: newIndex,
    });
    element[raiseChangeEvents] = saveRaiseChangesEvents;
  }
  return changed;
}

/**
 * Constants used by Elix mixins and components
 *
 * Sharing these constants allows for greater consistency in things such as user
 * interface timings.
 *
 * @module constants
 */

/**
 * Time in milliseconds after which the user is considered to have stopped
 * typing.
 *
 * This is used by
 * [KeyboardPrefixCursorMixin](KeyboardPrefixCursorMixin).
 *
 * @const {number} TYPING_TIMEOUT_DURATION
 */
const TYPING_TIMEOUT_DURATION = 1000;

// Symbols for private data members on an element.
const typedPrefixKey = Symbol("typedPrefix");
const prefixTimeoutKey = Symbol("prefixTimeout");

/**
 * Lets a user navigate an item cursor by typing the beginning of items
 *
 * Example: suppose a component using this mixin has the following items:
 *
 *     <sample-list-component>
 *       <div>Apple</div>
 *       <div>Apricot</div>
 *       <div>Banana</div>
 *       <div>Blackberry</div>
 *       <div>Blueberry</div>
 *       <div>Cantaloupe</div>
 *       <div>Cherry</div>
 *       <div>Lemon</div>
 *       <div>Lime</div>
 *     </sample-list-component>
 *
 * If this component receives the focus, and the user presses the "b" or "B"
 * key, the item cursor will move to "Banana", because it's the first item that
 * matches the prefix "b". (Matching is case-insensitive.) If the user now
 * presses the "l" or "L" key quickly, the prefix to match becomes "bl", so the
 * cursor will move to "Blackberry".
 *
 * The prefix typing feature has a one second timeout — the prefix to match will
 * be reset after a second has passed since the user last typed a key. If, in
 * the above example, the user waits a second between typing "b" and "l", the
 * prefix will become "l", so the cursor would move to "Lemon".
 *
 * This mixin expects the component to invoke a `keydown` method when a key is
 * pressed. You can use [KeyboardMixin](KeyboardMixin) for that purpose, or wire
 * up your own keyboard handling and call `keydown` yourself.
 *
 * This mixin also expects the component to provide an `items` property. The
 * `textContent` of those items will be used for purposes of prefix matching.
 *
 * @module KeyboardPrefixCursorMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function KeyboardPrefixCursorMixin(Base) {
  // The class prototype added by the mixin.
  class KeyboardPrefixCursor extends Base {
    constructor() {
      // @ts-ignore
      super();
      resetTypedPrefix(this);
    }

    /**
     * Go to the first item whose text content begins with the given prefix.
     *
     * @param {string} prefix - The prefix string to search for
     * @returns {boolean}
     */
    [goToItemWithPrefix](prefix) {
      if (super[goToItemWithPrefix]) {
        super[goToItemWithPrefix](prefix);
      }
      if (prefix == null || prefix.length === 0) {
        return false;
      }
      // Find item that begins with the prefix. Ignore case.
      const searchText = prefix.toLowerCase();
      /** @type {string[]} */ const texts = this[state].texts;
      const index = texts.findIndex(
        (text) => text.substr(0, prefix.length).toLowerCase() === searchText
      );
      if (index >= 0) {
        const previousIndex = this[state].currentIndex;
        this[setState]({ currentIndex: index });
        return this[state].currentIndex !== previousIndex;
      } else {
        return false;
      }
    }

    [keydown](/** @type {KeyboardEvent} */ event) {
      let handled;

      switch (event.key) {
        case "Backspace":
          handleBackspace(this);
          handled = true;
          break;

        case "Escape":
          // Pressing Escape lets user quickly start typing a new prefix.
          resetTypedPrefix(this);
          break;

        default:
          if (
            !event.ctrlKey &&
            !event.metaKey &&
            !event.altKey &&
            event.key.length === 1
          ) {
            handlePlainCharacter(this, event.key);
          }
      }

      // Prefer mixin result if it's defined, otherwise use base result.
      return handled || (super[keydown] && super[keydown](event));
    }
  }

  return KeyboardPrefixCursor;
}

/**
 * Handle the Backspace key: remove the last character from the prefix.
 *
 * @private
 * @param {ReactiveElement} element
 */
function handleBackspace(element) {
  /** @type {any} */ const cast = element;
  const length = cast[typedPrefixKey] ? cast[typedPrefixKey].length : 0;
  if (length > 0) {
    cast[typedPrefixKey] = cast[typedPrefixKey].substr(0, length - 1);
  }
  element[goToItemWithPrefix](cast[typedPrefixKey]);
  setPrefixTimeout(element);
}

/**
 * Add a plain character to the prefix.
 *
 * @private
 * @param {ReactiveElement} element
 * @param {string} char
 */
function handlePlainCharacter(element, char) {
  /** @type {any} */ const cast = element;
  const prefix = cast[typedPrefixKey] || "";
  cast[typedPrefixKey] = prefix + char;
  element[goToItemWithPrefix](cast[typedPrefixKey]);
  setPrefixTimeout(element);
}

/**
 * Stop listening for typing.
 *
 * @private
 * @param {ReactiveElement} element
 */
function resetPrefixTimeout(element) {
  /** @type {any} */ const cast = element;
  if (cast[prefixTimeoutKey]) {
    clearTimeout(cast[prefixTimeoutKey]);
    cast[prefixTimeoutKey] = false;
  }
}

/**
 * Clear the prefix under construction.
 *
 * @private
 * @param {ReactiveElement} element
 */
function resetTypedPrefix(element) {
  /** @type {any} */ (element)[typedPrefixKey] = "";
  resetPrefixTimeout(element);
}

/**
 * Wait for the user to stop typing.
 *
 * @private
 * @param {ReactiveElement} element
 */
function setPrefixTimeout(element) {
  resetPrefixTimeout(element);
  /** @type {any} */ (element)[prefixTimeoutKey] = setTimeout(() => {
    resetTypedPrefix(element);
  }, TYPING_TIMEOUT_DURATION);
}

/**
 * Lets an element determine whether it resides in right-to-left text.
 *
 * @module LanguageDirectionMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function LanguageDirectionMixin(Base) {
  // The class prototype added by the mixin.
  return class LanguageDirection extends Base {
    // The only way to get text direction is to wait for the component to
    // connect and then inspect the computed style on its root element. We set
    // state before calling super so the new state will be included when
    // ReactiveMixin calls render.
    connectedCallback() {
      /** @type {any} */ const element = this;
      const languageDirection = getComputedStyle(element).direction;
      const rightToLeft = languageDirection === "rtl";
      this[setState]({ rightToLeft });
      super.connectedCallback();
    }
  };
}

/**
 * Treats an element's content nodes as list items.
 *
 * Items differ from nodes contents in several ways:
 *
 * * They are often referenced via index.
 * * They may have a selection state.
 * * It's common to do work to initialize the appearance or state of a new
 *   item.
 * * Text nodes are filtered out.
 * * Auxiliary invisible child elements are filtered out and not counted as
 *   items. Auxiliary elements include link, script, style, and template
 *   elements. This filtering ensures that those auxiliary elements can be
 *   used in markup inside of a list without being treated as list items.
 *
 * This mixin expects a component to provide a `content` state member returning
 * a raw set of elements. You can provide that yourself, or use
 * [SlotContentMixin](SlotContentMixin).
 *
 * Most Elix [elements](elements) use `ContentItemsMixin`, including
 * [ListBox](ListBox), [Modes](Modes), and [Tabs](Tabs).
 *
 * @module ContentItemsMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function ContentItemsMixin(Base) {
  return class ContentItems extends Base {
    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        items: null,
      });
    }

    [stateEffects](state, changed) {
      const effects = super[stateEffects]
        ? super[stateEffects](state, changed)
        : {};

      // Regenerate items when content changes.
      if (changed.content) {
        /** @type {Node[]} */ const content = state.content;
        const items = content
          ? Array.prototype.filter.call(content, (/** @type {Node} */ item) =>
              isSubstantiveElement(item)
            )
          : null;
        if (items) {
          Object.freeze(items);
        }
        Object.assign(effects, { items });
      }

      return effects;
    }
  };
}

/**
 * Treats the elements assigned to the default slot as list items
 *
 * This is simply a combination of
 * [ContentItemsMixin](ContentItemsMixin) and
 * [SlotContentMixin](SlotContentMixin).
 *
 * @module SlotItemsMixin
 * @mixes ContentItemsMixin
 * @mixes SlotContentMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function SlotItemsMixin(Base) {
  return ContentItemsMixin(SlotContentMixin(Base));
}

/**
 * A tap/mousedown on a list item makes that item current.
 *
 * This simple mixin is useful in list-like elements like [ListBox](ListBox),
 * where a tap/mousedown on a list item implicitly selects it.
 *
 * The standard use for this mixin is in list-like elements. Native list
 * boxes don't appear to be consistent with regard to whether they select
 * on mousedown or click/mouseup. This mixin assumes the use of mousedown.
 * On touch devices, that event appears to trigger when the touch is *released*.
 *
 * This mixin only listens to mousedown events for the primary mouse button
 * (typically the left button). Right clicks are ignored so that the browser may
 * display a context menu.
 *
 * This mixin expects the component to provide an `state.items` member. It also
 * expects the component to define a `state.currentIndex` member; you can
 * provide that yourself, or use [ItemsCursorMixin](ItemsCursorMixin).
 *
 * If the component receives an event that doesn't correspond to an item (e.g.,
 * the user taps on the element background visible between items), the cursor
 * will be removed. However, if the component sets `state.currentItemRequired` to
 * true, a background tap will *not* remove the cursor.
 *
 * @module TapCursorMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function TapCursorMixin(Base) {
  // The class prototype added by the mixin.
  return class TapCursor extends Base {
    constructor() {
      // @ts-ignore
      super();
      this.addEventListener("mousedown", (event) => {
        // Only process events for the main (usually left) button.
        if (event.button !== 0) {
          return;
        }
        this[raiseChangeEvents] = true;
        this[tap](event);
        this[raiseChangeEvents] = false;
      });
    }

    [render](/** @type {ChangedFlags} */ changed) {
      if (super[render]) {
        super[render](changed);
      }
      if (this[firstRender]) {
        Object.assign(this.style, {
          touchAction: "manipulation", // for iOS Safari
          mozUserSelect: "none",
          msUserSelect: "none",
          webkitUserSelect: "none",
          userSelect: "none",
        });
      }
    }

    [tap](/** @type {MouseEvent} */ event) {
      // In some situations, the event target will not be the child which was
      // originally clicked on. E.g., if the item clicked on is a button, the
      // event seems to be raised in phase 2 (AT_TARGET) — but the event target
      // will be the component, not the item that was clicked on. Instead of
      // using the event target, we get the first node in the event's composed
      // path.
      // @ts-ignore
      const target = event.composedPath
        ? event.composedPath()[0]
        : event.target;

      // Find which item was clicked on and, if found, make it current. Ignore
      // clicks on disabled items.
      //
      // For elements which don't require a cursor, a background click will
      // determine the item was null, in which we case we'll remove the cursor.
      const { items, currentItemRequired } = this[state];
      if (items && target instanceof Node) {
        const targetIndex = indexOfItemContainingTarget(items, target);
        const item = targetIndex >= 0 ? items[targetIndex] : null;
        if ((item && !item.disabled) || (!item && !currentItemRequired)) {
          this[setState]({
            currentIndex: targetIndex,
          });
          event.stopPropagation();
        }
      }
    }
  };
}

const Base$6 = AriaMenuMixin(
  CursorAPIMixin(
    CursorInViewMixin(
      DelegateFocusMixin(
        DirectionCursorMixin(
          ItemsAPIMixin(
            ItemsCursorMixin(
              ItemsTextMixin(
                KeyboardDirectionMixin(
                  KeyboardMixin(
                    KeyboardPagedCursorMixin(
                      KeyboardPrefixCursorMixin(
                        LanguageDirectionMixin(
                          SlotItemsMixin(TapCursorMixin(ReactiveElement))
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
);

/**
 * A menu of choices or commands
 *
 * This holds the contents of the menu, not the top-level UI element that invokes
 * a menu. For that, see [MenuButton](MenuButton) or [PopupSource](PopupSource).
 *
 * @inherits ReactiveElement
 * @mixes AriaMenuMixin
 * @mixes CursorInViewMixin
 * @mixes CursorAPIMixin
 * @mixes DelegateFocusMixin
 * @mixes DirectionCursorMixin
 * @mixes ItemsAPIMixin
 * @mixes ItemsCursorMixin
 * @mixes ItemsTextMixin
 * @mixes KeyboardDirectionMixin
 * @mixes KeyboardMixin
 * @mixes KeyboardPagedCursorMixin
 * @mixes KeyboardPrefixCursorMixin
 * @mixes LanguageDirectionMixin
 * @mixes SingleSelectAPIMixin
 * @mixes SlotItemsMixin
 * @mixes TapCursorMixin
 */
class Menu extends Base$6 {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      availableItemFlags: null,
      highlightCurrentItem: true,
      orientation: "vertical",
      currentItemFocused: false,
    });
  }

  /**
   * Flash the current item.
   *
   * By default, this uses a heuristic to guess whether the menu was closed by a
   * keyboard or mouse (on desktop). If so, the menu flashes the current item
   * off then back on, emulating the menu item selection effect in macOS.
   * Otherwise, it does nothing.
   */
  async flashCurrentItem() {
    const keyboardActive = this[state].focusVisible;
    const probablyDesktop = matchMedia("(pointer: fine)").matches;
    if (keyboardActive || probablyDesktop) {
      const flashDuration = 75; // milliseconds
      this[setState]({ highlightCurrentItem: false });
      await new Promise((resolve) => setTimeout(resolve, flashDuration));
      this[setState]({ highlightCurrentItem: true });
      await new Promise((resolve) => setTimeout(resolve, flashDuration));
    }
  }

  [render](/** @type {ChangedFlags} */ changed) {
    super[render](changed);

    if (this[firstRender]) {
      // Listen to changes in disabled state.
      this.addEventListener("disabledchange", (event) => {
        this[raiseChangeEvents] = true;
        /** @type {any} */ const target = event.target;
        const { items } = this[state];
        const index = items === null ? -1 : items.indexOf(target);
        if (index >= 0) {
          // Update item availability.
          const availableItemFlags = this[state].availableItemFlags.slice();
          availableItemFlags[index] = !target.disabled;
          this[setState]({ availableItemFlags });
        }
        this[raiseChangeEvents] = false;
      });

      // Treat a pointerdown event as a tap.
      if ("PointerEvent" in window) {
        // Prefer listening to standard pointer events.
        this.addEventListener("pointerdown", (event) => this[tap](event));
      } else {
        this.addEventListener("touchstart", (event) => this[tap](event));
      }

      this.removeAttribute("tabindex");
    }

    const { currentIndex, items } = this[state];

    // Highlight the current item.
    if (
      (changed.items || changed.currentIndex || changed.highlightCurrentItem) &&
      items
    ) {
      const { highlightCurrentItem } = this[state];
      items.forEach((item, index) => {
        item.toggleAttribute(
          "current",
          highlightCurrentItem && index === currentIndex
        );
      });
    }

    if (
      (changed.items ||
        changed.currentIndex ||
        changed.currentItemFocused ||
        changed.focusVisible) &&
      items
    ) {
      // A menu has a complicated focus arrangement in which the current item has
      // focus, which means it needs a tabindex. However, we don't want any other
      // item in the menu to have a tabindex, so that if the user presses Tab or
      // Shift+Tab, they move away from the menu entirely (rather than just moving
      // to the next or previous item).
      //
      // That's already complex, but to make things worse, if we remove the
      // tabindex from an item that has the focus, the focus gets moved to the
      // document. In popup menus, the popup will conclude it's lost the focus,
      // and implicitly close. So we want to move the focus in two phases: 1)
      // set tabindex on a newly-current item so we can focus on it, 2) after
      // the new item has been focused, remove the tabindex from any
      // previous item.
      items.forEach((item, index) => {
        const current = index === currentIndex;
        const isDefaultFocusableItem = currentIndex < 0 && index === 0;
        if (!this[state].currentItemFocused) {
          // Phase 1: Add tabindex to newly-current item.
          if (current || isDefaultFocusableItem) {
            item.tabIndex = 0;
          }
        } else {
          // Phase 2: Remove tabindex from any previous item.
          if (!(current || isDefaultFocusableItem)) {
            item.removeAttribute("tabindex");
          }
        }
      });
    }
  }

  [rendered](/** @type {ChangedFlags} */ changed) {
    super[rendered](changed);
    if (
      !this[firstRender] &&
      changed.currentIndex &&
      !this[state].currentItemFocused
    ) {
      // The current item needs the focus, but this is complicated. See notes
      // in render.
      const { currentItem } = this[state];
      const focusElement =
        currentItem instanceof HTMLElement ? currentItem : this;
      focusElement.focus();

      // Now that the current item has been focused, we can remove/reset the
      // tabindex on any item that had previously been current.
      this[setState]({
        currentItemFocused: true,
      });
    }
  }

  // @ts-ignore
  get [scrollTarget]() {
    return this[ids].content;
  }

  [stateEffects](state, changed) {
    const effects = super[stateEffects](state, changed);

    // When current item changes, we'll need to focus on it in rendered.
    if (changed.currentIndex) {
      Object.assign(effects, {
        currentItemFocused: false,
      });
    }

    // Mark disabled items as unavailable.
    if (changed.items) {
      const { items } = state;
      const availableItemFlags =
        items === null ? null : items.map((item) => !item.disabled);
      Object.assign(effects, { availableItemFlags });
    }

    return effects;
  }

  get [template]() {
    return templateFrom.html`
      <style>
        :host {
          box-sizing: border-box;
          cursor: default;
          display: inline-flex;
          -webkit-tap-highlight-color: transparent;
          touch-action: manipulation;
        }

        #content {
          display: flex;
          flex: 1;
          flex-direction: column;
          max-height: 100%;
          overflow-x: hidden;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch; /* for momentum scrolling */
        }
        
        ::slotted(*) {
          flex-shrink: 0;
          outline: none;
          touch-action: manipulation;
        }

        ::slotted(option) {
          font: inherit;
          min-height: inherit;
        }
      </style>
      <div id="content" role="none">
        <slot></slot>
      </div>
    `;
  }
}

const documentMouseupListenerKey = Symbol("documentMouseupListener");

/**
 * Add drag-select behavior to an element with a popup.
 *
 * This allows a user to mouse down on a popup source, drag into the resulting
 * popup, and release the mouse to select something in the popup. This can be
 * used in conjunction with [PopupListMixin](PopupListMixin).
 *
 * @module PopupDragSelectMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function PopupDragSelectMixin(Base) {
  // The class prototype added by the mixin.
  class PopupDragSelect extends Base {
    connectedCallback() {
      super.connectedCallback();
      // Handle edge case where component is opened, removed, then added back.
      listenIfOpenAndConnected$1(this);
    }

    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        dragSelect: true,
      });
    }

    disconnectedCallback() {
      if (super.disconnectedCallback) {
        super.disconnectedCallback();
      }
      listenIfOpenAndConnected$1(this);
    }

    [rendered](/** @type {ChangedFlags} */ changed) {
      super[rendered](changed);

      if (changed.opened) {
        listenIfOpenAndConnected$1(this);
      }
    }

    [stateEffects](state, changed) {
      const effects = super[stateEffects](state, changed);

      // Set things when opening, or reset things when closing.
      if (changed.opened) {
        if (state.opened) {
          // Opening
          Object.assign(effects, {
            // Until we get a mouseup, we're doing a drag-select.
            dragSelect: true,
          });
        }
      }

      return effects;
    }
  }

  return PopupDragSelect;
}

async function handleMouseup(/** @type {MouseEvent} */ event) {
  // @ts-ignore
  const element = this;
  const hitTargets = element[shadowRoot].elementsFromPoint(
    event.clientX,
    event.clientY
  );
  if (element.opened) {
    // Was mouseup over source part?
    const overSource = hitTargets.indexOf(element[ids].source) >= 0;

    // Was mouseup over the popup or popup frame?
    const popup = element[ids].popup;
    const overPopup = hitTargets.indexOf(popup) >= 0;
    const overPopupFrame = popup.frame && hitTargets.indexOf(popup.frame) >= 0;

    if (overSource) {
      // User released the mouse over the source button (behind the
      // backdrop), so we're no longer doing a drag-select.
      if (element[state].dragSelect) {
        element[raiseChangeEvents] = true;
        element[setState]({
          dragSelect: false,
        });
        element[raiseChangeEvents] = false;
      }
    } else if (!(overPopup || overPopupFrame)) {
      // If we get to this point, the user released over the backdrop with
      // the popup open, so close.
      element[raiseChangeEvents] = true;
      await element.close();
      element[raiseChangeEvents] = false;
    }
  }
}

function listenIfOpenAndConnected$1(element) {
  if (element[state].opened && element.isConnected) {
    // If the popup is open and user releases the mouse over the backdrop, we
    // want to close the popup. We need to listen to mouseup on the document,
    // not this element. If the user mouses down on the source, then moves the
    // mouse off the document before releasing the mouse, the element itself
    // won't get the mouseup. The document will, however, so it's a more
    // reliable source of mouse state.
    //
    // Coincidentally, we *also* need to listen to mouseup on the document to
    // tell whether the user released the mouse over the source button. When the
    // user mouses down, the backdrop will appear and cover the source, so from
    // that point on the source won't receive a mouseup event. Again, we can
    // listen to mouseup on the document and do our own hit-testing to see if
    // the user released the mouse over the source.
    if (!element[documentMouseupListenerKey]) {
      // Not listening yet; start.
      element[documentMouseupListenerKey] = handleMouseup.bind(element);
      document.addEventListener("mouseup", element[documentMouseupListenerKey]);
    }
  } else if (element[documentMouseupListenerKey]) {
    // Currently listening; stop.
    document.removeEventListener(
      "mouseup",
      element[documentMouseupListenerKey]
    );
    element[documentMouseupListenerKey] = null;
  }
}

/**
 * Tracks the disabled state of a component that can be disabled
 *
 * @module DisabledMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function DisabledMixin(Base) {
  // The class prototype added by the mixin.
  class Disabled extends Base {
    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        disabled: false,
      });
    }

    /**
     * True if the component is disabled, false (the default) if not.
     *
     * The value of this property will be reflected to the `disabled` attribute
     * so that it can be referenced in CSS. Note that this non-native
     * implementation of the `disabled` attribute will *not* trigger the
     * `:disabled` CSS pseudo-class, so your style rules will have to reference
     * the presence or absence of the `disabled` attribute. That is, instead
     * of writing
     *
     *     my-component:disabled { ... }
     *
     * write this instead
     *
     *     my-component[disabled] { ... }
     *
     * Like the native `disabled` attribute, this attribute is boolean. That
     * means that it's *existence* in markup sets the attribute, even if set to
     * an empty string or a string like "false".
     *
     * @type {boolean}
     * @default false
     */
    get disabled() {
      return this[state].disabled;
    }
    // AttributeMarshallingMixin should parse this as a boolean attribute for us.
    set disabled(disabled) {
      this[setState]({ disabled });
    }

    [rendered](/** @type {ChangedFlags} */ changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }

      if (changed.disabled) {
        // Reflect value of disabled property to the corresponding attribute.
        this.toggleAttribute("disabled", this.disabled);

        if (this[raiseChangeEvents]) {
          const oldEvent = new CustomEvent("disabled-changed", {
            bubbles: true,
          });
          this.dispatchEvent(oldEvent);
          /**
           * Raised when the `disabled` property changes.
           *
           * @event disabledchange
           */
          const event = new CustomEvent("disabledchange", {
            bubbles: true,
          });
          this.dispatchEvent(event);
        }
      }
    }
  }

  return Disabled;
}

/**
 * Function for positioning a popup relative to a source element.
 *
 * @module positionPopup
 */

/**
 * Given an (x, y) origin point, a bounding rectangle, and a layout, return the
 * height and width of the available space in the quadrant used by that layout.
 *
 * @private
 * @param {DOMRect} sourceRect
 * @param {DOMRect} boundsRect
 */
function availableSpace(sourceRect, boundsRect, direction, align) {
  const sourceOrigin = getSourceOrigin(sourceRect, direction, align);

  let height = 0;
  let width = 0;
  const vertical = direction === "above" || direction === "below";
  switch (direction) {
    case "above":
      height = sourceOrigin.y - boundsRect.top;
      break;
    case "below":
      height = boundsRect.bottom - sourceOrigin.y;
      break;
    case "left":
      width = sourceOrigin.x - boundsRect.left;
      break;
    case "right":
      width = boundsRect.right - sourceOrigin.x;
      break;
  }
  switch (align) {
    case "bottom":
      height = sourceOrigin.y - boundsRect.top;
      break;
    case "center":
      if (vertical) {
        width = boundsRect.width;
      } else {
        height = boundsRect.height;
      }
      break;
    case "stretch":
      if (vertical) {
        width = sourceRect.width;
      } else {
        height = sourceRect.height;
      }
      break;
    case "left":
      width = boundsRect.right - sourceOrigin.x;
      break;
    case "right":
      width = sourceOrigin.x - boundsRect.left;
      break;
    case "top":
      height = boundsRect.bottom - sourceOrigin.y;
      break;
  }
  height = Math.max(0, height);
  width = Math.max(0, width);
  return { height, width };
}

/**
 * Given two layouts, return -1 if the first is better, 1 if the second is
 * better, and 0 if they're equally good.
 *
 * Our comparison uses a heuristic that looks to see whether a layout can fit
 * the popup in height, width, or both. A layout is best if it fits both height
 * and width. If each layout only fits one dimension, then the layout that gives
 * the popup more space is preferred.
 *
 * @private
 * @param {DOMRect} sourceRect
 * @param {DOMRect} popupRect
 * @param {DOMRect} boundsRect
 */
function compareLayouts(layout1, layout2, sourceRect, popupRect, boundsRect) {
  const space1 = availableSpace(
    sourceRect,
    boundsRect,
    layout1.direction,
    layout1.align
  );
  const space2 = availableSpace(
    sourceRect,
    boundsRect,
    layout2.direction,
    layout2.align
  );
  const fitsWidth1 = popupRect.width <= space1.width;
  const fitsHeight1 = popupRect.height <= space1.height;
  const fitsEither1 = fitsWidth1 || fitsHeight1;
  const fitsBoth1 = fitsWidth1 && fitsHeight1;
  const fitsWidth2 = popupRect.width <= space2.width;
  const fitsHeight2 = popupRect.height <= space2.height;
  const fitsEither2 = fitsWidth2 || fitsHeight2;
  const fitsBoth2 = fitsWidth2 && fitsHeight2;
  const area1 = space1.width * space1.height;
  const area2 = space2.width * space2.height;
  if (fitsBoth1 && fitsBoth2) {
    // Both layouts can fit in both dimensions; they're equally good.
    return 0;
  } else if (fitsBoth1) {
    // Layout 1 has space for popup in both dimensions.
    return -1;
  } else if (fitsBoth2) {
    // Layout 2 has space for popup in both dimensions.
    return 1;
  } else if (fitsEither1 && !fitsEither2) {
    // Layout 1 fits in one dimension, layout 2 doesn't fit either.
    return -1;
  } else if (fitsEither2 && !fitsEither1) {
    // Layout 2 fits in one dimensions, layout 1 doesn't fit either.
    return 1;
  } else if (fitsEither1 && area1 > area2) {
    // Layout 1 fits in one dimension and gives popup more space.
    return -1;
  } else if (fitsEither2 && area2 > area1) {
    // Layout 2 fits in one dimension and gives popup more space.
    return 1;
  } else if (area1 > area2) {
    // Layout 1 gives popup more space.
    return -1;
  } else if (area2 > area1) {
    // Layout 2 gives popup more space.
    return 1;
  } else {
    // Layouts equally good or bad.
    return 0;
  }
}

/**
 * Determine the (x, y) location at which the popup should be positioned to
 * touch the indicated source origin point.
 *
 * @private
 * @param {DOMRect} sourceRect
 * @param {DOMRect} popupRect
 * @param {DOMRect} boundsRect
 */
function getPositionedRect(
  sourceRect,
  popupRect,
  boundsRect,
  direction,
  align
) {
  // With respect to which point on the source will we position the popup?
  const sourceOrigin = getSourceOrigin(sourceRect, direction, align);

  // We'll adjust our bounds depending upon the layout.
  let {
    x: boundsLeft,
    y: boundsTop,
    bottom: boundsBottom,
    right: boundsRight,
  } = boundsRect;

  let x = 0;
  let y = 0;
  let height = popupRect.height;
  let width = popupRect.width;
  const vertical = direction === "above" || direction === "below";
  switch (direction) {
    case "above":
      y = sourceOrigin.y - popupRect.height;
      boundsBottom = sourceOrigin.y;
      break;
    case "below":
      y = sourceOrigin.y;
      boundsTop = sourceOrigin.y;
      break;
    case "left":
      x = sourceOrigin.x - popupRect.width;
      boundsRight = sourceOrigin.x;
      break;
    case "right":
      x = sourceOrigin.x;
      boundsLeft = sourceOrigin.x;
      break;
  }
  switch (align) {
    case "bottom":
      y = sourceOrigin.y - popupRect.height;
      boundsBottom = sourceOrigin.y;
      break;
    case "left":
      x = sourceOrigin.x;
      boundsLeft = sourceOrigin.x;
      break;
    case "center":
      if (vertical) {
        x = sourceOrigin.x - popupRect.width / 2;
      } else {
        y = sourceOrigin.y - popupRect.height / 2;
      }
      break;
    case "right":
      x = sourceOrigin.x - popupRect.width;
      boundsRight = sourceOrigin.x;
      break;
    case "stretch":
      if (vertical) {
        x = sourceOrigin.x;
        width = sourceRect.width;
      } else {
        y = sourceOrigin.y;
        height = sourceRect.height;
      }
      break;
    case "top":
      y = sourceOrigin.y;
      boundsTop = sourceOrigin.y;
      break;
  }

  // Force the desired rectangle to fit within the bounds.
  x = Math.max(x, boundsLeft);
  y = Math.max(y, boundsTop);
  width = Math.min(width, boundsRight - x);
  height = Math.min(height, boundsBottom - y);

  return new DOMRect(x, y, width, height);
}

/**
 * For a given layout, we will use a different point on the source element as a
 * reference point to position the popup. Return that (x, y) point.
 *
 * @private
 * @param {DOMRect} sourceRect
 */
function getSourceOrigin(sourceRect, direction, align) {
  let x = 0;
  let y = 0;
  const vertical = direction === "above" || direction === "below";
  switch (direction) {
    case "above":
      y = sourceRect.top;
      break;
    case "below":
      y = sourceRect.bottom;
      break;
    case "left":
    case "right":
      x = sourceRect[direction];
      break;
  }
  switch (align) {
    case "bottom":
    case "top":
      y = sourceRect[align];
      break;
    case "left":
    case "right":
      x = sourceRect[align];
      break;
    case "center":
      if (vertical) {
        x = sourceRect.left + sourceRect.width / 2;
      } else {
        y = sourceRect.top + sourceRect.height / 2;
      }
      break;
    case "stretch":
      if (vertical) {
        x = sourceRect.left;
      } else {
        y = sourceRect.top;
      }
      break;
  }
  return { x, y };
}

/**
 * Return the optimum layout for the popup element with respect to a source
 * element that fits in the given bounds.
 *
 * @param {DOMRect} sourceRect
 * @param {DOMRect} popupRect
 * @param {DOMRect} boundsRect
 * @param {any} options
 */
function layoutPopup(
  sourceRect,
  popupRect,
  boundsRect,
  options
) {
  const normalized = normalizeOptions(options);

  // Given the direction and alignment, which layouts do we want to consider?
  const layouts = prioritizedLayouts(normalized.direction, normalized.align);

  // Sort layouts by our heuristic.
  layouts.sort((layout1, layout2) =>
    compareLayouts(layout1, layout2, sourceRect, popupRect, boundsRect)
  );

  // Take the best layout.
  const layout = layouts[0];

  // Find the positioned rect with respect to the source origin.
  layout.rect = getPositionedRect(
    sourceRect,
    popupRect,
    boundsRect,
    layout.direction,
    layout.align
  );

  return layout;
}

// Normalize the popup options. Convert any logical layout options (start, end)
// to physical options (e.g., left, right). Replace any unknown option values
// with defaults.
function normalizeOptions(options) {
  const {
    align: logicalAlign,
    direction: logicalDirection,
    rightToLeft,
  } = options;
  const defaultDirection = "below";
  const physicalDirection =
    {
      above: "above",
      below: "below",
      column: "below",
      "column-reverse": "above",
      left: "left",
      right: "right",
      row: rightToLeft ? "left" : "right",
      "row-reverse": rightToLeft ? "right" : "left",
    }[logicalDirection] || defaultDirection;
  const crossAxis = {
    above: "horizontal",
    below: "horizontal",
    left: "vertical",
    right: "vertical",
  }[physicalDirection];
  const defaultAlign = {
    horizontal: "left",
    vertical: "top",
  }[crossAxis];
  const physicalAlign =
    {
      horizontal: {
        center: "center",
        end: rightToLeft ? "left" : "right",
        left: "left",
        right: "right",
        start: rightToLeft ? "right" : "left",
        stretch: "stretch",
      },
      vertical: {
        bottom: "bottom",
        center: "center",
        end: "bottom",
        start: "top",
        stretch: "stretch",
        top: "top",
      },
    }[crossAxis][logicalAlign] || defaultAlign;
  return {
    align: physicalAlign,
    direction: physicalDirection,
    rightToLeft,
  };
}

// Given a preferred direction and alignment, determine the set of 2 or 4 layout
// alternatives that should be considered, in priority order.
function prioritizedLayouts(preferredDirection, preferredAlign) {
  const flipDirection = {
    above: "below",
    below: "above",
    left: "right",
    right: "left",
  };
  const flipAlign = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left",
  };

  // Our first choice of layout will be the preferred options.
  const possibilties = [
    { align: preferredAlign, direction: preferredDirection },
  ];

  if (preferredAlign === "center" || preferredAlign === "stretch") {
    // Center/stretch align only needs to consider flipping over main axis.
    possibilties.push({
      align: preferredAlign,
      direction: flipDirection[preferredDirection],
    });
  } else {
    // Consider possibilities of flipping on either axis or both.
    possibilties.push({
      align: flipAlign[preferredAlign],
      direction: preferredDirection,
    });
    possibilties.push({
      align: preferredAlign,
      direction: flipDirection[preferredDirection],
    });
    possibilties.push({
      align: flipAlign[preferredAlign],
      direction: flipDirection[preferredDirection],
    });
  }

  return possibilties;
}

/** @type {any} */
const implicitCloseListenerKey = Symbol("implicitCloseListener");

/**
 * Gives an overlay lightweight popup-style behavior.
 *
 * This mixin expects the component to provide:
 *
 * * An open/close API compatible with `OpenCloseMixin`.
 *
 * The mixin provides these features to the component:
 *
 * * Event handlers that close the element presses the Esc key, moves the focus
 *   outside the element, scrolls the document, resizes the document, or
 *   switches focus away from the document.
 * * A default ARIA role of `alert`.
 *
 * For modal overlays, use `DialogModalityMixin` instead. See the documentation
 * of that mixin for a comparison of modality behaviors.
 *
 * @module PopupModalityMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function PopupModalityMixin(Base) {
  // The class prototype added by the mixin.
  class PopupModality extends Base {
    /**
     * True if the popup should close if the user resizes the window.
     *
     * @type {boolean}
     * @default true
     */
    get closeOnWindowResize() {
      return this[state].closeOnWindowResize;
    }
    set closeOnWindowResize(closeOnWindowResize) {
      this[setState]({ closeOnWindowResize });
    }

    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        closeOnWindowResize: true,
        role: "alert",
      });
    }

    // Close on Esc key.
    [keydown](/** @type {KeyboardEvent} */ event) {
      let handled = false;

      switch (event.key) {
        case "Escape":
          this.close({
            canceled: "Escape",
          });
          handled = true;
          break;
      }

      // Prefer mixin result if it's defined, otherwise use base result.
      return handled || (super.keydown && super.keydown(event)) || false;
    }

    [render](/** @type {ChangedFlags} */ changed) {
      if (super[render]) {
        super[render](changed);
      }

      if (this[firstRender]) {
        // If we lose focus, and the new focus isn't inside us, then close.
        this.addEventListener("blur", blurHandler$1.bind(this));
      }

      if (changed.role) {
        // Apply top-level role.
        const { role } = this[state];
        this.setAttribute("role", role);
      }
    }

    [rendered](/** @type {ChangedFlags} */ changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }

      if (changed.opened) {
        if (this.opened) {
          // Wait before wiring up events – if the popup was opened because the
          // user clicked something, that opening click event may still be
          // bubbling up, and we only want to start listening after it's been
          // processed. Alternatively, if the popup caused the page to scroll, we
          // don't want to immediately close because the page scrolled (only if
          // the user scrolls).
          const callback =
            "requestIdleCallback" in window
              ? window["requestIdleCallback"]
              : setTimeout;
          callback(() => {
            // It's conceivable the popup was closed before the timeout completed,
            // so double-check that it's still opened before listening to events.
            if (this.opened) {
              addEventListeners$1(this);
            }
          });
        } else {
          removeEventListeners$1(this);
        }
      }
    }

    // Setting the standard role attribute will invoke this property setter,
    // which will allow us to update our state.
    get role() {
      return super.role;
    }
    set role(role) {
      super.role = role;
      if (!this[rendering]) {
        this[setState]({ role });
      }
    }
  }

  return PopupModality;
}

function addEventListeners$1(/** @type {ReactiveElement} */ element) {
  // Close handlers for window events.
  element[implicitCloseListenerKey] = closeHandler.bind(element);

  // Window blur event tracks loss of focus of *window*, not just element.
  window.addEventListener("blur", element[implicitCloseListenerKey]);
  window.addEventListener("resize", element[implicitCloseListenerKey]);
  window.addEventListener("scroll", element[implicitCloseListenerKey]);
}

function removeEventListeners$1(/** @type {ReactiveElement} */ element) {
  if (element[implicitCloseListenerKey]) {
    window.removeEventListener("blur", element[implicitCloseListenerKey]);
    window.removeEventListener("resize", element[implicitCloseListenerKey]);
    window.removeEventListener("scroll", element[implicitCloseListenerKey]);
    element[implicitCloseListenerKey] = null;
  }
}

// Note: This routine also exists in PopupButton, may want to eventually
// share that. Note that PopupButton handles blur on the *button*; here
// we're dealing with the popup.
async function blurHandler$1(/** @type {Event} */ event) {
  // @ts-ignore
  /** @type {any} */ const element = this;
  // What has the focus now?
  const newFocusedElement =
    /** @type {any} */ (event).relatedTarget || document.activeElement;
  /** @type {any} */
  if (
    newFocusedElement instanceof Element &&
    !deepContains(element, newFocusedElement)
  ) {
    element[raiseChangeEvents] = true;
    await element.close({ canceled: "window blur" });
    element[raiseChangeEvents] = false;
  }
}

async function closeHandler(/** @type {Event} */ event) {
  // @ts-ignore
  /** @type {any} */ const element = this;
  const handleEvent =
    event.type !== "resize" || element[state].closeOnWindowResize;
  if (!ownEvent(element, event) && handleEvent) {
    element[raiseChangeEvents] = true;
    await element.close({
      canceled: `window ${event.type}`,
    });
    element[raiseChangeEvents] = false;
  }
}

const Base$5 = KeyboardMixin(PopupModalityMixin(Overlay));

/**
 * Lightweight form of modeless overlay that can be easily dismissed
 *
 * When opened, the popup displays its children on top of other page elements.
 *
 * @inherits Overlay
 * @mixes KeyboardMixin
 * @mixes PopupModalityMixin
 */
class Popup extends Base$5 {
  [render](/** @type {ChangedFlags} */ changed) {
    super[render](changed);
    if (changed.backdropPartType) {
      this[ids].backdrop.addEventListener(
        "mousedown",
        mousedownHandler.bind(this)
      );

      // Mobile Safari doesn't seem to generate a mousedown handler on the
      // backdrop in some cases that Mobile Chrome handles. For completeness, we
      // also listen to touchend.
      if (!("PointerEvent" in window)) {
        this[ids].backdrop.addEventListener("touchend", mousedownHandler);
      }
    }
  }
}

/**
 * @private
 * @param {Event} event
 */
async function mousedownHandler(event) {
  // @ts-ignore
  const element = this;
  element[raiseChangeEvents] = true;
  await element.close({
    canceled: "mousedown outside",
  });
  element[raiseChangeEvents] = false;
  event.preventDefault();
  event.stopPropagation();
}

const resizeListenerKey = Symbol("resizeListener");

const Base$4 = DisabledMixin(
  FocusVisibleMixin(LanguageDirectionMixin(OpenCloseMixin(ReactiveElement)))
);

/**
 * Positions a popup with respect to a source element
 *
 * @inherits ReactiveElement
 * @mixes DisabledMixin
 * @mixes FocusVisibleMixin
 * @mixes OpenCloseMixin
 * @part {Popup} popup - the popup element
 * @part {button} source - the element used as the reference point for positioning the popup, generally the element that invokes the popup
 */
class PopupSource extends Base$4 {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      ariaHasPopup: "true",
      popupAlign: "start",
      popupDirection: "column",
      popupLayout: null,
      popupPartType: Popup,
      sourcePartType: "div",
    });
  }

  // By default, assume that the source part is an input-like element that will
  // get the foucs.
  get [inputDelegate]() {
    return this[ids].source;
  }

  get frame() {
    return /** @type {any} */ (this[ids].popup).frame;
  }

  // TODO: Remove this deprecated property.
  get horizontalAlign() {
    return this[state].popupAlign;
  }
  set horizontalAlign(horizontalAlign) {
    console.warn(
      `The "horizontalAlign" property has been renamed to "popupAlign"; the "horizontal-align" attribute is now "popup-align".`
    );
    this[setState]({ popupAlign: horizontalAlign });
  }

  /**
   * The alignment of the popup with respect to the source button.
   *
   * * `bottom`: popup and source are bottom-aligned
   * * `end`: popup and source are aligned on the trailing edge according to the
   *   text direction
   * * `left`: popup and source are left-aligned
   * * `right`: popup and source are right-aligned
   * * `start`: popup and source are aligned on the leading edge according to
   *   the text direction
   * * `stretch`: both left and right edges are aligned
   * * `top`: popup and source are top-aligned
   *
   * @type {('bottom'|'end'|'left'|'right'|'start'|'stretch'|'top')}
   * @default 'start'
   */
  get popupAlign() {
    return this[state].popupAlign;
  }
  set popupAlign(popupAlign) {
    this[setState]({ popupAlign });
  }

  /**
   * The preferred direction for the popup.
   *
   * * `above`: popup appears above the source
   * * `below`: popup appears below the source
   * * `column-reverse`: popup appears before the source in the block axis
   * * `column`: popup appears after the source in the block axis
   * * `left`: popup appears to the left of the source
   * * `right`: popup appears to the right of the source
   * * `row-reverse`: popup appears before the source in the inline axis
   * * `row`: popup appears after the source in the inline axis
   *
   * @type {('above'|'below'|'column-reverse'|'column'|'left'|'right'|'row-reverse'|'row')}
   * @default 'column'
   */
  get popupDirection() {
    return this[state].popupDirection;
  }
  set popupDirection(popupDirection) {
    this[setState]({ popupDirection });
  }

  // TODO: Remove this deprecated property.
  get popupPosition() {
    return this[state].popupPosition;
  }
  set popupPosition(popupPosition) {
    console.warn(
      `The "popupPosition" property has been renamed to "popupDirection"; the "popup-position" attribute is now "popup-direction".`
    );
    this[setState]({ popupPosition });
  }

  /**
   * The class or tag used to create the `popup` part – the element
   * responsible for displaying the popup and handling overlay behavior.
   *
   * @type {PartDescriptor}
   * @default Popup
   */
  get popupPartType() {
    return this[state].popupPartType;
  }
  set popupPartType(popupPartType) {
    this[setState]({ popupPartType });
  }

  [render](/** @type {ChangedFlags} */ changed) {
    super[render](changed);

    renderParts$2(this[shadowRoot], this[state], changed);

    if (this[firstRender] || changed.ariaHasPopup) {
      const { ariaHasPopup } = this[state];
      if (ariaHasPopup === null) {
        this[inputDelegate].removeAttribute("aria-haspopup");
      } else {
        this[inputDelegate].setAttribute(
          "aria-haspopup",
          this[state].ariaHasPopup
        );
      }
    }

    if (changed.popupPartType) {
      // Popup's opened state becomes our own opened state.
      this[ids].popup.addEventListener("open", () => {
        if (!this.opened) {
          this[raiseChangeEvents] = true;
          this.open();
          this[raiseChangeEvents] = false;
        }
      });

      // Popup's closed state becomes our own closed state.
      this[ids].popup.addEventListener("close", (event) => {
        if (!this.closed) {
          this[raiseChangeEvents] = true;
          /** @type {any} */

          const cast = event;
          const closeResult = cast.detail.closeResult;
          this.close(closeResult);
          this[raiseChangeEvents] = false;
        }
      });
    }

    if (changed.opened || changed.popupLayout) {
      const { opened, popupLayout } = this[state];

      if (!opened) {
        // Popup closed. Reset the styles used to position it.
        Object.assign(this[ids].popup.style, {
          bottom: "",
          left: "",
          opacity: "",
          right: "",
          top: "",
        });
      } else if (!popupLayout) {
        // Popup opened but not yet laid out.
        //
        // Render the component invisibly so we can measure it before showing
        // it. We hide it by giving it zero opacity. If we use `visibility:
        // hidden` for this purpose, the popup won't be able to receive the
        // focus, which would complicate our overlay focus handling.
        //
        // In case the popup is being relayed out because a layout-affecting
        // property changed while the popup is open, we reset the positiong
        // styles too.
        Object.assign(this[ids].popup.style, {
          bottom: "",
          left: "",
          opacity: 0,
          right: "",
          top: "",
        });
      } else {
        // Popup opened and laid out. Position the popup using only the edges
        // implicated in the layout.
        const popup = this[ids].popup;
        const positionStyling = getPositiongStylingForLayout(popupLayout);
        Object.assign(popup.style, positionStyling, {
          opacity: "",
        });
      }
    }

    if (changed.opened) {
      const { opened } = this[state];
      /** @type {any} */ (this[ids].popup).opened = opened;
    }

    if (changed.disabled) {
      if ("disabled" in this[ids].source) {
        const { disabled } = this[state];
        /** @type {any} */ (this[ids].source).disabled = disabled;
      }
    }

    // Let the popup know its position relative to the source.
    if (changed.popupLayout) {
      const { popupLayout } = this[state];
      if (popupLayout) {
        const { align, direction } = popupLayout;
        /** @type {any} */ const popup = this[ids].popup;
        if ("position" in popup) {
          popup.position = direction;
        }
        if ("align" in popup) {
          popup.align = align;
        }
      }
    }
  }

  [rendered](/** @type {ChangedFlags} */ changed) {
    super[rendered](changed);
    const { opened } = this[state];
    if (changed.opened) {
      if (opened) {
        // Worth noting that's possible (but unusual) for a popup to render
        // opened on first render.
        waitThenRenderOpened(this);
      } else {
        removeEventListeners(this);
      }
    } else if (
      changed.popupLayout &&
      this[state].opened &&
      !this[state].popupLayout
    ) {
      // A layout-affecting property changed while the popup is open; do layout
      // again.
      choosePopupLayout(this);
    }
  }

  /**
   * The class or tag used to create the `source` part - the button
   * (or other element) the user can tap/click to invoke the popup.
   *
   * @type {PartDescriptor}
   * @default 'button'
   */
  get sourcePartType() {
    return this[state].sourcePartType;
  }
  set sourcePartType(sourcePartType) {
    this[setState]({ sourcePartType });
  }

  [stateEffects](state, changed) {
    const effects = super[stateEffects](state, changed);

    // We reset our popup calculations when the popup closes, or if it's open
    // and state that affects positioning has changed.
    if (
      (changed.opened && !state.opened) ||
      (state.opened &&
        (changed.popupAlign || changed.popupDirection || changed.rightToLeft))
    ) {
      Object.assign(effects, {
        popupLayout: null,
      });
    }

    return effects;
  }

  get [template]() {
    const result = super[template];
    result.content.append(fragmentFrom.html`
      <style>
        :host {
          display: inline-block;
          position: relative;
        }

        [part~="source"] {
          height: 100%;
          -webkit-tap-highlight-color: transparent;
          touch-action: manipulation;
          width: 100%;
        }

        [part~="popup"] {
          max-height: 100%;
          max-width: 100%;
          outline: none;
          position: fixed;
        }
      </style>
      <div id="source" part="source">
        <slot name="source"></slot>
      </div>
      <div id="popup" part="popup" exportparts="backdrop, frame" role="none">
        <slot></slot>
      </div>
    `);

    renderParts$2(result.content, this[state]);

    return result;
  }
}

function addEventListeners(/** @type {PopupSource} */ element) {
  /** @type {any} */ const cast = element;
  cast[resizeListenerKey] = () => {
    // If viewport resizes while the popup is open, we may want to change which
    // layout we're using for the popup.
    choosePopupLayout(element);
  };
  const viewport = window.visualViewport || window;
  viewport.addEventListener("resize", cast[resizeListenerKey]);
}

/**
 * Based on the current size of the source, popup, and viewport, determine which
 * layout we'll use for the popup.
 *
 * @private
 * @param {PopupSource} element
 */
function choosePopupLayout(element) {
  const { popupAlign, popupDirection, rightToLeft } = element[state];
  const sourceRect = element[ids].source.getBoundingClientRect();
  const popupRect = element[ids].popup.getBoundingClientRect();
  const boundsRect = viewportBounds();

  const popupLayout = layoutPopup(sourceRect, popupRect, boundsRect, {
    align: popupAlign,
    direction: popupDirection,
    rightToLeft,
  });

  element[setState]({ popupLayout });
}

// Given a complete layout for a popup (including the rect), determine the
// styling that should be applied to the popup.
function getPositiongStylingForLayout(layout) {
  const { align, direction, rect } = layout;
  const bounds = viewportBounds();
  const styling = {};
  const vertical = direction === "above" || direction === "below";
  switch (direction) {
    case "above":
      styling.bottom = `${bounds.bottom - rect.bottom}px`;
      break;
    case "below":
      styling.top = `${rect.top}px`;
      break;
    case "left":
      styling.right = `${bounds.right - rect.right}px`;
      break;
    case "right":
      styling.left = `${rect.left}px`;
      break;
  }
  switch (align) {
    case "bottom":
      styling.bottom = `${bounds.bottom - rect.bottom}px`;
      break;
    case "center":
    case "stretch":
      if (vertical) {
        styling.left = `${rect.left}px`;
        styling.right = `${bounds.right - rect.right}px`;
      } else {
        styling.bottom = `${bounds.bottom - rect.bottom}px`;
        styling.top = `${rect.top}px`;
      }
      break;
    case "left":
      styling.left = `${rect.left}px`;
      break;
    case "right":
      styling.right = `${bounds.right - rect.right}px`;
      break;
    case "top":
      styling.top = `${rect.top}px`;
      break;
  }
  return styling;
}

function removeEventListeners(/** @type {PopupSource} */ element) {
  /** @type {any} */ const cast = element;
  if (cast[resizeListenerKey]) {
    const viewport = window.visualViewport || window;
    viewport.removeEventListener("resize", cast[resizeListenerKey]);
    cast[resizeListenerKey] = null;
  }
}

/**
 * Render parts for the template or an instance.
 *
 * @private
 * @param {DocumentFragment} root
 * @param {PlainObject} state
 * @param {ChangedFlags} [changed]
 */
function renderParts$2(root, state, changed) {
  if (!changed || changed.popupPartType) {
    const { popupPartType } = state;
    const popup = root.getElementById("popup");
    if (popup) {
      transmute(popup, popupPartType);
    }
  }
  if (!changed || changed.sourcePartType) {
    const { sourcePartType } = state;
    const source = root.getElementById("source");
    if (source) {
      transmute(source, sourcePartType);
    }
  }
}

// Determine the bounding rectangle of the viewport. We prefer the
// VisualViewport API where that's available, as that handles a pinch-zoomed
// viewport on mobile. If not availble (as of October 2020, Firefox), we fall
// back to using the window as the viewport.
function viewportBounds() {
  // @ts-ignore
  const viewport = window.visualViewport;
  const boundsRect = viewport
    ? new DOMRect(
        viewport.offsetLeft,
        viewport.offsetTop,
        viewport.width,
        viewport.height
      )
    : new DOMRect(0, 0, window.innerWidth, window.innerHeight);
  return boundsRect;
}

/**
 *
 * When a popup is first rendered, we let it render invisibly so that it doesn't
 * affect the page layout.
 *
 * We then wait, for two reasons:
 *
 * 1) We need to give the popup time to render invisibly. That lets us get the
 *    true size of the popup content.
 *
 * 2) Wire up events that can dismiss the popup. If the popup was opened because
 *    the user clicked something, that opening click event may still be bubbling
 *    up, and we only want to start listening after it's been processed.
 *    Along the same lines, if the popup caused the page to scroll, we don't
 *    want to immediately close because the page scrolled (only if the user
 *    scrolls).
 *
 * After waiting, we can take care of both of the above tasks.
 *
 * @private
 * @param {PopupSource} element
 */
function waitThenRenderOpened(element) {
  // Wait a tick to let the newly-opened component actually render.
  setTimeout(() => {
    // It's conceivable the popup was closed before the timeout completed,
    // so double-check that it's still opened before listening to events.
    if (element[state].opened) {
      choosePopupLayout(element);
      addEventListeners(element);
    }
  });
}

const Base$3 = DelegateFocusMixin(
  KeyboardMixin(PopupDragSelectMixin(PopupSource))
);

/**
 * A button that invokes an attached popup
 *
 * @inherits PopupSource
 * @mixes DelegateFocusMixin
 * @mixes KeyboardMixin
 * @mixes PopupDragSelectMixin
 */
class PopupButton extends Base$3 {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      sourcePartType: "button",
    });
  }

  [keydown](/** @type {KeyboardEvent} */ event) {
    let handled;

    switch (event.key) {
      // Space or Up/Down arrow keys open the popup.
      case " ":
      case "ArrowDown":
      case "ArrowUp":
        if (this.closed) {
          this.open();
          handled = true;
        }
        break;

      // Enter opens popup.
      case "Enter":
        if (!this.opened) {
          this.open();
          handled = true;
        }
        break;

      // If popup is open, pressing Esc should close popup.
      // This code exists to handle cases where the popup does not take the
      // focus (autoFocus is false). In cases where the popup takes focus, it
      // will be up to the popup to handle closing when Esc is pressed.
      case "Escape":
        if (this.opened) {
          this.close({
            canceled: "Escape",
          });
          handled = true;
        }
        break;
    }

    // Give superclass a chance to handle.
    handled = super[keydown] && super[keydown](event);

    if (!handled && this.opened && !event.metaKey && !event.altKey) {
      // If they haven't already been handled, absorb keys that might cause the
      // page to scroll in the background, which would in turn cause the popup to
      // inadvertently close.
      switch (event.key) {
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "End":
        case "Home":
        case "PageDown":
        case "PageUp":
        case " ":
          handled = true;
      }
    }

    return handled;
  }

  [render](/** @type {ChangedFlags} */ changed) {
    super[render](changed);

    if (this[firstRender]) {
      // Close the popup if we're opened and lose focus. A typical popup using
      // PopupModalityMixin will have its own logic to close on blur -- but in
      // cases where the popup itself doesn't get focus (e.g., TooltipButton),
      // that logic won't apply.
      this.addEventListener("blur", blurHandler.bind(this));

      // If the source element gets the focus while the popup is open, the
      // most likely expanation is that the user hit Shift+Tab to back up out of
      // the popup. In that case, we should close.
      this[ids].source.addEventListener("focus", async (event) => {
        const popupFocused = ownEvent(this[ids].popup, event);
        // It's possible to get a focus event in the initial mousedown on the
        // source button before the popup is even rendered. We don't want to
        // close in that case, so we check to see if we've already measured the
        // popup dimensions (which will be true if the popup fully completed
        // rendering).
        const measured = this[state].popupHeight !== null;
        if (!popupFocused && this.opened && measured) {
          this[raiseChangeEvents] = true;
          await this.close();
          this[raiseChangeEvents] = false;
        }
      });
    }

    if (changed.opened) {
      // Reflect opened state to attribute for styling.
      const { opened } = this[state];
      this.toggleAttribute("opened", opened);
    }

    if (changed.sourcePartType) {
      // Desktop popups generally open on mousedown, not click/mouseup. On mobile,
      // mousedown won't fire until the user releases their finger, so it behaves
      // like a click.
      const source = this[ids].source;
      source.addEventListener("mousedown", (event) => {
        // mousedown events fire even if button is disabled, so we need
        // to explicitly ignore those.
        if (this.disabled) {
          event.preventDefault();
          return;
        }
        // Only handle primary button mouse down to avoid interfering with
        // right-click behavior.
        /** @type {any} */
        const cast = event;
        if (cast.button && cast.button !== 0) {
          return;
        }
        // We give the default focus behavior time to run before opening the
        // popup. See note below.
        setTimeout(() => {
          if (!this.opened) {
            this[raiseChangeEvents] = true;
            this.open();
            this[raiseChangeEvents] = false;
          }
        });
        event.stopPropagation();
        // We don't prevent the default behavior for mousedown. Among other
        // things, it sets the focus to the element the user moused down on.
        // That's important for us, because OverlayMixin will remember that
        // focused element (i.e., this element) when opening, and restore focus to
        // it when the popup closes.
      });
    }

    if (changed.popupPartType) {
      this[ids].popup.removeAttribute("tabindex");
    }
  }

  get [template]() {
    const result = super[template];
    // When popup is open, it will have focus; don't show focus ring on host.
    result.content.append(
      fragmentFrom.html`
        <style>
          [part~="source"] {
            cursor: default;
            outline: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-user-select: none;
            user-select: none;
          }

          :host([opened][focus-visible]) {
            outline: none;
          }
        </style>
      `
    );
    return result;
  }
}

// Note: This routine also exists in PopupModalityMixin, may want to eventually
// share that. Note that PopupModalityMixin handles blur on the *popup*; here
// we're dealing with the source button.
async function blurHandler(/** @type {Event} */ event) {
  // @ts-ignore
  /** @type {any} */ const element = this;
  // What has the focus now?
  const newFocusedElement =
    /** @type {any} */ (event).relatedTarget || document.activeElement;
  /** @type {any} */
  if (
    newFocusedElement instanceof Element &&
    !deepContains(element, newFocusedElement)
  ) {
    element[raiseChangeEvents] = true;
    await element.close({ canceled: "blur" });
    element[raiseChangeEvents] = false;
  }
}

const documentMousemoveListenerKey = Symbol("documentMousemoveListener");

/**
 * Syncs the cursor a popup source and a list-like element inside the popup.
 *
 * This includes support for drag-select operations: the user can mouse down on
 * the source to produce the popup, drag into the popup to highlight an item,
 * then release the mouse to select that item.
 *
 * @module PopupListMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function PopupListMixin(Base) {
  // The class prototype added by the mixin.
  class PopupList extends Base {
    connectedCallback() {
      super.connectedCallback();
      // Handle edge case where component is opened, removed, then added back.
      listenIfOpenAndConnected(this);
    }

    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        currentIndex: -1,
        hasHoveredOverItemSinceOpened: false,
        popupList: null,
      });
    }

    disconnectedCallback() {
      if (super.disconnectedCallback) {
        super.disconnectedCallback();
      }
      listenIfOpenAndConnected(this);
    }

    [keydown](/** @type {KeyboardEvent} */ event) {
      let handled = false;

      switch (event.key) {
        // Enter closes popup.
        case "Enter":
          if (this.opened) {
            selectCurrentItemAndClose(this);
            handled = true;
          }
      }

      // Prefer our result if it's defined, otherwise use base result.
      return handled || (super[keydown] && super[keydown](event)) || false;
    }

    [render](changed) {
      if (super[render]) {
        super[render](changed);
      }

      if (changed.popupList) {
        const { popupList } = this[state];
        if (popupList) {
          // If the user mouses up on a list item, close the list with that item as
          // the close result.
          popupList.addEventListener("mouseup", async (event) => {
            // If we're doing a drag-select (user moused down on button, dragged
            // mouse into list, and released), we close. If we're not doing a
            // drag-select (the user opened the list with a complete click), and
            // there's a selection, they clicked on an item, so also close.
            // Otherwise, the user clicked the list open, then clicked on a list
            // separator or list padding; stay open.
            const currentIndex = this[state].currentIndex;
            if (this[state].dragSelect || currentIndex >= 0) {
              // We don't want the document mouseup handler in
              // PopupDragSelectMixin to close the popup before we've asked the
              // list to highlight the selection. We stop event propagation
              // here, before we enter any async code, to actually stop
              // propagation.
              event.stopPropagation();
              this[raiseChangeEvents] = true;
              await selectCurrentItemAndClose(this);
              this[raiseChangeEvents] = false;
            } else {
              event.stopPropagation();
            }
          });

          // Track changes in the list's cursor.
          popupList.addEventListener("currentindexchange", (event) => {
            this[raiseChangeEvents] = true;
            /** @type {any} */
            const cast = event;
            this[setState]({
              currentIndex: cast.detail.currentIndex,
            });
            this[raiseChangeEvents] = false;
          });
        }
      }

      // The popup's current item is represented in the visible list.
      if (changed.currentIndex || changed.popupList) {
        const { currentIndex, popupList } = this[state];
        if (popupList && "currentIndex" in popupList) {
          popupList.currentIndex = currentIndex;
        }
      }
    }

    [rendered](changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }

      if (changed.opened) {
        if (this[state].opened) {
          // Ensure the list's cursor is visible. If the cursor moved while the
          // list was closed, the cursor may not be in view yet.
          const { popupList } = this[state];
          if (popupList.scrollCurrentItemIntoView) {
            // Give popup time to render.
            setTimeout(() => {
              popupList.scrollCurrentItemIntoView();
            });
          }
        }
        listenIfOpenAndConnected(this);
      }
    }

    [stateEffects](state, changed) {
      const effects = super[stateEffects]
        ? super[stateEffects](state, changed)
        : {};

      // When opening, reset out notion of whether the user has hovered over an
      // item since the list was opened.
      if (changed.opened && state.opened) {
        Object.assign(effects, {
          hasHoveredOverItemSinceOpened: false,
        });
      }

      return effects;
    }
  }

  return PopupList;
}

// Handle a mouse hover select operation.
function handleMousemove(/** @type {MouseEvent} */ event) {
  // @ts-ignore
  const element = this;
  const { hasHoveredOverItemSinceOpened, opened } = element[state];
  if (opened) {
    // Treat the deepest element in the composed event path as the target.
    const target = event.composedPath ? event.composedPath()[0] : event.target;
    const items = element.items;

    if (target && target instanceof Node && items) {
      const hoverIndex = indexOfItemContainingTarget(items, target);
      const item = items[hoverIndex];

      // If the user is hovering over an enabled item, make it current.
      // If the user is not hovering over an enabled item, but has
      // hovered over such an item at least once since the list was
      // opened, then clear cursor.
      const currentIndex = item && !item.disabled ? hoverIndex : -1;

      if (
        (hasHoveredOverItemSinceOpened || currentIndex >= 0) &&
        currentIndex !== element[state].currentIndex
      ) {
        element[raiseChangeEvents] = true;
        element[setState]({ currentIndex });
        if (currentIndex >= 0 && !hasHoveredOverItemSinceOpened) {
          element[setState]({ hasHoveredOverItemSinceOpened: true });
        }
        element[raiseChangeEvents] = false;
      }
    }
  }
}

function listenIfOpenAndConnected(element) {
  if (element[state].opened && element.isConnected) {
    if (!element[documentMousemoveListenerKey]) {
      // Not listening yet; start.
      element[documentMousemoveListenerKey] = handleMousemove.bind(element);
      document.addEventListener(
        "mousemove",
        element[documentMousemoveListenerKey]
      );
    }
  } else if (element[documentMousemoveListenerKey]) {
    // Currently listening; stop.
    document.removeEventListener(
      "mousemove",
      element[documentMousemoveListenerKey]
    );
    element[documentMousemoveListenerKey] = null;
  }
}

/**
 * Highlight the current item (if one exists), then close the menu.
 */
async function selectCurrentItemAndClose(element) {
  const originalRaiseChangeEvents = element[raiseChangeEvents];
  const cursorDefined = element[state].currentIndex >= 0;
  const items = element.items;
  if (items) {
    const closeResult = cursorDefined
      ? items[element[state].currentIndex]
      : undefined;

    const list = element[state].popupList;
    if (cursorDefined && "flashCurrentItem" in list) {
      await list.flashCurrentItem();
    }
    const saveRaiseChangeEvents = element[raiseChangeEvents];
    element[raiseChangeEvents] = originalRaiseChangeEvents;
    await element.close(closeResult);
    element[raiseChangeEvents] = saveRaiseChangeEvents;
  }
}

const Base$2 = PopupListMixin(PopupButton);

/**
 * A button that invokes a menu.
 *
 * @inherits PopupButton
 * @mixes PopupListMixin
 * @part {Menu} menu - the menu shown in the popup
 */
class MenuButton extends Base$2 {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      menuPartType: Menu,
    });
  }

  get items() {
    /** @type {any} */
    const menu = this[ids] && this[ids].menu;
    return menu ? menu.items : null;
  }

  /**
   * The class or tag used to define the `menu` part – the element
   * presenting the menu items and handling navigation between them.
   *
   * @type {PartDescriptor}
   * @default Menu
   */
  get menuPartType() {
    return this[state].menuPartType;
  }
  set menuPartType(menuPartType) {
    this[setState]({ menuPartType });
  }

  [render](/** @type {ChangedFlags} */ changed) {
    super[render](changed);

    renderParts$1(this[shadowRoot], this[state], changed);

    if (changed.menuPartType) {
      // Close the popup if menu loses focus.
      this[ids].menu.addEventListener("blur", async (event) => {
        /** @type {any} */
        const cast = event;
        const newFocusedElement = cast.relatedTarget || document.activeElement;
        if (this.opened && !deepContains(this[ids].menu, newFocusedElement)) {
          this[raiseChangeEvents] = true;
          await this.close();
          this[raiseChangeEvents] = false;
        }
      });

      // mousedown events on the menu will propagate up to the top-level element,
      // which will then steal the focus. We want to keep the focus on the menu,
      // both to permit keyboard use, and to avoid closing the menu on blur (see
      // separate blur handler). To keep the focus on the menu, we prevent the
      // default event behavior.
      this[ids].menu.addEventListener("mousedown", (event) => {
        // Only process events for the main (usually left) button.
        if (/** @type {MouseEvent} */ (event).button !== 0) {
          return;
        }
        if (this.opened) {
          event.stopPropagation();
          event.preventDefault();
        }
      });
    }

    if (changed.opened) {
      // Reflect opened state to source for ARIA.
      const { opened } = this[state];
      this[ids].source.setAttribute("aria-expanded", opened.toString());
    }
  }

  [rendered](changed) {
    super[rendered](changed);

    if (changed.menuPartType) {
      this[setState]({
        popupList: this[ids].menu,
      });
    }
  }

  [stateEffects](state, changed) {
    const effects = super[stateEffects](state, changed);

    // When closing, clear menu selection.
    if (changed.opened && !state.opened) {
      Object.assign(effects, {
        currentIndex: -1,
      });
    }

    return effects;
  }

  get [template]() {
    const result = super[template];

    // Wrap default slot with a menu.
    const defaultSlot = result.content.querySelector("slot:not([name])");
    if (defaultSlot) {
      defaultSlot.replaceWith(fragmentFrom.html`
        <div id="menu" part="menu">
          <slot></slot>
        </div>
      `);
    }

    renderParts$1(result.content, this[state]);

    result.content.append(fragmentFrom.html`
      <style>
        [part~="menu"] {
          max-height: 100%;
        }
      </style>
    `);

    return result;
  }
}

/**
 * Render parts for the template or an instance.
 *
 * @private
 * @param {DocumentFragment} root
 * @param {PlainObject} state
 * @param {ChangedFlags} [changed]
 */
function renderParts$1(root, state, changed) {
  if (!changed || changed.menuPartType) {
    const { menuPartType } = state;
    const menu = root.getElementById("menu");
    if (menu) {
      transmute(menu, menuPartType);
    }
  }
}

const Base$1 = DisabledMixin(ReactiveElement);

/**
 * An element that can point up or down.
 *
 * @inherits ReactiveElement
 * @mixes DisabledMixin
 * @part down-icon - the icon shown in the toggle if the popup will open or close in the down direction
 * @part toggle-icon - both the up and down icons
 * @part up-icon - the icon shown in the toggle if the popup will open or close in the up direction
 */
class UpDownToggle extends Base$1 {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      direction: "down",
    });
  }

  /**
   * Indicates which direction the element should point to.
   *
   * @type {'down'|'up'}
   * @default 'down'
   */
  get direction() {
    return this[state].direction;
  }
  set direction(direction) {
    this[setState]({ direction });
  }

  [render](/** @type {ChangedFlags} */ changed) {
    super[render](changed);

    if (changed.direction) {
      const { direction } = this[state];
      this[ids].downIcon.style.display =
        direction === "down" ? "block" : "none";
      this[ids].upIcon.style.display = direction === "up" ? "block" : "none";
    }
  }

  get [template]() {
    return templateFrom.html`
      <style>
        :host {
          display: inline-block;
        }
      </style>
      <div id="downIcon" part="toggle-icon down-icon">
        <slot name="down-icon"></slot>
      </div>
      <div id="upIcon" part="toggle-icon up-icon">
        <slot name="up-icon"></slot>
      </div>
    `;
  }
}

/**
 * Manages a popup toggle part for a popup source.
 *
 * @module PopupToggleMixin
 * @part {UpDownToggle} popup-toggle - the element that lets the user know they can open the popup
 * @part down-icon - the icon shown in the toggle if the popup will open or close in the down direction
 * @part up-icon - the icon shown in the toggle if the popup will open or close in the up direction
 * @param {Constructor<ReactiveElement>} Base
 */
function PopupToggleMixin(Base) {
  // The class prototype added by the mixin.
  class PopupToggle extends Base {
    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        popupTogglePartType: UpDownToggle,
      });
    }

    /**
     * The class or tag used to create the `popup-toggle` part – the
     * element that lets the user know they can open the popup.
     *
     * @type {PartDescriptor}
     * @default UpDownToggle
     */
    get popupTogglePartType() {
      return this[state].popupTogglePartType;
    }
    set popupTogglePartType(popupTogglePartType) {
      this[setState]({ popupTogglePartType });
    }

    [render](/** @type {ChangedFlags} */ changed) {
      super[render](changed);

      renderParts(this[shadowRoot], this[state], changed);

      // Tell the toggle which direction it should point to depending on which
      // direction the popup will open. Since we assume this is used for up/down
      // popup directions, we don't handle left/right directions.
      if (changed.popupDirection || changed.popupTogglePartType) {
        const { popupDirection } = this[state];
        const toggleDirection =
          popupDirection === "above" || popupDirection === "column-reverse"
            ? "up"
            : "down";
        /** @type {any} */ const popupToggle = this[ids].popupToggle;
        if ("direction" in popupToggle) {
          popupToggle.direction = toggleDirection;
        }
      }

      if (changed.disabled) {
        const { disabled } = this[state];
        /** @type {any} */ (this[ids].popupToggle).disabled = disabled;
      }
    }

    get [template]() {
      const result = super[template];

      // Append a toggle button to the source.
      const source = result.content.querySelector('[part~="source"]');
      if (source) {
        source.append(fragmentFrom.html`
          <div
            id="popupToggle"
            part="popup-toggle"
            exportparts="toggle-icon, down-icon, up-icon"
            tabindex="-1"
          ></div>
      `);
      }

      renderParts(result.content, this[state]);

      result.content.append(fragmentFrom.html`
      <style>
        [part~="popup-toggle"] {
          outline: none;
        }

        [part~="source"] {
          align-items: center;
          display: flex;
        }
      </style>
    `);

      return result;
    }
  }

  return PopupToggle;
}

/**
 * Render parts for the template or an instance.
 *
 * @private
 * @param {DocumentFragment} root
 * @param {PlainObject} state
 * @param {ChangedFlags} [changed]
 */
function renderParts(root, state, changed) {
  if (!changed || changed.popupTogglePartType) {
    const { popupTogglePartType } = state;
    const popupToggle = root.getElementById("popupToggle");
    if (popupToggle) {
      transmute(popupToggle, popupTogglePartType);
    }
  }
}

/**
 * Menu component in the Plain reference design system
 *
 * @inherits Menu
 */
class PlainMenu extends Menu {
  get [template]() {
    const result = super[template];
    result.content.append(
      fragmentFrom.html`
        <style>
          :host ::slotted(*) {
            padding: 0.25em 1em;
          }
          
          :host ::slotted([current]) {
            background: highlight;
            color: highlighttext;
          }

          @media (pointer: coarse) {
            ::slotted(*) {
              padding: 1em;
            }
          }
        </style>
      `
    );
    return result;
  }
}

/**
 * OpenCloseToggle component in the Plain reference design system
 *
 * @inherits OpenCloseToggle
 */
class PlainOpenCloseToggle extends UpDownToggle {
  get [template]() {
    const result = super[template];

    // Replace the icons with our up/down glyphs.
    const downIcon = result.content.getElementById("downIcon");
    const downIconGlyph = fragmentFrom.html`
      <svg
        id="downIcon"
        part="toggle-icon down-icon"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 10 5"
      >
        <path d="M 0 0 l5 5 5 -5 z" />
      </svg>
    `.firstElementChild;
    if (downIcon && downIconGlyph) {
      replace(downIcon, downIconGlyph);
    }
    const upIcon = result.content.getElementById("upIcon");
    const upIconGlyph = fragmentFrom.html`
      <svg
        id="upIcon"
        part="toggle-icon up-icon"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 10 5"
      >
        <path d="M 0 5 l5 -5 5 5 z" />
      </svg>
    `.firstElementChild;
    if (upIcon && upIconGlyph) {
      replace(upIcon, upIconGlyph);
    }

    result.content.append(
      fragmentFrom.html`
        <style>
          :host {
            align-items: center;
            display: inline-flex;
            padding: 2px;
          }

          :host(:not([disabled])):hover {
            background: #eee;
          }

          [part~="toggle-icon"] {
            fill: currentColor;
            height: 10px;
            margin: 0.25em;
            width: 10px;
          }
        </style>
      `
    );
    return result;
  }
}

/**
 * Backdrop component in the Plain reference design system
 *
 * @inherits Backdrop
 */
class PlainBackdrop extends Backdrop {}

/**
 * Popup component in the Plain reference design system
 *
 * @inherits Popup
 * @part {PlainBackdrop} backdrop
 * @part {PlainOverlayFrame} frame
 */
class PlainPopup extends Popup {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      backdropPartType: PlainBackdrop,
      framePartType: PlainOverlayFrame,
    });
  }
}

/**
 * MenuButton component in the Plain reference design system
 *
 * @inherits MenuButton
 * @part {PlainMenu} menu
 * @part {PlainPopup} popup
 * @part {PlainOpenCloseToggle} popup-toggle
 * @part {PlainBorderButton} source
 * @mixes PopupToggleMixin
 */
class PlainMenuButton extends PopupToggleMixin(MenuButton) {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      menuPartType: PlainMenu,
      popupPartType: PlainPopup,
      popupTogglePartType: PlainOpenCloseToggle,
      sourcePartType: PlainBorderButton,
    });
  }

  get [template]() {
    const result = super[template];
    result.content.append(
      fragmentFrom.html`
        <style>
          [part~="menu"] {
            background: window;
            border: none;
            padding: 0.5em 0;
          }
        </style>
      `
    );
    return result;
  }
}

class ElixMenuButton extends PlainMenuButton {}
customElements.define("elix-menu-button", ElixMenuButton);

/**
 * Tracks whether an item is the current item.
 *
 * @module CurrentMixin
 * @state current
 * @param {Constructor<ReactiveElement>} Base
 */
function CurrentMixin(Base) {
  // The class prototype added by the mixin.
  return class Current extends Base {
    constructor() {
      super();
      /** @type {any} */ const cast = this;
      if (!this[nativeInternals] && cast.attachInternals) {
        this[nativeInternals] = cast.attachInternals();
      }
    }

    attributeChangedCallback(name, oldValue, newValue) {
      if (name === "current") {
        const value = booleanAttributeValue(name, newValue);
        if (this.current !== value) {
          this.current = value;
        }
      } else {
        super.attributeChangedCallback(name, oldValue, newValue);
      }
    }

    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        current: false,
      });
    }

    [render](/** @type {ChangedFlags} */ changed) {
      super[render](changed);
      if (changed.current) {
        const { current } = this[state];
        setInternalState(this, "current", current);
      }
    }

    [rendered](/** @type {ChangedFlags} */ changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }

      // TODO: How do we know whether to raise this if selection is set by Menu? */
      if (changed.current /* && this[raiseChangeEvents] */) {
        const { current } = this[state];
        const oldEvent = new CustomEvent("current-changed", {
          bubbles: true,
          detail: { current },
        });
        this.dispatchEvent(oldEvent);
        /**
         * Raised when the `current` property changes.
         *
         * @event currentchange
         */
        const event = new CustomEvent("currentchange", {
          bubbles: true,
          detail: { current },
        });
        this.dispatchEvent(event);
      }
    }

    /**
     * True if the element is currently current.
     *
     * @type {boolean}
     * @default false
     */
    get current() {
      return this[state].current;
    }
    set current(current) {
      // Note: AttributeMarshallingMixin will recognize `current` as the name of
      // attribute that should be parsed as a boolean attribute, and so will
      // handling parsing it for us.
      this[setState]({ current });
    }
  };
}

/**
 * Tracks whether the element is currently selected.
 *
 * @module SelectableMixin
 * @state selected
 * @param {Constructor<ReactiveElement>} Base
 */
function SelectableMixin(Base) {
  // The class prototype added by the mixin.
  return class Selectable extends Base {
    constructor() {
      super();
      /** @type {any} */ const cast = this;
      if (!this[nativeInternals] && cast.attachInternals) {
        this[nativeInternals] = cast.attachInternals();
      }
    }

    // @ts-ignore
    get [defaultState]() {
      return Object.assign(super[defaultState] || {}, {
        selected: false,
      });
    }

    [render](/** @type {ChangedFlags} */ changed) {
      super[render](changed);
      if (changed.selected) {
        const { selected } = this[state];
        setInternalState(this, "selected", selected);
      }
    }

    [rendered](/** @type {ChangedFlags} */ changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }

      // TODO: How do we know whether to raise this if selection is set by Menu? */
      if (changed.selected /* && this[raiseChangeEvents] */) {
        const { selected } = this[state];
        const oldEvent = new CustomEvent("selected-changed", {
          bubbles: true,
          detail: { selected },
        });
        this.dispatchEvent(oldEvent);
        /**
         * Raised when the `selected` property changes.
         *
         * @event selectedchange
         */
        const event = new CustomEvent("selectedchange", {
          bubbles: true,
          detail: { selected },
        });
        this.dispatchEvent(event);
      }
    }

    /**
     * True if the element is currently selected.
     *
     * @type {boolean}
     * @default false
     */
    get selected() {
      return this[state].selected;
    }
    set selected(selected) {
      // Note: AttributeMarshallingMixin will recognize `selected` as the name of
      // attribute that should be parsed as a boolean attribute, and so will
      // handling parsing it for us.
      this[setState]({ selected });
    }
  };
}

/**
 * A choice in a menu
 *
 * This class is a convenient way to popuplate a [Menu](Menu) with items that
 * exhibit an appearance roughly consistent with operating system menu items.
 * Use of this class is not required, however -- a `Menu` can contain any type
 * of item you want.
 *
 * @inherits ReactiveElement
 * @mixes CurrentMixin
 * @mixes DisabledMixin
 * @mixes SelectableMixin
 */
class MenuItem extends CurrentMixin(
  DisabledMixin(SelectableMixin(ReactiveElement))
) {}

/**
 * MenuItem component in the Plain reference design system
 *
 * @inherits MenuItem
 */
class PlainMenuItem extends MenuItem {
  get [template]() {
    // Apply variety of system fonts.
    // Checkmark icon from Material Design.
    return templateFrom.html`
      <style>
        :host {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
          font-size: 10pt;
          white-space: nowrap;
        }

        :host([disabled]) {
          opacity: 0.5;
        }

        #checkmark {
          height: 1em;
          visibility: hidden;
          width: 1em;
        }

        :host([selected]) #checkmark {
          visibility: visible;
        }
      </style>
      <svg id="checkmark" xmlns="http://www.w3.org/2000/svg" viewBox="4 6 18 12">
        <path d="M0 0h24v24H0V0z" fill="none"/>
        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
      </svg>
      <slot></slot>
    `;
  }
}

class ElixMenuItem extends PlainMenuItem {}
customElements.define("elix-menu-item", ElixMenuItem);

/**
 * Inactive item that helps group related menu items
 *
 * See [Menu](Menu) for sample usage.
 *
 * @inherits ReactiveElement
 */
class MenuSeparator extends ReactiveElement {
  get disabled() {
    return true;
  }

  [render](/** @type {ChangedFlags} */ changed) {
    super[render](changed);
    if (this[firstRender]) {
      this.setAttribute("aria-hidden", "true");
    }
  }
}

/**
 * MenuSeparator component in the Plain reference design system
 *
 * @inherits MenuSeparator
 */
class PlainMenuSeparator extends MenuSeparator {
  get [template]() {
    return templateFrom.html`
      <style>
        :host {
          padding: 0 !important;
        }

        hr {
          border-bottom-width: 0px;
          border-color: #fff; /* Ends up as light gray */
          border-top-width: 1px;
          margin: 0.25em 0;
        }
      </style>
      <hr>
    `;
  }
}

class ElixMenuSeparator extends PlainMenuSeparator {}
customElements.define("elix-menu-separator", ElixMenuSeparator);

/**
 * Update state before, during, and after CSS transitions
 *
 * @module TransitionEffectMixin
 * @param {Constructor<ReactiveElement>} Base
 */
function TransitionEffectMixin(Base) {
  // The class prototype added by the mixin.
  class TransitionEffect extends Base {
    /**
     * Return the elements that use CSS transitions to provide visual effects.
     *
     * By default, this assumes the host element itself will have a CSS
     * transition applied to it, and so returns an array containing the element.
     * If you will be applying CSS transitions to other elements, override this
     * property and return an array containing the implicated elements.
     *
     * See [effectEndTarget](internal#internal.effectEndTarget)
     * for details.
     *
     * @type {HTMLElement}
     */
    get [effectEndTarget]() {
      return super[effectEndTarget] || this;
    }

    [render](/** @type {ChangedFlags} */ changed) {
      if (super[render]) {
        super[render](changed);
      }
      if (this[firstRender]) {
        // Listen for `transitionend` events so we can check to see whether an
        // effect has completed. If the component defines an `effectEndTarget`
        // that's the host, listen to events on that. Otherwise, we assume the
        // target is either in the shadow or an element that will be slotted into
        // a slot in the shadow, so we'll listen to events that reach the shadow
        // root.
        const target = this[effectEndTarget] === this ? this : this[shadowRoot];
        target.addEventListener("transitionend", (event) => {
          // See if the event target is our expected `effectEndTarget`. If the
          // component defines a `effectEndTarget` state, we use that; otherwise,
          // we use the element identified with `internal.effectEndTarget`.
          const effectTarget =
            this[state].effectEndTarget || this[effectEndTarget];
          if (event.target === effectTarget) {
            // Advance to the next phase.
            this[setState]({
              effectPhase: "after",
            });
          }
        });
      }
    }

    [rendered](/** @type {ChangedFlags} */ changed) {
      if (super[rendered]) {
        super[rendered](changed);
      }
      if (changed.effect || changed.effectPhase) {
        const { effect, effectPhase } = this[state];
        const oldEvent = new CustomEvent("effect-phase-changed", {
          bubbles: true,
          detail: {
            effect,
            effectPhase,
          },
        });
        this.dispatchEvent(oldEvent);
        /**
         * Raised when [state.effect](TransitionEffectMixin#effect-phases) or
         * [state.effectPhase](TransitionEffectMixin#effect-phases) changes.
         *
         * Note: In general, Elix components do not raise events in response to
         * outside manipulation. (See
         * [raiseChangeEvents](internal#internal.raiseChangeEvents).) However, for
         * a component using `TransitionEffectMixin`, a single invocation of the
         * `startEffect` method will cause the element to pass through multiple
         * visual states. This makes it hard for external hosts of this
         * component to know what visual state the component is in. Accordingly,
         * the mixin raises the `effectphasechange` event whenever the effect or
         * phase changes, even if `internal.raiseChangeEvents` is false.
         *
         * @event effectphasechange
         */
        const event = new CustomEvent("effectphasechange", {
          bubbles: true,
          detail: {
            effect,
            effectPhase,
          },
        });
        this.dispatchEvent(event);

        if (effect) {
          if (effectPhase !== "after") {
            // We read a layout property to force the browser to render the component
            // with its current styles before we move to the next state. This ensures
            // animated values will actually be applied before we move to the next
            // state.
            this.offsetHeight;
          }
          if (effectPhase === "before") {
            // Advance to the next phase.
            this[setState]({
              effectPhase: "during",
            });
          }
        }
      }
    }

    /**
     * See [startEffect](internal#internal.startEffect).
     *
     * @param {string} effect
     */
    async [startEffect](effect) {
      await this[setState]({
        effect,
        effectPhase: "before",
      });
    }
  }

  return TransitionEffect;
}

const timeoutKey = Symbol("timeout");

const Base = LanguageDirectionMixin(TransitionEffectMixin(Popup));

/**
 * Lightweight popup intended to display a short, non-critical message
 *
 * The message remains until  the user dismisses it or a specified `duration`
 * elapses.
 *
 * @inherits Popup
 * @mixes LanguageDirectionMixin
 * @mixes TransitionEffectMixin
 */
class Toast extends Base {
  constructor() {
    super();
    this.addEventListener("mouseout", () => {
      startTimerIfOpened(this);
    });
    this.addEventListener("mouseover", () => {
      clearTimer(this);
    });
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "duration") {
      this.duration = Number(newValue);
    } else {
      super.attributeChangedCallback(name, oldValue, newValue);
    }
  }

  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      duration: null,
      fromEdge: "bottom",
    });
  }

  /**
   * The duration, in milliseconds, for which the toast will appear on screen.
   *
   * The `duration` value refers to the duration of time in which the toast
   * will appear on the screen. In other words, this is the time between
   * the `opened` and `closed` event for the toast.
   *
   * @type {number}
   * @default null
   */
  get duration() {
    return this[state].duration;
  }
  set duration(duration) {
    if (!isNaN(duration)) {
      this[setState]({ duration });
    }
  }

  // @ts-ignore
  get [effectEndTarget]() {
    return this[ids].frame;
  }

  /**
   * The edge of the viewport from which the toast will appear.
   *
   * The `start` and `end` values refer to text direction: in left-to-right
   * languages such as English, these are equivalent to `left` and `right`,
   * respectively.
   *
   * @type {('bottom'|'end'|'left'|'right'|'start'|'top')}
   * @default 'bottom'
   */
  get fromEdge() {
    return this[state].fromEdge;
  }
  set fromEdge(fromEdge) {
    this[setState]({ fromEdge });
  }

  [render](/** @type {ChangedFlags} */ changed) {
    super[render](changed);
    if (changed.fromEdge) {
      // Host
      /** @type {IndexedObject<any>} */
      const hostEdgeStyles = {
        bottom: {
          alignItems: "center",
          justifyContent: "flex-end",
        },
        "bottom-left": {
          alignItems: "flex-start",
          justifyContent: "flex-end",
        },
        "bottom-right": {
          alignItems: "flex-end",
          justifyContent: "flex-end",
        },
        top: {
          alignItems: "center",
          justifyContent: null,
        },
        "top-left": {
          alignItems: "flex-start",
          justifyContent: null,
        },
        "top-right": {
          alignItems: "flex-end",
          justifyContent: null,
        },
      };
      Object.assign(this.style, hostEdgeStyles[this[state].fromEdge]);
    }
    if (
      changed.effect ||
      changed.effectPhase ||
      changed.fromEdge ||
      changed.rightToLeft
    ) {
      const { effect, effectPhase, fromEdge, rightToLeft } = this[state];
      /** @type {IndexedObject<string>} */
      const oppositeEdge = {
        "bottom-left": "bottom-right",
        "bottom-right": "bottom-left",
        "top-left": "top-right",
        "top-right": "top-left",
      };
      const languageAdjustedEdge = rightToLeft
        ? oppositeEdge[fromEdge] || fromEdge
        : fromEdge;

      /** @type {IndexedObject<string>} */
      const edgeTransforms = {
        bottom: "translateY(100%)",
        "bottom-left": "translateX(-100%)",
        "bottom-right": "translateX(100%)",
        top: "translateY(-100%)",
        "top-left": "translateX(-100%)",
        "top-right": "translateX(100%)",
      };

      /** @type {IndexedObject<string>} */
      const openEdgeTransforms = {
        bottom: "translateY(0)",
        "bottom-left": "translateX(0)",
        "bottom-right": "translateX(0)",
        top: "translateY(0)",
        "top-left": "translateX(0)",
        "top-right": "translateX(0)",
      };

      const opened =
        (effect === "open" && effectPhase !== "before") ||
        (effect === "close" && effectPhase === "before");

      const opacity = opened ? 1 : 0;
      const transform = opened
        ? openEdgeTransforms[languageAdjustedEdge]
        : edgeTransforms[languageAdjustedEdge];

      Object.assign(this[ids].frame.style, {
        opacity,
        transform,
      });
    }
  }

  [rendered](/** @type {ChangedFlags} */ changed) {
    super[rendered](changed);
    startTimerIfOpened(this);
  }
}

function clearTimer(/** @type {Toast} */ element) {
  /** @type {any} */ const cast = element;
  if (cast[timeoutKey]) {
    clearTimeout(cast[timeoutKey]);
    cast[timeoutKey] = null;
  }
}

function startTimer(/** @type {Toast} */ element) {
  clearTimer(element);
  const duration = element[state].duration;
  if (duration !== null && duration > 0) {
    /** @type {any} */ (element)[timeoutKey] = setTimeout(() => {
      element.close();
    }, duration);
  }
}

function startTimerIfOpened(/** @type {Toast} */ element) {
  if (element.opened) {
    startTimer(element);
  }
}

/**
 * @inherits Toast
 * @part {PlainOverlayFrame} frame
 */
class PlainToast extends Toast {
  // @ts-ignore
  get [defaultState]() {
    return Object.assign(super[defaultState], {
      framePartType: PlainOverlayFrame,
    });
  }

  get [template]() {
    const result = super[template];
    result.content.append(
      fragmentFrom.html`
        <style>
          :host {
            align-items: initial;
            display: flex;
            flex-direction: column;
            height: 100%;
            justify-content: initial;
            left: 0;
            outline: none;
            pointer-events: none;
            top: 0;
            -webkit-tap-highlight-color: transparent;
            width: 100%;
          }

          [part~="frame"] {
            margin: 1em;
            transition-duration: 0.25s;
            transition-property: opacity, transform;
            will-change: opacity, transform;
          }
        </style>
      `
    );
    return result;
  }
}

class ElixToast extends PlainToast {}
customElements.define("elix-toast", ElixToast);

/*!
 * Quill Editor v1.3.7
 * https://quilljs.com/
 * Copyright (c) 2014, Jason Chen
 * Copyright (c) 2013, salesforce.com
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Quill"] = factory();
	else
		root["Quill"] = factory();
})(typeof self !== 'undefined' ? self : undefined, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 109);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var container_1 = __webpack_require__(17);
var format_1 = __webpack_require__(18);
var leaf_1 = __webpack_require__(19);
var scroll_1 = __webpack_require__(45);
var inline_1 = __webpack_require__(46);
var block_1 = __webpack_require__(47);
var embed_1 = __webpack_require__(48);
var text_1 = __webpack_require__(49);
var attributor_1 = __webpack_require__(12);
var class_1 = __webpack_require__(32);
var style_1 = __webpack_require__(33);
var store_1 = __webpack_require__(31);
var Registry = __webpack_require__(1);
var Parchment = {
    Scope: Registry.Scope,
    create: Registry.create,
    find: Registry.find,
    query: Registry.query,
    register: Registry.register,
    Container: container_1.default,
    Format: format_1.default,
    Leaf: leaf_1.default,
    Embed: embed_1.default,
    Scroll: scroll_1.default,
    Block: block_1.default,
    Inline: inline_1.default,
    Text: text_1.default,
    Attributor: {
        Attribute: attributor_1.default,
        Class: class_1.default,
        Style: style_1.default,
        Store: store_1.default,
    },
};
exports.default = Parchment;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ParchmentError = /** @class */ (function (_super) {
    __extends(ParchmentError, _super);
    function ParchmentError(message) {
        var _this = this;
        message = '[Parchment] ' + message;
        _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = _this.constructor.name;
        return _this;
    }
    return ParchmentError;
}(Error));
exports.ParchmentError = ParchmentError;
var attributes = {};
var classes = {};
var tags = {};
var types = {};
exports.DATA_KEY = '__blot';
var Scope;
(function (Scope) {
    Scope[Scope["TYPE"] = 3] = "TYPE";
    Scope[Scope["LEVEL"] = 12] = "LEVEL";
    Scope[Scope["ATTRIBUTE"] = 13] = "ATTRIBUTE";
    Scope[Scope["BLOT"] = 14] = "BLOT";
    Scope[Scope["INLINE"] = 7] = "INLINE";
    Scope[Scope["BLOCK"] = 11] = "BLOCK";
    Scope[Scope["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
    Scope[Scope["INLINE_BLOT"] = 6] = "INLINE_BLOT";
    Scope[Scope["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
    Scope[Scope["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
    Scope[Scope["ANY"] = 15] = "ANY";
})(Scope = exports.Scope || (exports.Scope = {}));
function create(input, value) {
    var match = query(input);
    if (match == null) {
        throw new ParchmentError("Unable to create " + input + " blot");
    }
    var BlotClass = match;
    var node = 
    // @ts-ignore
    input instanceof Node || input['nodeType'] === Node.TEXT_NODE ? input : BlotClass.create(value);
    return new BlotClass(node, value);
}
exports.create = create;
function find(node, bubble) {
    if (bubble === void 0) { bubble = false; }
    if (node == null)
        return null;
    // @ts-ignore
    if (node[exports.DATA_KEY] != null)
        return node[exports.DATA_KEY].blot;
    if (bubble)
        return find(node.parentNode, bubble);
    return null;
}
exports.find = find;
function query(query, scope) {
    if (scope === void 0) { scope = Scope.ANY; }
    var match;
    if (typeof query === 'string') {
        match = types[query] || attributes[query];
        // @ts-ignore
    }
    else if (query instanceof Text || query['nodeType'] === Node.TEXT_NODE) {
        match = types['text'];
    }
    else if (typeof query === 'number') {
        if (query & Scope.LEVEL & Scope.BLOCK) {
            match = types['block'];
        }
        else if (query & Scope.LEVEL & Scope.INLINE) {
            match = types['inline'];
        }
    }
    else if (query instanceof HTMLElement) {
        var names = (query.getAttribute('class') || '').split(/\s+/);
        for (var i in names) {
            match = classes[names[i]];
            if (match)
                break;
        }
        match = match || tags[query.tagName];
    }
    if (match == null)
        return null;
    // @ts-ignore
    if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope)
        return match;
    return null;
}
exports.query = query;
function register() {
    var Definitions = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        Definitions[_i] = arguments[_i];
    }
    if (Definitions.length > 1) {
        return Definitions.map(function (d) {
            return register(d);
        });
    }
    var Definition = Definitions[0];
    if (typeof Definition.blotName !== 'string' && typeof Definition.attrName !== 'string') {
        throw new ParchmentError('Invalid definition');
    }
    else if (Definition.blotName === 'abstract') {
        throw new ParchmentError('Cannot register abstract class');
    }
    types[Definition.blotName || Definition.attrName] = Definition;
    if (typeof Definition.keyName === 'string') {
        attributes[Definition.keyName] = Definition;
    }
    else {
        if (Definition.className != null) {
            classes[Definition.className] = Definition;
        }
        if (Definition.tagName != null) {
            if (Array.isArray(Definition.tagName)) {
                Definition.tagName = Definition.tagName.map(function (tagName) {
                    return tagName.toUpperCase();
                });
            }
            else {
                Definition.tagName = Definition.tagName.toUpperCase();
            }
            var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
            tagNames.forEach(function (tag) {
                if (tags[tag] == null || Definition.className == null) {
                    tags[tag] = Definition;
                }
            });
        }
    }
    return Definition;
}
exports.register = register;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var diff = __webpack_require__(51);
var equal = __webpack_require__(11);
var extend = __webpack_require__(3);
var op = __webpack_require__(20);


var NULL_CHARACTER = String.fromCharCode(0);  // Placeholder char for embed in diff()


var Delta = function (ops) {
  // Assume we are given a well formed ops
  if (Array.isArray(ops)) {
    this.ops = ops;
  } else if (ops != null && Array.isArray(ops.ops)) {
    this.ops = ops.ops;
  } else {
    this.ops = [];
  }
};


Delta.prototype.insert = function (text, attributes) {
  var newOp = {};
  if (text.length === 0) return this;
  newOp.insert = text;
  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
    newOp.attributes = attributes;
  }
  return this.push(newOp);
};

Delta.prototype['delete'] = function (length) {
  if (length <= 0) return this;
  return this.push({ 'delete': length });
};

Delta.prototype.retain = function (length, attributes) {
  if (length <= 0) return this;
  var newOp = { retain: length };
  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
    newOp.attributes = attributes;
  }
  return this.push(newOp);
};

Delta.prototype.push = function (newOp) {
  var index = this.ops.length;
  var lastOp = this.ops[index - 1];
  newOp = extend(true, {}, newOp);
  if (typeof lastOp === 'object') {
    if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {
      this.ops[index - 1] = { 'delete': lastOp['delete'] + newOp['delete'] };
      return this;
    }
    // Since it does not matter if we insert before or after deleting at the same index,
    // always prefer to insert first
    if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {
      index -= 1;
      lastOp = this.ops[index - 1];
      if (typeof lastOp !== 'object') {
        this.ops.unshift(newOp);
        return this;
      }
    }
    if (equal(newOp.attributes, lastOp.attributes)) {
      if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
        this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
        return this;
      } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
        this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
        return this;
      }
    }
  }
  if (index === this.ops.length) {
    this.ops.push(newOp);
  } else {
    this.ops.splice(index, 0, newOp);
  }
  return this;
};

Delta.prototype.chop = function () {
  var lastOp = this.ops[this.ops.length - 1];
  if (lastOp && lastOp.retain && !lastOp.attributes) {
    this.ops.pop();
  }
  return this;
};

Delta.prototype.filter = function (predicate) {
  return this.ops.filter(predicate);
};

Delta.prototype.forEach = function (predicate) {
  this.ops.forEach(predicate);
};

Delta.prototype.map = function (predicate) {
  return this.ops.map(predicate);
};

Delta.prototype.partition = function (predicate) {
  var passed = [], failed = [];
  this.forEach(function(op) {
    var target = predicate(op) ? passed : failed;
    target.push(op);
  });
  return [passed, failed];
};

Delta.prototype.reduce = function (predicate, initial) {
  return this.ops.reduce(predicate, initial);
};

Delta.prototype.changeLength = function () {
  return this.reduce(function (length, elem) {
    if (elem.insert) {
      return length + op.length(elem);
    } else if (elem.delete) {
      return length - elem.delete;
    }
    return length;
  }, 0);
};

Delta.prototype.length = function () {
  return this.reduce(function (length, elem) {
    return length + op.length(elem);
  }, 0);
};

Delta.prototype.slice = function (start, end) {
  start = start || 0;
  if (typeof end !== 'number') end = Infinity;
  var ops = [];
  var iter = op.iterator(this.ops);
  var index = 0;
  while (index < end && iter.hasNext()) {
    var nextOp;
    if (index < start) {
      nextOp = iter.next(start - index);
    } else {
      nextOp = iter.next(end - index);
      ops.push(nextOp);
    }
    index += op.length(nextOp);
  }
  return new Delta(ops);
};


Delta.prototype.compose = function (other) {
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  var ops = [];
  var firstOther = otherIter.peek();
  if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {
    var firstLeft = firstOther.retain;
    while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {
      firstLeft -= thisIter.peekLength();
      ops.push(thisIter.next());
    }
    if (firstOther.retain - firstLeft > 0) {
      otherIter.next(firstOther.retain - firstLeft);
    }
  }
  var delta = new Delta(ops);
  while (thisIter.hasNext() || otherIter.hasNext()) {
    if (otherIter.peekType() === 'insert') {
      delta.push(otherIter.next());
    } else if (thisIter.peekType() === 'delete') {
      delta.push(thisIter.next());
    } else {
      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
      var thisOp = thisIter.next(length);
      var otherOp = otherIter.next(length);
      if (typeof otherOp.retain === 'number') {
        var newOp = {};
        if (typeof thisOp.retain === 'number') {
          newOp.retain = length;
        } else {
          newOp.insert = thisOp.insert;
        }
        // Preserve null when composing with a retain, otherwise remove it for inserts
        var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
        if (attributes) newOp.attributes = attributes;
        delta.push(newOp);

        // Optimization if rest of other is just retain
        if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
          var rest = new Delta(thisIter.rest());
          return delta.concat(rest).chop();
        }

      // Other op should be delete, we could be an insert or retain
      // Insert + delete cancels out
      } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {
        delta.push(otherOp);
      }
    }
  }
  return delta.chop();
};

Delta.prototype.concat = function (other) {
  var delta = new Delta(this.ops.slice());
  if (other.ops.length > 0) {
    delta.push(other.ops[0]);
    delta.ops = delta.ops.concat(other.ops.slice(1));
  }
  return delta;
};

Delta.prototype.diff = function (other, index) {
  if (this.ops === other.ops) {
    return new Delta();
  }
  var strings = [this, other].map(function (delta) {
    return delta.map(function (op) {
      if (op.insert != null) {
        return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;
      }
      var prep = (delta === other) ? 'on' : 'with';
      throw new Error('diff() called ' + prep + ' non-document');
    }).join('');
  });
  var delta = new Delta();
  var diffResult = diff(strings[0], strings[1], index);
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  diffResult.forEach(function (component) {
    var length = component[1].length;
    while (length > 0) {
      var opLength = 0;
      switch (component[0]) {
        case diff.INSERT:
          opLength = Math.min(otherIter.peekLength(), length);
          delta.push(otherIter.next(opLength));
          break;
        case diff.DELETE:
          opLength = Math.min(length, thisIter.peekLength());
          thisIter.next(opLength);
          delta['delete'](opLength);
          break;
        case diff.EQUAL:
          opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
          var thisOp = thisIter.next(opLength);
          var otherOp = otherIter.next(opLength);
          if (equal(thisOp.insert, otherOp.insert)) {
            delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
          } else {
            delta.push(otherOp)['delete'](opLength);
          }
          break;
      }
      length -= opLength;
    }
  });
  return delta.chop();
};

Delta.prototype.eachLine = function (predicate, newline) {
  newline = newline || '\n';
  var iter = op.iterator(this.ops);
  var line = new Delta();
  var i = 0;
  while (iter.hasNext()) {
    if (iter.peekType() !== 'insert') return;
    var thisOp = iter.peek();
    var start = op.length(thisOp) - iter.peekLength();
    var index = typeof thisOp.insert === 'string' ?
      thisOp.insert.indexOf(newline, start) - start : -1;
    if (index < 0) {
      line.push(iter.next());
    } else if (index > 0) {
      line.push(iter.next(index));
    } else {
      if (predicate(line, iter.next(1).attributes || {}, i) === false) {
        return;
      }
      i += 1;
      line = new Delta();
    }
  }
  if (line.length() > 0) {
    predicate(line, {}, i);
  }
};

Delta.prototype.transform = function (other, priority) {
  priority = !!priority;
  if (typeof other === 'number') {
    return this.transformPosition(other, priority);
  }
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  var delta = new Delta();
  while (thisIter.hasNext() || otherIter.hasNext()) {
    if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
      delta.retain(op.length(thisIter.next()));
    } else if (otherIter.peekType() === 'insert') {
      delta.push(otherIter.next());
    } else {
      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
      var thisOp = thisIter.next(length);
      var otherOp = otherIter.next(length);
      if (thisOp['delete']) {
        // Our delete either makes their delete redundant or removes their retain
        continue;
      } else if (otherOp['delete']) {
        delta.push(otherOp);
      } else {
        // We retain either their retain or insert
        delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
      }
    }
  }
  return delta.chop();
};

Delta.prototype.transformPosition = function (index, priority) {
  priority = !!priority;
  var thisIter = op.iterator(this.ops);
  var offset = 0;
  while (thisIter.hasNext() && offset <= index) {
    var length = thisIter.peekLength();
    var nextType = thisIter.peekType();
    thisIter.next();
    if (nextType === 'delete') {
      index -= Math.min(length, index - offset);
      continue;
    } else if (nextType === 'insert' && (offset < index || !priority)) {
      index += length;
    }
    offset += length;
  }
  return index;
};


module.exports = Delta;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BlockEmbed = exports.bubbleFormats = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _extend = __webpack_require__(3);

var _extend2 = _interopRequireDefault(_extend);

var _quillDelta = __webpack_require__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _break = __webpack_require__(16);

var _break2 = _interopRequireDefault(_break);

var _inline = __webpack_require__(6);

var _inline2 = _interopRequireDefault(_inline);

var _text = __webpack_require__(7);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NEWLINE_LENGTH = 1;

var BlockEmbed = function (_Parchment$Embed) {
  _inherits(BlockEmbed, _Parchment$Embed);

  function BlockEmbed() {
    _classCallCheck(this, BlockEmbed);

    return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));
  }

  _createClass(BlockEmbed, [{
    key: 'attach',
    value: function attach() {
      _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'attach', this).call(this);
      this.attributes = new _parchment2.default.Attributor.Store(this.domNode);
    }
  }, {
    key: 'delta',
    value: function delta() {
      return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));
    }
  }, {
    key: 'format',
    value: function format(name, value) {
      var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);
      if (attribute != null) {
        this.attributes.attribute(attribute, value);
      }
    }
  }, {
    key: 'formatAt',
    value: function formatAt(index, length, name, value) {
      this.format(name, value);
    }
  }, {
    key: 'insertAt',
    value: function insertAt(index, value, def) {
      if (typeof value === 'string' && value.endsWith('\n')) {
        var block = _parchment2.default.create(Block.blotName);
        this.parent.insertBefore(block, index === 0 ? this : this.next);
        block.insertAt(0, value.slice(0, -1));
      } else {
        _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'insertAt', this).call(this, index, value, def);
      }
    }
  }]);

  return BlockEmbed;
}(_parchment2.default.Embed);

BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;
// It is important for cursor behavior BlockEmbeds use tags that are block level elements


var Block = function (_Parchment$Block) {
  _inherits(Block, _Parchment$Block);

  function Block(domNode) {
    _classCallCheck(this, Block);

    var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));

    _this2.cache = {};
    return _this2;
  }

  _createClass(Block, [{
    key: 'delta',
    value: function delta() {
      if (this.cache.delta == null) {
        this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function (delta, leaf) {
          if (leaf.length() === 0) {
            return delta;
          } else {
            return delta.insert(leaf.value(), bubbleFormats(leaf));
          }
        }, new _quillDelta2.default()).insert('\n', bubbleFormats(this));
      }
      return this.cache.delta;
    }
  }, {
    key: 'deleteAt',
    value: function deleteAt(index, length) {
      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'deleteAt', this).call(this, index, length);
      this.cache = {};
    }
  }, {
    key: 'formatAt',
    value: function formatAt(index, length, name, value) {
      if (length <= 0) return;
      if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
        if (index + length === this.length()) {
          this.format(name, value);
        }
      } else {
        _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'formatAt', this).call(this, index, Math.min(length, this.length() - index - 1), name, value);
      }
      this.cache = {};
    }
  }, {
    key: 'insertAt',
    value: function insertAt(index, value, def) {
      if (def != null) return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, index, value, def);
      if (value.length === 0) return;
      var lines = value.split('\n');
      var text = lines.shift();
      if (text.length > 0) {
        if (index < this.length() - 1 || this.children.tail == null) {
          _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, Math.min(index, this.length() - 1), text);
        } else {
          this.children.tail.insertAt(this.children.tail.length(), text);
        }
        this.cache = {};
      }
      var block = this;
      lines.reduce(function (index, line) {
        block = block.split(index, true);
        block.insertAt(0, line);
        return line.length;
      }, index + text.length);
    }
  }, {
    key: 'insertBefore',
    value: function insertBefore(blot, ref) {
      var head = this.children.head;
      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertBefore', this).call(this, blot, ref);
      if (head instanceof _break2.default) {
        head.remove();
      }
      this.cache = {};
    }
  }, {
    key: 'length',
    value: function length() {
      if (this.cache.length == null) {
        this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'length', this).call(this) + NEWLINE_LENGTH;
      }
      return this.cache.length;
    }
  }, {
    key: 'moveChildren',
    value: function moveChildren(target, ref) {
      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'moveChildren', this).call(this, target, ref);
      this.cache = {};
    }
  }, {
    key: 'optimize',
    value: function optimize(context) {
      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'optimize', this).call(this, context);
      this.cache = {};
    }
  }, {
    key: 'path',
    value: function path(index) {
      return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'path', this).call(this, index, true);
    }
  }, {
    key: 'removeChild',
    value: function removeChild(child) {
      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'removeChild', this).call(this, child);
      this.cache = {};
    }
  }, {
    key: 'split',
    value: function split(index) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {
        var clone = this.clone();
        if (index === 0) {
          this.parent.insertBefore(clone, this);
          return this;
        } else {
          this.parent.insertBefore(clone, this.next);
          return clone;
        }
      } else {
        var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'split', this).call(this, index, force);
        this.cache = {};
        return next;
      }
    }
  }]);

  return Block;
}(_parchment2.default.Block);

Block.blotName = 'block';
Block.tagName = 'P';
Block.defaultChild = 'break';
Block.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];

function bubbleFormats(blot) {
  var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (blot == null) return formats;
  if (typeof blot.formats === 'function') {
    formats = (0, _extend2.default)(formats, blot.formats());
  }
  if (blot.parent == null || blot.parent.blotName == 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {
    return formats;
  }
  return bubbleFormats(blot.parent, formats);
}

exports.bubbleFormats = bubbleFormats;
exports.BlockEmbed = BlockEmbed;
exports.default = Block;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.overload = exports.expandConfig = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(50);

var _quillDelta = __webpack_require__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _editor = __webpack_require__(14);

var _editor2 = _interopRequireDefault(_editor);

var _emitter3 = __webpack_require__(8);

var _emitter4 = _interopRequireDefault(_emitter3);

var _module = __webpack_require__(9);

var _module2 = _interopRequireDefault(_module);

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _selection = __webpack_require__(15);

var _selection2 = _interopRequireDefault(_selection);

var _extend = __webpack_require__(3);

var _extend2 = _interopRequireDefault(_extend);

var _logger = __webpack_require__(10);

var _logger2 = _interopRequireDefault(_logger);

var _theme = __webpack_require__(34);

var _theme2 = _interopRequireDefault(_theme);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = (0, _logger2.default)('quill');

var Quill = function () {
  _createClass(Quill, null, [{
    key: 'debug',
    value: function debug(limit) {
      if (limit === true) {
        limit = 'log';
      }
      _logger2.default.level(limit);
    }
  }, {
    key: 'find',
    value: function find(node) {
      return node.__quill || _parchment2.default.find(node);
    }
  }, {
    key: 'import',
    value: function _import(name) {
      if (this.imports[name] == null) {
        debug.error('Cannot import ' + name + '. Are you sure it was registered?');
      }
      return this.imports[name];
    }
  }, {
    key: 'register',
    value: function register(path, target) {
      var _this = this;

      var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (typeof path !== 'string') {
        var name = path.attrName || path.blotName;
        if (typeof name === 'string') {
          // register(Blot | Attributor, overwrite)
          this.register('formats/' + name, path, target);
        } else {
          Object.keys(path).forEach(function (key) {
            _this.register(key, path[key], target);
          });
        }
      } else {
        if (this.imports[path] != null && !overwrite) {
          debug.warn('Overwriting ' + path + ' with', target);
        }
        this.imports[path] = target;
        if ((path.startsWith('blots/') || path.startsWith('formats/')) && target.blotName !== 'abstract') {
          _parchment2.default.register(target);
        } else if (path.startsWith('modules') && typeof target.register === 'function') {
          target.register();
        }
      }
    }
  }]);

  function Quill(container) {
    var _this2 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Quill);

    this.options = expandConfig(container, options);
    this.container = this.options.container;
    if (this.container == null) {
      return debug.error('Invalid Quill container', container);
    }
    if (this.options.debug) {
      Quill.debug(this.options.debug);
    }
    var html = this.container.innerHTML.trim();
    this.container.classList.add('ql-container');
    this.container.innerHTML = '';
    this.container.__quill = this;
    this.root = this.addContainer('ql-editor');
    this.root.classList.add('ql-blank');
    this.root.setAttribute('data-gramm', false);
    this.scrollingContainer = this.options.scrollingContainer || this.root;
    this.emitter = new _emitter4.default();
    this.scroll = _parchment2.default.create(this.root, {
      emitter: this.emitter,
      whitelist: this.options.formats
    });
    this.editor = new _editor2.default(this.scroll);
    this.selection = new _selection2.default(this.scroll, this.emitter);
    this.theme = new this.options.theme(this, this.options);
    this.keyboard = this.theme.addModule('keyboard');
    this.clipboard = this.theme.addModule('clipboard');
    this.history = this.theme.addModule('history');
    this.theme.init();
    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type) {
      if (type === _emitter4.default.events.TEXT_CHANGE) {
        _this2.root.classList.toggle('ql-blank', _this2.editor.isBlank());
      }
    });
    this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function (source, mutations) {
      var range = _this2.selection.lastRange;
      var index = range && range.length === 0 ? range.index : undefined;
      modify.call(_this2, function () {
        return _this2.editor.update(null, mutations, index);
      }, source);
    });
    var contents = this.clipboard.convert('<div class=\'ql-editor\' style="white-space: normal;">' + html + '<p><br></p></div>');
    this.setContents(contents);
    this.history.clear();
    if (this.options.placeholder) {
      this.root.setAttribute('data-placeholder', this.options.placeholder);
    }
    if (this.options.readOnly) {
      this.disable();
    }
  }

  _createClass(Quill, [{
    key: 'addContainer',
    value: function addContainer(container) {
      var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (typeof container === 'string') {
        var className = container;
        container = document.createElement('div');
        container.classList.add(className);
      }
      this.container.insertBefore(container, refNode);
      return container;
    }
  }, {
    key: 'blur',
    value: function blur() {
      this.selection.setRange(null);
    }
  }, {
    key: 'deleteText',
    value: function deleteText(index, length, source) {
      var _this3 = this;

      var _overload = overload(index, length, source);

      var _overload2 = _slicedToArray(_overload, 4);

      index = _overload2[0];
      length = _overload2[1];
      source = _overload2[3];

      return modify.call(this, function () {
        return _this3.editor.deleteText(index, length);
      }, source, index, -1 * length);
    }
  }, {
    key: 'disable',
    value: function disable() {
      this.enable(false);
    }
  }, {
    key: 'enable',
    value: function enable() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.scroll.enable(enabled);
      this.container.classList.toggle('ql-disabled', !enabled);
    }
  }, {
    key: 'focus',
    value: function focus() {
      var scrollTop = this.scrollingContainer.scrollTop;
      this.selection.focus();
      this.scrollingContainer.scrollTop = scrollTop;
      this.scrollIntoView();
    }
  }, {
    key: 'format',
    value: function format(name, value) {
      var _this4 = this;

      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;

      return modify.call(this, function () {
        var range = _this4.getSelection(true);
        var change = new _quillDelta2.default();
        if (range == null) {
          return change;
        } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
          change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));
        } else if (range.length === 0) {
          _this4.selection.format(name, value);
          return change;
        } else {
          change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));
        }
        _this4.setSelection(range, _emitter4.default.sources.SILENT);
        return change;
      }, source);
    }
  }, {
    key: 'formatLine',
    value: function formatLine(index, length, name, value, source) {
      var _this5 = this;

      var formats = void 0;

      var _overload3 = overload(index, length, name, value, source);

      var _overload4 = _slicedToArray(_overload3, 4);

      index = _overload4[0];
      length = _overload4[1];
      formats = _overload4[2];
      source = _overload4[3];

      return modify.call(this, function () {
        return _this5.editor.formatLine(index, length, formats);
      }, source, index, 0);
    }
  }, {
    key: 'formatText',
    value: function formatText(index, length, name, value, source) {
      var _this6 = this;

      var formats = void 0;

      var _overload5 = overload(index, length, name, value, source);

      var _overload6 = _slicedToArray(_overload5, 4);

      index = _overload6[0];
      length = _overload6[1];
      formats = _overload6[2];
      source = _overload6[3];

      return modify.call(this, function () {
        return _this6.editor.formatText(index, length, formats);
      }, source, index, 0);
    }
  }, {
    key: 'getBounds',
    value: function getBounds(index) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var bounds = void 0;
      if (typeof index === 'number') {
        bounds = this.selection.getBounds(index, length);
      } else {
        bounds = this.selection.getBounds(index.index, index.length);
      }
      var containerBounds = this.container.getBoundingClientRect();
      return {
        bottom: bounds.bottom - containerBounds.top,
        height: bounds.height,
        left: bounds.left - containerBounds.left,
        right: bounds.right - containerBounds.left,
        top: bounds.top - containerBounds.top,
        width: bounds.width
      };
    }
  }, {
    key: 'getContents',
    value: function getContents() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;

      var _overload7 = overload(index, length);

      var _overload8 = _slicedToArray(_overload7, 2);

      index = _overload8[0];
      length = _overload8[1];

      return this.editor.getContents(index, length);
    }
  }, {
    key: 'getFormat',
    value: function getFormat() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (typeof index === 'number') {
        return this.editor.getFormat(index, length);
      } else {
        return this.editor.getFormat(index.index, index.length);
      }
    }
  }, {
    key: 'getIndex',
    value: function getIndex(blot) {
      return blot.offset(this.scroll);
    }
  }, {
    key: 'getLength',
    value: function getLength() {
      return this.scroll.length();
    }
  }, {
    key: 'getLeaf',
    value: function getLeaf(index) {
      return this.scroll.leaf(index);
    }
  }, {
    key: 'getLine',
    value: function getLine(index) {
      return this.scroll.line(index);
    }
  }, {
    key: 'getLines',
    value: function getLines() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;

      if (typeof index !== 'number') {
        return this.scroll.lines(index.index, index.length);
      } else {
        return this.scroll.lines(index, length);
      }
    }
  }, {
    key: 'getModule',
    value: function getModule(name) {
      return this.theme.modules[name];
    }
  }, {
    key: 'getSelection',
    value: function getSelection() {
      var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (focus) this.focus();
      this.update(); // Make sure we access getRange with editor in consistent state
      return this.selection.getRange()[0];
    }
  }, {
    key: 'getText',
    value: function getText() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;

      var _overload9 = overload(index, length);

      var _overload10 = _slicedToArray(_overload9, 2);

      index = _overload10[0];
      length = _overload10[1];

      return this.editor.getText(index, length);
    }
  }, {
    key: 'hasFocus',
    value: function hasFocus() {
      return this.selection.hasFocus();
    }
  }, {
    key: 'insertEmbed',
    value: function insertEmbed(index, embed, value) {
      var _this7 = this;

      var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;

      return modify.call(this, function () {
        return _this7.editor.insertEmbed(index, embed, value);
      }, source, index);
    }
  }, {
    key: 'insertText',
    value: function insertText(index, text, name, value, source) {
      var _this8 = this;

      var formats = void 0;

      var _overload11 = overload(index, 0, name, value, source);

      var _overload12 = _slicedToArray(_overload11, 4);

      index = _overload12[0];
      formats = _overload12[2];
      source = _overload12[3];

      return modify.call(this, function () {
        return _this8.editor.insertText(index, text, formats);
      }, source, index, text.length);
    }
  }, {
    key: 'isEnabled',
    value: function isEnabled() {
      return !this.container.classList.contains('ql-disabled');
    }
  }, {
    key: 'off',
    value: function off() {
      return this.emitter.off.apply(this.emitter, arguments);
    }
  }, {
    key: 'on',
    value: function on() {
      return this.emitter.on.apply(this.emitter, arguments);
    }
  }, {
    key: 'once',
    value: function once() {
      return this.emitter.once.apply(this.emitter, arguments);
    }
  }, {
    key: 'pasteHTML',
    value: function pasteHTML(index, html, source) {
      this.clipboard.dangerouslyPasteHTML(index, html, source);
    }
  }, {
    key: 'removeFormat',
    value: function removeFormat(index, length, source) {
      var _this9 = this;

      var _overload13 = overload(index, length, source);

      var _overload14 = _slicedToArray(_overload13, 4);

      index = _overload14[0];
      length = _overload14[1];
      source = _overload14[3];

      return modify.call(this, function () {
        return _this9.editor.removeFormat(index, length);
      }, source, index);
    }
  }, {
    key: 'scrollIntoView',
    value: function scrollIntoView() {
      this.selection.scrollIntoView(this.scrollingContainer);
    }
  }, {
    key: 'setContents',
    value: function setContents(delta) {
      var _this10 = this;

      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;

      return modify.call(this, function () {
        delta = new _quillDelta2.default(delta);
        var length = _this10.getLength();
        var deleted = _this10.editor.deleteText(0, length);
        var applied = _this10.editor.applyDelta(delta);
        var lastOp = applied.ops[applied.ops.length - 1];
        if (lastOp != null && typeof lastOp.insert === 'string' && lastOp.insert[lastOp.insert.length - 1] === '\n') {
          _this10.editor.deleteText(_this10.getLength() - 1, 1);
          applied.delete(1);
        }
        var ret = deleted.compose(applied);
        return ret;
      }, source);
    }
  }, {
    key: 'setSelection',
    value: function setSelection(index, length, source) {
      if (index == null) {
        this.selection.setRange(null, length || Quill.sources.API);
      } else {
        var _overload15 = overload(index, length, source);

        var _overload16 = _slicedToArray(_overload15, 4);

        index = _overload16[0];
        length = _overload16[1];
        source = _overload16[3];

        this.selection.setRange(new _selection.Range(index, length), source);
        if (source !== _emitter4.default.sources.SILENT) {
          this.selection.scrollIntoView(this.scrollingContainer);
        }
      }
    }
  }, {
    key: 'setText',
    value: function setText(text) {
      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;

      var delta = new _quillDelta2.default().insert(text);
      return this.setContents(delta, source);
    }
  }, {
    key: 'update',
    value: function update() {
      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;

      var change = this.scroll.update(source); // Will update selection before selection.update() does if text changes
      this.selection.update(source);
      return change;
    }
  }, {
    key: 'updateContents',
    value: function updateContents(delta) {
      var _this11 = this;

      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;

      return modify.call(this, function () {
        delta = new _quillDelta2.default(delta);
        return _this11.editor.applyDelta(delta, source);
      }, source, true);
    }
  }]);

  return Quill;
}();

Quill.DEFAULTS = {
  bounds: null,
  formats: null,
  modules: {},
  placeholder: '',
  readOnly: false,
  scrollingContainer: null,
  strict: true,
  theme: 'default'
};
Quill.events = _emitter4.default.events;
Quill.sources = _emitter4.default.sources;
// eslint-disable-next-line no-undef
Quill.version =  "1.3.7";

Quill.imports = {
  'delta': _quillDelta2.default,
  'parchment': _parchment2.default,
  'core/module': _module2.default,
  'core/theme': _theme2.default
};

function expandConfig(container, userConfig) {
  userConfig = (0, _extend2.default)(true, {
    container: container,
    modules: {
      clipboard: true,
      keyboard: true,
      history: true
    }
  }, userConfig);
  if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {
    userConfig.theme = _theme2.default;
  } else {
    userConfig.theme = Quill.import('themes/' + userConfig.theme);
    if (userConfig.theme == null) {
      throw new Error('Invalid theme ' + userConfig.theme + '. Did you register it?');
    }
  }
  var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);
  [themeConfig, userConfig].forEach(function (config) {
    config.modules = config.modules || {};
    Object.keys(config.modules).forEach(function (module) {
      if (config.modules[module] === true) {
        config.modules[module] = {};
      }
    });
  });
  var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
  var moduleConfig = moduleNames.reduce(function (config, name) {
    var moduleClass = Quill.import('modules/' + name);
    if (moduleClass == null) {
      debug.error('Cannot load ' + name + ' module. Are you sure you registered it?');
    } else {
      config[name] = moduleClass.DEFAULTS || {};
    }
    return config;
  }, {});
  // Special case toolbar shorthand
  if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
    userConfig.modules.toolbar = {
      container: userConfig.modules.toolbar
    };
  }
  userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, { modules: moduleConfig }, themeConfig, userConfig);
  ['bounds', 'container', 'scrollingContainer'].forEach(function (key) {
    if (typeof userConfig[key] === 'string') {
      userConfig[key] = document.querySelector(userConfig[key]);
    }
  });
  userConfig.modules = Object.keys(userConfig.modules).reduce(function (config, name) {
    if (userConfig.modules[name]) {
      config[name] = userConfig.modules[name];
    }
    return config;
  }, {});
  return userConfig;
}

// Handle selection preservation and TEXT_CHANGE emission
// common to modification APIs
function modify(modifier, source, index, shift) {
  if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {
    return new _quillDelta2.default();
  }
  var range = index == null ? null : this.getSelection();
  var oldDelta = this.editor.delta;
  var change = modifier();
  if (range != null) {
    if (index === true) index = range.index;
    if (shift == null) {
      range = shiftRange(range, change, source);
    } else if (shift !== 0) {
      range = shiftRange(range, index, shift, source);
    }
    this.setSelection(range, _emitter4.default.sources.SILENT);
  }
  if (change.length() > 0) {
    var _emitter;

    var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];
    (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
    if (source !== _emitter4.default.sources.SILENT) {
      var _emitter2;

      (_emitter2 = this.emitter).emit.apply(_emitter2, args);
    }
  }
  return change;
}

function overload(index, length, name, value, source) {
  var formats = {};
  if (typeof index.index === 'number' && typeof index.length === 'number') {
    // Allow for throwaway end (used by insertText/insertEmbed)
    if (typeof length !== 'number') {
      source = value, value = name, name = length, length = index.length, index = index.index;
    } else {
      length = index.length, index = index.index;
    }
  } else if (typeof length !== 'number') {
    source = value, value = name, name = length, length = 0;
  }
  // Handle format being object, two format name/value strings or excluded
  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
    formats = name;
    source = value;
  } else if (typeof name === 'string') {
    if (value != null) {
      formats[name] = value;
    } else {
      source = name;
    }
  }
  // Handle optional source
  source = source || _emitter4.default.sources.API;
  return [index, length, formats, source];
}

function shiftRange(range, index, length, source) {
  if (range == null) return null;
  var start = void 0,
      end = void 0;
  if (index instanceof _quillDelta2.default) {
    var _map = [range.index, range.index + range.length].map(function (pos) {
      return index.transformPosition(pos, source !== _emitter4.default.sources.USER);
    });

    var _map2 = _slicedToArray(_map, 2);

    start = _map2[0];
    end = _map2[1];
  } else {
    var _map3 = [range.index, range.index + range.length].map(function (pos) {
      if (pos < index || pos === index && source === _emitter4.default.sources.USER) return pos;
      if (length >= 0) {
        return pos + length;
      } else {
        return Math.max(index, pos + length);
      }
    });

    var _map4 = _slicedToArray(_map3, 2);

    start = _map4[0];
    end = _map4[1];
  }
  return new _selection.Range(start, end - start);
}

exports.expandConfig = expandConfig;
exports.overload = overload;
exports.default = Quill;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _text = __webpack_require__(7);

var _text2 = _interopRequireDefault(_text);

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Inline = function (_Parchment$Inline) {
  _inherits(Inline, _Parchment$Inline);

  function Inline() {
    _classCallCheck(this, Inline);

    return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));
  }

  _createClass(Inline, [{
    key: 'formatAt',
    value: function formatAt(index, length, name, value) {
      if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {
        var blot = this.isolate(index, length);
        if (value) {
          blot.wrap(name, value);
        }
      } else {
        _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'formatAt', this).call(this, index, length, name, value);
      }
    }
  }, {
    key: 'optimize',
    value: function optimize(context) {
      _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'optimize', this).call(this, context);
      if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
        var parent = this.parent.isolate(this.offset(), this.length());
        this.moveChildren(parent);
        parent.wrap(this);
      }
    }
  }], [{
    key: 'compare',
    value: function compare(self, other) {
      var selfIndex = Inline.order.indexOf(self);
      var otherIndex = Inline.order.indexOf(other);
      if (selfIndex >= 0 || otherIndex >= 0) {
        return selfIndex - otherIndex;
      } else if (self === other) {
        return 0;
      } else if (self < other) {
        return -1;
      } else {
        return 1;
      }
    }
  }]);

  return Inline;
}(_parchment2.default.Inline);

Inline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];
// Lower index means deeper in the DOM tree, since not found (-1) is for embeds
Inline.order = ['cursor', 'inline', // Must be lower
'underline', 'strike', 'italic', 'bold', 'script', 'link', 'code' // Must be higher
];

exports.default = Inline;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TextBlot = function (_Parchment$Text) {
  _inherits(TextBlot, _Parchment$Text);

  function TextBlot() {
    _classCallCheck(this, TextBlot);

    return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));
  }

  return TextBlot;
}(_parchment2.default.Text);

exports.default = TextBlot;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _eventemitter = __webpack_require__(54);

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _logger = __webpack_require__(10);

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _logger2.default)('quill:events');

var EVENTS = ['selectionchange', 'mousedown', 'mouseup', 'click'];

EVENTS.forEach(function (eventName) {
  document.addEventListener(eventName, function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    [].slice.call(document.querySelectorAll('.ql-container')).forEach(function (node) {
      // TODO use WeakMap
      if (node.__quill && node.__quill.emitter) {
        var _node$__quill$emitter;

        (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
      }
    });
  });
});

var Emitter = function (_EventEmitter) {
  _inherits(Emitter, _EventEmitter);

  function Emitter() {
    _classCallCheck(this, Emitter);

    var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));

    _this.listeners = {};
    _this.on('error', debug.error);
    return _this;
  }

  _createClass(Emitter, [{
    key: 'emit',
    value: function emit() {
      debug.log.apply(debug, arguments);
      _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), 'emit', this).apply(this, arguments);
    }
  }, {
    key: 'handleDOM',
    value: function handleDOM(event) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      (this.listeners[event.type] || []).forEach(function (_ref) {
        var node = _ref.node,
            handler = _ref.handler;

        if (event.target === node || node.contains(event.target)) {
          handler.apply(undefined, [event].concat(args));
        }
      });
    }
  }, {
    key: 'listenDOM',
    value: function listenDOM(eventName, node, handler) {
      if (!this.listeners[eventName]) {
        this.listeners[eventName] = [];
      }
      this.listeners[eventName].push({ node: node, handler: handler });
    }
  }]);

  return Emitter;
}(_eventemitter2.default);

Emitter.events = {
  EDITOR_CHANGE: 'editor-change',
  SCROLL_BEFORE_UPDATE: 'scroll-before-update',
  SCROLL_OPTIMIZE: 'scroll-optimize',
  SCROLL_UPDATE: 'scroll-update',
  SELECTION_CHANGE: 'selection-change',
  TEXT_CHANGE: 'text-change'
};
Emitter.sources = {
  API: 'api',
  SILENT: 'silent',
  USER: 'user'
};

exports.default = Emitter;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Module = function Module(quill) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  _classCallCheck(this, Module);

  this.quill = quill;
  this.options = options;
};

Module.DEFAULTS = {};

exports.default = Module;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
var levels = ['error', 'warn', 'log', 'info'];
var level = 'warn';

function debug(method) {
  if (levels.indexOf(method) <= levels.indexOf(level)) {
    var _console;

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (_console = console)[method].apply(_console, args); // eslint-disable-line no-console
  }
}

function namespace(ns) {
  return levels.reduce(function (logger, method) {
    logger[method] = debug.bind(console, method, ns);
    return logger;
  }, {});
}

debug.level = namespace.level = function (newLevel) {
  level = newLevel;
};

exports.default = namespace;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var pSlice = Array.prototype.slice;
var objectKeys = __webpack_require__(52);
var isArguments = __webpack_require__(53);

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
};

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var Registry = __webpack_require__(1);
var Attributor = /** @class */ (function () {
    function Attributor(attrName, keyName, options) {
        if (options === void 0) { options = {}; }
        this.attrName = attrName;
        this.keyName = keyName;
        var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;
        if (options.scope != null) {
            // Ignore type bits, force attribute bit
            this.scope = (options.scope & Registry.Scope.LEVEL) | attributeBit;
        }
        else {
            this.scope = Registry.Scope.ATTRIBUTE;
        }
        if (options.whitelist != null)
            this.whitelist = options.whitelist;
    }
    Attributor.keys = function (node) {
        return [].map.call(node.attributes, function (item) {
            return item.name;
        });
    };
    Attributor.prototype.add = function (node, value) {
        if (!this.canAdd(node, value))
            return false;
        node.setAttribute(this.keyName, value);
        return true;
    };
    Attributor.prototype.canAdd = function (node, value) {
        var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
        if (match == null)
            return false;
        if (this.whitelist == null)
            return true;
        if (typeof value === 'string') {
            return this.whitelist.indexOf(value.replace(/["']/g, '')) > -1;
        }
        else {
            return this.whitelist.indexOf(value) > -1;
        }
    };
    Attributor.prototype.remove = function (node) {
        node.removeAttribute(this.keyName);
    };
    Attributor.prototype.value = function (node) {
        var value = node.getAttribute(this.keyName);
        if (this.canAdd(node, value) && value) {
            return value;
        }
        return '';
    };
    return Attributor;
}());
exports.default = Attributor;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Code = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _quillDelta = __webpack_require__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _block = __webpack_require__(4);

var _block2 = _interopRequireDefault(_block);

var _inline = __webpack_require__(6);

var _inline2 = _interopRequireDefault(_inline);

var _text = __webpack_require__(7);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Code = function (_Inline) {
  _inherits(Code, _Inline);

  function Code() {
    _classCallCheck(this, Code);

    return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));
  }

  return Code;
}(_inline2.default);

Code.blotName = 'code';
Code.tagName = 'CODE';

var CodeBlock = function (_Block) {
  _inherits(CodeBlock, _Block);

  function CodeBlock() {
    _classCallCheck(this, CodeBlock);

    return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));
  }

  _createClass(CodeBlock, [{
    key: 'delta',
    value: function delta() {
      var _this3 = this;

      var text = this.domNode.textContent;
      if (text.endsWith('\n')) {
        // Should always be true
        text = text.slice(0, -1);
      }
      return text.split('\n').reduce(function (delta, frag) {
        return delta.insert(frag).insert('\n', _this3.formats());
      }, new _quillDelta2.default());
    }
  }, {
    key: 'format',
    value: function format(name, value) {
      if (name === this.statics.blotName && value) return;

      var _descendant = this.descendant(_text2.default, this.length() - 1),
          _descendant2 = _slicedToArray(_descendant, 1),
          text = _descendant2[0];

      if (text != null) {
        text.deleteAt(text.length() - 1, 1);
      }
      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'format', this).call(this, name, value);
    }
  }, {
    key: 'formatAt',
    value: function formatAt(index, length, name, value) {
      if (length === 0) return;
      if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {
        return;
      }
      var nextNewline = this.newlineIndex(index);
      if (nextNewline < 0 || nextNewline >= index + length) return;
      var prevNewline = this.newlineIndex(index, true) + 1;
      var isolateLength = nextNewline - prevNewline + 1;
      var blot = this.isolate(prevNewline, isolateLength);
      var next = blot.next;
      blot.format(name, value);
      if (next instanceof CodeBlock) {
        next.formatAt(0, index - prevNewline + length - isolateLength, name, value);
      }
    }
  }, {
    key: 'insertAt',
    value: function insertAt(index, value, def) {
      if (def != null) return;

      var _descendant3 = this.descendant(_text2.default, index),
          _descendant4 = _slicedToArray(_descendant3, 2),
          text = _descendant4[0],
          offset = _descendant4[1];

      text.insertAt(offset, value);
    }
  }, {
    key: 'length',
    value: function length() {
      var length = this.domNode.textContent.length;
      if (!this.domNode.textContent.endsWith('\n')) {
        return length + 1;
      }
      return length;
    }
  }, {
    key: 'newlineIndex',
    value: function newlineIndex(searchIndex) {
      var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!reverse) {
        var offset = this.domNode.textContent.slice(searchIndex).indexOf('\n');
        return offset > -1 ? searchIndex + offset : -1;
      } else {
        return this.domNode.textContent.slice(0, searchIndex).lastIndexOf('\n');
      }
    }
  }, {
    key: 'optimize',
    value: function optimize(context) {
      if (!this.domNode.textContent.endsWith('\n')) {
        this.appendChild(_parchment2.default.create('text', '\n'));
      }
      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'optimize', this).call(this, context);
      var next = this.next;
      if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {
        next.optimize(context);
        next.moveChildren(this);
        next.remove();
      }
    }
  }, {
    key: 'replace',
    value: function replace(target) {
      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'replace', this).call(this, target);
      [].slice.call(this.domNode.querySelectorAll('*')).forEach(function (node) {
        var blot = _parchment2.default.find(node);
        if (blot == null) {
          node.parentNode.removeChild(node);
        } else if (blot instanceof _parchment2.default.Embed) {
          blot.remove();
        } else {
          blot.unwrap();
        }
      });
    }
  }], [{
    key: 'create',
    value: function create(value) {
      var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), 'create', this).call(this, value);
      domNode.setAttribute('spellcheck', false);
      return domNode;
    }
  }, {
    key: 'formats',
    value: function formats() {
      return true;
    }
  }]);

  return CodeBlock;
}(_block2.default);

CodeBlock.blotName = 'code-block';
CodeBlock.tagName = 'PRE';
CodeBlock.TAB = '  ';

exports.Code = Code;
exports.default = CodeBlock;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _quillDelta = __webpack_require__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _op = __webpack_require__(20);

var _op2 = _interopRequireDefault(_op);

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _code = __webpack_require__(13);

var _code2 = _interopRequireDefault(_code);

var _cursor = __webpack_require__(24);

var _cursor2 = _interopRequireDefault(_cursor);

var _block = __webpack_require__(4);

var _block2 = _interopRequireDefault(_block);

var _break = __webpack_require__(16);

var _break2 = _interopRequireDefault(_break);

var _clone = __webpack_require__(21);

var _clone2 = _interopRequireDefault(_clone);

var _deepEqual = __webpack_require__(11);

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _extend = __webpack_require__(3);

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ASCII = /^[ -~]*$/;

var Editor = function () {
  function Editor(scroll) {
    _classCallCheck(this, Editor);

    this.scroll = scroll;
    this.delta = this.getDelta();
  }

  _createClass(Editor, [{
    key: 'applyDelta',
    value: function applyDelta(delta) {
      var _this = this;

      var consumeNextNewline = false;
      this.scroll.update();
      var scrollLength = this.scroll.length();
      this.scroll.batchStart();
      delta = normalizeDelta(delta);
      delta.reduce(function (index, op) {
        var length = op.retain || op.delete || op.insert.length || 1;
        var attributes = op.attributes || {};
        if (op.insert != null) {
          if (typeof op.insert === 'string') {
            var text = op.insert;
            if (text.endsWith('\n') && consumeNextNewline) {
              consumeNextNewline = false;
              text = text.slice(0, -1);
            }
            if (index >= scrollLength && !text.endsWith('\n')) {
              consumeNextNewline = true;
            }
            _this.scroll.insertAt(index, text);

            var _scroll$line = _this.scroll.line(index),
                _scroll$line2 = _slicedToArray(_scroll$line, 2),
                line = _scroll$line2[0],
                offset = _scroll$line2[1];

            var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));
            if (line instanceof _block2.default) {
              var _line$descendant = line.descendant(_parchment2.default.Leaf, offset),
                  _line$descendant2 = _slicedToArray(_line$descendant, 1),
                  leaf = _line$descendant2[0];

              formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));
            }
            attributes = _op2.default.attributes.diff(formats, attributes) || {};
          } else if (_typeof(op.insert) === 'object') {
            var key = Object.keys(op.insert)[0]; // There should only be one key
            if (key == null) return index;
            _this.scroll.insertAt(index, key, op.insert[key]);
          }
          scrollLength += length;
        }
        Object.keys(attributes).forEach(function (name) {
          _this.scroll.formatAt(index, length, name, attributes[name]);
        });
        return index + length;
      }, 0);
      delta.reduce(function (index, op) {
        if (typeof op.delete === 'number') {
          _this.scroll.deleteAt(index, op.delete);
          return index;
        }
        return index + (op.retain || op.insert.length || 1);
      }, 0);
      this.scroll.batchEnd();
      return this.update(delta);
    }
  }, {
    key: 'deleteText',
    value: function deleteText(index, length) {
      this.scroll.deleteAt(index, length);
      return this.update(new _quillDelta2.default().retain(index).delete(length));
    }
  }, {
    key: 'formatLine',
    value: function formatLine(index, length) {
      var _this2 = this;

      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      this.scroll.update();
      Object.keys(formats).forEach(function (format) {
        if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format]) return;
        var lines = _this2.scroll.lines(index, Math.max(length, 1));
        var lengthRemaining = length;
        lines.forEach(function (line) {
          var lineLength = line.length();
          if (!(line instanceof _code2.default)) {
            line.format(format, formats[format]);
          } else {
            var codeIndex = index - line.offset(_this2.scroll);
            var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
            line.formatAt(codeIndex, codeLength, format, formats[format]);
          }
          lengthRemaining -= lineLength;
        });
      });
      this.scroll.optimize();
      return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
    }
  }, {
    key: 'formatText',
    value: function formatText(index, length) {
      var _this3 = this;

      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      Object.keys(formats).forEach(function (format) {
        _this3.scroll.formatAt(index, length, format, formats[format]);
      });
      return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
    }
  }, {
    key: 'getContents',
    value: function getContents(index, length) {
      return this.delta.slice(index, index + length);
    }
  }, {
    key: 'getDelta',
    value: function getDelta() {
      return this.scroll.lines().reduce(function (delta, line) {
        return delta.concat(line.delta());
      }, new _quillDelta2.default());
    }
  }, {
    key: 'getFormat',
    value: function getFormat(index) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var lines = [],
          leaves = [];
      if (length === 0) {
        this.scroll.path(index).forEach(function (path) {
          var _path = _slicedToArray(path, 1),
              blot = _path[0];

          if (blot instanceof _block2.default) {
            lines.push(blot);
          } else if (blot instanceof _parchment2.default.Leaf) {
            leaves.push(blot);
          }
        });
      } else {
        lines = this.scroll.lines(index, length);
        leaves = this.scroll.descendants(_parchment2.default.Leaf, index, length);
      }
      var formatsArr = [lines, leaves].map(function (blots) {
        if (blots.length === 0) return {};
        var formats = (0, _block.bubbleFormats)(blots.shift());
        while (Object.keys(formats).length > 0) {
          var blot = blots.shift();
          if (blot == null) return formats;
          formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
        }
        return formats;
      });
      return _extend2.default.apply(_extend2.default, formatsArr);
    }
  }, {
    key: 'getText',
    value: function getText(index, length) {
      return this.getContents(index, length).filter(function (op) {
        return typeof op.insert === 'string';
      }).map(function (op) {
        return op.insert;
      }).join('');
    }
  }, {
    key: 'insertEmbed',
    value: function insertEmbed(index, embed, value) {
      this.scroll.insertAt(index, embed, value);
      return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({}, embed, value)));
    }
  }, {
    key: 'insertText',
    value: function insertText(index, text) {
      var _this4 = this;

      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      this.scroll.insertAt(index, text);
      Object.keys(formats).forEach(function (format) {
        _this4.scroll.formatAt(index, text.length, format, formats[format]);
      });
      return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));
    }
  }, {
    key: 'isBlank',
    value: function isBlank() {
      if (this.scroll.children.length == 0) return true;
      if (this.scroll.children.length > 1) return false;
      var block = this.scroll.children.head;
      if (block.statics.blotName !== _block2.default.blotName) return false;
      if (block.children.length > 1) return false;
      return block.children.head instanceof _break2.default;
    }
  }, {
    key: 'removeFormat',
    value: function removeFormat(index, length) {
      var text = this.getText(index, length);

      var _scroll$line3 = this.scroll.line(index + length),
          _scroll$line4 = _slicedToArray(_scroll$line3, 2),
          line = _scroll$line4[0],
          offset = _scroll$line4[1];

      var suffixLength = 0,
          suffix = new _quillDelta2.default();
      if (line != null) {
        if (!(line instanceof _code2.default)) {
          suffixLength = line.length() - offset;
        } else {
          suffixLength = line.newlineIndex(offset) - offset + 1;
        }
        suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\n');
      }
      var contents = this.getContents(index, length + suffixLength);
      var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));
      var delta = new _quillDelta2.default().retain(index).concat(diff);
      return this.applyDelta(delta);
    }
  }, {
    key: 'update',
    value: function update(change) {
      var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      var oldDelta = this.delta;
      if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {
        // Optimization for character changes
        var textBlot = _parchment2.default.find(mutations[0].target);
        var formats = (0, _block.bubbleFormats)(textBlot);
        var index = textBlot.offset(this.scroll);
        var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, '');
        var oldText = new _quillDelta2.default().insert(oldValue);
        var newText = new _quillDelta2.default().insert(textBlot.value());
        var diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, cursorIndex));
        change = diffDelta.reduce(function (delta, op) {
          if (op.insert) {
            return delta.insert(op.insert, formats);
          } else {
            return delta.push(op);
          }
        }, new _quillDelta2.default());
        this.delta = oldDelta.compose(change);
      } else {
        this.delta = this.getDelta();
        if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {
          change = oldDelta.diff(this.delta, cursorIndex);
        }
      }
      return change;
    }
  }]);

  return Editor;
}();

function combineFormats(formats, combined) {
  return Object.keys(combined).reduce(function (merged, name) {
    if (formats[name] == null) return merged;
    if (combined[name] === formats[name]) {
      merged[name] = combined[name];
    } else if (Array.isArray(combined[name])) {
      if (combined[name].indexOf(formats[name]) < 0) {
        merged[name] = combined[name].concat([formats[name]]);
      }
    } else {
      merged[name] = [combined[name], formats[name]];
    }
    return merged;
  }, {});
}

function normalizeDelta(delta) {
  return delta.reduce(function (delta, op) {
    if (op.insert === 1) {
      var attributes = (0, _clone2.default)(op.attributes);
      delete attributes['image'];
      return delta.insert({ image: op.attributes.image }, attributes);
    }
    if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {
      op = (0, _clone2.default)(op);
      if (op.attributes.list) {
        op.attributes.list = 'ordered';
      } else {
        op.attributes.list = 'bullet';
        delete op.attributes.bullet;
      }
    }
    if (typeof op.insert === 'string') {
      var text = op.insert.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      return delta.insert(text, op.attributes);
    }
    return delta.push(op);
  }, new _quillDelta2.default());
}

exports.default = Editor;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Range = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _clone = __webpack_require__(21);

var _clone2 = _interopRequireDefault(_clone);

var _deepEqual = __webpack_require__(11);

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _emitter3 = __webpack_require__(8);

var _emitter4 = _interopRequireDefault(_emitter3);

var _logger = __webpack_require__(10);

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = (0, _logger2.default)('quill:selection');

var Range = function Range(index) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  _classCallCheck(this, Range);

  this.index = index;
  this.length = length;
};

var Selection = function () {
  function Selection(scroll, emitter) {
    var _this = this;

    _classCallCheck(this, Selection);

    this.emitter = emitter;
    this.scroll = scroll;
    this.composing = false;
    this.mouseDown = false;
    this.root = this.scroll.domNode;
    this.cursor = _parchment2.default.create('cursor', this);
    // savedRange is last non-null range
    this.lastRange = this.savedRange = new Range(0, 0);
    this.handleComposition();
    this.handleDragging();
    this.emitter.listenDOM('selectionchange', document, function () {
      if (!_this.mouseDown) {
        setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);
      }
    });
    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type, delta) {
      if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {
        _this.update(_emitter4.default.sources.SILENT);
      }
    });
    this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function () {
      if (!_this.hasFocus()) return;
      var native = _this.getNativeRange();
      if (native == null) return;
      if (native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle
      // TODO unclear if this has negative side effects
      _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function () {
        try {
          _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
        } catch (ignored) {}
      });
    });
    this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function (mutations, context) {
      if (context.range) {
        var _context$range = context.range,
            startNode = _context$range.startNode,
            startOffset = _context$range.startOffset,
            endNode = _context$range.endNode,
            endOffset = _context$range.endOffset;

        _this.setNativeRange(startNode, startOffset, endNode, endOffset);
      }
    });
    this.update(_emitter4.default.sources.SILENT);
  }

  _createClass(Selection, [{
    key: 'handleComposition',
    value: function handleComposition() {
      var _this2 = this;

      this.root.addEventListener('compositionstart', function () {
        _this2.composing = true;
      });
      this.root.addEventListener('compositionend', function () {
        _this2.composing = false;
        if (_this2.cursor.parent) {
          var range = _this2.cursor.restore();
          if (!range) return;
          setTimeout(function () {
            _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
          }, 1);
        }
      });
    }
  }, {
    key: 'handleDragging',
    value: function handleDragging() {
      var _this3 = this;

      this.emitter.listenDOM('mousedown', document.body, function () {
        _this3.mouseDown = true;
      });
      this.emitter.listenDOM('mouseup', document.body, function () {
        _this3.mouseDown = false;
        _this3.update(_emitter4.default.sources.USER);
      });
    }
  }, {
    key: 'focus',
    value: function focus() {
      if (this.hasFocus()) return;
      this.root.focus();
      this.setRange(this.savedRange);
    }
  }, {
    key: 'format',
    value: function format(_format, value) {
      if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;
      this.scroll.update();
      var nativeRange = this.getNativeRange();
      if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK)) return;
      if (nativeRange.start.node !== this.cursor.textNode) {
        var blot = _parchment2.default.find(nativeRange.start.node, false);
        if (blot == null) return;
        // TODO Give blot ability to not split
        if (blot instanceof _parchment2.default.Leaf) {
          var after = blot.split(nativeRange.start.offset);
          blot.parent.insertBefore(this.cursor, after);
        } else {
          blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen
        }
        this.cursor.attach();
      }
      this.cursor.format(_format, value);
      this.scroll.optimize();
      this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
      this.update();
    }
  }, {
    key: 'getBounds',
    value: function getBounds(index) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var scrollLength = this.scroll.length();
      index = Math.min(index, scrollLength - 1);
      length = Math.min(index + length, scrollLength - 1) - index;
      var node = void 0,
          _scroll$leaf = this.scroll.leaf(index),
          _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2),
          leaf = _scroll$leaf2[0],
          offset = _scroll$leaf2[1];
      if (leaf == null) return null;

      var _leaf$position = leaf.position(offset, true);

      var _leaf$position2 = _slicedToArray(_leaf$position, 2);

      node = _leaf$position2[0];
      offset = _leaf$position2[1];

      var range = document.createRange();
      if (length > 0) {
        range.setStart(node, offset);

        var _scroll$leaf3 = this.scroll.leaf(index + length);

        var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);

        leaf = _scroll$leaf4[0];
        offset = _scroll$leaf4[1];

        if (leaf == null) return null;

        var _leaf$position3 = leaf.position(offset, true);

        var _leaf$position4 = _slicedToArray(_leaf$position3, 2);

        node = _leaf$position4[0];
        offset = _leaf$position4[1];

        range.setEnd(node, offset);
        return range.getBoundingClientRect();
      } else {
        var side = 'left';
        var rect = void 0;
        if (node instanceof Text) {
          if (offset < node.data.length) {
            range.setStart(node, offset);
            range.setEnd(node, offset + 1);
          } else {
            range.setStart(node, offset - 1);
            range.setEnd(node, offset);
            side = 'right';
          }
          rect = range.getBoundingClientRect();
        } else {
          rect = leaf.domNode.getBoundingClientRect();
          if (offset > 0) side = 'right';
        }
        return {
          bottom: rect.top + rect.height,
          height: rect.height,
          left: rect[side],
          right: rect[side],
          top: rect.top,
          width: 0
        };
      }
    }
  }, {
    key: 'getNativeRange',
    value: function getNativeRange() {
      var selection = document.getSelection();
      if (selection == null || selection.rangeCount <= 0) return null;
      var nativeRange = selection.getRangeAt(0);
      if (nativeRange == null) return null;
      var range = this.normalizeNative(nativeRange);
      debug.info('getNativeRange', range);
      return range;
    }
  }, {
    key: 'getRange',
    value: function getRange() {
      var normalized = this.getNativeRange();
      if (normalized == null) return [null, null];
      var range = this.normalizedToRange(normalized);
      return [range, normalized];
    }
  }, {
    key: 'hasFocus',
    value: function hasFocus() {
      return document.activeElement === this.root;
    }
  }, {
    key: 'normalizedToRange',
    value: function normalizedToRange(range) {
      var _this4 = this;

      var positions = [[range.start.node, range.start.offset]];
      if (!range.native.collapsed) {
        positions.push([range.end.node, range.end.offset]);
      }
      var indexes = positions.map(function (position) {
        var _position = _slicedToArray(position, 2),
            node = _position[0],
            offset = _position[1];

        var blot = _parchment2.default.find(node, true);
        var index = blot.offset(_this4.scroll);
        if (offset === 0) {
          return index;
        } else if (blot instanceof _parchment2.default.Container) {
          return index + blot.length();
        } else {
          return index + blot.index(node, offset);
        }
      });
      var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);
      var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));
      return new Range(start, end - start);
    }
  }, {
    key: 'normalizeNative',
    value: function normalizeNative(nativeRange) {
      if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
        return null;
      }
      var range = {
        start: { node: nativeRange.startContainer, offset: nativeRange.startOffset },
        end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },
        native: nativeRange
      };
      [range.start, range.end].forEach(function (position) {
        var node = position.node,
            offset = position.offset;
        while (!(node instanceof Text) && node.childNodes.length > 0) {
          if (node.childNodes.length > offset) {
            node = node.childNodes[offset];
            offset = 0;
          } else if (node.childNodes.length === offset) {
            node = node.lastChild;
            offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;
          } else {
            break;
          }
        }
        position.node = node, position.offset = offset;
      });
      return range;
    }
  }, {
    key: 'rangeToNative',
    value: function rangeToNative(range) {
      var _this5 = this;

      var indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];
      var args = [];
      var scrollLength = this.scroll.length();
      indexes.forEach(function (index, i) {
        index = Math.min(scrollLength - 1, index);
        var node = void 0,
            _scroll$leaf5 = _this5.scroll.leaf(index),
            _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2),
            leaf = _scroll$leaf6[0],
            offset = _scroll$leaf6[1];
        var _leaf$position5 = leaf.position(offset, i !== 0);

        var _leaf$position6 = _slicedToArray(_leaf$position5, 2);

        node = _leaf$position6[0];
        offset = _leaf$position6[1];

        args.push(node, offset);
      });
      if (args.length < 2) {
        args = args.concat(args);
      }
      return args;
    }
  }, {
    key: 'scrollIntoView',
    value: function scrollIntoView(scrollingContainer) {
      var range = this.lastRange;
      if (range == null) return;
      var bounds = this.getBounds(range.index, range.length);
      if (bounds == null) return;
      var limit = this.scroll.length() - 1;

      var _scroll$line = this.scroll.line(Math.min(range.index, limit)),
          _scroll$line2 = _slicedToArray(_scroll$line, 1),
          first = _scroll$line2[0];

      var last = first;
      if (range.length > 0) {
        var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));

        var _scroll$line4 = _slicedToArray(_scroll$line3, 1);

        last = _scroll$line4[0];
      }
      if (first == null || last == null) return;
      var scrollBounds = scrollingContainer.getBoundingClientRect();
      if (bounds.top < scrollBounds.top) {
        scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
      } else if (bounds.bottom > scrollBounds.bottom) {
        scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
      }
    }
  }, {
    key: 'setNativeRange',
    value: function setNativeRange(startNode, startOffset) {
      var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;
      var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;
      var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);
      if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
        return;
      }
      var selection = document.getSelection();
      if (selection == null) return;
      if (startNode != null) {
        if (!this.hasFocus()) this.root.focus();
        var native = (this.getNativeRange() || {}).native;
        if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {

          if (startNode.tagName == "BR") {
            startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
            startNode = startNode.parentNode;
          }
          if (endNode.tagName == "BR") {
            endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
            endNode = endNode.parentNode;
          }
          var range = document.createRange();
          range.setStart(startNode, startOffset);
          range.setEnd(endNode, endOffset);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      } else {
        selection.removeAllRanges();
        this.root.blur();
        document.body.focus(); // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)
      }
    }
  }, {
    key: 'setRange',
    value: function setRange(range) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;

      if (typeof force === 'string') {
        source = force;
        force = false;
      }
      debug.info('setRange', range);
      if (range != null) {
        var args = this.rangeToNative(range);
        this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));
      } else {
        this.setNativeRange(null);
      }
      this.update(source);
    }
  }, {
    key: 'update',
    value: function update() {
      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;

      var oldRange = this.lastRange;

      var _getRange = this.getRange(),
          _getRange2 = _slicedToArray(_getRange, 2),
          lastRange = _getRange2[0],
          nativeRange = _getRange2[1];

      this.lastRange = lastRange;
      if (this.lastRange != null) {
        this.savedRange = this.lastRange;
      }
      if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {
        var _emitter;

        if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
          this.cursor.restore();
        }
        var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];
        (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
        if (source !== _emitter4.default.sources.SILENT) {
          var _emitter2;

          (_emitter2 = this.emitter).emit.apply(_emitter2, args);
        }
      }
    }
  }]);

  return Selection;
}();

function contains(parent, descendant) {
  try {
    // Firefox inserts inaccessible nodes around video elements
    descendant.parentNode;
  } catch (e) {
    return false;
  }
  // IE11 has bug with Text nodes
  // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect
  if (descendant instanceof Text) {
    descendant = descendant.parentNode;
  }
  return parent.contains(descendant);
}

exports.Range = Range;
exports.default = Selection;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Break = function (_Parchment$Embed) {
  _inherits(Break, _Parchment$Embed);

  function Break() {
    _classCallCheck(this, Break);

    return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));
  }

  _createClass(Break, [{
    key: 'insertInto',
    value: function insertInto(parent, ref) {
      if (parent.children.length === 0) {
        _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), 'insertInto', this).call(this, parent, ref);
      } else {
        this.remove();
      }
    }
  }, {
    key: 'length',
    value: function length() {
      return 0;
    }
  }, {
    key: 'value',
    value: function value() {
      return '';
    }
  }], [{
    key: 'value',
    value: function value() {
      return undefined;
    }
  }]);

  return Break;
}(_parchment2.default.Embed);

Break.blotName = 'break';
Break.tagName = 'BR';

exports.default = Break;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var linked_list_1 = __webpack_require__(44);
var shadow_1 = __webpack_require__(30);
var Registry = __webpack_require__(1);
var ContainerBlot = /** @class */ (function (_super) {
    __extends(ContainerBlot, _super);
    function ContainerBlot(domNode) {
        var _this = _super.call(this, domNode) || this;
        _this.build();
        return _this;
    }
    ContainerBlot.prototype.appendChild = function (other) {
        this.insertBefore(other);
    };
    ContainerBlot.prototype.attach = function () {
        _super.prototype.attach.call(this);
        this.children.forEach(function (child) {
            child.attach();
        });
    };
    ContainerBlot.prototype.build = function () {
        var _this = this;
        this.children = new linked_list_1.default();
        // Need to be reversed for if DOM nodes already in order
        [].slice
            .call(this.domNode.childNodes)
            .reverse()
            .forEach(function (node) {
            try {
                var child = makeBlot(node);
                _this.insertBefore(child, _this.children.head || undefined);
            }
            catch (err) {
                if (err instanceof Registry.ParchmentError)
                    return;
                else
                    throw err;
            }
        });
    };
    ContainerBlot.prototype.deleteAt = function (index, length) {
        if (index === 0 && length === this.length()) {
            return this.remove();
        }
        this.children.forEachAt(index, length, function (child, offset, length) {
            child.deleteAt(offset, length);
        });
    };
    ContainerBlot.prototype.descendant = function (criteria, index) {
        var _a = this.children.find(index), child = _a[0], offset = _a[1];
        if ((criteria.blotName == null && criteria(child)) ||
            (criteria.blotName != null && child instanceof criteria)) {
            return [child, offset];
        }
        else if (child instanceof ContainerBlot) {
            return child.descendant(criteria, offset);
        }
        else {
            return [null, -1];
        }
    };
    ContainerBlot.prototype.descendants = function (criteria, index, length) {
        if (index === void 0) { index = 0; }
        if (length === void 0) { length = Number.MAX_VALUE; }
        var descendants = [];
        var lengthLeft = length;
        this.children.forEachAt(index, length, function (child, index, length) {
            if ((criteria.blotName == null && criteria(child)) ||
                (criteria.blotName != null && child instanceof criteria)) {
                descendants.push(child);
            }
            if (child instanceof ContainerBlot) {
                descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));
            }
            lengthLeft -= length;
        });
        return descendants;
    };
    ContainerBlot.prototype.detach = function () {
        this.children.forEach(function (child) {
            child.detach();
        });
        _super.prototype.detach.call(this);
    };
    ContainerBlot.prototype.formatAt = function (index, length, name, value) {
        this.children.forEachAt(index, length, function (child, offset, length) {
            child.formatAt(offset, length, name, value);
        });
    };
    ContainerBlot.prototype.insertAt = function (index, value, def) {
        var _a = this.children.find(index), child = _a[0], offset = _a[1];
        if (child) {
            child.insertAt(offset, value, def);
        }
        else {
            var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
            this.appendChild(blot);
        }
    };
    ContainerBlot.prototype.insertBefore = function (childBlot, refBlot) {
        if (this.statics.allowedChildren != null &&
            !this.statics.allowedChildren.some(function (child) {
                return childBlot instanceof child;
            })) {
            throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
        }
        childBlot.insertInto(this, refBlot);
    };
    ContainerBlot.prototype.length = function () {
        return this.children.reduce(function (memo, child) {
            return memo + child.length();
        }, 0);
    };
    ContainerBlot.prototype.moveChildren = function (targetParent, refNode) {
        this.children.forEach(function (child) {
            targetParent.insertBefore(child, refNode);
        });
    };
    ContainerBlot.prototype.optimize = function (context) {
        _super.prototype.optimize.call(this, context);
        if (this.children.length === 0) {
            if (this.statics.defaultChild != null) {
                var child = Registry.create(this.statics.defaultChild);
                this.appendChild(child);
                child.optimize(context);
            }
            else {
                this.remove();
            }
        }
    };
    ContainerBlot.prototype.path = function (index, inclusive) {
        if (inclusive === void 0) { inclusive = false; }
        var _a = this.children.find(index, inclusive), child = _a[0], offset = _a[1];
        var position = [[this, index]];
        if (child instanceof ContainerBlot) {
            return position.concat(child.path(offset, inclusive));
        }
        else if (child != null) {
            position.push([child, offset]);
        }
        return position;
    };
    ContainerBlot.prototype.removeChild = function (child) {
        this.children.remove(child);
    };
    ContainerBlot.prototype.replace = function (target) {
        if (target instanceof ContainerBlot) {
            target.moveChildren(this);
        }
        _super.prototype.replace.call(this, target);
    };
    ContainerBlot.prototype.split = function (index, force) {
        if (force === void 0) { force = false; }
        if (!force) {
            if (index === 0)
                return this;
            if (index === this.length())
                return this.next;
        }
        var after = this.clone();
        this.parent.insertBefore(after, this.next);
        this.children.forEachAt(index, this.length(), function (child, offset, length) {
            child = child.split(offset, force);
            after.appendChild(child);
        });
        return after;
    };
    ContainerBlot.prototype.unwrap = function () {
        this.moveChildren(this.parent, this.next);
        this.remove();
    };
    ContainerBlot.prototype.update = function (mutations, context) {
        var _this = this;
        var addedNodes = [];
        var removedNodes = [];
        mutations.forEach(function (mutation) {
            if (mutation.target === _this.domNode && mutation.type === 'childList') {
                addedNodes.push.apply(addedNodes, mutation.addedNodes);
                removedNodes.push.apply(removedNodes, mutation.removedNodes);
            }
        });
        removedNodes.forEach(function (node) {
            // Check node has actually been removed
            // One exception is Chrome does not immediately remove IFRAMEs
            // from DOM but MutationRecord is correct in its reported removal
            if (node.parentNode != null &&
                // @ts-ignore
                node.tagName !== 'IFRAME' &&
                document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                return;
            }
            var blot = Registry.find(node);
            if (blot == null)
                return;
            if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                blot.detach();
            }
        });
        addedNodes
            .filter(function (node) {
            return node.parentNode == _this.domNode;
        })
            .sort(function (a, b) {
            if (a === b)
                return 0;
            if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {
                return 1;
            }
            return -1;
        })
            .forEach(function (node) {
            var refBlot = null;
            if (node.nextSibling != null) {
                refBlot = Registry.find(node.nextSibling);
            }
            var blot = makeBlot(node);
            if (blot.next != refBlot || blot.next == null) {
                if (blot.parent != null) {
                    blot.parent.removeChild(_this);
                }
                _this.insertBefore(blot, refBlot || undefined);
            }
        });
    };
    return ContainerBlot;
}(shadow_1.default));
function makeBlot(node) {
    var blot = Registry.find(node);
    if (blot == null) {
        try {
            blot = Registry.create(node);
        }
        catch (e) {
            blot = Registry.create(Registry.Scope.INLINE);
            [].slice.call(node.childNodes).forEach(function (child) {
                // @ts-ignore
                blot.domNode.appendChild(child);
            });
            if (node.parentNode) {
                node.parentNode.replaceChild(blot.domNode, node);
            }
            blot.attach();
        }
    }
    return blot;
}
exports.default = ContainerBlot;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var attributor_1 = __webpack_require__(12);
var store_1 = __webpack_require__(31);
var container_1 = __webpack_require__(17);
var Registry = __webpack_require__(1);
var FormatBlot = /** @class */ (function (_super) {
    __extends(FormatBlot, _super);
    function FormatBlot(domNode) {
        var _this = _super.call(this, domNode) || this;
        _this.attributes = new store_1.default(_this.domNode);
        return _this;
    }
    FormatBlot.formats = function (domNode) {
        if (typeof this.tagName === 'string') {
            return true;
        }
        else if (Array.isArray(this.tagName)) {
            return domNode.tagName.toLowerCase();
        }
        return undefined;
    };
    FormatBlot.prototype.format = function (name, value) {
        var format = Registry.query(name);
        if (format instanceof attributor_1.default) {
            this.attributes.attribute(format, value);
        }
        else if (value) {
            if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {
                this.replaceWith(name, value);
            }
        }
    };
    FormatBlot.prototype.formats = function () {
        var formats = this.attributes.values();
        var format = this.statics.formats(this.domNode);
        if (format != null) {
            formats[this.statics.blotName] = format;
        }
        return formats;
    };
    FormatBlot.prototype.replaceWith = function (name, value) {
        var replacement = _super.prototype.replaceWith.call(this, name, value);
        this.attributes.copy(replacement);
        return replacement;
    };
    FormatBlot.prototype.update = function (mutations, context) {
        var _this = this;
        _super.prototype.update.call(this, mutations, context);
        if (mutations.some(function (mutation) {
            return mutation.target === _this.domNode && mutation.type === 'attributes';
        })) {
            this.attributes.build();
        }
    };
    FormatBlot.prototype.wrap = function (name, value) {
        var wrapper = _super.prototype.wrap.call(this, name, value);
        if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {
            this.attributes.move(wrapper);
        }
        return wrapper;
    };
    return FormatBlot;
}(container_1.default));
exports.default = FormatBlot;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var shadow_1 = __webpack_require__(30);
var Registry = __webpack_require__(1);
var LeafBlot = /** @class */ (function (_super) {
    __extends(LeafBlot, _super);
    function LeafBlot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LeafBlot.value = function (domNode) {
        return true;
    };
    LeafBlot.prototype.index = function (node, offset) {
        if (this.domNode === node ||
            this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
            return Math.min(offset, 1);
        }
        return -1;
    };
    LeafBlot.prototype.position = function (index, inclusive) {
        var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
        if (index > 0)
            offset += 1;
        return [this.parent.domNode, offset];
    };
    LeafBlot.prototype.value = function () {
        var _a;
        return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;
    };
    LeafBlot.scope = Registry.Scope.INLINE_BLOT;
    return LeafBlot;
}(shadow_1.default));
exports.default = LeafBlot;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var equal = __webpack_require__(11);
var extend = __webpack_require__(3);


var lib = {
  attributes: {
    compose: function (a, b, keepNull) {
      if (typeof a !== 'object') a = {};
      if (typeof b !== 'object') b = {};
      var attributes = extend(true, {}, b);
      if (!keepNull) {
        attributes = Object.keys(attributes).reduce(function (copy, key) {
          if (attributes[key] != null) {
            copy[key] = attributes[key];
          }
          return copy;
        }, {});
      }
      for (var key in a) {
        if (a[key] !== undefined && b[key] === undefined) {
          attributes[key] = a[key];
        }
      }
      return Object.keys(attributes).length > 0 ? attributes : undefined;
    },

    diff: function(a, b) {
      if (typeof a !== 'object') a = {};
      if (typeof b !== 'object') b = {};
      var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function (attributes, key) {
        if (!equal(a[key], b[key])) {
          attributes[key] = b[key] === undefined ? null : b[key];
        }
        return attributes;
      }, {});
      return Object.keys(attributes).length > 0 ? attributes : undefined;
    },

    transform: function (a, b, priority) {
      if (typeof a !== 'object') return b;
      if (typeof b !== 'object') return undefined;
      if (!priority) return b;  // b simply overwrites us without priority
      var attributes = Object.keys(b).reduce(function (attributes, key) {
        if (a[key] === undefined) attributes[key] = b[key];  // null is a valid value
        return attributes;
      }, {});
      return Object.keys(attributes).length > 0 ? attributes : undefined;
    }
  },

  iterator: function (ops) {
    return new Iterator(ops);
  },

  length: function (op) {
    if (typeof op['delete'] === 'number') {
      return op['delete'];
    } else if (typeof op.retain === 'number') {
      return op.retain;
    } else {
      return typeof op.insert === 'string' ? op.insert.length : 1;
    }
  }
};


function Iterator(ops) {
  this.ops = ops;
  this.index = 0;
  this.offset = 0;
}
Iterator.prototype.hasNext = function () {
  return this.peekLength() < Infinity;
};

Iterator.prototype.next = function (length) {
  if (!length) length = Infinity;
  var nextOp = this.ops[this.index];
  if (nextOp) {
    var offset = this.offset;
    var opLength = lib.length(nextOp);
    if (length >= opLength - offset) {
      length = opLength - offset;
      this.index += 1;
      this.offset = 0;
    } else {
      this.offset += length;
    }
    if (typeof nextOp['delete'] === 'number') {
      return { 'delete': length };
    } else {
      var retOp = {};
      if (nextOp.attributes) {
        retOp.attributes = nextOp.attributes;
      }
      if (typeof nextOp.retain === 'number') {
        retOp.retain = length;
      } else if (typeof nextOp.insert === 'string') {
        retOp.insert = nextOp.insert.substr(offset, length);
      } else {
        // offset should === 0, length should === 1
        retOp.insert = nextOp.insert;
      }
      return retOp;
    }
  } else {
    return { retain: Infinity };
  }
};

Iterator.prototype.peek = function () {
  return this.ops[this.index];
};

Iterator.prototype.peekLength = function () {
  if (this.ops[this.index]) {
    // Should never return 0 if our index is being managed correctly
    return lib.length(this.ops[this.index]) - this.offset;
  } else {
    return Infinity;
  }
};

Iterator.prototype.peekType = function () {
  if (this.ops[this.index]) {
    if (typeof this.ops[this.index]['delete'] === 'number') {
      return 'delete';
    } else if (typeof this.ops[this.index].retain === 'number') {
      return 'retain';
    } else {
      return 'insert';
    }
  }
  return 'retain';
};

Iterator.prototype.rest = function () {
  if (!this.hasNext()) {
    return [];
  } else if (this.offset === 0) {
    return this.ops.slice(this.index);
  } else {
    var offset = this.offset;
    var index = this.index;
    var next = this.next();
    var rest = this.ops.slice(this.index);
    this.offset = offset;
    this.index = index;
    return [next].concat(rest);
  }
};


module.exports = lib;


/***/ }),
/* 21 */
/***/ (function(module, exports) {

var clone = (function() {

function _instanceof(obj, type) {
  return type != null && obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  // maybe a reference error because no `Map`. Give it a dummy value that no
  // value will ever be an instanceof.
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i < symbols.length; i++) {
        // Don't need to worry about cloning a symbol because it is a primitive,
        // like a number or string.
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        if (!descriptor.enumerable) {
          Object.defineProperty(child, symbol, {
            enumerable: false
          });
        }
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i < allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor && descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, {
          enumerable: false
        });
      }
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _emitter = __webpack_require__(8);

var _emitter2 = _interopRequireDefault(_emitter);

var _block = __webpack_require__(4);

var _block2 = _interopRequireDefault(_block);

var _break = __webpack_require__(16);

var _break2 = _interopRequireDefault(_break);

var _code = __webpack_require__(13);

var _code2 = _interopRequireDefault(_code);

var _container = __webpack_require__(25);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function isLine(blot) {
  return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;
}

var Scroll = function (_Parchment$Scroll) {
  _inherits(Scroll, _Parchment$Scroll);

  function Scroll(domNode, config) {
    _classCallCheck(this, Scroll);

    var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));

    _this.emitter = config.emitter;
    if (Array.isArray(config.whitelist)) {
      _this.whitelist = config.whitelist.reduce(function (whitelist, format) {
        whitelist[format] = true;
        return whitelist;
      }, {});
    }
    // Some reason fixes composition issues with character languages in Windows/Chrome, Safari
    _this.domNode.addEventListener('DOMNodeInserted', function () {});
    _this.optimize();
    _this.enable();
    return _this;
  }

  _createClass(Scroll, [{
    key: 'batchStart',
    value: function batchStart() {
      this.batch = true;
    }
  }, {
    key: 'batchEnd',
    value: function batchEnd() {
      this.batch = false;
      this.optimize();
    }
  }, {
    key: 'deleteAt',
    value: function deleteAt(index, length) {
      var _line = this.line(index),
          _line2 = _slicedToArray(_line, 2),
          first = _line2[0],
          offset = _line2[1];

      var _line3 = this.line(index + length),
          _line4 = _slicedToArray(_line3, 1),
          last = _line4[0];

      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'deleteAt', this).call(this, index, length);
      if (last != null && first !== last && offset > 0) {
        if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {
          this.optimize();
          return;
        }
        if (first instanceof _code2.default) {
          var newlineIndex = first.newlineIndex(first.length(), true);
          if (newlineIndex > -1) {
            first = first.split(newlineIndex + 1);
            if (first === last) {
              this.optimize();
              return;
            }
          }
        } else if (last instanceof _code2.default) {
          var _newlineIndex = last.newlineIndex(0);
          if (_newlineIndex > -1) {
            last.split(_newlineIndex + 1);
          }
        }
        var ref = last.children.head instanceof _break2.default ? null : last.children.head;
        first.moveChildren(last, ref);
        first.remove();
      }
      this.optimize();
    }
  }, {
    key: 'enable',
    value: function enable() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.domNode.setAttribute('contenteditable', enabled);
    }
  }, {
    key: 'formatAt',
    value: function formatAt(index, length, format, value) {
      if (this.whitelist != null && !this.whitelist[format]) return;
      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'formatAt', this).call(this, index, length, format, value);
      this.optimize();
    }
  }, {
    key: 'insertAt',
    value: function insertAt(index, value, def) {
      if (def != null && this.whitelist != null && !this.whitelist[value]) return;
      if (index >= this.length()) {
        if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {
          var blot = _parchment2.default.create(this.statics.defaultChild);
          this.appendChild(blot);
          if (def == null && value.endsWith('\n')) {
            value = value.slice(0, -1);
          }
          blot.insertAt(0, value, def);
        } else {
          var embed = _parchment2.default.create(value, def);
          this.appendChild(embed);
        }
      } else {
        _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertAt', this).call(this, index, value, def);
      }
      this.optimize();
    }
  }, {
    key: 'insertBefore',
    value: function insertBefore(blot, ref) {
      if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {
        var wrapper = _parchment2.default.create(this.statics.defaultChild);
        wrapper.appendChild(blot);
        blot = wrapper;
      }
      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertBefore', this).call(this, blot, ref);
    }
  }, {
    key: 'leaf',
    value: function leaf(index) {
      return this.path(index).pop() || [null, -1];
    }
  }, {
    key: 'line',
    value: function line(index) {
      if (index === this.length()) {
        return this.line(index - 1);
      }
      return this.descendant(isLine, index);
    }
  }, {
    key: 'lines',
    value: function lines() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;

      var getLines = function getLines(blot, index, length) {
        var lines = [],
            lengthLeft = length;
        blot.children.forEachAt(index, length, function (child, index, length) {
          if (isLine(child)) {
            lines.push(child);
          } else if (child instanceof _parchment2.default.Container) {
            lines = lines.concat(getLines(child, index, lengthLeft));
          }
          lengthLeft -= length;
        });
        return lines;
      };
      return getLines(this, index, length);
    }
  }, {
    key: 'optimize',
    value: function optimize() {
      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.batch === true) return;
      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'optimize', this).call(this, mutations, context);
      if (mutations.length > 0) {
        this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);
      }
    }
  }, {
    key: 'path',
    value: function path(index) {
      return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'path', this).call(this, index).slice(1); // Exclude self
    }
  }, {
    key: 'update',
    value: function update(mutations) {
      if (this.batch === true) return;
      var source = _emitter2.default.sources.USER;
      if (typeof mutations === 'string') {
        source = mutations;
      }
      if (!Array.isArray(mutations)) {
        mutations = this.observer.takeRecords();
      }
      if (mutations.length > 0) {
        this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);
      }
      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'update', this).call(this, mutations.concat([])); // pass copy
      if (mutations.length > 0) {
        this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);
      }
    }
  }]);

  return Scroll;
}(_parchment2.default.Scroll);

Scroll.blotName = 'scroll';
Scroll.className = 'ql-editor';
Scroll.tagName = 'DIV';
Scroll.defaultChild = 'block';
Scroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];

exports.default = Scroll;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SHORTKEY = exports.default = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _clone = __webpack_require__(21);

var _clone2 = _interopRequireDefault(_clone);

var _deepEqual = __webpack_require__(11);

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _extend = __webpack_require__(3);

var _extend2 = _interopRequireDefault(_extend);

var _quillDelta = __webpack_require__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _op = __webpack_require__(20);

var _op2 = _interopRequireDefault(_op);

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __webpack_require__(5);

var _quill2 = _interopRequireDefault(_quill);

var _logger = __webpack_require__(10);

var _logger2 = _interopRequireDefault(_logger);

var _module = __webpack_require__(9);

var _module2 = _interopRequireDefault(_module);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _logger2.default)('quill:keyboard');

var SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';

var Keyboard = function (_Module) {
  _inherits(Keyboard, _Module);

  _createClass(Keyboard, null, [{
    key: 'match',
    value: function match(evt, binding) {
      binding = normalize(binding);
      if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function (key) {
        return !!binding[key] !== evt[key] && binding[key] !== null;
      })) {
        return false;
      }
      return binding.key === (evt.which || evt.keyCode);
    }
  }]);

  function Keyboard(quill, options) {
    _classCallCheck(this, Keyboard);

    var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));

    _this.bindings = {};
    Object.keys(_this.options.bindings).forEach(function (name) {
      if (name === 'list autofill' && quill.scroll.whitelist != null && !quill.scroll.whitelist['list']) {
        return;
      }
      if (_this.options.bindings[name]) {
        _this.addBinding(_this.options.bindings[name]);
      }
    });
    _this.addBinding({ key: Keyboard.keys.ENTER, shiftKey: null }, handleEnter);
    _this.addBinding({ key: Keyboard.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function () {});
    if (/Firefox/i.test(navigator.userAgent)) {
      // Need to handle delete and backspace for Firefox in the general case #1171
      _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true }, handleBackspace);
      _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true }, handleDelete);
    } else {
      _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, handleBackspace);
      _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, handleDelete);
    }
    _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: false }, handleDeleteRange);
    _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: false }, handleDeleteRange);
    _this.addBinding({ key: Keyboard.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, handleBackspace);
    _this.listen();
    return _this;
  }

  _createClass(Keyboard, [{
    key: 'addBinding',
    value: function addBinding(key) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var binding = normalize(key);
      if (binding == null || binding.key == null) {
        return debug.warn('Attempted to add invalid keyboard binding', binding);
      }
      if (typeof context === 'function') {
        context = { handler: context };
      }
      if (typeof handler === 'function') {
        handler = { handler: handler };
      }
      binding = (0, _extend2.default)(binding, context, handler);
      this.bindings[binding.key] = this.bindings[binding.key] || [];
      this.bindings[binding.key].push(binding);
    }
  }, {
    key: 'listen',
    value: function listen() {
      var _this2 = this;

      this.quill.root.addEventListener('keydown', function (evt) {
        if (evt.defaultPrevented) return;
        var which = evt.which || evt.keyCode;
        var bindings = (_this2.bindings[which] || []).filter(function (binding) {
          return Keyboard.match(evt, binding);
        });
        if (bindings.length === 0) return;
        var range = _this2.quill.getSelection();
        if (range == null || !_this2.quill.hasFocus()) return;

        var _quill$getLine = _this2.quill.getLine(range.index),
            _quill$getLine2 = _slicedToArray(_quill$getLine, 2),
            line = _quill$getLine2[0],
            offset = _quill$getLine2[1];

        var _quill$getLeaf = _this2.quill.getLeaf(range.index),
            _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2),
            leafStart = _quill$getLeaf2[0],
            offsetStart = _quill$getLeaf2[1];

        var _ref = range.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range.index + range.length),
            _ref2 = _slicedToArray(_ref, 2),
            leafEnd = _ref2[0],
            offsetEnd = _ref2[1];

        var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : '';
        var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : '';
        var curContext = {
          collapsed: range.length === 0,
          empty: range.length === 0 && line.length() <= 1,
          format: _this2.quill.getFormat(range),
          offset: offset,
          prefix: prefixText,
          suffix: suffixText
        };
        var prevented = bindings.some(function (binding) {
          if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;
          if (binding.empty != null && binding.empty !== curContext.empty) return false;
          if (binding.offset != null && binding.offset !== curContext.offset) return false;
          if (Array.isArray(binding.format)) {
            // any format is present
            if (binding.format.every(function (name) {
              return curContext.format[name] == null;
            })) {
              return false;
            }
          } else if (_typeof(binding.format) === 'object') {
            // all formats must match
            if (!Object.keys(binding.format).every(function (name) {
              if (binding.format[name] === true) return curContext.format[name] != null;
              if (binding.format[name] === false) return curContext.format[name] == null;
              return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);
            })) {
              return false;
            }
          }
          if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;
          if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;
          return binding.handler.call(_this2, range, curContext) !== true;
        });
        if (prevented) {
          evt.preventDefault();
        }
      });
    }
  }]);

  return Keyboard;
}(_module2.default);

Keyboard.keys = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  ESCAPE: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  DELETE: 46
};

Keyboard.DEFAULTS = {
  bindings: {
    'bold': makeFormatHandler('bold'),
    'italic': makeFormatHandler('italic'),
    'underline': makeFormatHandler('underline'),
    'indent': {
      // highlight tab or tab at beginning of list, indent or blockquote
      key: Keyboard.keys.TAB,
      format: ['blockquote', 'indent', 'list'],
      handler: function handler(range, context) {
        if (context.collapsed && context.offset !== 0) return true;
        this.quill.format('indent', '+1', _quill2.default.sources.USER);
      }
    },
    'outdent': {
      key: Keyboard.keys.TAB,
      shiftKey: true,
      format: ['blockquote', 'indent', 'list'],
      // highlight tab or tab at beginning of list, indent or blockquote
      handler: function handler(range, context) {
        if (context.collapsed && context.offset !== 0) return true;
        this.quill.format('indent', '-1', _quill2.default.sources.USER);
      }
    },
    'outdent backspace': {
      key: Keyboard.keys.BACKSPACE,
      collapsed: true,
      shiftKey: null,
      metaKey: null,
      ctrlKey: null,
      altKey: null,
      format: ['indent', 'list'],
      offset: 0,
      handler: function handler(range, context) {
        if (context.format.indent != null) {
          this.quill.format('indent', '-1', _quill2.default.sources.USER);
        } else if (context.format.list != null) {
          this.quill.format('list', false, _quill2.default.sources.USER);
        }
      }
    },
    'indent code-block': makeCodeBlockHandler(true),
    'outdent code-block': makeCodeBlockHandler(false),
    'remove tab': {
      key: Keyboard.keys.TAB,
      shiftKey: true,
      collapsed: true,
      prefix: /\t$/,
      handler: function handler(range) {
        this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);
      }
    },
    'tab': {
      key: Keyboard.keys.TAB,
      handler: function handler(range) {
        this.quill.history.cutoff();
        var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert('\t');
        this.quill.updateContents(delta, _quill2.default.sources.USER);
        this.quill.history.cutoff();
        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
      }
    },
    'list empty enter': {
      key: Keyboard.keys.ENTER,
      collapsed: true,
      format: ['list'],
      empty: true,
      handler: function handler(range, context) {
        this.quill.format('list', false, _quill2.default.sources.USER);
        if (context.format.indent) {
          this.quill.format('indent', false, _quill2.default.sources.USER);
        }
      }
    },
    'checklist enter': {
      key: Keyboard.keys.ENTER,
      collapsed: true,
      format: { list: 'checked' },
      handler: function handler(range) {
        var _quill$getLine3 = this.quill.getLine(range.index),
            _quill$getLine4 = _slicedToArray(_quill$getLine3, 2),
            line = _quill$getLine4[0],
            offset = _quill$getLine4[1];

        var formats = (0, _extend2.default)({}, line.formats(), { list: 'checked' });
        var delta = new _quillDelta2.default().retain(range.index).insert('\n', formats).retain(line.length() - offset - 1).retain(1, { list: 'unchecked' });
        this.quill.updateContents(delta, _quill2.default.sources.USER);
        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
        this.quill.scrollIntoView();
      }
    },
    'header enter': {
      key: Keyboard.keys.ENTER,
      collapsed: true,
      format: ['header'],
      suffix: /^$/,
      handler: function handler(range, context) {
        var _quill$getLine5 = this.quill.getLine(range.index),
            _quill$getLine6 = _slicedToArray(_quill$getLine5, 2),
            line = _quill$getLine6[0],
            offset = _quill$getLine6[1];

        var delta = new _quillDelta2.default().retain(range.index).insert('\n', context.format).retain(line.length() - offset - 1).retain(1, { header: null });
        this.quill.updateContents(delta, _quill2.default.sources.USER);
        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
        this.quill.scrollIntoView();
      }
    },
    'list autofill': {
      key: ' ',
      collapsed: true,
      format: { list: false },
      prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
      handler: function handler(range, context) {
        var length = context.prefix.length;

        var _quill$getLine7 = this.quill.getLine(range.index),
            _quill$getLine8 = _slicedToArray(_quill$getLine7, 2),
            line = _quill$getLine8[0],
            offset = _quill$getLine8[1];

        if (offset > length) return true;
        var value = void 0;
        switch (context.prefix.trim()) {
          case '[]':case '[ ]':
            value = 'unchecked';
            break;
          case '[x]':
            value = 'checked';
            break;
          case '-':case '*':
            value = 'bullet';
            break;
          default:
            value = 'ordered';
        }
        this.quill.insertText(range.index, ' ', _quill2.default.sources.USER);
        this.quill.history.cutoff();
        var delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, { list: value });
        this.quill.updateContents(delta, _quill2.default.sources.USER);
        this.quill.history.cutoff();
        this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);
      }
    },
    'code exit': {
      key: Keyboard.keys.ENTER,
      collapsed: true,
      format: ['code-block'],
      prefix: /\n\n$/,
      suffix: /^\s+$/,
      handler: function handler(range) {
        var _quill$getLine9 = this.quill.getLine(range.index),
            _quill$getLine10 = _slicedToArray(_quill$getLine9, 2),
            line = _quill$getLine10[0],
            offset = _quill$getLine10[1];

        var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, { 'code-block': null }).delete(1);
        this.quill.updateContents(delta, _quill2.default.sources.USER);
      }
    },
    'embed left': makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
    'embed left shift': makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
    'embed right': makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
    'embed right shift': makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
  }
};

function makeEmbedArrowHandler(key, shiftKey) {
  var _ref3;

  var where = key === Keyboard.keys.LEFT ? 'prefix' : 'suffix';
  return _ref3 = {
    key: key,
    shiftKey: shiftKey,
    altKey: null
  }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, 'handler', function handler(range) {
    var index = range.index;
    if (key === Keyboard.keys.RIGHT) {
      index += range.length + 1;
    }

    var _quill$getLeaf3 = this.quill.getLeaf(index),
        _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1),
        leaf = _quill$getLeaf4[0];

    if (!(leaf instanceof _parchment2.default.Embed)) return true;
    if (key === Keyboard.keys.LEFT) {
      if (shiftKey) {
        this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);
      } else {
        this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);
      }
    } else {
      if (shiftKey) {
        this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);
      } else {
        this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);
      }
    }
    return false;
  }), _ref3;
}

function handleBackspace(range, context) {
  if (range.index === 0 || this.quill.getLength() <= 1) return;

  var _quill$getLine11 = this.quill.getLine(range.index),
      _quill$getLine12 = _slicedToArray(_quill$getLine11, 1),
      line = _quill$getLine12[0];

  var formats = {};
  if (context.offset === 0) {
    var _quill$getLine13 = this.quill.getLine(range.index - 1),
        _quill$getLine14 = _slicedToArray(_quill$getLine13, 1),
        prev = _quill$getLine14[0];

    if (prev != null && prev.length() > 1) {
      var curFormats = line.formats();
      var prevFormats = this.quill.getFormat(range.index - 1, 1);
      formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};
    }
  }
  // Check for astral symbols
  var length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
  this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);
  if (Object.keys(formats).length > 0) {
    this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);
  }
  this.quill.focus();
}

function handleDelete(range, context) {
  // Check for astral symbols
  var length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
  if (range.index >= this.quill.getLength() - length) return;
  var formats = {},
      nextLength = 0;

  var _quill$getLine15 = this.quill.getLine(range.index),
      _quill$getLine16 = _slicedToArray(_quill$getLine15, 1),
      line = _quill$getLine16[0];

  if (context.offset >= line.length() - 1) {
    var _quill$getLine17 = this.quill.getLine(range.index + 1),
        _quill$getLine18 = _slicedToArray(_quill$getLine17, 1),
        next = _quill$getLine18[0];

    if (next) {
      var curFormats = line.formats();
      var nextFormats = this.quill.getFormat(range.index, 1);
      formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};
      nextLength = next.length();
    }
  }
  this.quill.deleteText(range.index, length, _quill2.default.sources.USER);
  if (Object.keys(formats).length > 0) {
    this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);
  }
}

function handleDeleteRange(range) {
  var lines = this.quill.getLines(range);
  var formats = {};
  if (lines.length > 1) {
    var firstFormats = lines[0].formats();
    var lastFormats = lines[lines.length - 1].formats();
    formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};
  }
  this.quill.deleteText(range, _quill2.default.sources.USER);
  if (Object.keys(formats).length > 0) {
    this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);
  }
  this.quill.setSelection(range.index, _quill2.default.sources.SILENT);
  this.quill.focus();
}

function handleEnter(range, context) {
  var _this3 = this;

  if (range.length > 0) {
    this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change
  }
  var lineFormats = Object.keys(context.format).reduce(function (lineFormats, format) {
    if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {
      lineFormats[format] = context.format[format];
    }
    return lineFormats;
  }, {});
  this.quill.insertText(range.index, '\n', lineFormats, _quill2.default.sources.USER);
  // Earlier scroll.deleteAt might have messed up our selection,
  // so insertText's built in selection preservation is not reliable
  this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
  this.quill.focus();
  Object.keys(context.format).forEach(function (name) {
    if (lineFormats[name] != null) return;
    if (Array.isArray(context.format[name])) return;
    if (name === 'link') return;
    _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);
  });
}

function makeCodeBlockHandler(indent) {
  return {
    key: Keyboard.keys.TAB,
    shiftKey: !indent,
    format: { 'code-block': true },
    handler: function handler(range) {
      var CodeBlock = _parchment2.default.query('code-block');
      var index = range.index,
          length = range.length;

      var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index),
          _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
          block = _quill$scroll$descend2[0],
          offset = _quill$scroll$descend2[1];

      if (block == null) return;
      var scrollIndex = this.quill.getIndex(block);
      var start = block.newlineIndex(offset, true) + 1;
      var end = block.newlineIndex(scrollIndex + offset + length);
      var lines = block.domNode.textContent.slice(start, end).split('\n');
      offset = 0;
      lines.forEach(function (line, i) {
        if (indent) {
          block.insertAt(start + offset, CodeBlock.TAB);
          offset += CodeBlock.TAB.length;
          if (i === 0) {
            index += CodeBlock.TAB.length;
          } else {
            length += CodeBlock.TAB.length;
          }
        } else if (line.startsWith(CodeBlock.TAB)) {
          block.deleteAt(start + offset, CodeBlock.TAB.length);
          offset -= CodeBlock.TAB.length;
          if (i === 0) {
            index -= CodeBlock.TAB.length;
          } else {
            length -= CodeBlock.TAB.length;
          }
        }
        offset += line.length + 1;
      });
      this.quill.update(_quill2.default.sources.USER);
      this.quill.setSelection(index, length, _quill2.default.sources.SILENT);
    }
  };
}

function makeFormatHandler(format) {
  return {
    key: format[0].toUpperCase(),
    shortKey: true,
    handler: function handler(range, context) {
      this.quill.format(format, !context.format[format], _quill2.default.sources.USER);
    }
  };
}

function normalize(binding) {
  if (typeof binding === 'string' || typeof binding === 'number') {
    return normalize({ key: binding });
  }
  if ((typeof binding === 'undefined' ? 'undefined' : _typeof(binding)) === 'object') {
    binding = (0, _clone2.default)(binding, false);
  }
  if (typeof binding.key === 'string') {
    if (Keyboard.keys[binding.key.toUpperCase()] != null) {
      binding.key = Keyboard.keys[binding.key.toUpperCase()];
    } else if (binding.key.length === 1) {
      binding.key = binding.key.toUpperCase().charCodeAt(0);
    } else {
      return null;
    }
  }
  if (binding.shortKey) {
    binding[SHORTKEY] = binding.shortKey;
    delete binding.shortKey;
  }
  return binding;
}

exports.default = Keyboard;
exports.SHORTKEY = SHORTKEY;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _text = __webpack_require__(7);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = function (_Parchment$Embed) {
  _inherits(Cursor, _Parchment$Embed);

  _createClass(Cursor, null, [{
    key: 'value',
    value: function value() {
      return undefined;
    }
  }]);

  function Cursor(domNode, selection) {
    _classCallCheck(this, Cursor);

    var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));

    _this.selection = selection;
    _this.textNode = document.createTextNode(Cursor.CONTENTS);
    _this.domNode.appendChild(_this.textNode);
    _this._length = 0;
    return _this;
  }

  _createClass(Cursor, [{
    key: 'detach',
    value: function detach() {
      // super.detach() will also clear domNode.__blot
      if (this.parent != null) this.parent.removeChild(this);
    }
  }, {
    key: 'format',
    value: function format(name, value) {
      if (this._length !== 0) {
        return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'format', this).call(this, name, value);
      }
      var target = this,
          index = 0;
      while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {
        index += target.offset(target.parent);
        target = target.parent;
      }
      if (target != null) {
        this._length = Cursor.CONTENTS.length;
        target.optimize();
        target.formatAt(index, Cursor.CONTENTS.length, name, value);
        this._length = 0;
      }
    }
  }, {
    key: 'index',
    value: function index(node, offset) {
      if (node === this.textNode) return 0;
      return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'index', this).call(this, node, offset);
    }
  }, {
    key: 'length',
    value: function length() {
      return this._length;
    }
  }, {
    key: 'position',
    value: function position() {
      return [this.textNode, this.textNode.data.length];
    }
  }, {
    key: 'remove',
    value: function remove() {
      _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'remove', this).call(this);
      this.parent = null;
    }
  }, {
    key: 'restore',
    value: function restore() {
      if (this.selection.composing || this.parent == null) return;
      var textNode = this.textNode;
      var range = this.selection.getNativeRange();
      var restoreText = void 0,
          start = void 0,
          end = void 0;
      if (range != null && range.start.node === textNode && range.end.node === textNode) {
        var _ref = [textNode, range.start.offset, range.end.offset];
        restoreText = _ref[0];
        start = _ref[1];
        end = _ref[2];
      }
      // Link format will insert text outside of anchor tag
      while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
        this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
      }
      if (this.textNode.data !== Cursor.CONTENTS) {
        var text = this.textNode.data.split(Cursor.CONTENTS).join('');
        if (this.next instanceof _text2.default) {
          restoreText = this.next.domNode;
          this.next.insertAt(0, text);
          this.textNode.data = Cursor.CONTENTS;
        } else {
          this.textNode.data = text;
          this.parent.insertBefore(_parchment2.default.create(this.textNode), this);
          this.textNode = document.createTextNode(Cursor.CONTENTS);
          this.domNode.appendChild(this.textNode);
        }
      }
      this.remove();
      if (start != null) {
        var _map = [start, end].map(function (offset) {
          return Math.max(0, Math.min(restoreText.data.length, offset - 1));
        });

        var _map2 = _slicedToArray(_map, 2);

        start = _map2[0];
        end = _map2[1];

        return {
          startNode: restoreText,
          startOffset: start,
          endNode: restoreText,
          endOffset: end
        };
      }
    }
  }, {
    key: 'update',
    value: function update(mutations, context) {
      var _this2 = this;

      if (mutations.some(function (mutation) {
        return mutation.type === 'characterData' && mutation.target === _this2.textNode;
      })) {
        var range = this.restore();
        if (range) context.range = range;
      }
    }
  }, {
    key: 'value',
    value: function value() {
      return '';
    }
  }]);

  return Cursor;
}(_parchment2.default.Embed);

Cursor.blotName = 'cursor';
Cursor.className = 'ql-cursor';
Cursor.tagName = 'span';
Cursor.CONTENTS = '\uFEFF'; // Zero width no break space


exports.default = Cursor;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _block = __webpack_require__(4);

var _block2 = _interopRequireDefault(_block);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_Parchment$Container) {
  _inherits(Container, _Parchment$Container);

  function Container() {
    _classCallCheck(this, Container);

    return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));
  }

  return Container;
}(_parchment2.default.Container);

Container.allowedChildren = [_block2.default, _block.BlockEmbed, Container];

exports.default = Container;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorStyle = exports.ColorClass = exports.ColorAttributor = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ColorAttributor = function (_Parchment$Attributor) {
  _inherits(ColorAttributor, _Parchment$Attributor);

  function ColorAttributor() {
    _classCallCheck(this, ColorAttributor);

    return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));
  }

  _createClass(ColorAttributor, [{
    key: 'value',
    value: function value(domNode) {
      var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), 'value', this).call(this, domNode);
      if (!value.startsWith('rgb(')) return value;
      value = value.replace(/^[^\d]+/, '').replace(/[^\d]+$/, '');
      return '#' + value.split(',').map(function (component) {
        return ('00' + parseInt(component).toString(16)).slice(-2);
      }).join('');
    }
  }]);

  return ColorAttributor;
}(_parchment2.default.Attributor.Style);

var ColorClass = new _parchment2.default.Attributor.Class('color', 'ql-color', {
  scope: _parchment2.default.Scope.INLINE
});
var ColorStyle = new ColorAttributor('color', 'color', {
  scope: _parchment2.default.Scope.INLINE
});

exports.ColorAttributor = ColorAttributor;
exports.ColorClass = ColorClass;
exports.ColorStyle = ColorStyle;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sanitize = exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inline = __webpack_require__(6);

var _inline2 = _interopRequireDefault(_inline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Link = function (_Inline) {
  _inherits(Link, _Inline);

  function Link() {
    _classCallCheck(this, Link);

    return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));
  }

  _createClass(Link, [{
    key: 'format',
    value: function format(name, value) {
      if (name !== this.statics.blotName || !value) return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), 'format', this).call(this, name, value);
      value = this.constructor.sanitize(value);
      this.domNode.setAttribute('href', value);
    }
  }], [{
    key: 'create',
    value: function create(value) {
      var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), 'create', this).call(this, value);
      value = this.sanitize(value);
      node.setAttribute('href', value);
      node.setAttribute('rel', 'noopener noreferrer');
      node.setAttribute('target', '_blank');
      return node;
    }
  }, {
    key: 'formats',
    value: function formats(domNode) {
      return domNode.getAttribute('href');
    }
  }, {
    key: 'sanitize',
    value: function sanitize(url) {
      return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
    }
  }]);

  return Link;
}(_inline2.default);

Link.blotName = 'link';
Link.tagName = 'A';
Link.SANITIZED_URL = 'about:blank';
Link.PROTOCOL_WHITELIST = ['http', 'https', 'mailto', 'tel'];

function _sanitize(url, protocols) {
  var anchor = document.createElement('a');
  anchor.href = url;
  var protocol = anchor.href.slice(0, anchor.href.indexOf(':'));
  return protocols.indexOf(protocol) > -1;
}

exports.default = Link;
exports.sanitize = _sanitize;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _keyboard = __webpack_require__(23);

var _keyboard2 = _interopRequireDefault(_keyboard);

var _dropdown = __webpack_require__(107);

var _dropdown2 = _interopRequireDefault(_dropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var optionsCounter = 0;

function toggleAriaAttribute(element, attribute) {
  element.setAttribute(attribute, !(element.getAttribute(attribute) === 'true'));
}

var Picker = function () {
  function Picker(select) {
    var _this = this;

    _classCallCheck(this, Picker);

    this.select = select;
    this.container = document.createElement('span');
    this.buildPicker();
    this.select.style.display = 'none';
    this.select.parentNode.insertBefore(this.container, this.select);

    this.label.addEventListener('mousedown', function () {
      _this.togglePicker();
    });
    this.label.addEventListener('keydown', function (event) {
      switch (event.keyCode) {
        // Allows the "Enter" key to open the picker
        case _keyboard2.default.keys.ENTER:
          _this.togglePicker();
          break;

        // Allows the "Escape" key to close the picker
        case _keyboard2.default.keys.ESCAPE:
          _this.escape();
          event.preventDefault();
          break;
      }
    });
    this.select.addEventListener('change', this.update.bind(this));
  }

  _createClass(Picker, [{
    key: 'togglePicker',
    value: function togglePicker() {
      this.container.classList.toggle('ql-expanded');
      // Toggle aria-expanded and aria-hidden to make the picker accessible
      toggleAriaAttribute(this.label, 'aria-expanded');
      toggleAriaAttribute(this.options, 'aria-hidden');
    }
  }, {
    key: 'buildItem',
    value: function buildItem(option) {
      var _this2 = this;

      var item = document.createElement('span');
      item.tabIndex = '0';
      item.setAttribute('role', 'button');

      item.classList.add('ql-picker-item');
      if (option.hasAttribute('value')) {
        item.setAttribute('data-value', option.getAttribute('value'));
      }
      if (option.textContent) {
        item.setAttribute('data-label', option.textContent);
      }
      item.addEventListener('click', function () {
        _this2.selectItem(item, true);
      });
      item.addEventListener('keydown', function (event) {
        switch (event.keyCode) {
          // Allows the "Enter" key to select an item
          case _keyboard2.default.keys.ENTER:
            _this2.selectItem(item, true);
            event.preventDefault();
            break;

          // Allows the "Escape" key to close the picker
          case _keyboard2.default.keys.ESCAPE:
            _this2.escape();
            event.preventDefault();
            break;
        }
      });

      return item;
    }
  }, {
    key: 'buildLabel',
    value: function buildLabel() {
      var label = document.createElement('span');
      label.classList.add('ql-picker-label');
      label.innerHTML = _dropdown2.default;
      label.tabIndex = '0';
      label.setAttribute('role', 'button');
      label.setAttribute('aria-expanded', 'false');
      this.container.appendChild(label);
      return label;
    }
  }, {
    key: 'buildOptions',
    value: function buildOptions() {
      var _this3 = this;

      var options = document.createElement('span');
      options.classList.add('ql-picker-options');

      // Don't want screen readers to read this until options are visible
      options.setAttribute('aria-hidden', 'true');
      options.tabIndex = '-1';

      // Need a unique id for aria-controls
      options.id = 'ql-picker-options-' + optionsCounter;
      optionsCounter += 1;
      this.label.setAttribute('aria-controls', options.id);

      this.options = options;

      [].slice.call(this.select.options).forEach(function (option) {
        var item = _this3.buildItem(option);
        options.appendChild(item);
        if (option.selected === true) {
          _this3.selectItem(item);
        }
      });
      this.container.appendChild(options);
    }
  }, {
    key: 'buildPicker',
    value: function buildPicker() {
      var _this4 = this;

      [].slice.call(this.select.attributes).forEach(function (item) {
        _this4.container.setAttribute(item.name, item.value);
      });
      this.container.classList.add('ql-picker');
      this.label = this.buildLabel();
      this.buildOptions();
    }
  }, {
    key: 'escape',
    value: function escape() {
      var _this5 = this;

      // Close menu and return focus to trigger label
      this.close();
      // Need setTimeout for accessibility to ensure that the browser executes
      // focus on the next process thread and after any DOM content changes
      setTimeout(function () {
        return _this5.label.focus();
      }, 1);
    }
  }, {
    key: 'close',
    value: function close() {
      this.container.classList.remove('ql-expanded');
      this.label.setAttribute('aria-expanded', 'false');
      this.options.setAttribute('aria-hidden', 'true');
    }
  }, {
    key: 'selectItem',
    value: function selectItem(item) {
      var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var selected = this.container.querySelector('.ql-selected');
      if (item === selected) return;
      if (selected != null) {
        selected.classList.remove('ql-selected');
      }
      if (item == null) return;
      item.classList.add('ql-selected');
      this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);
      if (item.hasAttribute('data-value')) {
        this.label.setAttribute('data-value', item.getAttribute('data-value'));
      } else {
        this.label.removeAttribute('data-value');
      }
      if (item.hasAttribute('data-label')) {
        this.label.setAttribute('data-label', item.getAttribute('data-label'));
      } else {
        this.label.removeAttribute('data-label');
      }
      if (trigger) {
        if (typeof Event === 'function') {
          this.select.dispatchEvent(new Event('change'));
        } else if ((typeof Event === 'undefined' ? 'undefined' : _typeof(Event)) === 'object') {
          // IE11
          var event = document.createEvent('Event');
          event.initEvent('change', true, true);
          this.select.dispatchEvent(event);
        }
        this.close();
      }
    }
  }, {
    key: 'update',
    value: function update() {
      var option = void 0;
      if (this.select.selectedIndex > -1) {
        var item = this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];
        option = this.select.options[this.select.selectedIndex];
        this.selectItem(item);
      } else {
        this.selectItem(null);
      }
      var isActive = option != null && option !== this.select.querySelector('option[selected]');
      this.label.classList.toggle('ql-active', isActive);
    }
  }]);

  return Picker;
}();

exports.default = Picker;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __webpack_require__(5);

var _quill2 = _interopRequireDefault(_quill);

var _block = __webpack_require__(4);

var _block2 = _interopRequireDefault(_block);

var _break = __webpack_require__(16);

var _break2 = _interopRequireDefault(_break);

var _container = __webpack_require__(25);

var _container2 = _interopRequireDefault(_container);

var _cursor = __webpack_require__(24);

var _cursor2 = _interopRequireDefault(_cursor);

var _embed = __webpack_require__(35);

var _embed2 = _interopRequireDefault(_embed);

var _inline = __webpack_require__(6);

var _inline2 = _interopRequireDefault(_inline);

var _scroll = __webpack_require__(22);

var _scroll2 = _interopRequireDefault(_scroll);

var _text = __webpack_require__(7);

var _text2 = _interopRequireDefault(_text);

var _clipboard = __webpack_require__(55);

var _clipboard2 = _interopRequireDefault(_clipboard);

var _history = __webpack_require__(42);

var _history2 = _interopRequireDefault(_history);

var _keyboard = __webpack_require__(23);

var _keyboard2 = _interopRequireDefault(_keyboard);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_quill2.default.register({
  'blots/block': _block2.default,
  'blots/block/embed': _block.BlockEmbed,
  'blots/break': _break2.default,
  'blots/container': _container2.default,
  'blots/cursor': _cursor2.default,
  'blots/embed': _embed2.default,
  'blots/inline': _inline2.default,
  'blots/scroll': _scroll2.default,
  'blots/text': _text2.default,

  'modules/clipboard': _clipboard2.default,
  'modules/history': _history2.default,
  'modules/keyboard': _keyboard2.default
});

_parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);

exports.default = _quill2.default;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var Registry = __webpack_require__(1);
var ShadowBlot = /** @class */ (function () {
    function ShadowBlot(domNode) {
        this.domNode = domNode;
        // @ts-ignore
        this.domNode[Registry.DATA_KEY] = { blot: this };
    }
    Object.defineProperty(ShadowBlot.prototype, "statics", {
        // Hack for accessing inherited static methods
        get: function () {
            return this.constructor;
        },
        enumerable: true,
        configurable: true
    });
    ShadowBlot.create = function (value) {
        if (this.tagName == null) {
            throw new Registry.ParchmentError('Blot definition missing tagName');
        }
        var node;
        if (Array.isArray(this.tagName)) {
            if (typeof value === 'string') {
                value = value.toUpperCase();
                if (parseInt(value).toString() === value) {
                    value = parseInt(value);
                }
            }
            if (typeof value === 'number') {
                node = document.createElement(this.tagName[value - 1]);
            }
            else if (this.tagName.indexOf(value) > -1) {
                node = document.createElement(value);
            }
            else {
                node = document.createElement(this.tagName[0]);
            }
        }
        else {
            node = document.createElement(this.tagName);
        }
        if (this.className) {
            node.classList.add(this.className);
        }
        return node;
    };
    ShadowBlot.prototype.attach = function () {
        if (this.parent != null) {
            this.scroll = this.parent.scroll;
        }
    };
    ShadowBlot.prototype.clone = function () {
        var domNode = this.domNode.cloneNode(false);
        return Registry.create(domNode);
    };
    ShadowBlot.prototype.detach = function () {
        if (this.parent != null)
            this.parent.removeChild(this);
        // @ts-ignore
        delete this.domNode[Registry.DATA_KEY];
    };
    ShadowBlot.prototype.deleteAt = function (index, length) {
        var blot = this.isolate(index, length);
        blot.remove();
    };
    ShadowBlot.prototype.formatAt = function (index, length, name, value) {
        var blot = this.isolate(index, length);
        if (Registry.query(name, Registry.Scope.BLOT) != null && value) {
            blot.wrap(name, value);
        }
        else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {
            var parent = Registry.create(this.statics.scope);
            blot.wrap(parent);
            parent.format(name, value);
        }
    };
    ShadowBlot.prototype.insertAt = function (index, value, def) {
        var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
        var ref = this.split(index);
        this.parent.insertBefore(blot, ref);
    };
    ShadowBlot.prototype.insertInto = function (parentBlot, refBlot) {
        if (refBlot === void 0) { refBlot = null; }
        if (this.parent != null) {
            this.parent.children.remove(this);
        }
        var refDomNode = null;
        parentBlot.children.insertBefore(this, refBlot);
        if (refBlot != null) {
            refDomNode = refBlot.domNode;
        }
        if (this.domNode.parentNode != parentBlot.domNode ||
            this.domNode.nextSibling != refDomNode) {
            parentBlot.domNode.insertBefore(this.domNode, refDomNode);
        }
        this.parent = parentBlot;
        this.attach();
    };
    ShadowBlot.prototype.isolate = function (index, length) {
        var target = this.split(index);
        target.split(length);
        return target;
    };
    ShadowBlot.prototype.length = function () {
        return 1;
    };
    ShadowBlot.prototype.offset = function (root) {
        if (root === void 0) { root = this.parent; }
        if (this.parent == null || this == root)
            return 0;
        return this.parent.children.offset(this) + this.parent.offset(root);
    };
    ShadowBlot.prototype.optimize = function (context) {
        // TODO clean up once we use WeakMap
        // @ts-ignore
        if (this.domNode[Registry.DATA_KEY] != null) {
            // @ts-ignore
            delete this.domNode[Registry.DATA_KEY].mutations;
        }
    };
    ShadowBlot.prototype.remove = function () {
        if (this.domNode.parentNode != null) {
            this.domNode.parentNode.removeChild(this.domNode);
        }
        this.detach();
    };
    ShadowBlot.prototype.replace = function (target) {
        if (target.parent == null)
            return;
        target.parent.insertBefore(this, target.next);
        target.remove();
    };
    ShadowBlot.prototype.replaceWith = function (name, value) {
        var replacement = typeof name === 'string' ? Registry.create(name, value) : name;
        replacement.replace(this);
        return replacement;
    };
    ShadowBlot.prototype.split = function (index, force) {
        return index === 0 ? this : this.next;
    };
    ShadowBlot.prototype.update = function (mutations, context) {
        // Nothing to do by default
    };
    ShadowBlot.prototype.wrap = function (name, value) {
        var wrapper = typeof name === 'string' ? Registry.create(name, value) : name;
        if (this.parent != null) {
            this.parent.insertBefore(wrapper, this.next);
        }
        wrapper.appendChild(this);
        return wrapper;
    };
    ShadowBlot.blotName = 'abstract';
    return ShadowBlot;
}());
exports.default = ShadowBlot;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var attributor_1 = __webpack_require__(12);
var class_1 = __webpack_require__(32);
var style_1 = __webpack_require__(33);
var Registry = __webpack_require__(1);
var AttributorStore = /** @class */ (function () {
    function AttributorStore(domNode) {
        this.attributes = {};
        this.domNode = domNode;
        this.build();
    }
    AttributorStore.prototype.attribute = function (attribute, value) {
        // verb
        if (value) {
            if (attribute.add(this.domNode, value)) {
                if (attribute.value(this.domNode) != null) {
                    this.attributes[attribute.attrName] = attribute;
                }
                else {
                    delete this.attributes[attribute.attrName];
                }
            }
        }
        else {
            attribute.remove(this.domNode);
            delete this.attributes[attribute.attrName];
        }
    };
    AttributorStore.prototype.build = function () {
        var _this = this;
        this.attributes = {};
        var attributes = attributor_1.default.keys(this.domNode);
        var classes = class_1.default.keys(this.domNode);
        var styles = style_1.default.keys(this.domNode);
        attributes
            .concat(classes)
            .concat(styles)
            .forEach(function (name) {
            var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);
            if (attr instanceof attributor_1.default) {
                _this.attributes[attr.attrName] = attr;
            }
        });
    };
    AttributorStore.prototype.copy = function (target) {
        var _this = this;
        Object.keys(this.attributes).forEach(function (key) {
            var value = _this.attributes[key].value(_this.domNode);
            target.format(key, value);
        });
    };
    AttributorStore.prototype.move = function (target) {
        var _this = this;
        this.copy(target);
        Object.keys(this.attributes).forEach(function (key) {
            _this.attributes[key].remove(_this.domNode);
        });
        this.attributes = {};
    };
    AttributorStore.prototype.values = function () {
        var _this = this;
        return Object.keys(this.attributes).reduce(function (attributes, name) {
            attributes[name] = _this.attributes[name].value(_this.domNode);
            return attributes;
        }, {});
    };
    return AttributorStore;
}());
exports.default = AttributorStore;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var attributor_1 = __webpack_require__(12);
function match(node, prefix) {
    var className = node.getAttribute('class') || '';
    return className.split(/\s+/).filter(function (name) {
        return name.indexOf(prefix + "-") === 0;
    });
}
var ClassAttributor = /** @class */ (function (_super) {
    __extends(ClassAttributor, _super);
    function ClassAttributor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ClassAttributor.keys = function (node) {
        return (node.getAttribute('class') || '').split(/\s+/).map(function (name) {
            return name
                .split('-')
                .slice(0, -1)
                .join('-');
        });
    };
    ClassAttributor.prototype.add = function (node, value) {
        if (!this.canAdd(node, value))
            return false;
        this.remove(node);
        node.classList.add(this.keyName + "-" + value);
        return true;
    };
    ClassAttributor.prototype.remove = function (node) {
        var matches = match(node, this.keyName);
        matches.forEach(function (name) {
            node.classList.remove(name);
        });
        if (node.classList.length === 0) {
            node.removeAttribute('class');
        }
    };
    ClassAttributor.prototype.value = function (node) {
        var result = match(node, this.keyName)[0] || '';
        var value = result.slice(this.keyName.length + 1); // +1 for hyphen
        return this.canAdd(node, value) ? value : '';
    };
    return ClassAttributor;
}(attributor_1.default));
exports.default = ClassAttributor;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var attributor_1 = __webpack_require__(12);
function camelize(name) {
    var parts = name.split('-');
    var rest = parts
        .slice(1)
        .map(function (part) {
        return part[0].toUpperCase() + part.slice(1);
    })
        .join('');
    return parts[0] + rest;
}
var StyleAttributor = /** @class */ (function (_super) {
    __extends(StyleAttributor, _super);
    function StyleAttributor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StyleAttributor.keys = function (node) {
        return (node.getAttribute('style') || '').split(';').map(function (value) {
            var arr = value.split(':');
            return arr[0].trim();
        });
    };
    StyleAttributor.prototype.add = function (node, value) {
        if (!this.canAdd(node, value))
            return false;
        // @ts-ignore
        node.style[camelize(this.keyName)] = value;
        return true;
    };
    StyleAttributor.prototype.remove = function (node) {
        // @ts-ignore
        node.style[camelize(this.keyName)] = '';
        if (!node.getAttribute('style')) {
            node.removeAttribute('style');
        }
    };
    StyleAttributor.prototype.value = function (node) {
        // @ts-ignore
        var value = node.style[camelize(this.keyName)];
        return this.canAdd(node, value) ? value : '';
    };
    return StyleAttributor;
}(attributor_1.default));
exports.default = StyleAttributor;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Theme = function () {
  function Theme(quill, options) {
    _classCallCheck(this, Theme);

    this.quill = quill;
    this.options = options;
    this.modules = {};
  }

  _createClass(Theme, [{
    key: 'init',
    value: function init() {
      var _this = this;

      Object.keys(this.options.modules).forEach(function (name) {
        if (_this.modules[name] == null) {
          _this.addModule(name);
        }
      });
    }
  }, {
    key: 'addModule',
    value: function addModule(name) {
      var moduleClass = this.quill.constructor.import('modules/' + name);
      this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});
      return this.modules[name];
    }
  }]);

  return Theme;
}();

Theme.DEFAULTS = {
  modules: {}
};
Theme.themes = {
  'default': Theme
};

exports.default = Theme;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _text = __webpack_require__(7);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GUARD_TEXT = '\uFEFF';

var Embed = function (_Parchment$Embed) {
  _inherits(Embed, _Parchment$Embed);

  function Embed(node) {
    _classCallCheck(this, Embed);

    var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));

    _this.contentNode = document.createElement('span');
    _this.contentNode.setAttribute('contenteditable', false);
    [].slice.call(_this.domNode.childNodes).forEach(function (childNode) {
      _this.contentNode.appendChild(childNode);
    });
    _this.leftGuard = document.createTextNode(GUARD_TEXT);
    _this.rightGuard = document.createTextNode(GUARD_TEXT);
    _this.domNode.appendChild(_this.leftGuard);
    _this.domNode.appendChild(_this.contentNode);
    _this.domNode.appendChild(_this.rightGuard);
    return _this;
  }

  _createClass(Embed, [{
    key: 'index',
    value: function index(node, offset) {
      if (node === this.leftGuard) return 0;
      if (node === this.rightGuard) return 1;
      return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), 'index', this).call(this, node, offset);
    }
  }, {
    key: 'restore',
    value: function restore(node) {
      var range = void 0,
          textNode = void 0;
      var text = node.data.split(GUARD_TEXT).join('');
      if (node === this.leftGuard) {
        if (this.prev instanceof _text2.default) {
          var prevLength = this.prev.length();
          this.prev.insertAt(prevLength, text);
          range = {
            startNode: this.prev.domNode,
            startOffset: prevLength + text.length
          };
        } else {
          textNode = document.createTextNode(text);
          this.parent.insertBefore(_parchment2.default.create(textNode), this);
          range = {
            startNode: textNode,
            startOffset: text.length
          };
        }
      } else if (node === this.rightGuard) {
        if (this.next instanceof _text2.default) {
          this.next.insertAt(0, text);
          range = {
            startNode: this.next.domNode,
            startOffset: text.length
          };
        } else {
          textNode = document.createTextNode(text);
          this.parent.insertBefore(_parchment2.default.create(textNode), this.next);
          range = {
            startNode: textNode,
            startOffset: text.length
          };
        }
      }
      node.data = GUARD_TEXT;
      return range;
    }
  }, {
    key: 'update',
    value: function update(mutations, context) {
      var _this2 = this;

      mutations.forEach(function (mutation) {
        if (mutation.type === 'characterData' && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
          var range = _this2.restore(mutation.target);
          if (range) context.range = range;
        }
      });
    }
  }]);

  return Embed;
}(_parchment2.default.Embed);

exports.default = Embed;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlignStyle = exports.AlignClass = exports.AlignAttribute = undefined;

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var config = {
  scope: _parchment2.default.Scope.BLOCK,
  whitelist: ['right', 'center', 'justify']
};

var AlignAttribute = new _parchment2.default.Attributor.Attribute('align', 'align', config);
var AlignClass = new _parchment2.default.Attributor.Class('align', 'ql-align', config);
var AlignStyle = new _parchment2.default.Attributor.Style('align', 'text-align', config);

exports.AlignAttribute = AlignAttribute;
exports.AlignClass = AlignClass;
exports.AlignStyle = AlignStyle;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BackgroundStyle = exports.BackgroundClass = undefined;

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _color = __webpack_require__(26);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BackgroundClass = new _parchment2.default.Attributor.Class('background', 'ql-bg', {
  scope: _parchment2.default.Scope.INLINE
});
var BackgroundStyle = new _color.ColorAttributor('background', 'background-color', {
  scope: _parchment2.default.Scope.INLINE
});

exports.BackgroundClass = BackgroundClass;
exports.BackgroundStyle = BackgroundStyle;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DirectionStyle = exports.DirectionClass = exports.DirectionAttribute = undefined;

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var config = {
  scope: _parchment2.default.Scope.BLOCK,
  whitelist: ['rtl']
};

var DirectionAttribute = new _parchment2.default.Attributor.Attribute('direction', 'dir', config);
var DirectionClass = new _parchment2.default.Attributor.Class('direction', 'ql-direction', config);
var DirectionStyle = new _parchment2.default.Attributor.Style('direction', 'direction', config);

exports.DirectionAttribute = DirectionAttribute;
exports.DirectionClass = DirectionClass;
exports.DirectionStyle = DirectionStyle;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FontClass = exports.FontStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var config = {
  scope: _parchment2.default.Scope.INLINE,
  whitelist: ['serif', 'monospace']
};

var FontClass = new _parchment2.default.Attributor.Class('font', 'ql-font', config);

var FontStyleAttributor = function (_Parchment$Attributor) {
  _inherits(FontStyleAttributor, _Parchment$Attributor);

  function FontStyleAttributor() {
    _classCallCheck(this, FontStyleAttributor);

    return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));
  }

  _createClass(FontStyleAttributor, [{
    key: 'value',
    value: function value(node) {
      return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), 'value', this).call(this, node).replace(/["']/g, '');
    }
  }]);

  return FontStyleAttributor;
}(_parchment2.default.Attributor.Style);

var FontStyle = new FontStyleAttributor('font', 'font-family', config);

exports.FontStyle = FontStyle;
exports.FontClass = FontClass;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SizeStyle = exports.SizeClass = undefined;

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SizeClass = new _parchment2.default.Attributor.Class('size', 'ql-size', {
  scope: _parchment2.default.Scope.INLINE,
  whitelist: ['small', 'large', 'huge']
});
var SizeStyle = new _parchment2.default.Attributor.Style('size', 'font-size', {
  scope: _parchment2.default.Scope.INLINE,
  whitelist: ['10px', '18px', '32px']
});

exports.SizeClass = SizeClass;
exports.SizeStyle = SizeStyle;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = {
  'align': {
    '': __webpack_require__(76),
    'center': __webpack_require__(77),
    'right': __webpack_require__(78),
    'justify': __webpack_require__(79)
  },
  'background': __webpack_require__(80),
  'blockquote': __webpack_require__(81),
  'bold': __webpack_require__(82),
  'clean': __webpack_require__(83),
  'code': __webpack_require__(58),
  'code-block': __webpack_require__(58),
  'color': __webpack_require__(84),
  'direction': {
    '': __webpack_require__(85),
    'rtl': __webpack_require__(86)
  },
  'float': {
    'center': __webpack_require__(87),
    'full': __webpack_require__(88),
    'left': __webpack_require__(89),
    'right': __webpack_require__(90)
  },
  'formula': __webpack_require__(91),
  'header': {
    '1': __webpack_require__(92),
    '2': __webpack_require__(93)
  },
  'italic': __webpack_require__(94),
  'image': __webpack_require__(95),
  'indent': {
    '+1': __webpack_require__(96),
    '-1': __webpack_require__(97)
  },
  'link': __webpack_require__(98),
  'list': {
    'ordered': __webpack_require__(99),
    'bullet': __webpack_require__(100),
    'check': __webpack_require__(101)
  },
  'script': {
    'sub': __webpack_require__(102),
    'super': __webpack_require__(103)
  },
  'strike': __webpack_require__(104),
  'underline': __webpack_require__(105),
  'video': __webpack_require__(106)
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLastChangeIndex = exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __webpack_require__(5);

var _quill2 = _interopRequireDefault(_quill);

var _module = __webpack_require__(9);

var _module2 = _interopRequireDefault(_module);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var History = function (_Module) {
  _inherits(History, _Module);

  function History(quill, options) {
    _classCallCheck(this, History);

    var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));

    _this.lastRecorded = 0;
    _this.ignoreChange = false;
    _this.clear();
    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (eventName, delta, oldDelta, source) {
      if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange) return;
      if (!_this.options.userOnly || source === _quill2.default.sources.USER) {
        _this.record(delta, oldDelta);
      } else {
        _this.transform(delta);
      }
    });
    _this.quill.keyboard.addBinding({ key: 'Z', shortKey: true }, _this.undo.bind(_this));
    _this.quill.keyboard.addBinding({ key: 'Z', shortKey: true, shiftKey: true }, _this.redo.bind(_this));
    if (/Win/i.test(navigator.platform)) {
      _this.quill.keyboard.addBinding({ key: 'Y', shortKey: true }, _this.redo.bind(_this));
    }
    return _this;
  }

  _createClass(History, [{
    key: 'change',
    value: function change(source, dest) {
      if (this.stack[source].length === 0) return;
      var delta = this.stack[source].pop();
      this.stack[dest].push(delta);
      this.lastRecorded = 0;
      this.ignoreChange = true;
      this.quill.updateContents(delta[source], _quill2.default.sources.USER);
      this.ignoreChange = false;
      var index = getLastChangeIndex(delta[source]);
      this.quill.setSelection(index);
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.stack = { undo: [], redo: [] };
    }
  }, {
    key: 'cutoff',
    value: function cutoff() {
      this.lastRecorded = 0;
    }
  }, {
    key: 'record',
    value: function record(changeDelta, oldDelta) {
      if (changeDelta.ops.length === 0) return;
      this.stack.redo = [];
      var undoDelta = this.quill.getContents().diff(oldDelta);
      var timestamp = Date.now();
      if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
        var delta = this.stack.undo.pop();
        undoDelta = undoDelta.compose(delta.undo);
        changeDelta = delta.redo.compose(changeDelta);
      } else {
        this.lastRecorded = timestamp;
      }
      this.stack.undo.push({
        redo: changeDelta,
        undo: undoDelta
      });
      if (this.stack.undo.length > this.options.maxStack) {
        this.stack.undo.shift();
      }
    }
  }, {
    key: 'redo',
    value: function redo() {
      this.change('redo', 'undo');
    }
  }, {
    key: 'transform',
    value: function transform(delta) {
      this.stack.undo.forEach(function (change) {
        change.undo = delta.transform(change.undo, true);
        change.redo = delta.transform(change.redo, true);
      });
      this.stack.redo.forEach(function (change) {
        change.undo = delta.transform(change.undo, true);
        change.redo = delta.transform(change.redo, true);
      });
    }
  }, {
    key: 'undo',
    value: function undo() {
      this.change('undo', 'redo');
    }
  }]);

  return History;
}(_module2.default);

History.DEFAULTS = {
  delay: 1000,
  maxStack: 100,
  userOnly: false
};

function endsWithNewlineChange(delta) {
  var lastOp = delta.ops[delta.ops.length - 1];
  if (lastOp == null) return false;
  if (lastOp.insert != null) {
    return typeof lastOp.insert === 'string' && lastOp.insert.endsWith('\n');
  }
  if (lastOp.attributes != null) {
    return Object.keys(lastOp.attributes).some(function (attr) {
      return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;
    });
  }
  return false;
}

function getLastChangeIndex(delta) {
  var deleteLength = delta.reduce(function (length, op) {
    length += op.delete || 0;
    return length;
  }, 0);
  var changeIndex = delta.length() - deleteLength;
  if (endsWithNewlineChange(delta)) {
    changeIndex -= 1;
  }
  return changeIndex;
}

exports.default = History;
exports.getLastChangeIndex = getLastChangeIndex;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BaseTooltip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _extend = __webpack_require__(3);

var _extend2 = _interopRequireDefault(_extend);

var _quillDelta = __webpack_require__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _emitter = __webpack_require__(8);

var _emitter2 = _interopRequireDefault(_emitter);

var _keyboard = __webpack_require__(23);

var _keyboard2 = _interopRequireDefault(_keyboard);

var _theme = __webpack_require__(34);

var _theme2 = _interopRequireDefault(_theme);

var _colorPicker = __webpack_require__(59);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _iconPicker = __webpack_require__(60);

var _iconPicker2 = _interopRequireDefault(_iconPicker);

var _picker = __webpack_require__(28);

var _picker2 = _interopRequireDefault(_picker);

var _tooltip = __webpack_require__(61);

var _tooltip2 = _interopRequireDefault(_tooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ALIGNS = [false, 'center', 'right', 'justify'];

var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];

var FONTS = [false, 'serif', 'monospace'];

var HEADERS = ['1', '2', '3', false];

var SIZES = ['small', false, 'large', 'huge'];

var BaseTheme = function (_Theme) {
  _inherits(BaseTheme, _Theme);

  function BaseTheme(quill, options) {
    _classCallCheck(this, BaseTheme);

    var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));

    var listener = function listener(e) {
      if (!document.body.contains(quill.root)) {
        return document.body.removeEventListener('click', listener);
      }
      if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
        _this.tooltip.hide();
      }
      if (_this.pickers != null) {
        _this.pickers.forEach(function (picker) {
          if (!picker.container.contains(e.target)) {
            picker.close();
          }
        });
      }
    };
    quill.emitter.listenDOM('click', document.body, listener);
    return _this;
  }

  _createClass(BaseTheme, [{
    key: 'addModule',
    value: function addModule(name) {
      var module = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), 'addModule', this).call(this, name);
      if (name === 'toolbar') {
        this.extendToolbar(module);
      }
      return module;
    }
  }, {
    key: 'buildButtons',
    value: function buildButtons(buttons, icons) {
      buttons.forEach(function (button) {
        var className = button.getAttribute('class') || '';
        className.split(/\s+/).forEach(function (name) {
          if (!name.startsWith('ql-')) return;
          name = name.slice('ql-'.length);
          if (icons[name] == null) return;
          if (name === 'direction') {
            button.innerHTML = icons[name][''] + icons[name]['rtl'];
          } else if (typeof icons[name] === 'string') {
            button.innerHTML = icons[name];
          } else {
            var value = button.value || '';
            if (value != null && icons[name][value]) {
              button.innerHTML = icons[name][value];
            }
          }
        });
      });
    }
  }, {
    key: 'buildPickers',
    value: function buildPickers(selects, icons) {
      var _this2 = this;

      this.pickers = selects.map(function (select) {
        if (select.classList.contains('ql-align')) {
          if (select.querySelector('option') == null) {
            fillSelect(select, ALIGNS);
          }
          return new _iconPicker2.default(select, icons.align);
        } else if (select.classList.contains('ql-background') || select.classList.contains('ql-color')) {
          var format = select.classList.contains('ql-background') ? 'background' : 'color';
          if (select.querySelector('option') == null) {
            fillSelect(select, COLORS, format === 'background' ? '#ffffff' : '#000000');
          }
          return new _colorPicker2.default(select, icons[format]);
        } else {
          if (select.querySelector('option') == null) {
            if (select.classList.contains('ql-font')) {
              fillSelect(select, FONTS);
            } else if (select.classList.contains('ql-header')) {
              fillSelect(select, HEADERS);
            } else if (select.classList.contains('ql-size')) {
              fillSelect(select, SIZES);
            }
          }
          return new _picker2.default(select);
        }
      });
      var update = function update() {
        _this2.pickers.forEach(function (picker) {
          picker.update();
        });
      };
      this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);
    }
  }]);

  return BaseTheme;
}(_theme2.default);

BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        formula: function formula() {
          this.quill.theme.tooltip.edit('formula');
        },
        image: function image() {
          var _this3 = this;

          var fileInput = this.container.querySelector('input.ql-image[type=file]');
          if (fileInput == null) {
            fileInput = document.createElement('input');
            fileInput.setAttribute('type', 'file');
            fileInput.setAttribute('accept', 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon');
            fileInput.classList.add('ql-image');
            fileInput.addEventListener('change', function () {
              if (fileInput.files != null && fileInput.files[0] != null) {
                var reader = new FileReader();
                reader.onload = function (e) {
                  var range = _this3.quill.getSelection(true);
                  _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({ image: e.target.result }), _emitter2.default.sources.USER);
                  _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);
                  fileInput.value = "";
                };
                reader.readAsDataURL(fileInput.files[0]);
              }
            });
            this.container.appendChild(fileInput);
          }
          fileInput.click();
        },
        video: function video() {
          this.quill.theme.tooltip.edit('video');
        }
      }
    }
  }
});

var BaseTooltip = function (_Tooltip) {
  _inherits(BaseTooltip, _Tooltip);

  function BaseTooltip(quill, boundsContainer) {
    _classCallCheck(this, BaseTooltip);

    var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));

    _this4.textbox = _this4.root.querySelector('input[type="text"]');
    _this4.listen();
    return _this4;
  }

  _createClass(BaseTooltip, [{
    key: 'listen',
    value: function listen() {
      var _this5 = this;

      this.textbox.addEventListener('keydown', function (event) {
        if (_keyboard2.default.match(event, 'enter')) {
          _this5.save();
          event.preventDefault();
        } else if (_keyboard2.default.match(event, 'escape')) {
          _this5.cancel();
          event.preventDefault();
        }
      });
    }
  }, {
    key: 'cancel',
    value: function cancel() {
      this.hide();
    }
  }, {
    key: 'edit',
    value: function edit() {
      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'link';
      var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this.root.classList.remove('ql-hidden');
      this.root.classList.add('ql-editing');
      if (preview != null) {
        this.textbox.value = preview;
      } else if (mode !== this.root.getAttribute('data-mode')) {
        this.textbox.value = '';
      }
      this.position(this.quill.getBounds(this.quill.selection.savedRange));
      this.textbox.select();
      this.textbox.setAttribute('placeholder', this.textbox.getAttribute('data-' + mode) || '');
      this.root.setAttribute('data-mode', mode);
    }
  }, {
    key: 'restoreFocus',
    value: function restoreFocus() {
      var scrollTop = this.quill.scrollingContainer.scrollTop;
      this.quill.focus();
      this.quill.scrollingContainer.scrollTop = scrollTop;
    }
  }, {
    key: 'save',
    value: function save() {
      var value = this.textbox.value;
      switch (this.root.getAttribute('data-mode')) {
        case 'link':
          {
            var scrollTop = this.quill.root.scrollTop;
            if (this.linkRange) {
              this.quill.formatText(this.linkRange, 'link', value, _emitter2.default.sources.USER);
              delete this.linkRange;
            } else {
              this.restoreFocus();
              this.quill.format('link', value, _emitter2.default.sources.USER);
            }
            this.quill.root.scrollTop = scrollTop;
            break;
          }
        case 'video':
          {
            value = extractVideoUrl(value);
          } // eslint-disable-next-line no-fallthrough
        case 'formula':
          {
            if (!value) break;
            var range = this.quill.getSelection(true);
            if (range != null) {
              var index = range.index + range.length;
              this.quill.insertEmbed(index, this.root.getAttribute('data-mode'), value, _emitter2.default.sources.USER);
              if (this.root.getAttribute('data-mode') === 'formula') {
                this.quill.insertText(index + 1, ' ', _emitter2.default.sources.USER);
              }
              this.quill.setSelection(index + 2, _emitter2.default.sources.USER);
            }
            break;
          }
      }
      this.textbox.value = '';
      this.hide();
    }
  }]);

  return BaseTooltip;
}(_tooltip2.default);

function extractVideoUrl(url) {
  var match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
  if (match) {
    return (match[1] || 'https') + '://www.youtube.com/embed/' + match[2] + '?showinfo=0';
  }
  if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
    // eslint-disable-line no-cond-assign
    return (match[1] || 'https') + '://player.vimeo.com/video/' + match[2] + '/';
  }
  return url;
}

function fillSelect(select, values) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  values.forEach(function (value) {
    var option = document.createElement('option');
    if (value === defaultValue) {
      option.setAttribute('selected', 'selected');
    } else {
      option.setAttribute('value', value);
    }
    select.appendChild(option);
  });
}

exports.BaseTooltip = BaseTooltip;
exports.default = BaseTheme;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var LinkedList = /** @class */ (function () {
    function LinkedList() {
        this.head = this.tail = null;
        this.length = 0;
    }
    LinkedList.prototype.append = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        this.insertBefore(nodes[0], null);
        if (nodes.length > 1) {
            this.append.apply(this, nodes.slice(1));
        }
    };
    LinkedList.prototype.contains = function (node) {
        var cur, next = this.iterator();
        while ((cur = next())) {
            if (cur === node)
                return true;
        }
        return false;
    };
    LinkedList.prototype.insertBefore = function (node, refNode) {
        if (!node)
            return;
        node.next = refNode;
        if (refNode != null) {
            node.prev = refNode.prev;
            if (refNode.prev != null) {
                refNode.prev.next = node;
            }
            refNode.prev = node;
            if (refNode === this.head) {
                this.head = node;
            }
        }
        else if (this.tail != null) {
            this.tail.next = node;
            node.prev = this.tail;
            this.tail = node;
        }
        else {
            node.prev = null;
            this.head = this.tail = node;
        }
        this.length += 1;
    };
    LinkedList.prototype.offset = function (target) {
        var index = 0, cur = this.head;
        while (cur != null) {
            if (cur === target)
                return index;
            index += cur.length();
            cur = cur.next;
        }
        return -1;
    };
    LinkedList.prototype.remove = function (node) {
        if (!this.contains(node))
            return;
        if (node.prev != null)
            node.prev.next = node.next;
        if (node.next != null)
            node.next.prev = node.prev;
        if (node === this.head)
            this.head = node.next;
        if (node === this.tail)
            this.tail = node.prev;
        this.length -= 1;
    };
    LinkedList.prototype.iterator = function (curNode) {
        if (curNode === void 0) { curNode = this.head; }
        // TODO use yield when we can
        return function () {
            var ret = curNode;
            if (curNode != null)
                curNode = curNode.next;
            return ret;
        };
    };
    LinkedList.prototype.find = function (index, inclusive) {
        if (inclusive === void 0) { inclusive = false; }
        var cur, next = this.iterator();
        while ((cur = next())) {
            var length = cur.length();
            if (index < length ||
                (inclusive && index === length && (cur.next == null || cur.next.length() !== 0))) {
                return [cur, index];
            }
            index -= length;
        }
        return [null, 0];
    };
    LinkedList.prototype.forEach = function (callback) {
        var cur, next = this.iterator();
        while ((cur = next())) {
            callback(cur);
        }
    };
    LinkedList.prototype.forEachAt = function (index, length, callback) {
        if (length <= 0)
            return;
        var _a = this.find(index), startNode = _a[0], offset = _a[1];
        var cur, curIndex = index - offset, next = this.iterator(startNode);
        while ((cur = next()) && curIndex < index + length) {
            var curLength = cur.length();
            if (index > curIndex) {
                callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));
            }
            else {
                callback(cur, 0, Math.min(curLength, index + length - curIndex));
            }
            curIndex += curLength;
        }
    };
    LinkedList.prototype.map = function (callback) {
        return this.reduce(function (memo, cur) {
            memo.push(callback(cur));
            return memo;
        }, []);
    };
    LinkedList.prototype.reduce = function (callback, memo) {
        var cur, next = this.iterator();
        while ((cur = next())) {
            memo = callback(memo, cur);
        }
        return memo;
    };
    return LinkedList;
}());
exports.default = LinkedList;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var container_1 = __webpack_require__(17);
var Registry = __webpack_require__(1);
var OBSERVER_CONFIG = {
    attributes: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true,
};
var MAX_OPTIMIZE_ITERATIONS = 100;
var ScrollBlot = /** @class */ (function (_super) {
    __extends(ScrollBlot, _super);
    function ScrollBlot(node) {
        var _this = _super.call(this, node) || this;
        _this.scroll = _this;
        _this.observer = new MutationObserver(function (mutations) {
            _this.update(mutations);
        });
        _this.observer.observe(_this.domNode, OBSERVER_CONFIG);
        _this.attach();
        return _this;
    }
    ScrollBlot.prototype.detach = function () {
        _super.prototype.detach.call(this);
        this.observer.disconnect();
    };
    ScrollBlot.prototype.deleteAt = function (index, length) {
        this.update();
        if (index === 0 && length === this.length()) {
            this.children.forEach(function (child) {
                child.remove();
            });
        }
        else {
            _super.prototype.deleteAt.call(this, index, length);
        }
    };
    ScrollBlot.prototype.formatAt = function (index, length, name, value) {
        this.update();
        _super.prototype.formatAt.call(this, index, length, name, value);
    };
    ScrollBlot.prototype.insertAt = function (index, value, def) {
        this.update();
        _super.prototype.insertAt.call(this, index, value, def);
    };
    ScrollBlot.prototype.optimize = function (mutations, context) {
        var _this = this;
        if (mutations === void 0) { mutations = []; }
        if (context === void 0) { context = {}; }
        _super.prototype.optimize.call(this, context);
        // We must modify mutations directly, cannot make copy and then modify
        var records = [].slice.call(this.observer.takeRecords());
        // Array.push currently seems to be implemented by a non-tail recursive function
        // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());
        while (records.length > 0)
            mutations.push(records.pop());
        // TODO use WeakMap
        var mark = function (blot, markParent) {
            if (markParent === void 0) { markParent = true; }
            if (blot == null || blot === _this)
                return;
            if (blot.domNode.parentNode == null)
                return;
            // @ts-ignore
            if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY].mutations = [];
            }
            if (markParent)
                mark(blot.parent);
        };
        var optimize = function (blot) {
            // Post-order traversal
            if (
            // @ts-ignore
            blot.domNode[Registry.DATA_KEY] == null ||
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY].mutations == null) {
                return;
            }
            if (blot instanceof container_1.default) {
                blot.children.forEach(optimize);
            }
            blot.optimize(context);
        };
        var remaining = mutations;
        for (var i = 0; remaining.length > 0; i += 1) {
            if (i >= MAX_OPTIMIZE_ITERATIONS) {
                throw new Error('[Parchment] Maximum optimize iterations reached');
            }
            remaining.forEach(function (mutation) {
                var blot = Registry.find(mutation.target, true);
                if (blot == null)
                    return;
                if (blot.domNode === mutation.target) {
                    if (mutation.type === 'childList') {
                        mark(Registry.find(mutation.previousSibling, false));
                        [].forEach.call(mutation.addedNodes, function (node) {
                            var child = Registry.find(node, false);
                            mark(child, false);
                            if (child instanceof container_1.default) {
                                child.children.forEach(function (grandChild) {
                                    mark(grandChild, false);
                                });
                            }
                        });
                    }
                    else if (mutation.type === 'attributes') {
                        mark(blot.prev);
                    }
                }
                mark(blot);
            });
            this.children.forEach(optimize);
            remaining = [].slice.call(this.observer.takeRecords());
            records = remaining.slice();
            while (records.length > 0)
                mutations.push(records.pop());
        }
    };
    ScrollBlot.prototype.update = function (mutations, context) {
        var _this = this;
        if (context === void 0) { context = {}; }
        mutations = mutations || this.observer.takeRecords();
        // TODO use WeakMap
        mutations
            .map(function (mutation) {
            var blot = Registry.find(mutation.target, true);
            if (blot == null)
                return null;
            // @ts-ignore
            if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                return blot;
            }
            else {
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                return null;
            }
        })
            .forEach(function (blot) {
            if (blot == null ||
                blot === _this ||
                //@ts-ignore
                blot.domNode[Registry.DATA_KEY] == null)
                return;
            // @ts-ignore
            blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);
        });
        // @ts-ignore
        if (this.domNode[Registry.DATA_KEY].mutations != null) {
            // @ts-ignore
            _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);
        }
        this.optimize(mutations, context);
    };
    ScrollBlot.blotName = 'scroll';
    ScrollBlot.defaultChild = 'block';
    ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;
    ScrollBlot.tagName = 'DIV';
    return ScrollBlot;
}(container_1.default));
exports.default = ScrollBlot;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var format_1 = __webpack_require__(18);
var Registry = __webpack_require__(1);
// Shallow object comparison
function isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length)
        return false;
    // @ts-ignore
    for (var prop in obj1) {
        // @ts-ignore
        if (obj1[prop] !== obj2[prop])
            return false;
    }
    return true;
}
var InlineBlot = /** @class */ (function (_super) {
    __extends(InlineBlot, _super);
    function InlineBlot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InlineBlot.formats = function (domNode) {
        if (domNode.tagName === InlineBlot.tagName)
            return undefined;
        return _super.formats.call(this, domNode);
    };
    InlineBlot.prototype.format = function (name, value) {
        var _this = this;
        if (name === this.statics.blotName && !value) {
            this.children.forEach(function (child) {
                if (!(child instanceof format_1.default)) {
                    child = child.wrap(InlineBlot.blotName, true);
                }
                _this.attributes.copy(child);
            });
            this.unwrap();
        }
        else {
            _super.prototype.format.call(this, name, value);
        }
    };
    InlineBlot.prototype.formatAt = function (index, length, name, value) {
        if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {
            var blot = this.isolate(index, length);
            blot.format(name, value);
        }
        else {
            _super.prototype.formatAt.call(this, index, length, name, value);
        }
    };
    InlineBlot.prototype.optimize = function (context) {
        _super.prototype.optimize.call(this, context);
        var formats = this.formats();
        if (Object.keys(formats).length === 0) {
            return this.unwrap(); // unformatted span
        }
        var next = this.next;
        if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {
            next.moveChildren(this);
            next.remove();
        }
    };
    InlineBlot.blotName = 'inline';
    InlineBlot.scope = Registry.Scope.INLINE_BLOT;
    InlineBlot.tagName = 'SPAN';
    return InlineBlot;
}(format_1.default));
exports.default = InlineBlot;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var format_1 = __webpack_require__(18);
var Registry = __webpack_require__(1);
var BlockBlot = /** @class */ (function (_super) {
    __extends(BlockBlot, _super);
    function BlockBlot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BlockBlot.formats = function (domNode) {
        var tagName = Registry.query(BlockBlot.blotName).tagName;
        if (domNode.tagName === tagName)
            return undefined;
        return _super.formats.call(this, domNode);
    };
    BlockBlot.prototype.format = function (name, value) {
        if (Registry.query(name, Registry.Scope.BLOCK) == null) {
            return;
        }
        else if (name === this.statics.blotName && !value) {
            this.replaceWith(BlockBlot.blotName);
        }
        else {
            _super.prototype.format.call(this, name, value);
        }
    };
    BlockBlot.prototype.formatAt = function (index, length, name, value) {
        if (Registry.query(name, Registry.Scope.BLOCK) != null) {
            this.format(name, value);
        }
        else {
            _super.prototype.formatAt.call(this, index, length, name, value);
        }
    };
    BlockBlot.prototype.insertAt = function (index, value, def) {
        if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
            // Insert text or inline
            _super.prototype.insertAt.call(this, index, value, def);
        }
        else {
            var after = this.split(index);
            var blot = Registry.create(value, def);
            after.parent.insertBefore(blot, after);
        }
    };
    BlockBlot.prototype.update = function (mutations, context) {
        if (navigator.userAgent.match(/Trident/)) {
            this.build();
        }
        else {
            _super.prototype.update.call(this, mutations, context);
        }
    };
    BlockBlot.blotName = 'block';
    BlockBlot.scope = Registry.Scope.BLOCK_BLOT;
    BlockBlot.tagName = 'P';
    return BlockBlot;
}(format_1.default));
exports.default = BlockBlot;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var leaf_1 = __webpack_require__(19);
var EmbedBlot = /** @class */ (function (_super) {
    __extends(EmbedBlot, _super);
    function EmbedBlot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EmbedBlot.formats = function (domNode) {
        return undefined;
    };
    EmbedBlot.prototype.format = function (name, value) {
        // super.formatAt wraps, which is what we want in general,
        // but this allows subclasses to overwrite for formats
        // that just apply to particular embeds
        _super.prototype.formatAt.call(this, 0, this.length(), name, value);
    };
    EmbedBlot.prototype.formatAt = function (index, length, name, value) {
        if (index === 0 && length === this.length()) {
            this.format(name, value);
        }
        else {
            _super.prototype.formatAt.call(this, index, length, name, value);
        }
    };
    EmbedBlot.prototype.formats = function () {
        return this.statics.formats(this.domNode);
    };
    return EmbedBlot;
}(leaf_1.default));
exports.default = EmbedBlot;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var leaf_1 = __webpack_require__(19);
var Registry = __webpack_require__(1);
var TextBlot = /** @class */ (function (_super) {
    __extends(TextBlot, _super);
    function TextBlot(node) {
        var _this = _super.call(this, node) || this;
        _this.text = _this.statics.value(_this.domNode);
        return _this;
    }
    TextBlot.create = function (value) {
        return document.createTextNode(value);
    };
    TextBlot.value = function (domNode) {
        var text = domNode.data;
        // @ts-ignore
        if (text['normalize'])
            text = text['normalize']();
        return text;
    };
    TextBlot.prototype.deleteAt = function (index, length) {
        this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);
    };
    TextBlot.prototype.index = function (node, offset) {
        if (this.domNode === node) {
            return offset;
        }
        return -1;
    };
    TextBlot.prototype.insertAt = function (index, value, def) {
        if (def == null) {
            this.text = this.text.slice(0, index) + value + this.text.slice(index);
            this.domNode.data = this.text;
        }
        else {
            _super.prototype.insertAt.call(this, index, value, def);
        }
    };
    TextBlot.prototype.length = function () {
        return this.text.length;
    };
    TextBlot.prototype.optimize = function (context) {
        _super.prototype.optimize.call(this, context);
        this.text = this.statics.value(this.domNode);
        if (this.text.length === 0) {
            this.remove();
        }
        else if (this.next instanceof TextBlot && this.next.prev === this) {
            this.insertAt(this.length(), this.next.value());
            this.next.remove();
        }
    };
    TextBlot.prototype.position = function (index, inclusive) {
        return [this.domNode, index];
    };
    TextBlot.prototype.split = function (index, force) {
        if (force === void 0) { force = false; }
        if (!force) {
            if (index === 0)
                return this;
            if (index === this.length())
                return this.next;
        }
        var after = Registry.create(this.domNode.splitText(index));
        this.parent.insertBefore(after, this.next);
        this.text = this.statics.value(this.domNode);
        return after;
    };
    TextBlot.prototype.update = function (mutations, context) {
        var _this = this;
        if (mutations.some(function (mutation) {
            return mutation.type === 'characterData' && mutation.target === _this.domNode;
        })) {
            this.text = this.statics.value(this.domNode);
        }
    };
    TextBlot.prototype.value = function () {
        return this.text;
    };
    TextBlot.blotName = 'text';
    TextBlot.scope = Registry.Scope.INLINE_BLOT;
    return TextBlot;
}(leaf_1.default));
exports.default = TextBlot;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {


var elem = document.createElement('div');
elem.classList.toggle('test-class', false);
if (elem.classList.contains('test-class')) {
  var _toggle = DOMTokenList.prototype.toggle;
  DOMTokenList.prototype.toggle = function (token, force) {
    if (arguments.length > 1 && !this.contains(token) === !force) {
      return force;
    } else {
      return _toggle.call(this, token);
    }
  };
}

if (!String.prototype.startsWith) {
  String.prototype.startsWith = function (searchString, position) {
    position = position || 0;
    return this.substr(position, searchString.length) === searchString;
  };
}

if (!String.prototype.endsWith) {
  String.prototype.endsWith = function (searchString, position) {
    var subjectString = this.toString();
    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
      position = subjectString.length;
    }
    position -= searchString.length;
    var lastIndex = subjectString.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
}

if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, "find", {
    value: function value(predicate) {
      if (this === null) {
        throw new TypeError('Array.prototype.find called on null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      var list = Object(this);
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      var value;

      for (var i = 0; i < length; i++) {
        value = list[i];
        if (predicate.call(thisArg, value, i, list)) {
          return value;
        }
      }
      return undefined;
    }
  });
}

document.addEventListener("DOMContentLoaded", function () {
  // Disable resizing in Firefox
  document.execCommand("enableObjectResizing", false, false);
  // Disable automatic linkifying in IE11
  document.execCommand("autoUrlDetect", false, false);
});

/***/ }),
/* 51 */
/***/ (function(module, exports) {

/**
 * This library modifies the diff-patch-match library by Neil Fraser
 * by removing the patch and match functionality and certain advanced
 * options in the diff function. The original license is as follows:
 *
 * ===
 *
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {Int} cursor_pos Expected edit position in text1 (optional)
 * @return {Array} Array of diff tuples.
 */
function diff_main(text1, text2, cursor_pos) {
  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  // Check cursor_pos within bounds
  if (cursor_pos < 0 || text1.length < cursor_pos) {
    cursor_pos = null;
  }

  // Trim off common prefix (speedup).
  var commonlength = diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = diff_compute_(text1, text2);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  diff_cleanupMerge(diffs);
  if (cursor_pos != null) {
    diffs = fix_cursor(diffs, cursor_pos);
  }
  diffs = fix_emoji(diffs);
  return diffs;
}

/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
function diff_compute_(text1, text2) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = diff_main(text1_a, text2_a);
    var diffs_b = diff_main(text1_b, text2_b);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  return diff_bisect_(text1, text2);
}

/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 * @private
 */
function diff_bisect_(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
}

/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @return {Array} Array of diff tuples.
 */
function diff_bisectSplit_(text1, text2, x, y) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = diff_main(text1a, text2a);
  var diffsb = diff_main(text1b, text2b);

  return diffs.concat(diffsb);
}

/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
function diff_commonPrefix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}

/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
function diff_commonSuffix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}

/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
function diff_halfMatch_(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = diff_commonPrefix(longtext.substring(i),
                                           shorttext.substring(j));
      var suffixLength = diff_commonSuffix(longtext.substring(0, i),
                                           shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
}

/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array} diffs Array of diff tuples.
 */
function diff_cleanupMerge(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    diff_cleanupMerge(diffs);
  }
}

var diff = diff_main;
diff.INSERT = DIFF_INSERT;
diff.DELETE = DIFF_DELETE;
diff.EQUAL = DIFF_EQUAL;

module.exports = diff;

/*
 * Modify a diff such that the cursor position points to the start of a change:
 * E.g.
 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
 *
 * @param {Array} diffs Array of diff tuples
 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
 */
function cursor_normalize_diff (diffs, cursor_pos) {
  if (cursor_pos === 0) {
    return [DIFF_EQUAL, diffs];
  }
  for (var current_pos = 0, i = 0; i < diffs.length; i++) {
    var d = diffs[i];
    if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
      var next_pos = current_pos + d[1].length;
      if (cursor_pos === next_pos) {
        return [i + 1, diffs];
      } else if (cursor_pos < next_pos) {
        // copy to prevent side effects
        diffs = diffs.slice();
        // split d into two diff changes
        var split_pos = cursor_pos - current_pos;
        var d_left = [d[0], d[1].slice(0, split_pos)];
        var d_right = [d[0], d[1].slice(split_pos)];
        diffs.splice(i, 1, d_left, d_right);
        return [i + 1, diffs];
      } else {
        current_pos = next_pos;
      }
    }
  }
  throw new Error('cursor_pos is out of bounds!')
}

/*
 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
 *
 * Case 1)
 *   Check if a naive shift is possible:
 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
 * Case 2)
 *   Check if the following shifts are possible:
 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
 *         ^            ^
 *         d          d_next
 *
 * @param {Array} diffs Array of diff tuples
 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
 * @return {Array} Array of diff tuples
 */
function fix_cursor (diffs, cursor_pos) {
  var norm = cursor_normalize_diff(diffs, cursor_pos);
  var ndiffs = norm[1];
  var cursor_pointer = norm[0];
  var d = ndiffs[cursor_pointer];
  var d_next = ndiffs[cursor_pointer + 1];

  if (d == null) {
    // Text was deleted from end of original string,
    // cursor is now out of bounds in new string
    return diffs;
  } else if (d[0] !== DIFF_EQUAL) {
    // A modification happened at the cursor location.
    // This is the expected outcome, so we can return the original diff.
    return diffs;
  } else {
    if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
      // Case 1)
      // It is possible to perform a naive shift
      ndiffs.splice(cursor_pointer, 2, d_next, d);
      return merge_tuples(ndiffs, cursor_pointer, 2)
    } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
      // Case 2)
      // d[1] is a prefix of d_next[1]
      // We can assume that d_next[0] !== 0, since d[0] === 0
      // Shift edit locations..
      ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
      var suffix = d_next[1].slice(d[1].length);
      if (suffix.length > 0) {
        ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
      }
      return merge_tuples(ndiffs, cursor_pointer, 3)
    } else {
      // Not possible to perform any modification
      return diffs;
    }
  }
}

/*
 * Check diff did not split surrogate pairs.
 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
 *
 * @param {Array} diffs Array of diff tuples
 * @return {Array} Array of diff tuples
 */
function fix_emoji (diffs) {
  var compact = false;
  var starts_with_pair_end = function(str) {
    return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
  };
  var ends_with_pair_start = function(str) {
    return str.charCodeAt(str.length-1) >= 0xD800 && str.charCodeAt(str.length-1) <= 0xDBFF;
  };
  for (var i = 2; i < diffs.length; i += 1) {
    if (diffs[i-2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i-2][1]) &&
        diffs[i-1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i-1][1]) &&
        diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {
      compact = true;

      diffs[i-1][1] = diffs[i-2][1].slice(-1) + diffs[i-1][1];
      diffs[i][1] = diffs[i-2][1].slice(-1) + diffs[i][1];

      diffs[i-2][1] = diffs[i-2][1].slice(0, -1);
    }
  }
  if (!compact) {
    return diffs;
  }
  var fixed_diffs = [];
  for (var i = 0; i < diffs.length; i += 1) {
    if (diffs[i][1].length > 0) {
      fixed_diffs.push(diffs[i]);
    }
  }
  return fixed_diffs;
}

/*
 * Try to merge tuples with their neigbors in a given range.
 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
 *
 * @param {Array} diffs Array of diff tuples.
 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
 * @param {Int} length Number of consecutive elements to check.
 * @return {Array} Array of merged diff tuples.
 */
function merge_tuples (diffs, start, length) {
  // Check from (start-1) to (start+length).
  for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
    if (i + 1 < diffs.length) {
      var left_d = diffs[i];
      var right_d = diffs[i+1];
      if (left_d[0] === right_d[1]) {
        diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
      }
    }
  }
  return diffs;
}


/***/ }),
/* 52 */
/***/ (function(module, exports) {

exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}


/***/ }),
/* 53 */
/***/ (function(module, exports) {

var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}
exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
}

/***/ }),
/* 54 */
/***/ (function(module, exports) {

var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @api private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {Mixed} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Boolean} exists Only check if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
};

/**
 * Remove the listeners of a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {Mixed} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
         listeners.fn === fn
      && (!once || listeners.once)
      && (!context || listeners.context === context)
    ) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
           listeners[i].fn !== fn
        || (once && !listeners[i].once)
        || (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {String|Symbol} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchText = exports.matchSpacing = exports.matchNewline = exports.matchBlot = exports.matchAttributor = exports.default = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extend2 = __webpack_require__(3);

var _extend3 = _interopRequireDefault(_extend2);

var _quillDelta = __webpack_require__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __webpack_require__(5);

var _quill2 = _interopRequireDefault(_quill);

var _logger = __webpack_require__(10);

var _logger2 = _interopRequireDefault(_logger);

var _module = __webpack_require__(9);

var _module2 = _interopRequireDefault(_module);

var _align = __webpack_require__(36);

var _background = __webpack_require__(37);

var _code = __webpack_require__(13);

var _code2 = _interopRequireDefault(_code);

var _color = __webpack_require__(26);

var _direction = __webpack_require__(38);

var _font = __webpack_require__(39);

var _size = __webpack_require__(40);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _logger2.default)('quill:clipboard');

var DOM_KEY = '__ql-matcher';

var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ['br', matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ['li', matchIndent], ['b', matchAlias.bind(matchAlias, 'bold')], ['i', matchAlias.bind(matchAlias, 'italic')], ['style', matchIgnore]];

var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function (memo, attr) {
  memo[attr.keyName] = attr;
  return memo;
}, {});

var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function (memo, attr) {
  memo[attr.keyName] = attr;
  return memo;
}, {});

var Clipboard = function (_Module) {
  _inherits(Clipboard, _Module);

  function Clipboard(quill, options) {
    _classCallCheck(this, Clipboard);

    var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));

    _this.quill.root.addEventListener('paste', _this.onPaste.bind(_this));
    _this.container = _this.quill.addContainer('ql-clipboard');
    _this.container.setAttribute('contenteditable', true);
    _this.container.setAttribute('tabindex', -1);
    _this.matchers = [];
    CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          selector = _ref2[0],
          matcher = _ref2[1];

      if (!options.matchVisual && matcher === matchSpacing) return;
      _this.addMatcher(selector, matcher);
    });
    return _this;
  }

  _createClass(Clipboard, [{
    key: 'addMatcher',
    value: function addMatcher(selector, matcher) {
      this.matchers.push([selector, matcher]);
    }
  }, {
    key: 'convert',
    value: function convert(html) {
      if (typeof html === 'string') {
        this.container.innerHTML = html.replace(/\>\r?\n +\</g, '><'); // Remove spaces between tags
        return this.convert();
      }
      var formats = this.quill.getFormat(this.quill.selection.savedRange.index);
      if (formats[_code2.default.blotName]) {
        var text = this.container.innerText;
        this.container.innerHTML = '';
        return new _quillDelta2.default().insert(text, _defineProperty({}, _code2.default.blotName, formats[_code2.default.blotName]));
      }

      var _prepareMatching = this.prepareMatching(),
          _prepareMatching2 = _slicedToArray(_prepareMatching, 2),
          elementMatchers = _prepareMatching2[0],
          textMatchers = _prepareMatching2[1];

      var delta = traverse(this.container, elementMatchers, textMatchers);
      // Remove trailing newline
      if (deltaEndsWith(delta, '\n') && delta.ops[delta.ops.length - 1].attributes == null) {
        delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));
      }
      debug.log('convert', this.container.innerHTML, delta);
      this.container.innerHTML = '';
      return delta;
    }
  }, {
    key: 'dangerouslyPasteHTML',
    value: function dangerouslyPasteHTML(index, html) {
      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2.default.sources.API;

      if (typeof index === 'string') {
        this.quill.setContents(this.convert(index), html);
        this.quill.setSelection(0, _quill2.default.sources.SILENT);
      } else {
        var paste = this.convert(html);
        this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);
        this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);
      }
    }
  }, {
    key: 'onPaste',
    value: function onPaste(e) {
      var _this2 = this;

      if (e.defaultPrevented || !this.quill.isEnabled()) return;
      var range = this.quill.getSelection();
      var delta = new _quillDelta2.default().retain(range.index);
      var scrollTop = this.quill.scrollingContainer.scrollTop;
      this.container.focus();
      this.quill.selection.update(_quill2.default.sources.SILENT);
      setTimeout(function () {
        delta = delta.concat(_this2.convert()).delete(range.length);
        _this2.quill.updateContents(delta, _quill2.default.sources.USER);
        // range.length contributes to delta.length()
        _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);
        _this2.quill.scrollingContainer.scrollTop = scrollTop;
        _this2.quill.focus();
      }, 1);
    }
  }, {
    key: 'prepareMatching',
    value: function prepareMatching() {
      var _this3 = this;

      var elementMatchers = [],
          textMatchers = [];
      this.matchers.forEach(function (pair) {
        var _pair = _slicedToArray(pair, 2),
            selector = _pair[0],
            matcher = _pair[1];

        switch (selector) {
          case Node.TEXT_NODE:
            textMatchers.push(matcher);
            break;
          case Node.ELEMENT_NODE:
            elementMatchers.push(matcher);
            break;
          default:
            [].forEach.call(_this3.container.querySelectorAll(selector), function (node) {
              // TODO use weakmap
              node[DOM_KEY] = node[DOM_KEY] || [];
              node[DOM_KEY].push(matcher);
            });
            break;
        }
      });
      return [elementMatchers, textMatchers];
    }
  }]);

  return Clipboard;
}(_module2.default);

Clipboard.DEFAULTS = {
  matchers: [],
  matchVisual: true
};

function applyFormat(delta, format, value) {
  if ((typeof format === 'undefined' ? 'undefined' : _typeof(format)) === 'object') {
    return Object.keys(format).reduce(function (delta, key) {
      return applyFormat(delta, key, format[key]);
    }, delta);
  } else {
    return delta.reduce(function (delta, op) {
      if (op.attributes && op.attributes[format]) {
        return delta.push(op);
      } else {
        return delta.insert(op.insert, (0, _extend3.default)({}, _defineProperty({}, format, value), op.attributes));
      }
    }, new _quillDelta2.default());
  }
}

function computeStyle(node) {
  if (node.nodeType !== Node.ELEMENT_NODE) return {};
  var DOM_KEY = '__ql-computed-style';
  return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));
}

function deltaEndsWith(delta, text) {
  var endText = "";
  for (var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
    var op = delta.ops[i];
    if (typeof op.insert !== 'string') break;
    endText = op.insert + endText;
  }
  return endText.slice(-1 * text.length) === text;
}

function isLine(node) {
  if (node.childNodes.length === 0) return false; // Exclude embed blocks
  var style = computeStyle(node);
  return ['block', 'list-item'].indexOf(style.display) > -1;
}

function traverse(node, elementMatchers, textMatchers) {
  // Post-order
  if (node.nodeType === node.TEXT_NODE) {
    return textMatchers.reduce(function (delta, matcher) {
      return matcher(node, delta);
    }, new _quillDelta2.default());
  } else if (node.nodeType === node.ELEMENT_NODE) {
    return [].reduce.call(node.childNodes || [], function (delta, childNode) {
      var childrenDelta = traverse(childNode, elementMatchers, textMatchers);
      if (childNode.nodeType === node.ELEMENT_NODE) {
        childrenDelta = elementMatchers.reduce(function (childrenDelta, matcher) {
          return matcher(childNode, childrenDelta);
        }, childrenDelta);
        childrenDelta = (childNode[DOM_KEY] || []).reduce(function (childrenDelta, matcher) {
          return matcher(childNode, childrenDelta);
        }, childrenDelta);
      }
      return delta.concat(childrenDelta);
    }, new _quillDelta2.default());
  } else {
    return new _quillDelta2.default();
  }
}

function matchAlias(format, node, delta) {
  return applyFormat(delta, format, true);
}

function matchAttributor(node, delta) {
  var attributes = _parchment2.default.Attributor.Attribute.keys(node);
  var classes = _parchment2.default.Attributor.Class.keys(node);
  var styles = _parchment2.default.Attributor.Style.keys(node);
  var formats = {};
  attributes.concat(classes).concat(styles).forEach(function (name) {
    var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);
    if (attr != null) {
      formats[attr.attrName] = attr.value(node);
      if (formats[attr.attrName]) return;
    }
    attr = ATTRIBUTE_ATTRIBUTORS[name];
    if (attr != null && (attr.attrName === name || attr.keyName === name)) {
      formats[attr.attrName] = attr.value(node) || undefined;
    }
    attr = STYLE_ATTRIBUTORS[name];
    if (attr != null && (attr.attrName === name || attr.keyName === name)) {
      attr = STYLE_ATTRIBUTORS[name];
      formats[attr.attrName] = attr.value(node) || undefined;
    }
  });
  if (Object.keys(formats).length > 0) {
    delta = applyFormat(delta, formats);
  }
  return delta;
}

function matchBlot(node, delta) {
  var match = _parchment2.default.query(node);
  if (match == null) return delta;
  if (match.prototype instanceof _parchment2.default.Embed) {
    var embed = {};
    var value = match.value(node);
    if (value != null) {
      embed[match.blotName] = value;
      delta = new _quillDelta2.default().insert(embed, match.formats(node));
    }
  } else if (typeof match.formats === 'function') {
    delta = applyFormat(delta, match.blotName, match.formats(node));
  }
  return delta;
}

function matchBreak(node, delta) {
  if (!deltaEndsWith(delta, '\n')) {
    delta.insert('\n');
  }
  return delta;
}

function matchIgnore() {
  return new _quillDelta2.default();
}

function matchIndent(node, delta) {
  var match = _parchment2.default.query(node);
  if (match == null || match.blotName !== 'list-item' || !deltaEndsWith(delta, '\n')) {
    return delta;
  }
  var indent = -1,
      parent = node.parentNode;
  while (!parent.classList.contains('ql-clipboard')) {
    if ((_parchment2.default.query(parent) || {}).blotName === 'list') {
      indent += 1;
    }
    parent = parent.parentNode;
  }
  if (indent <= 0) return delta;
  return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, { indent: indent }));
}

function matchNewline(node, delta) {
  if (!deltaEndsWith(delta, '\n')) {
    if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {
      delta.insert('\n');
    }
  }
  return delta;
}

function matchSpacing(node, delta) {
  if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, '\n\n')) {
    var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);
    if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {
      delta.insert('\n');
    }
  }
  return delta;
}

function matchStyles(node, delta) {
  var formats = {};
  var style = node.style || {};
  if (style.fontStyle && computeStyle(node).fontStyle === 'italic') {
    formats.italic = true;
  }
  if (style.fontWeight && (computeStyle(node).fontWeight.startsWith('bold') || parseInt(computeStyle(node).fontWeight) >= 700)) {
    formats.bold = true;
  }
  if (Object.keys(formats).length > 0) {
    delta = applyFormat(delta, formats);
  }
  if (parseFloat(style.textIndent || 0) > 0) {
    // Could be 0.5in
    delta = new _quillDelta2.default().insert('\t').concat(delta);
  }
  return delta;
}

function matchText(node, delta) {
  var text = node.data;
  // Word represents empty line with <o:p>&nbsp;</o:p>
  if (node.parentNode.tagName === 'O:P') {
    return delta.insert(text.trim());
  }
  if (text.trim().length === 0 && node.parentNode.classList.contains('ql-clipboard')) {
    return delta;
  }
  if (!computeStyle(node.parentNode).whiteSpace.startsWith('pre')) {
    // eslint-disable-next-line func-style
    var replacer = function replacer(collapse, match) {
      match = match.replace(/[^\u00a0]/g, ''); // \u00a0 is nbsp;
      return match.length < 1 && collapse ? ' ' : match;
    };
    text = text.replace(/\r\n/g, ' ').replace(/\n/g, ' ');
    text = text.replace(/\s\s+/g, replacer.bind(replacer, true)); // collapse whitespace
    if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {
      text = text.replace(/^\s+/, replacer.bind(replacer, false));
    }
    if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {
      text = text.replace(/\s+$/, replacer.bind(replacer, false));
    }
  }
  return delta.insert(text);
}

exports.default = Clipboard;
exports.matchAttributor = matchAttributor;
exports.matchBlot = matchBlot;
exports.matchNewline = matchNewline;
exports.matchSpacing = matchSpacing;
exports.matchText = matchText;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inline = __webpack_require__(6);

var _inline2 = _interopRequireDefault(_inline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Bold = function (_Inline) {
  _inherits(Bold, _Inline);

  function Bold() {
    _classCallCheck(this, Bold);

    return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));
  }

  _createClass(Bold, [{
    key: 'optimize',
    value: function optimize(context) {
      _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), 'optimize', this).call(this, context);
      if (this.domNode.tagName !== this.statics.tagName[0]) {
        this.replaceWith(this.statics.blotName);
      }
    }
  }], [{
    key: 'create',
    value: function create() {
      return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), 'create', this).call(this);
    }
  }, {
    key: 'formats',
    value: function formats() {
      return true;
    }
  }]);

  return Bold;
}(_inline2.default);

Bold.blotName = 'bold';
Bold.tagName = ['STRONG', 'B'];

exports.default = Bold;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addControls = exports.default = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _quillDelta = __webpack_require__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __webpack_require__(5);

var _quill2 = _interopRequireDefault(_quill);

var _logger = __webpack_require__(10);

var _logger2 = _interopRequireDefault(_logger);

var _module = __webpack_require__(9);

var _module2 = _interopRequireDefault(_module);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _logger2.default)('quill:toolbar');

var Toolbar = function (_Module) {
  _inherits(Toolbar, _Module);

  function Toolbar(quill, options) {
    _classCallCheck(this, Toolbar);

    var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));

    if (Array.isArray(_this.options.container)) {
      var container = document.createElement('div');
      addControls(container, _this.options.container);
      quill.container.parentNode.insertBefore(container, quill.container);
      _this.container = container;
    } else if (typeof _this.options.container === 'string') {
      _this.container = document.querySelector(_this.options.container);
    } else {
      _this.container = _this.options.container;
    }
    if (!(_this.container instanceof HTMLElement)) {
      var _ret;

      return _ret = debug.error('Container required for toolbar', _this.options), _possibleConstructorReturn(_this, _ret);
    }
    _this.container.classList.add('ql-toolbar');
    _this.controls = [];
    _this.handlers = {};
    Object.keys(_this.options.handlers).forEach(function (format) {
      _this.addHandler(format, _this.options.handlers[format]);
    });
    [].forEach.call(_this.container.querySelectorAll('button, select'), function (input) {
      _this.attach(input);
    });
    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (type, range) {
      if (type === _quill2.default.events.SELECTION_CHANGE) {
        _this.update(range);
      }
    });
    _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
      var _this$quill$selection = _this.quill.selection.getRange(),
          _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1),
          range = _this$quill$selection2[0]; // quill.getSelection triggers update


      _this.update(range);
    });
    return _this;
  }

  _createClass(Toolbar, [{
    key: 'addHandler',
    value: function addHandler(format, handler) {
      this.handlers[format] = handler;
    }
  }, {
    key: 'attach',
    value: function attach(input) {
      var _this2 = this;

      var format = [].find.call(input.classList, function (className) {
        return className.indexOf('ql-') === 0;
      });
      if (!format) return;
      format = format.slice('ql-'.length);
      if (input.tagName === 'BUTTON') {
        input.setAttribute('type', 'button');
      }
      if (this.handlers[format] == null) {
        if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {
          debug.warn('ignoring attaching to disabled format', format, input);
          return;
        }
        if (_parchment2.default.query(format) == null) {
          debug.warn('ignoring attaching to nonexistent format', format, input);
          return;
        }
      }
      var eventName = input.tagName === 'SELECT' ? 'change' : 'click';
      input.addEventListener(eventName, function (e) {
        var value = void 0;
        if (input.tagName === 'SELECT') {
          if (input.selectedIndex < 0) return;
          var selected = input.options[input.selectedIndex];
          if (selected.hasAttribute('selected')) {
            value = false;
          } else {
            value = selected.value || false;
          }
        } else {
          if (input.classList.contains('ql-active')) {
            value = false;
          } else {
            value = input.value || !input.hasAttribute('value');
          }
          e.preventDefault();
        }
        _this2.quill.focus();

        var _quill$selection$getR = _this2.quill.selection.getRange(),
            _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1),
            range = _quill$selection$getR2[0];

        if (_this2.handlers[format] != null) {
          _this2.handlers[format].call(_this2, value);
        } else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {
          value = prompt('Enter ' + format);
          if (!value) return;
          _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({}, format, value)), _quill2.default.sources.USER);
        } else {
          _this2.quill.format(format, value, _quill2.default.sources.USER);
        }
        _this2.update(range);
      });
      // TODO use weakmap
      this.controls.push([format, input]);
    }
  }, {
    key: 'update',
    value: function update(range) {
      var formats = range == null ? {} : this.quill.getFormat(range);
      this.controls.forEach(function (pair) {
        var _pair = _slicedToArray(pair, 2),
            format = _pair[0],
            input = _pair[1];

        if (input.tagName === 'SELECT') {
          var option = void 0;
          if (range == null) {
            option = null;
          } else if (formats[format] == null) {
            option = input.querySelector('option[selected]');
          } else if (!Array.isArray(formats[format])) {
            var value = formats[format];
            if (typeof value === 'string') {
              value = value.replace(/\"/g, '\\"');
            }
            option = input.querySelector('option[value="' + value + '"]');
          }
          if (option == null) {
            input.value = ''; // TODO make configurable?
            input.selectedIndex = -1;
          } else {
            option.selected = true;
          }
        } else {
          if (range == null) {
            input.classList.remove('ql-active');
          } else if (input.hasAttribute('value')) {
            // both being null should match (default values)
            // '1' should match with 1 (headers)
            var isActive = formats[format] === input.getAttribute('value') || formats[format] != null && formats[format].toString() === input.getAttribute('value') || formats[format] == null && !input.getAttribute('value');
            input.classList.toggle('ql-active', isActive);
          } else {
            input.classList.toggle('ql-active', formats[format] != null);
          }
        }
      });
    }
  }]);

  return Toolbar;
}(_module2.default);

Toolbar.DEFAULTS = {};

function addButton(container, format, value) {
  var input = document.createElement('button');
  input.setAttribute('type', 'button');
  input.classList.add('ql-' + format);
  if (value != null) {
    input.value = value;
  }
  container.appendChild(input);
}

function addControls(container, groups) {
  if (!Array.isArray(groups[0])) {
    groups = [groups];
  }
  groups.forEach(function (controls) {
    var group = document.createElement('span');
    group.classList.add('ql-formats');
    controls.forEach(function (control) {
      if (typeof control === 'string') {
        addButton(group, control);
      } else {
        var format = Object.keys(control)[0];
        var value = control[format];
        if (Array.isArray(value)) {
          addSelect(group, format, value);
        } else {
          addButton(group, format, value);
        }
      }
    });
    container.appendChild(group);
  });
}

function addSelect(container, format, values) {
  var input = document.createElement('select');
  input.classList.add('ql-' + format);
  values.forEach(function (value) {
    var option = document.createElement('option');
    if (value !== false) {
      option.setAttribute('value', value);
    } else {
      option.setAttribute('selected', 'selected');
    }
    input.appendChild(option);
  });
  container.appendChild(input);
}

Toolbar.DEFAULTS = {
  container: null,
  handlers: {
    clean: function clean() {
      var _this3 = this;

      var range = this.quill.getSelection();
      if (range == null) return;
      if (range.length == 0) {
        var formats = this.quill.getFormat();
        Object.keys(formats).forEach(function (name) {
          // Clean functionality in existing apps only clean inline formats
          if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {
            _this3.quill.format(name, false);
          }
        });
      } else {
        this.quill.removeFormat(range, _quill2.default.sources.USER);
      }
    },
    direction: function direction(value) {
      var align = this.quill.getFormat()['align'];
      if (value === 'rtl' && align == null) {
        this.quill.format('align', 'right', _quill2.default.sources.USER);
      } else if (!value && align === 'right') {
        this.quill.format('align', false, _quill2.default.sources.USER);
      }
      this.quill.format('direction', value, _quill2.default.sources.USER);
    },
    indent: function indent(value) {
      var range = this.quill.getSelection();
      var formats = this.quill.getFormat(range);
      var indent = parseInt(formats.indent || 0);
      if (value === '+1' || value === '-1') {
        var modifier = value === '+1' ? 1 : -1;
        if (formats.direction === 'rtl') modifier *= -1;
        this.quill.format('indent', indent + modifier, _quill2.default.sources.USER);
      }
    },
    link: function link(value) {
      if (value === true) {
        value = prompt('Enter link URL:');
      }
      this.quill.format('link', value, _quill2.default.sources.USER);
    },
    list: function list(value) {
      var range = this.quill.getSelection();
      var formats = this.quill.getFormat(range);
      if (value === 'check') {
        if (formats['list'] === 'checked' || formats['list'] === 'unchecked') {
          this.quill.format('list', false, _quill2.default.sources.USER);
        } else {
          this.quill.format('list', 'unchecked', _quill2.default.sources.USER);
        }
      } else {
        this.quill.format('list', value, _quill2.default.sources.USER);
      }
    }
  }
};

exports.default = Toolbar;
exports.addControls = addControls;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>";

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _picker = __webpack_require__(28);

var _picker2 = _interopRequireDefault(_picker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ColorPicker = function (_Picker) {
  _inherits(ColorPicker, _Picker);

  function ColorPicker(select, label) {
    _classCallCheck(this, ColorPicker);

    var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));

    _this.label.innerHTML = label;
    _this.container.classList.add('ql-color-picker');
    [].slice.call(_this.container.querySelectorAll('.ql-picker-item'), 0, 7).forEach(function (item) {
      item.classList.add('ql-primary');
    });
    return _this;
  }

  _createClass(ColorPicker, [{
    key: 'buildItem',
    value: function buildItem(option) {
      var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'buildItem', this).call(this, option);
      item.style.backgroundColor = option.getAttribute('value') || '';
      return item;
    }
  }, {
    key: 'selectItem',
    value: function selectItem(item, trigger) {
      _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'selectItem', this).call(this, item, trigger);
      var colorLabel = this.label.querySelector('.ql-color-label');
      var value = item ? item.getAttribute('data-value') || '' : '';
      if (colorLabel) {
        if (colorLabel.tagName === 'line') {
          colorLabel.style.stroke = value;
        } else {
          colorLabel.style.fill = value;
        }
      }
    }
  }]);

  return ColorPicker;
}(_picker2.default);

exports.default = ColorPicker;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _picker = __webpack_require__(28);

var _picker2 = _interopRequireDefault(_picker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IconPicker = function (_Picker) {
  _inherits(IconPicker, _Picker);

  function IconPicker(select, icons) {
    _classCallCheck(this, IconPicker);

    var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));

    _this.container.classList.add('ql-icon-picker');
    [].forEach.call(_this.container.querySelectorAll('.ql-picker-item'), function (item) {
      item.innerHTML = icons[item.getAttribute('data-value') || ''];
    });
    _this.defaultItem = _this.container.querySelector('.ql-selected');
    _this.selectItem(_this.defaultItem);
    return _this;
  }

  _createClass(IconPicker, [{
    key: 'selectItem',
    value: function selectItem(item, trigger) {
      _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), 'selectItem', this).call(this, item, trigger);
      item = item || this.defaultItem;
      this.label.innerHTML = item.innerHTML;
    }
  }]);

  return IconPicker;
}(_picker2.default);

exports.default = IconPicker;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tooltip = function () {
  function Tooltip(quill, boundsContainer) {
    var _this = this;

    _classCallCheck(this, Tooltip);

    this.quill = quill;
    this.boundsContainer = boundsContainer || document.body;
    this.root = quill.addContainer('ql-tooltip');
    this.root.innerHTML = this.constructor.TEMPLATE;
    if (this.quill.root === this.quill.scrollingContainer) {
      this.quill.root.addEventListener('scroll', function () {
        _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + 'px';
      });
    }
    this.hide();
  }

  _createClass(Tooltip, [{
    key: 'hide',
    value: function hide() {
      this.root.classList.add('ql-hidden');
    }
  }, {
    key: 'position',
    value: function position(reference) {
      var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
      // root.scrollTop should be 0 if scrollContainer !== root
      var top = reference.bottom + this.quill.root.scrollTop;
      this.root.style.left = left + 'px';
      this.root.style.top = top + 'px';
      this.root.classList.remove('ql-flip');
      var containerBounds = this.boundsContainer.getBoundingClientRect();
      var rootBounds = this.root.getBoundingClientRect();
      var shift = 0;
      if (rootBounds.right > containerBounds.right) {
        shift = containerBounds.right - rootBounds.right;
        this.root.style.left = left + shift + 'px';
      }
      if (rootBounds.left < containerBounds.left) {
        shift = containerBounds.left - rootBounds.left;
        this.root.style.left = left + shift + 'px';
      }
      if (rootBounds.bottom > containerBounds.bottom) {
        var height = rootBounds.bottom - rootBounds.top;
        var verticalShift = reference.bottom - reference.top + height;
        this.root.style.top = top - verticalShift + 'px';
        this.root.classList.add('ql-flip');
      }
      return shift;
    }
  }, {
    key: 'show',
    value: function show() {
      this.root.classList.remove('ql-editing');
      this.root.classList.remove('ql-hidden');
    }
  }]);

  return Tooltip;
}();

exports.default = Tooltip;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extend = __webpack_require__(3);

var _extend2 = _interopRequireDefault(_extend);

var _emitter = __webpack_require__(8);

var _emitter2 = _interopRequireDefault(_emitter);

var _base = __webpack_require__(43);

var _base2 = _interopRequireDefault(_base);

var _link = __webpack_require__(27);

var _link2 = _interopRequireDefault(_link);

var _selection = __webpack_require__(15);

var _icons = __webpack_require__(41);

var _icons2 = _interopRequireDefault(_icons);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TOOLBAR_CONFIG = [[{ header: ['1', '2', '3', false] }], ['bold', 'italic', 'underline', 'link'], [{ list: 'ordered' }, { list: 'bullet' }], ['clean']];

var SnowTheme = function (_BaseTheme) {
  _inherits(SnowTheme, _BaseTheme);

  function SnowTheme(quill, options) {
    _classCallCheck(this, SnowTheme);

    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
      options.modules.toolbar.container = TOOLBAR_CONFIG;
    }

    var _this = _possibleConstructorReturn(this, (SnowTheme.__proto__ || Object.getPrototypeOf(SnowTheme)).call(this, quill, options));

    _this.quill.container.classList.add('ql-snow');
    return _this;
  }

  _createClass(SnowTheme, [{
    key: 'extendToolbar',
    value: function extendToolbar(toolbar) {
      toolbar.container.classList.add('ql-snow');
      this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
      this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
      this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
      if (toolbar.container.querySelector('.ql-link')) {
        this.quill.keyboard.addBinding({ key: 'K', shortKey: true }, function (range, context) {
          toolbar.handlers['link'].call(toolbar, !context.format.link);
        });
      }
    }
  }]);

  return SnowTheme;
}(_base2.default);

SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        link: function link(value) {
          if (value) {
            var range = this.quill.getSelection();
            if (range == null || range.length == 0) return;
            var preview = this.quill.getText(range);
            if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf('mailto:') !== 0) {
              preview = 'mailto:' + preview;
            }
            var tooltip = this.quill.theme.tooltip;
            tooltip.edit('link', preview);
          } else {
            this.quill.format('link', false);
          }
        }
      }
    }
  }
});

var SnowTooltip = function (_BaseTooltip) {
  _inherits(SnowTooltip, _BaseTooltip);

  function SnowTooltip(quill, bounds) {
    _classCallCheck(this, SnowTooltip);

    var _this2 = _possibleConstructorReturn(this, (SnowTooltip.__proto__ || Object.getPrototypeOf(SnowTooltip)).call(this, quill, bounds));

    _this2.preview = _this2.root.querySelector('a.ql-preview');
    return _this2;
  }

  _createClass(SnowTooltip, [{
    key: 'listen',
    value: function listen() {
      var _this3 = this;

      _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'listen', this).call(this);
      this.root.querySelector('a.ql-action').addEventListener('click', function (event) {
        if (_this3.root.classList.contains('ql-editing')) {
          _this3.save();
        } else {
          _this3.edit('link', _this3.preview.textContent);
        }
        event.preventDefault();
      });
      this.root.querySelector('a.ql-remove').addEventListener('click', function (event) {
        if (_this3.linkRange != null) {
          var range = _this3.linkRange;
          _this3.restoreFocus();
          _this3.quill.formatText(range, 'link', false, _emitter2.default.sources.USER);
          delete _this3.linkRange;
        }
        event.preventDefault();
        _this3.hide();
      });
      this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function (range, oldRange, source) {
        if (range == null) return;
        if (range.length === 0 && source === _emitter2.default.sources.USER) {
          var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range.index),
              _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
              link = _quill$scroll$descend2[0],
              offset = _quill$scroll$descend2[1];

          if (link != null) {
            _this3.linkRange = new _selection.Range(range.index - offset, link.length());
            var preview = _link2.default.formats(link.domNode);
            _this3.preview.textContent = preview;
            _this3.preview.setAttribute('href', preview);
            _this3.show();
            _this3.position(_this3.quill.getBounds(_this3.linkRange));
            return;
          }
        } else {
          delete _this3.linkRange;
        }
        _this3.hide();
      });
    }
  }, {
    key: 'show',
    value: function show() {
      _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'show', this).call(this);
      this.root.removeAttribute('data-mode');
    }
  }]);

  return SnowTooltip;
}(_base.BaseTooltip);

SnowTooltip.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join('');

exports.default = SnowTheme;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _core = __webpack_require__(29);

var _core2 = _interopRequireDefault(_core);

var _align = __webpack_require__(36);

var _direction = __webpack_require__(38);

var _indent = __webpack_require__(64);

var _blockquote = __webpack_require__(65);

var _blockquote2 = _interopRequireDefault(_blockquote);

var _header = __webpack_require__(66);

var _header2 = _interopRequireDefault(_header);

var _list = __webpack_require__(67);

var _list2 = _interopRequireDefault(_list);

var _background = __webpack_require__(37);

var _color = __webpack_require__(26);

var _font = __webpack_require__(39);

var _size = __webpack_require__(40);

var _bold = __webpack_require__(56);

var _bold2 = _interopRequireDefault(_bold);

var _italic = __webpack_require__(68);

var _italic2 = _interopRequireDefault(_italic);

var _link = __webpack_require__(27);

var _link2 = _interopRequireDefault(_link);

var _script = __webpack_require__(69);

var _script2 = _interopRequireDefault(_script);

var _strike = __webpack_require__(70);

var _strike2 = _interopRequireDefault(_strike);

var _underline = __webpack_require__(71);

var _underline2 = _interopRequireDefault(_underline);

var _image = __webpack_require__(72);

var _image2 = _interopRequireDefault(_image);

var _video = __webpack_require__(73);

var _video2 = _interopRequireDefault(_video);

var _code = __webpack_require__(13);

var _code2 = _interopRequireDefault(_code);

var _formula = __webpack_require__(74);

var _formula2 = _interopRequireDefault(_formula);

var _syntax = __webpack_require__(75);

var _syntax2 = _interopRequireDefault(_syntax);

var _toolbar = __webpack_require__(57);

var _toolbar2 = _interopRequireDefault(_toolbar);

var _icons = __webpack_require__(41);

var _icons2 = _interopRequireDefault(_icons);

var _picker = __webpack_require__(28);

var _picker2 = _interopRequireDefault(_picker);

var _colorPicker = __webpack_require__(59);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _iconPicker = __webpack_require__(60);

var _iconPicker2 = _interopRequireDefault(_iconPicker);

var _tooltip = __webpack_require__(61);

var _tooltip2 = _interopRequireDefault(_tooltip);

var _bubble = __webpack_require__(108);

var _bubble2 = _interopRequireDefault(_bubble);

var _snow = __webpack_require__(62);

var _snow2 = _interopRequireDefault(_snow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_core2.default.register({
  'attributors/attribute/direction': _direction.DirectionAttribute,

  'attributors/class/align': _align.AlignClass,
  'attributors/class/background': _background.BackgroundClass,
  'attributors/class/color': _color.ColorClass,
  'attributors/class/direction': _direction.DirectionClass,
  'attributors/class/font': _font.FontClass,
  'attributors/class/size': _size.SizeClass,

  'attributors/style/align': _align.AlignStyle,
  'attributors/style/background': _background.BackgroundStyle,
  'attributors/style/color': _color.ColorStyle,
  'attributors/style/direction': _direction.DirectionStyle,
  'attributors/style/font': _font.FontStyle,
  'attributors/style/size': _size.SizeStyle
}, true);

_core2.default.register({
  'formats/align': _align.AlignClass,
  'formats/direction': _direction.DirectionClass,
  'formats/indent': _indent.IndentClass,

  'formats/background': _background.BackgroundStyle,
  'formats/color': _color.ColorStyle,
  'formats/font': _font.FontClass,
  'formats/size': _size.SizeClass,

  'formats/blockquote': _blockquote2.default,
  'formats/code-block': _code2.default,
  'formats/header': _header2.default,
  'formats/list': _list2.default,

  'formats/bold': _bold2.default,
  'formats/code': _code.Code,
  'formats/italic': _italic2.default,
  'formats/link': _link2.default,
  'formats/script': _script2.default,
  'formats/strike': _strike2.default,
  'formats/underline': _underline2.default,

  'formats/image': _image2.default,
  'formats/video': _video2.default,

  'formats/list/item': _list.ListItem,

  'modules/formula': _formula2.default,
  'modules/syntax': _syntax2.default,
  'modules/toolbar': _toolbar2.default,

  'themes/bubble': _bubble2.default,
  'themes/snow': _snow2.default,

  'ui/icons': _icons2.default,
  'ui/picker': _picker2.default,
  'ui/icon-picker': _iconPicker2.default,
  'ui/color-picker': _colorPicker2.default,
  'ui/tooltip': _tooltip2.default
}, true);

exports.default = _core2.default;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndentClass = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IdentAttributor = function (_Parchment$Attributor) {
  _inherits(IdentAttributor, _Parchment$Attributor);

  function IdentAttributor() {
    _classCallCheck(this, IdentAttributor);

    return _possibleConstructorReturn(this, (IdentAttributor.__proto__ || Object.getPrototypeOf(IdentAttributor)).apply(this, arguments));
  }

  _createClass(IdentAttributor, [{
    key: 'add',
    value: function add(node, value) {
      if (value === '+1' || value === '-1') {
        var indent = this.value(node) || 0;
        value = value === '+1' ? indent + 1 : indent - 1;
      }
      if (value === 0) {
        this.remove(node);
        return true;
      } else {
        return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'add', this).call(this, node, value);
      }
    }
  }, {
    key: 'canAdd',
    value: function canAdd(node, value) {
      return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, value) || _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, parseInt(value));
    }
  }, {
    key: 'value',
    value: function value(node) {
      return parseInt(_get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'value', this).call(this, node)) || undefined; // Don't return NaN
    }
  }]);

  return IdentAttributor;
}(_parchment2.default.Attributor.Class);

var IndentClass = new IdentAttributor('indent', 'ql-indent', {
  scope: _parchment2.default.Scope.BLOCK,
  whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
});

exports.IndentClass = IndentClass;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _block = __webpack_require__(4);

var _block2 = _interopRequireDefault(_block);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Blockquote = function (_Block) {
  _inherits(Blockquote, _Block);

  function Blockquote() {
    _classCallCheck(this, Blockquote);

    return _possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).apply(this, arguments));
  }

  return Blockquote;
}(_block2.default);

Blockquote.blotName = 'blockquote';
Blockquote.tagName = 'blockquote';

exports.default = Blockquote;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _block = __webpack_require__(4);

var _block2 = _interopRequireDefault(_block);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Header = function (_Block) {
  _inherits(Header, _Block);

  function Header() {
    _classCallCheck(this, Header);

    return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));
  }

  _createClass(Header, null, [{
    key: 'formats',
    value: function formats(domNode) {
      return this.tagName.indexOf(domNode.tagName) + 1;
    }
  }]);

  return Header;
}(_block2.default);

Header.blotName = 'header';
Header.tagName = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];

exports.default = Header;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ListItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _block = __webpack_require__(4);

var _block2 = _interopRequireDefault(_block);

var _container = __webpack_require__(25);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ListItem = function (_Block) {
  _inherits(ListItem, _Block);

  function ListItem() {
    _classCallCheck(this, ListItem);

    return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));
  }

  _createClass(ListItem, [{
    key: 'format',
    value: function format(name, value) {
      if (name === List.blotName && !value) {
        this.replaceWith(_parchment2.default.create(this.statics.scope));
      } else {
        _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'format', this).call(this, name, value);
      }
    }
  }, {
    key: 'remove',
    value: function remove() {
      if (this.prev == null && this.next == null) {
        this.parent.remove();
      } else {
        _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'remove', this).call(this);
      }
    }
  }, {
    key: 'replaceWith',
    value: function replaceWith(name, value) {
      this.parent.isolate(this.offset(this.parent), this.length());
      if (name === this.parent.statics.blotName) {
        this.parent.replaceWith(name, value);
        return this;
      } else {
        this.parent.unwrap();
        return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'replaceWith', this).call(this, name, value);
      }
    }
  }], [{
    key: 'formats',
    value: function formats(domNode) {
      return domNode.tagName === this.tagName ? undefined : _get(ListItem.__proto__ || Object.getPrototypeOf(ListItem), 'formats', this).call(this, domNode);
    }
  }]);

  return ListItem;
}(_block2.default);

ListItem.blotName = 'list-item';
ListItem.tagName = 'LI';

var List = function (_Container) {
  _inherits(List, _Container);

  _createClass(List, null, [{
    key: 'create',
    value: function create(value) {
      var tagName = value === 'ordered' ? 'OL' : 'UL';
      var node = _get(List.__proto__ || Object.getPrototypeOf(List), 'create', this).call(this, tagName);
      if (value === 'checked' || value === 'unchecked') {
        node.setAttribute('data-checked', value === 'checked');
      }
      return node;
    }
  }, {
    key: 'formats',
    value: function formats(domNode) {
      if (domNode.tagName === 'OL') return 'ordered';
      if (domNode.tagName === 'UL') {
        if (domNode.hasAttribute('data-checked')) {
          return domNode.getAttribute('data-checked') === 'true' ? 'checked' : 'unchecked';
        } else {
          return 'bullet';
        }
      }
      return undefined;
    }
  }]);

  function List(domNode) {
    _classCallCheck(this, List);

    var _this2 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, domNode));

    var listEventHandler = function listEventHandler(e) {
      if (e.target.parentNode !== domNode) return;
      var format = _this2.statics.formats(domNode);
      var blot = _parchment2.default.find(e.target);
      if (format === 'checked') {
        blot.format('list', 'unchecked');
      } else if (format === 'unchecked') {
        blot.format('list', 'checked');
      }
    };

    domNode.addEventListener('touchstart', listEventHandler);
    domNode.addEventListener('mousedown', listEventHandler);
    return _this2;
  }

  _createClass(List, [{
    key: 'format',
    value: function format(name, value) {
      if (this.children.length > 0) {
        this.children.tail.format(name, value);
      }
    }
  }, {
    key: 'formats',
    value: function formats() {
      // We don't inherit from FormatBlot
      return _defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
    }
  }, {
    key: 'insertBefore',
    value: function insertBefore(blot, ref) {
      if (blot instanceof ListItem) {
        _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'insertBefore', this).call(this, blot, ref);
      } else {
        var index = ref == null ? this.length() : ref.offset(this);
        var after = this.split(index);
        after.parent.insertBefore(blot, after);
      }
    }
  }, {
    key: 'optimize',
    value: function optimize(context) {
      _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'optimize', this).call(this, context);
      var next = this.next;
      if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute('data-checked') === this.domNode.getAttribute('data-checked')) {
        next.moveChildren(this);
        next.remove();
      }
    }
  }, {
    key: 'replace',
    value: function replace(target) {
      if (target.statics.blotName !== this.statics.blotName) {
        var item = _parchment2.default.create(this.statics.defaultChild);
        target.moveChildren(item);
        this.appendChild(item);
      }
      _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'replace', this).call(this, target);
    }
  }]);

  return List;
}(_container2.default);

List.blotName = 'list';
List.scope = _parchment2.default.Scope.BLOCK_BLOT;
List.tagName = ['OL', 'UL'];
List.defaultChild = 'list-item';
List.allowedChildren = [ListItem];

exports.ListItem = ListItem;
exports.default = List;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bold = __webpack_require__(56);

var _bold2 = _interopRequireDefault(_bold);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Italic = function (_Bold) {
  _inherits(Italic, _Bold);

  function Italic() {
    _classCallCheck(this, Italic);

    return _possibleConstructorReturn(this, (Italic.__proto__ || Object.getPrototypeOf(Italic)).apply(this, arguments));
  }

  return Italic;
}(_bold2.default);

Italic.blotName = 'italic';
Italic.tagName = ['EM', 'I'];

exports.default = Italic;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inline = __webpack_require__(6);

var _inline2 = _interopRequireDefault(_inline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Script = function (_Inline) {
  _inherits(Script, _Inline);

  function Script() {
    _classCallCheck(this, Script);

    return _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).apply(this, arguments));
  }

  _createClass(Script, null, [{
    key: 'create',
    value: function create(value) {
      if (value === 'super') {
        return document.createElement('sup');
      } else if (value === 'sub') {
        return document.createElement('sub');
      } else {
        return _get(Script.__proto__ || Object.getPrototypeOf(Script), 'create', this).call(this, value);
      }
    }
  }, {
    key: 'formats',
    value: function formats(domNode) {
      if (domNode.tagName === 'SUB') return 'sub';
      if (domNode.tagName === 'SUP') return 'super';
      return undefined;
    }
  }]);

  return Script;
}(_inline2.default);

Script.blotName = 'script';
Script.tagName = ['SUB', 'SUP'];

exports.default = Script;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _inline = __webpack_require__(6);

var _inline2 = _interopRequireDefault(_inline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Strike = function (_Inline) {
  _inherits(Strike, _Inline);

  function Strike() {
    _classCallCheck(this, Strike);

    return _possibleConstructorReturn(this, (Strike.__proto__ || Object.getPrototypeOf(Strike)).apply(this, arguments));
  }

  return Strike;
}(_inline2.default);

Strike.blotName = 'strike';
Strike.tagName = 'S';

exports.default = Strike;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _inline = __webpack_require__(6);

var _inline2 = _interopRequireDefault(_inline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Underline = function (_Inline) {
  _inherits(Underline, _Inline);

  function Underline() {
    _classCallCheck(this, Underline);

    return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).apply(this, arguments));
  }

  return Underline;
}(_inline2.default);

Underline.blotName = 'underline';
Underline.tagName = 'U';

exports.default = Underline;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _link = __webpack_require__(27);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ATTRIBUTES = ['alt', 'height', 'width'];

var Image = function (_Parchment$Embed) {
  _inherits(Image, _Parchment$Embed);

  function Image() {
    _classCallCheck(this, Image);

    return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));
  }

  _createClass(Image, [{
    key: 'format',
    value: function format(name, value) {
      if (ATTRIBUTES.indexOf(name) > -1) {
        if (value) {
          this.domNode.setAttribute(name, value);
        } else {
          this.domNode.removeAttribute(name);
        }
      } else {
        _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), 'format', this).call(this, name, value);
      }
    }
  }], [{
    key: 'create',
    value: function create(value) {
      var node = _get(Image.__proto__ || Object.getPrototypeOf(Image), 'create', this).call(this, value);
      if (typeof value === 'string') {
        node.setAttribute('src', this.sanitize(value));
      }
      return node;
    }
  }, {
    key: 'formats',
    value: function formats(domNode) {
      return ATTRIBUTES.reduce(function (formats, attribute) {
        if (domNode.hasAttribute(attribute)) {
          formats[attribute] = domNode.getAttribute(attribute);
        }
        return formats;
      }, {});
    }
  }, {
    key: 'match',
    value: function match(url) {
      return (/\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url)
      );
    }
  }, {
    key: 'sanitize',
    value: function sanitize(url) {
      return (0, _link.sanitize)(url, ['http', 'https', 'data']) ? url : '//:0';
    }
  }, {
    key: 'value',
    value: function value(domNode) {
      return domNode.getAttribute('src');
    }
  }]);

  return Image;
}(_parchment2.default.Embed);

Image.blotName = 'image';
Image.tagName = 'IMG';

exports.default = Image;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _block = __webpack_require__(4);

var _link = __webpack_require__(27);

var _link2 = _interopRequireDefault(_link);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ATTRIBUTES = ['height', 'width'];

var Video = function (_BlockEmbed) {
  _inherits(Video, _BlockEmbed);

  function Video() {
    _classCallCheck(this, Video);

    return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));
  }

  _createClass(Video, [{
    key: 'format',
    value: function format(name, value) {
      if (ATTRIBUTES.indexOf(name) > -1) {
        if (value) {
          this.domNode.setAttribute(name, value);
        } else {
          this.domNode.removeAttribute(name);
        }
      } else {
        _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), 'format', this).call(this, name, value);
      }
    }
  }], [{
    key: 'create',
    value: function create(value) {
      var node = _get(Video.__proto__ || Object.getPrototypeOf(Video), 'create', this).call(this, value);
      node.setAttribute('frameborder', '0');
      node.setAttribute('allowfullscreen', true);
      node.setAttribute('src', this.sanitize(value));
      return node;
    }
  }, {
    key: 'formats',
    value: function formats(domNode) {
      return ATTRIBUTES.reduce(function (formats, attribute) {
        if (domNode.hasAttribute(attribute)) {
          formats[attribute] = domNode.getAttribute(attribute);
        }
        return formats;
      }, {});
    }
  }, {
    key: 'sanitize',
    value: function sanitize(url) {
      return _link2.default.sanitize(url);
    }
  }, {
    key: 'value',
    value: function value(domNode) {
      return domNode.getAttribute('src');
    }
  }]);

  return Video;
}(_block.BlockEmbed);

Video.blotName = 'video';
Video.className = 'ql-video';
Video.tagName = 'IFRAME';

exports.default = Video;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FormulaBlot = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _embed = __webpack_require__(35);

var _embed2 = _interopRequireDefault(_embed);

var _quill = __webpack_require__(5);

var _quill2 = _interopRequireDefault(_quill);

var _module = __webpack_require__(9);

var _module2 = _interopRequireDefault(_module);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FormulaBlot = function (_Embed) {
  _inherits(FormulaBlot, _Embed);

  function FormulaBlot() {
    _classCallCheck(this, FormulaBlot);

    return _possibleConstructorReturn(this, (FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot)).apply(this, arguments));
  }

  _createClass(FormulaBlot, null, [{
    key: 'create',
    value: function create(value) {
      var node = _get(FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot), 'create', this).call(this, value);
      if (typeof value === 'string') {
        window.katex.render(value, node, {
          throwOnError: false,
          errorColor: '#f00'
        });
        node.setAttribute('data-value', value);
      }
      return node;
    }
  }, {
    key: 'value',
    value: function value(domNode) {
      return domNode.getAttribute('data-value');
    }
  }]);

  return FormulaBlot;
}(_embed2.default);

FormulaBlot.blotName = 'formula';
FormulaBlot.className = 'ql-formula';
FormulaBlot.tagName = 'SPAN';

var Formula = function (_Module) {
  _inherits(Formula, _Module);

  _createClass(Formula, null, [{
    key: 'register',
    value: function register() {
      _quill2.default.register(FormulaBlot, true);
    }
  }]);

  function Formula() {
    _classCallCheck(this, Formula);

    var _this2 = _possibleConstructorReturn(this, (Formula.__proto__ || Object.getPrototypeOf(Formula)).call(this));

    if (window.katex == null) {
      throw new Error('Formula module requires KaTeX.');
    }
    return _this2;
  }

  return Formula;
}(_module2.default);

exports.FormulaBlot = FormulaBlot;
exports.default = Formula;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CodeToken = exports.CodeBlock = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __webpack_require__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __webpack_require__(5);

var _quill2 = _interopRequireDefault(_quill);

var _module = __webpack_require__(9);

var _module2 = _interopRequireDefault(_module);

var _code = __webpack_require__(13);

var _code2 = _interopRequireDefault(_code);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SyntaxCodeBlock = function (_CodeBlock) {
  _inherits(SyntaxCodeBlock, _CodeBlock);

  function SyntaxCodeBlock() {
    _classCallCheck(this, SyntaxCodeBlock);

    return _possibleConstructorReturn(this, (SyntaxCodeBlock.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock)).apply(this, arguments));
  }

  _createClass(SyntaxCodeBlock, [{
    key: 'replaceWith',
    value: function replaceWith(block) {
      this.domNode.textContent = this.domNode.textContent;
      this.attach();
      _get(SyntaxCodeBlock.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock.prototype), 'replaceWith', this).call(this, block);
    }
  }, {
    key: 'highlight',
    value: function highlight(_highlight) {
      var text = this.domNode.textContent;
      if (this.cachedText !== text) {
        if (text.trim().length > 0 || this.cachedText == null) {
          this.domNode.innerHTML = _highlight(text);
          this.domNode.normalize();
          this.attach();
        }
        this.cachedText = text;
      }
    }
  }]);

  return SyntaxCodeBlock;
}(_code2.default);

SyntaxCodeBlock.className = 'ql-syntax';

var CodeToken = new _parchment2.default.Attributor.Class('token', 'hljs', {
  scope: _parchment2.default.Scope.INLINE
});

var Syntax = function (_Module) {
  _inherits(Syntax, _Module);

  _createClass(Syntax, null, [{
    key: 'register',
    value: function register() {
      _quill2.default.register(CodeToken, true);
      _quill2.default.register(SyntaxCodeBlock, true);
    }
  }]);

  function Syntax(quill, options) {
    _classCallCheck(this, Syntax);

    var _this2 = _possibleConstructorReturn(this, (Syntax.__proto__ || Object.getPrototypeOf(Syntax)).call(this, quill, options));

    if (typeof _this2.options.highlight !== 'function') {
      throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');
    }
    var timer = null;
    _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
      clearTimeout(timer);
      timer = setTimeout(function () {
        _this2.highlight();
        timer = null;
      }, _this2.options.interval);
    });
    _this2.highlight();
    return _this2;
  }

  _createClass(Syntax, [{
    key: 'highlight',
    value: function highlight() {
      var _this3 = this;

      if (this.quill.selection.composing) return;
      this.quill.update(_quill2.default.sources.USER);
      var range = this.quill.getSelection();
      this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function (code) {
        code.highlight(_this3.options.highlight);
      });
      this.quill.update(_quill2.default.sources.SILENT);
      if (range != null) {
        this.quill.setSelection(range, _quill2.default.sources.SILENT);
      }
    }
  }]);

  return Syntax;
}(_module2.default);

Syntax.DEFAULTS = {
  highlight: function () {
    if (window.hljs == null) return null;
    return function (text) {
      var result = window.hljs.highlightAuto(text);
      return result.value;
    };
  }(),
  interval: 1000
};

exports.CodeBlock = SyntaxCodeBlock;
exports.CodeToken = CodeToken;
exports.default = Syntax;

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>";

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>";

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>";

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>";

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>";

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>";

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>";

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>";

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>";

/***/ }),
/* 85 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>";

/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>";

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>";

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>";

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>";

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>";

/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>";

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>";

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>";

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>";

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>";

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>";

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>";

/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>";

/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>";

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>";

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>";

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>";

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>";

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>";

/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>";

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>";

/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>";

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BubbleTooltip = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extend = __webpack_require__(3);

var _extend2 = _interopRequireDefault(_extend);

var _emitter = __webpack_require__(8);

var _emitter2 = _interopRequireDefault(_emitter);

var _base = __webpack_require__(43);

var _base2 = _interopRequireDefault(_base);

var _selection = __webpack_require__(15);

var _icons = __webpack_require__(41);

var _icons2 = _interopRequireDefault(_icons);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TOOLBAR_CONFIG = [['bold', 'italic', 'link'], [{ header: 1 }, { header: 2 }, 'blockquote']];

var BubbleTheme = function (_BaseTheme) {
  _inherits(BubbleTheme, _BaseTheme);

  function BubbleTheme(quill, options) {
    _classCallCheck(this, BubbleTheme);

    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
      options.modules.toolbar.container = TOOLBAR_CONFIG;
    }

    var _this = _possibleConstructorReturn(this, (BubbleTheme.__proto__ || Object.getPrototypeOf(BubbleTheme)).call(this, quill, options));

    _this.quill.container.classList.add('ql-bubble');
    return _this;
  }

  _createClass(BubbleTheme, [{
    key: 'extendToolbar',
    value: function extendToolbar(toolbar) {
      this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
      this.tooltip.root.appendChild(toolbar.container);
      this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
      this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
    }
  }]);

  return BubbleTheme;
}(_base2.default);

BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        link: function link(value) {
          if (!value) {
            this.quill.format('link', false);
          } else {
            this.quill.theme.tooltip.edit();
          }
        }
      }
    }
  }
});

var BubbleTooltip = function (_BaseTooltip) {
  _inherits(BubbleTooltip, _BaseTooltip);

  function BubbleTooltip(quill, bounds) {
    _classCallCheck(this, BubbleTooltip);

    var _this2 = _possibleConstructorReturn(this, (BubbleTooltip.__proto__ || Object.getPrototypeOf(BubbleTooltip)).call(this, quill, bounds));

    _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function (type, range, oldRange, source) {
      if (type !== _emitter2.default.events.SELECTION_CHANGE) return;
      if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {
        _this2.show();
        // Lock our width so we will expand beyond our offsetParent boundaries
        _this2.root.style.left = '0px';
        _this2.root.style.width = '';
        _this2.root.style.width = _this2.root.offsetWidth + 'px';
        var lines = _this2.quill.getLines(range.index, range.length);
        if (lines.length === 1) {
          _this2.position(_this2.quill.getBounds(range));
        } else {
          var lastLine = lines[lines.length - 1];
          var index = _this2.quill.getIndex(lastLine);
          var length = Math.min(lastLine.length() - 1, range.index + range.length - index);
          var _bounds = _this2.quill.getBounds(new _selection.Range(index, length));
          _this2.position(_bounds);
        }
      } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
        _this2.hide();
      }
    });
    return _this2;
  }

  _createClass(BubbleTooltip, [{
    key: 'listen',
    value: function listen() {
      var _this3 = this;

      _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'listen', this).call(this);
      this.root.querySelector('.ql-close').addEventListener('click', function () {
        _this3.root.classList.remove('ql-editing');
      });
      this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function () {
        // Let selection be restored by toolbar handlers before repositioning
        setTimeout(function () {
          if (_this3.root.classList.contains('ql-hidden')) return;
          var range = _this3.quill.getSelection();
          if (range != null) {
            _this3.position(_this3.quill.getBounds(range));
          }
        }, 1);
      });
    }
  }, {
    key: 'cancel',
    value: function cancel() {
      this.show();
    }
  }, {
    key: 'position',
    value: function position(reference) {
      var shift = _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'position', this).call(this, reference);
      var arrow = this.root.querySelector('.ql-tooltip-arrow');
      arrow.style.marginLeft = '';
      if (shift === 0) return shift;
      arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + 'px';
    }
  }]);

  return BubbleTooltip;
}(_base.BaseTooltip);

BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', '</div>'].join('');

exports.BubbleTooltip = BubbleTooltip;
exports.default = BubbleTheme;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(63);


/***/ })
/******/ ])["default"];
});

// node_modules/@lit/reactive-element/css-tag.js
var t$6 = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var e$9 = Symbol();
var n$7 = /* @__PURE__ */ new Map();
var s$5 = class {
  constructor(t3, n5) {
    if (this._$cssResult$ = true, n5 !== e$9)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t3;
  }
  get styleSheet() {
    let e4 = n$7.get(this.cssText);
    return t$6 && e4 === void 0 && (n$7.set(this.cssText, e4 = new CSSStyleSheet()), e4.replaceSync(this.cssText)), e4;
  }
  toString() {
    return this.cssText;
  }
};
var o$8 = (t3) => new s$5(typeof t3 == "string" ? t3 : t3 + "", e$9);
var r$5 = (t3, ...n5) => {
  const o5 = t3.length === 1 ? t3[0] : n5.reduce((e4, n6, s5) => e4 + ((t4) => {
    if (t4._$cssResult$ === true)
      return t4.cssText;
    if (typeof t4 == "number")
      return t4;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t4 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n6) + t3[s5 + 1], t3[0]);
  return new s$5(o5, e$9);
};
var i$8 = (e4, n5) => {
  t$6 ? e4.adoptedStyleSheets = n5.map((t3) => t3 instanceof CSSStyleSheet ? t3 : t3.styleSheet) : n5.forEach((t3) => {
    const n6 = document.createElement("style"), s5 = window.litNonce;
    s5 !== void 0 && n6.setAttribute("nonce", s5), n6.textContent = t3.cssText, e4.appendChild(n6);
  });
};
var S$2 = t$6 ? (t3) => t3 : (t3) => t3 instanceof CSSStyleSheet ? ((t4) => {
  let e4 = "";
  for (const n5 of t4.cssRules)
    e4 += n5.cssText;
  return o$8(e4);
})(t3) : t3;

// node_modules/@lit/reactive-element/reactive-element.js
var s2;
var e2 = window.trustedTypes;
var r2 = e2 ? e2.emptyScript : "";
var h$2 = window.reactiveElementPolyfillSupport;
var o2$1 = { toAttribute(t3, i3) {
  switch (i3) {
    case Boolean:
      t3 = t3 ? r2 : null;
      break;
    case Object:
    case Array:
      t3 = t3 == null ? t3 : JSON.stringify(t3);
  }
  return t3;
}, fromAttribute(t3, i3) {
  let s5 = t3;
  switch (i3) {
    case Boolean:
      s5 = t3 !== null;
      break;
    case Number:
      s5 = t3 === null ? null : Number(t3);
      break;
    case Object:
    case Array:
      try {
        s5 = JSON.parse(t3);
      } catch (t4) {
        s5 = null;
      }
  }
  return s5;
} };
var n2$1 = (t3, i3) => i3 !== t3 && (i3 == i3 || t3 == t3);
var l$6 = { attribute: true, type: String, converter: o2$1, reflect: false, hasChanged: n2$1 };
var a$3 = class extends HTMLElement {
  constructor() {
    super(), this._$Et = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$Ei = null, this.o();
  }
  static addInitializer(t3) {
    var i3;
    (i3 = this.l) !== null && i3 !== void 0 || (this.l = []), this.l.push(t3);
  }
  static get observedAttributes() {
    this.finalize();
    const t3 = [];
    return this.elementProperties.forEach((i3, s5) => {
      const e4 = this._$Eh(s5, i3);
      e4 !== void 0 && (this._$Eu.set(e4, s5), t3.push(e4));
    }), t3;
  }
  static createProperty(t3, i3 = l$6) {
    if (i3.state && (i3.attribute = false), this.finalize(), this.elementProperties.set(t3, i3), !i3.noAccessor && !this.prototype.hasOwnProperty(t3)) {
      const s5 = typeof t3 == "symbol" ? Symbol() : "__" + t3, e4 = this.getPropertyDescriptor(t3, s5, i3);
      e4 !== void 0 && Object.defineProperty(this.prototype, t3, e4);
    }
  }
  static getPropertyDescriptor(t3, i3, s5) {
    return { get() {
      return this[i3];
    }, set(e4) {
      const r4 = this[t3];
      this[i3] = e4, this.requestUpdate(t3, r4, s5);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t3) {
    return this.elementProperties.get(t3) || l$6;
  }
  static finalize() {
    if (this.hasOwnProperty("finalized"))
      return false;
    this.finalized = true;
    const t3 = Object.getPrototypeOf(this);
    if (t3.finalize(), this.elementProperties = new Map(t3.elementProperties), this._$Eu = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const t4 = this.properties, i3 = [...Object.getOwnPropertyNames(t4), ...Object.getOwnPropertySymbols(t4)];
      for (const s5 of i3)
        this.createProperty(s5, t4[s5]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), true;
  }
  static finalizeStyles(i3) {
    const s5 = [];
    if (Array.isArray(i3)) {
      const e4 = new Set(i3.flat(1 / 0).reverse());
      for (const i4 of e4)
        s5.unshift(S$2(i4));
    } else
      i3 !== void 0 && s5.push(S$2(i3));
    return s5;
  }
  static _$Eh(t3, i3) {
    const s5 = i3.attribute;
    return s5 === false ? void 0 : typeof s5 == "string" ? s5 : typeof t3 == "string" ? t3.toLowerCase() : void 0;
  }
  o() {
    var t3;
    this._$Ep = new Promise((t4) => this.enableUpdating = t4), this._$AL = /* @__PURE__ */ new Map(), this._$Em(), this.requestUpdate(), (t3 = this.constructor.l) === null || t3 === void 0 || t3.forEach((t4) => t4(this));
  }
  addController(t3) {
    var i3, s5;
    ((i3 = this._$Eg) !== null && i3 !== void 0 ? i3 : this._$Eg = []).push(t3), this.renderRoot !== void 0 && this.isConnected && ((s5 = t3.hostConnected) === null || s5 === void 0 || s5.call(t3));
  }
  removeController(t3) {
    var i3;
    (i3 = this._$Eg) === null || i3 === void 0 || i3.splice(this._$Eg.indexOf(t3) >>> 0, 1);
  }
  _$Em() {
    this.constructor.elementProperties.forEach((t3, i3) => {
      this.hasOwnProperty(i3) && (this._$Et.set(i3, this[i3]), delete this[i3]);
    });
  }
  createRenderRoot() {
    var t3;
    const s5 = (t3 = this.shadowRoot) !== null && t3 !== void 0 ? t3 : this.attachShadow(this.constructor.shadowRootOptions);
    return i$8(s5, this.constructor.elementStyles), s5;
  }
  connectedCallback() {
    var t3;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t3 = this._$Eg) === null || t3 === void 0 || t3.forEach((t4) => {
      var i3;
      return (i3 = t4.hostConnected) === null || i3 === void 0 ? void 0 : i3.call(t4);
    });
  }
  enableUpdating(t3) {
  }
  disconnectedCallback() {
    var t3;
    (t3 = this._$Eg) === null || t3 === void 0 || t3.forEach((t4) => {
      var i3;
      return (i3 = t4.hostDisconnected) === null || i3 === void 0 ? void 0 : i3.call(t4);
    });
  }
  attributeChangedCallback(t3, i3, s5) {
    this._$AK(t3, s5);
  }
  _$ES(t3, i3, s5 = l$6) {
    var e4, r4;
    const h3 = this.constructor._$Eh(t3, s5);
    if (h3 !== void 0 && s5.reflect === true) {
      const n5 = ((r4 = (e4 = s5.converter) === null || e4 === void 0 ? void 0 : e4.toAttribute) !== null && r4 !== void 0 ? r4 : o2$1.toAttribute)(i3, s5.type);
      this._$Ei = t3, n5 == null ? this.removeAttribute(h3) : this.setAttribute(h3, n5), this._$Ei = null;
    }
  }
  _$AK(t3, i3) {
    var s5, e4, r4;
    const h3 = this.constructor, n5 = h3._$Eu.get(t3);
    if (n5 !== void 0 && this._$Ei !== n5) {
      const t4 = h3.getPropertyOptions(n5), l4 = t4.converter, a3 = (r4 = (e4 = (s5 = l4) === null || s5 === void 0 ? void 0 : s5.fromAttribute) !== null && e4 !== void 0 ? e4 : typeof l4 == "function" ? l4 : null) !== null && r4 !== void 0 ? r4 : o2$1.fromAttribute;
      this._$Ei = n5, this[n5] = a3(i3, t4.type), this._$Ei = null;
    }
  }
  requestUpdate(t3, i3, s5) {
    let e4 = true;
    t3 !== void 0 && (((s5 = s5 || this.constructor.getPropertyOptions(t3)).hasChanged || n2$1)(this[t3], i3) ? (this._$AL.has(t3) || this._$AL.set(t3, i3), s5.reflect === true && this._$Ei !== t3 && (this._$E_ === void 0 && (this._$E_ = /* @__PURE__ */ new Map()), this._$E_.set(t3, s5))) : e4 = false), !this.isUpdatePending && e4 && (this._$Ep = this._$EC());
  }
  async _$EC() {
    this.isUpdatePending = true;
    try {
      await this._$Ep;
    } catch (t4) {
      Promise.reject(t4);
    }
    const t3 = this.scheduleUpdate();
    return t3 != null && await t3, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t3;
    if (!this.isUpdatePending)
      return;
    this.hasUpdated, this._$Et && (this._$Et.forEach((t4, i4) => this[i4] = t4), this._$Et = void 0);
    let i3 = false;
    const s5 = this._$AL;
    try {
      i3 = this.shouldUpdate(s5), i3 ? (this.willUpdate(s5), (t3 = this._$Eg) === null || t3 === void 0 || t3.forEach((t4) => {
        var i4;
        return (i4 = t4.hostUpdate) === null || i4 === void 0 ? void 0 : i4.call(t4);
      }), this.update(s5)) : this._$EU();
    } catch (t4) {
      throw i3 = false, this._$EU(), t4;
    }
    i3 && this._$AE(s5);
  }
  willUpdate(t3) {
  }
  _$AE(t3) {
    var i3;
    (i3 = this._$Eg) === null || i3 === void 0 || i3.forEach((t4) => {
      var i4;
      return (i4 = t4.hostUpdated) === null || i4 === void 0 ? void 0 : i4.call(t4);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t3)), this.updated(t3);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$Ep;
  }
  shouldUpdate(t3) {
    return true;
  }
  update(t3) {
    this._$E_ !== void 0 && (this._$E_.forEach((t4, i3) => this._$ES(i3, this[i3], t4)), this._$E_ = void 0), this._$EU();
  }
  updated(t3) {
  }
  firstUpdated(t3) {
  }
};
a$3.finalized = true, a$3.elementProperties = /* @__PURE__ */ new Map(), a$3.elementStyles = [], a$3.shadowRootOptions = { mode: "open" }, h$2 == null || h$2({ ReactiveElement: a$3 }), ((s2 = globalThis.reactiveElementVersions) !== null && s2 !== void 0 ? s2 : globalThis.reactiveElementVersions = []).push("1.2.3");

// node_modules/lit-html/lit-html.js
var t2;
var i2$1 = globalThis.trustedTypes;
var s3 = i2$1 ? i2$1.createPolicy("lit-html", { createHTML: (t3) => t3 }) : void 0;
var e3$1 = `lit$${(Math.random() + "").slice(9)}$`;
var o3 = "?" + e3$1;
var n3 = `<${o3}>`;
var l2 = document;
var h2 = (t3 = "") => l2.createComment(t3);
var r3 = (t3) => t3 === null || typeof t3 != "object" && typeof t3 != "function";
var d$1 = Array.isArray;
var u$1 = (t3) => {
  var i3;
  return d$1(t3) || typeof ((i3 = t3) === null || i3 === void 0 ? void 0 : i3[Symbol.iterator]) == "function";
};
var c$1 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var v$1 = /-->/g;
var a2 = />/g;
var f$2 = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g;
var _$1 = /'/g;
var m$1 = /"/g;
var g$1 = /^(?:script|style|textarea|title)$/i;
var p$1 = (t3) => (i3, ...s5) => ({ _$litType$: t3, strings: i3, values: s5 });
var $$1 = p$1(1);
var b$1 = Symbol.for("lit-noChange");
var w$1 = Symbol.for("lit-nothing");
var T$1 = /* @__PURE__ */ new WeakMap();
var x$1 = (t3, i3, s5) => {
  var e4, o5;
  const n5 = (e4 = s5 == null ? void 0 : s5.renderBefore) !== null && e4 !== void 0 ? e4 : i3;
  let l4 = n5._$litPart$;
  if (l4 === void 0) {
    const t4 = (o5 = s5 == null ? void 0 : s5.renderBefore) !== null && o5 !== void 0 ? o5 : null;
    n5._$litPart$ = l4 = new N$1(i3.insertBefore(h2(), t4), t4, void 0, s5 != null ? s5 : {});
  }
  return l4._$AI(t3), l4;
};
var A$1 = l2.createTreeWalker(l2, 129, null, false);
var C$2 = (t3, i3) => {
  const o5 = t3.length - 1, l4 = [];
  let h3, r4 = i3 === 2 ? "<svg>" : "", d2 = c$1;
  for (let i4 = 0; i4 < o5; i4++) {
    const s5 = t3[i4];
    let o6, u3, p2 = -1, $2 = 0;
    for (; $2 < s5.length && (d2.lastIndex = $2, u3 = d2.exec(s5), u3 !== null); )
      $2 = d2.lastIndex, d2 === c$1 ? u3[1] === "!--" ? d2 = v$1 : u3[1] !== void 0 ? d2 = a2 : u3[2] !== void 0 ? (g$1.test(u3[2]) && (h3 = RegExp("</" + u3[2], "g")), d2 = f$2) : u3[3] !== void 0 && (d2 = f$2) : d2 === f$2 ? u3[0] === ">" ? (d2 = h3 != null ? h3 : c$1, p2 = -1) : u3[1] === void 0 ? p2 = -2 : (p2 = d2.lastIndex - u3[2].length, o6 = u3[1], d2 = u3[3] === void 0 ? f$2 : u3[3] === '"' ? m$1 : _$1) : d2 === m$1 || d2 === _$1 ? d2 = f$2 : d2 === v$1 || d2 === a2 ? d2 = c$1 : (d2 = f$2, h3 = void 0);
    const y2 = d2 === f$2 && t3[i4 + 1].startsWith("/>") ? " " : "";
    r4 += d2 === c$1 ? s5 + n3 : p2 >= 0 ? (l4.push(o6), s5.slice(0, p2) + "$lit$" + s5.slice(p2) + e3$1 + y2) : s5 + e3$1 + (p2 === -2 ? (l4.push(void 0), i4) : y2);
  }
  const u2 = r4 + (t3[o5] || "<?>") + (i3 === 2 ? "</svg>" : "");
  if (!Array.isArray(t3) || !t3.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return [s3 !== void 0 ? s3.createHTML(u2) : u2, l4];
};
var E$1 = class {
  constructor({ strings: t3, _$litType$: s5 }, n5) {
    let l4;
    this.parts = [];
    let r4 = 0, d2 = 0;
    const u2 = t3.length - 1, c2 = this.parts, [v2, a3] = C$2(t3, s5);
    if (this.el = E$1.createElement(v2, n5), A$1.currentNode = this.el.content, s5 === 2) {
      const t4 = this.el.content, i3 = t4.firstChild;
      i3.remove(), t4.append(...i3.childNodes);
    }
    for (; (l4 = A$1.nextNode()) !== null && c2.length < u2; ) {
      if (l4.nodeType === 1) {
        if (l4.hasAttributes()) {
          const t4 = [];
          for (const i3 of l4.getAttributeNames())
            if (i3.endsWith("$lit$") || i3.startsWith(e3$1)) {
              const s6 = a3[d2++];
              if (t4.push(i3), s6 !== void 0) {
                const t5 = l4.getAttribute(s6.toLowerCase() + "$lit$").split(e3$1), i4 = /([.?@])?(.*)/.exec(s6);
                c2.push({ type: 1, index: r4, name: i4[2], strings: t5, ctor: i4[1] === "." ? M$2 : i4[1] === "?" ? H$1 : i4[1] === "@" ? I$2 : S2 });
              } else
                c2.push({ type: 6, index: r4 });
            }
          for (const i3 of t4)
            l4.removeAttribute(i3);
        }
        if (g$1.test(l4.tagName)) {
          const t4 = l4.textContent.split(e3$1), s6 = t4.length - 1;
          if (s6 > 0) {
            l4.textContent = i2$1 ? i2$1.emptyScript : "";
            for (let i3 = 0; i3 < s6; i3++)
              l4.append(t4[i3], h2()), A$1.nextNode(), c2.push({ type: 2, index: ++r4 });
            l4.append(t4[s6], h2());
          }
        }
      } else if (l4.nodeType === 8)
        if (l4.data === o3)
          c2.push({ type: 2, index: r4 });
        else {
          let t4 = -1;
          for (; (t4 = l4.data.indexOf(e3$1, t4 + 1)) !== -1; )
            c2.push({ type: 7, index: r4 }), t4 += e3$1.length - 1;
        }
      r4++;
    }
  }
  static createElement(t3, i3) {
    const s5 = l2.createElement("template");
    return s5.innerHTML = t3, s5;
  }
};
function P$1(t3, i3, s5 = t3, e4) {
  var o5, n5, l4, h3;
  if (i3 === b$1)
    return i3;
  let d2 = e4 !== void 0 ? (o5 = s5._$Cl) === null || o5 === void 0 ? void 0 : o5[e4] : s5._$Cu;
  const u2 = r3(i3) ? void 0 : i3._$litDirective$;
  return (d2 == null ? void 0 : d2.constructor) !== u2 && ((n5 = d2 == null ? void 0 : d2._$AO) === null || n5 === void 0 || n5.call(d2, false), u2 === void 0 ? d2 = void 0 : (d2 = new u2(t3), d2._$AT(t3, s5, e4)), e4 !== void 0 ? ((l4 = (h3 = s5)._$Cl) !== null && l4 !== void 0 ? l4 : h3._$Cl = [])[e4] = d2 : s5._$Cu = d2), d2 !== void 0 && (i3 = P$1(t3, d2._$AS(t3, i3.values), d2, e4)), i3;
}
var V$2 = class {
  constructor(t3, i3) {
    this.v = [], this._$AN = void 0, this._$AD = t3, this._$AM = i3;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  p(t3) {
    var i3;
    const { el: { content: s5 }, parts: e4 } = this._$AD, o5 = ((i3 = t3 == null ? void 0 : t3.creationScope) !== null && i3 !== void 0 ? i3 : l2).importNode(s5, true);
    A$1.currentNode = o5;
    let n5 = A$1.nextNode(), h3 = 0, r4 = 0, d2 = e4[0];
    for (; d2 !== void 0; ) {
      if (h3 === d2.index) {
        let i4;
        d2.type === 2 ? i4 = new N$1(n5, n5.nextSibling, this, t3) : d2.type === 1 ? i4 = new d2.ctor(n5, d2.name, d2.strings, this, t3) : d2.type === 6 && (i4 = new L$2(n5, this, t3)), this.v.push(i4), d2 = e4[++r4];
      }
      h3 !== (d2 == null ? void 0 : d2.index) && (n5 = A$1.nextNode(), h3++);
    }
    return o5;
  }
  m(t3) {
    let i3 = 0;
    for (const s5 of this.v)
      s5 !== void 0 && (s5.strings !== void 0 ? (s5._$AI(t3, s5, i3), i3 += s5.strings.length - 2) : s5._$AI(t3[i3])), i3++;
  }
};
var N$1 = class {
  constructor(t3, i3, s5, e4) {
    var o5;
    this.type = 2, this._$AH = w$1, this._$AN = void 0, this._$AA = t3, this._$AB = i3, this._$AM = s5, this.options = e4, this._$Cg = (o5 = e4 == null ? void 0 : e4.isConnected) === null || o5 === void 0 || o5;
  }
  get _$AU() {
    var t3, i3;
    return (i3 = (t3 = this._$AM) === null || t3 === void 0 ? void 0 : t3._$AU) !== null && i3 !== void 0 ? i3 : this._$Cg;
  }
  get parentNode() {
    let t3 = this._$AA.parentNode;
    const i3 = this._$AM;
    return i3 !== void 0 && t3.nodeType === 11 && (t3 = i3.parentNode), t3;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t3, i3 = this) {
    t3 = P$1(this, t3, i3), r3(t3) ? t3 === w$1 || t3 == null || t3 === "" ? (this._$AH !== w$1 && this._$AR(), this._$AH = w$1) : t3 !== this._$AH && t3 !== b$1 && this.$(t3) : t3._$litType$ !== void 0 ? this.T(t3) : t3.nodeType !== void 0 ? this.S(t3) : u$1(t3) ? this.A(t3) : this.$(t3);
  }
  M(t3, i3 = this._$AB) {
    return this._$AA.parentNode.insertBefore(t3, i3);
  }
  S(t3) {
    this._$AH !== t3 && (this._$AR(), this._$AH = this.M(t3));
  }
  $(t3) {
    this._$AH !== w$1 && r3(this._$AH) ? this._$AA.nextSibling.data = t3 : this.S(l2.createTextNode(t3)), this._$AH = t3;
  }
  T(t3) {
    var i3;
    const { values: s5, _$litType$: e4 } = t3, o5 = typeof e4 == "number" ? this._$AC(t3) : (e4.el === void 0 && (e4.el = E$1.createElement(e4.h, this.options)), e4);
    if (((i3 = this._$AH) === null || i3 === void 0 ? void 0 : i3._$AD) === o5)
      this._$AH.m(s5);
    else {
      const t4 = new V$2(o5, this), i4 = t4.p(this.options);
      t4.m(s5), this.S(i4), this._$AH = t4;
    }
  }
  _$AC(t3) {
    let i3 = T$1.get(t3.strings);
    return i3 === void 0 && T$1.set(t3.strings, i3 = new E$1(t3)), i3;
  }
  A(t3) {
    d$1(this._$AH) || (this._$AH = [], this._$AR());
    const i3 = this._$AH;
    let s5, e4 = 0;
    for (const o5 of t3)
      e4 === i3.length ? i3.push(s5 = new N$1(this.M(h2()), this.M(h2()), this, this.options)) : s5 = i3[e4], s5._$AI(o5), e4++;
    e4 < i3.length && (this._$AR(s5 && s5._$AB.nextSibling, e4), i3.length = e4);
  }
  _$AR(t3 = this._$AA.nextSibling, i3) {
    var s5;
    for ((s5 = this._$AP) === null || s5 === void 0 || s5.call(this, false, true, i3); t3 && t3 !== this._$AB; ) {
      const i4 = t3.nextSibling;
      t3.remove(), t3 = i4;
    }
  }
  setConnected(t3) {
    var i3;
    this._$AM === void 0 && (this._$Cg = t3, (i3 = this._$AP) === null || i3 === void 0 || i3.call(this, t3));
  }
};
var S2 = class {
  constructor(t3, i3, s5, e4, o5) {
    this.type = 1, this._$AH = w$1, this._$AN = void 0, this.element = t3, this.name = i3, this._$AM = e4, this.options = o5, s5.length > 2 || s5[0] !== "" || s5[1] !== "" ? (this._$AH = Array(s5.length - 1).fill(new String()), this.strings = s5) : this._$AH = w$1;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t3, i3 = this, s5, e4) {
    const o5 = this.strings;
    let n5 = false;
    if (o5 === void 0)
      t3 = P$1(this, t3, i3, 0), n5 = !r3(t3) || t3 !== this._$AH && t3 !== b$1, n5 && (this._$AH = t3);
    else {
      const e5 = t3;
      let l4, h3;
      for (t3 = o5[0], l4 = 0; l4 < o5.length - 1; l4++)
        h3 = P$1(this, e5[s5 + l4], i3, l4), h3 === b$1 && (h3 = this._$AH[l4]), n5 || (n5 = !r3(h3) || h3 !== this._$AH[l4]), h3 === w$1 ? t3 = w$1 : t3 !== w$1 && (t3 += (h3 != null ? h3 : "") + o5[l4 + 1]), this._$AH[l4] = h3;
    }
    n5 && !e4 && this.k(t3);
  }
  k(t3) {
    t3 === w$1 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t3 != null ? t3 : "");
  }
};
var M$2 = class extends S2 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  k(t3) {
    this.element[this.name] = t3 === w$1 ? void 0 : t3;
  }
};
var k$1 = i2$1 ? i2$1.emptyScript : "";
var H$1 = class extends S2 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  k(t3) {
    t3 && t3 !== w$1 ? this.element.setAttribute(this.name, k$1) : this.element.removeAttribute(this.name);
  }
};
var I$2 = class extends S2 {
  constructor(t3, i3, s5, e4, o5) {
    super(t3, i3, s5, e4, o5), this.type = 5;
  }
  _$AI(t3, i3 = this) {
    var s5;
    if ((t3 = (s5 = P$1(this, t3, i3, 0)) !== null && s5 !== void 0 ? s5 : w$1) === b$1)
      return;
    const e4 = this._$AH, o5 = t3 === w$1 && e4 !== w$1 || t3.capture !== e4.capture || t3.once !== e4.once || t3.passive !== e4.passive, n5 = t3 !== w$1 && (e4 === w$1 || o5);
    o5 && this.element.removeEventListener(this.name, this, e4), n5 && this.element.addEventListener(this.name, this, t3), this._$AH = t3;
  }
  handleEvent(t3) {
    var i3, s5;
    typeof this._$AH == "function" ? this._$AH.call((s5 = (i3 = this.options) === null || i3 === void 0 ? void 0 : i3.host) !== null && s5 !== void 0 ? s5 : this.element, t3) : this._$AH.handleEvent(t3);
  }
};
var L$2 = class {
  constructor(t3, i3, s5) {
    this.element = t3, this.type = 6, this._$AN = void 0, this._$AM = i3, this.options = s5;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t3) {
    P$1(this, t3);
  }
};
var z$1 = window.litHtmlPolyfillSupport;
z$1 == null || z$1(E$1, N$1), ((t2 = globalThis.litHtmlVersions) !== null && t2 !== void 0 ? t2 : globalThis.litHtmlVersions = []).push("2.1.3");

// node_modules/lit-element/lit-element.js
var l3;
var o4;
var s4 = class extends a$3 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Dt = void 0;
  }
  createRenderRoot() {
    var t3, e4;
    const i3 = super.createRenderRoot();
    return (t3 = (e4 = this.renderOptions).renderBefore) !== null && t3 !== void 0 || (e4.renderBefore = i3.firstChild), i3;
  }
  update(t3) {
    const i3 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t3), this._$Dt = x$1(i3, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t3;
    super.connectedCallback(), (t3 = this._$Dt) === null || t3 === void 0 || t3.setConnected(true);
  }
  disconnectedCallback() {
    var t3;
    super.disconnectedCallback(), (t3 = this._$Dt) === null || t3 === void 0 || t3.setConnected(false);
  }
  render() {
    return b$1;
  }
};
s4.finalized = true, s4._$litElement$ = true, (l3 = globalThis.litElementHydrateSupport) === null || l3 === void 0 || l3.call(globalThis, { LitElement: s4 });
var n4 = globalThis.litElementPolyfillSupport;
n4 == null || n4({ LitElement: s4 });
((o4 = globalThis.litElementVersions) !== null && o4 !== void 0 ? o4 : globalThis.litElementVersions = []).push("3.1.2");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

// src/styles/component.styles.ts
var component_styles_default = r$5`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

// src/components/radio-group/radio-group.styles.ts
var radio_group_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: block;
  }

  .radio-group {
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding: var(--sl-spacing-large);
    padding-top: var(--sl-spacing-x-small);
  }

  .radio-group .radio-group__label {
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-color);
    padding: 0 var(--sl-spacing-2x-small);
  }

  ::slotted(sl-radio:not(:last-of-type)) {
    display: block;
    margin-bottom: var(--sl-spacing-2x-small);
  }

  .radio-group:not(.radio-group--has-fieldset) {
    border: none;
    padding: 0;
    margin: 0;
    min-width: 0;
  }

  .radio-group:not(.radio-group--has-fieldset) .radio-group__label {
    position: absolute;
    width: 0;
    height: 0;
    clip: rect(0 0 0 0);
    clip-path: inset(50%);
    overflow: hidden;
    white-space: nowrap;
  }
`;

// node_modules/lit-html/directive.js
var t$5 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e$8 = (t2) => (...e2) => ({ _$litDirective$: t2, values: e2 });
var i$7 = class {
  constructor(t2) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t2, e2, i2) {
    this._$Ct = t2, this._$AM = e2, this._$Ci = i2;
  }
  _$AS(t2, e2) {
    return this.update(t2, e2);
  }
  update(t2, e2) {
    return this.render(...e2);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

// node_modules/lit-html/directives/class-map.js
var o$7 = e$8(class extends i$7 {
  constructor(t2) {
    var i2;
    if (super(t2), t2.type !== t$5.ATTRIBUTE || t2.name !== "class" || ((i2 = t2.strings) === null || i2 === void 0 ? void 0 : i2.length) > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t2) {
    return " " + Object.keys(t2).filter((i2) => t2[i2]).join(" ") + " ";
  }
  update(i2, [s]) {
    var r, o2;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), i2.strings !== void 0 && (this.et = new Set(i2.strings.join(" ").split(/\s/).filter((t2) => t2 !== "")));
      for (const t2 in s)
        s[t2] && !((r = this.et) === null || r === void 0 ? void 0 : r.has(t2)) && this.st.add(t2);
      return this.render(s);
    }
    const e2 = i2.element.classList;
    this.st.forEach((t2) => {
      t2 in s || (e2.remove(t2), this.st.delete(t2));
    });
    for (const t2 in s) {
      const i3 = !!s[t2];
      i3 === this.st.has(t2) || ((o2 = this.et) === null || o2 === void 0 ? void 0 : o2.has(t2)) || (i3 ? (e2.add(t2), this.st.add(t2)) : (e2.remove(t2), this.st.delete(t2)));
    }
    return b$1;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// node_modules/@lit/reactive-element/decorators/custom-element.js
var n$6 = (n3) => (e4) => typeof e4 == "function" ? ((n4, e5) => (window.customElements.define(n4, e5), e5))(n3, e4) : ((n4, e5) => {
  const { kind: t2, elements: i3 } = e5;
  return { kind: t2, elements: i3, finisher(e6) {
    window.customElements.define(n4, e6);
  } };
})(n3, e4);

// node_modules/@lit/reactive-element/decorators/property.js
var i$6 = (i3, e4) => e4.kind === "method" && e4.descriptor && !("value" in e4.descriptor) ? __spreadProps(__spreadValues({}, e4), { finisher(n3) {
  n3.createProperty(e4.key, i3);
} }) : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e4.key, initializer() {
  typeof e4.initializer == "function" && (this[e4.key] = e4.initializer.call(this));
}, finisher(n3) {
  n3.createProperty(e4.key, i3);
} };
function e$7(e4) {
  return (n3, t2) => t2 !== void 0 ? ((i3, e5, n4) => {
    e5.constructor.createProperty(n4, i3);
  })(e4, n3, t2) : i$6(e4, n3);
}

// node_modules/@lit/reactive-element/decorators/state.js
function t$4(t2) {
  return e$7(__spreadProps(__spreadValues({}, t2), { state: true }));
}

// node_modules/@lit/reactive-element/decorators/base.js
var o$6 = ({ finisher: e4, descriptor: t2 }) => (o2, n3) => {
  var r;
  if (n3 === void 0) {
    const n4 = (r = o2.originalKey) !== null && r !== void 0 ? r : o2.key, i3 = t2 != null ? { kind: "method", placement: "prototype", key: n4, descriptor: t2(o2.key) } : __spreadProps(__spreadValues({}, o2), { key: n4 });
    return e4 != null && (i3.finisher = function(t3) {
      e4(t3, n4);
    }), i3;
  }
  {
    const r2 = o2.constructor;
    t2 !== void 0 && Object.defineProperty(o2, n3, t2(n3)), e4 == null || e4(r2, n3);
  }
};

// node_modules/@lit/reactive-element/decorators/query.js
function i2(i3, n3) {
  return o$6({ descriptor: (o2) => {
    const t2 = { get() {
      var o3, n4;
      return (n4 = (o3 = this.renderRoot) === null || o3 === void 0 ? void 0 : o3.querySelector(i3)) !== null && n4 !== void 0 ? n4 : null;
    }, enumerable: true, configurable: true };
    if (n3) {
      const n4 = typeof o2 == "symbol" ? Symbol() : "__" + o2;
      t2.get = function() {
        var o3, t3;
        return this[n4] === void 0 && (this[n4] = (t3 = (o3 = this.renderRoot) === null || o3 === void 0 ? void 0 : o3.querySelector(i3)) !== null && t3 !== void 0 ? t3 : null), this[n4];
      };
    }
    return t2;
  } });
}

// node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
var n2;
((n2 = window.HTMLSlotElement) === null || n2 === void 0 ? void 0 : n2.prototype.assignedElements) != null ? (o2, n3) => o2.assignedElements(n3) : (o2, n3) => o2.assignedNodes(n3).filter((o3) => o3.nodeType === Node.ELEMENT_NODE);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

// src/components/radio-group/radio-group.ts
var RADIO_CHILDREN = ["sl-radio", "sl-radio-button"];
var SlRadioGroup = class extends s4 {
  constructor() {
    super(...arguments);
    this.hasButtonGroup = false;
    this.label = "";
    this.fieldset = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "radiogroup");
  }
  getAllRadios() {
    return [...this.querySelectorAll(RADIO_CHILDREN.join(","))].filter((el) => RADIO_CHILDREN.includes(el.tagName.toLowerCase()));
  }
  handleRadioClick(event) {
    const target = event.target;
    const checkedRadio = target.closest(RADIO_CHILDREN.map((selector) => `${selector}:not([disabled])`).join(","));
    if (checkedRadio) {
      const radios = this.getAllRadios();
      radios.forEach((radio) => {
        radio.checked = radio === checkedRadio;
        radio.input.tabIndex = radio === checkedRadio ? 0 : -1;
      });
    }
  }
  handleKeyDown(event) {
    var _a;
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
      const radios = this.getAllRadios().filter((radio) => !radio.disabled);
      const checkedRadio = (_a = radios.find((radio) => radio.checked)) != null ? _a : radios[0];
      const incr = ["ArrowUp", "ArrowLeft"].includes(event.key) ? -1 : 1;
      let index = radios.indexOf(checkedRadio) + incr;
      if (index < 0) {
        index = radios.length - 1;
      }
      if (index > radios.length - 1) {
        index = 0;
      }
      this.getAllRadios().forEach((radio) => {
        radio.checked = false;
        radio.input.tabIndex = -1;
      });
      radios[index].focus();
      radios[index].checked = true;
      radios[index].input.tabIndex = 0;
      event.preventDefault();
    }
  }
  handleSlotChange() {
    const radios = this.getAllRadios();
    const checkedRadio = radios.find((radio) => radio.checked);
    this.hasButtonGroup = !!radios.find((radio) => radio.tagName.toLowerCase() === "sl-radio-button");
    radios.forEach((radio) => {
      radio.setAttribute("role", "radio");
      radio.input.tabIndex = -1;
    });
    if (checkedRadio) {
      checkedRadio.input.tabIndex = 0;
    } else if (radios.length > 0) {
      radios[0].input.tabIndex = 0;
    }
  }
  render() {
    const defaultSlot = $$1`
      <slot @click=${this.handleRadioClick} @keydown=${this.handleKeyDown} @slotchange=${this.handleSlotChange}></slot>
    `;
    return $$1`
      <fieldset
        part="base"
        class=${o$7({
      "radio-group": true,
      "radio-group--has-fieldset": this.fieldset
    })}
      >
        <legend part="label" class="radio-group__label">
          <slot name="label">${this.label}</slot>
        </legend>
        ${this.hasButtonGroup ? $$1`<sl-button-group part="button-group">${defaultSlot}</sl-button-group>` : defaultSlot}
      </fieldset>
    `;
  }
};
SlRadioGroup.styles = radio_group_styles_default;
__decorateClass([
  i2("slot:not([name])")
], SlRadioGroup.prototype, "defaultSlot", 2);
__decorateClass([
  t$4()
], SlRadioGroup.prototype, "hasButtonGroup", 2);
__decorateClass([
  e$7()
], SlRadioGroup.prototype, "label", 2);
__decorateClass([
  e$7({ type: Boolean, attribute: "fieldset" })
], SlRadioGroup.prototype, "fieldset", 2);
SlRadioGroup = __decorateClass([
  n$6("sl-radio-group")
], SlRadioGroup);

// src/components/button-group/button-group.styles.ts
var button_group_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`;

// src/components/button-group/button-group.ts
var BUTTON_CHILDREN = ["sl-button", "sl-radio-button"];
var SlButtonGroup = class extends s4 {
  constructor() {
    super(...arguments);
    this.label = "";
  }
  handleFocus(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.classList.add("sl-button-group__button--focus");
  }
  handleBlur(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.classList.remove("sl-button-group__button--focus");
  }
  handleMouseOver(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.classList.add("sl-button-group__button--hover");
  }
  handleMouseOut(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.classList.remove("sl-button-group__button--hover");
  }
  handleSlotChange() {
    const slottedElements = [...this.defaultSlot.assignedElements({ flatten: true })];
    slottedElements.forEach((el) => {
      const index = slottedElements.indexOf(el);
      const button = findButton(el);
      if (button !== null) {
        button.classList.add("sl-button-group__button");
        button.classList.toggle("sl-button-group__button--first", index === 0);
        button.classList.toggle("sl-button-group__button--inner", index > 0 && index < slottedElements.length - 1);
        button.classList.toggle("sl-button-group__button--last", index === slottedElements.length - 1);
      }
    });
  }
  render() {
    return $$1`
      <div
        part="base"
        class="button-group"
        role="group"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlButtonGroup.styles = button_group_styles_default;
__decorateClass([
  i2("slot")
], SlButtonGroup.prototype, "defaultSlot", 2);
__decorateClass([
  e$7()
], SlButtonGroup.prototype, "label", 2);
SlButtonGroup = __decorateClass([
  n$6("sl-button-group")
], SlButtonGroup);
function findButton(el) {
  return BUTTON_CHILDREN.includes(el.tagName.toLowerCase()) ? el : el.querySelector(BUTTON_CHILDREN.join(","));
}

// src/internal/focus-visible.ts
var hasFocusVisible = (() => {
  const style = document.createElement("style");
  let isSupported;
  try {
    document.head.appendChild(style);
    style.sheet.insertRule(":focus-visible { color: inherit }");
    isSupported = true;
  } catch (e) {
    isSupported = false;
  } finally {
    style.remove();
  }
  return isSupported;
})();
var focusVisibleSelector = o$8(hasFocusVisible ? ":focus-visible" : ":focus");

// src/components/button/button.styles.ts
var button_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition: var(--sl-transition-x-fast) background-color, var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border, var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label ::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-success-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-neutral-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-warning-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-danger-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text${focusVisibleSelector}:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    font-size: var(--sl-button-font-size-small);
    height: var(--sl-input-height-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    font-size: var(--sl-button-font-size-medium);
    height: var(--sl-input-height-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    font-size: var(--sl-button-font-size-large);
    height: var(--sl-input-height-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    display: flex;
    align-items: center;
  }

  .button--caret .button__caret svg {
    width: 1em;
    height: 1em;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    transform: translateY(-50%) translateX(50%);
    pointer-events: none;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-left: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-left: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-right: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-right: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-right: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-right: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-right: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-right: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host(.sl-button-group__button--first:not(.sl-button-group__button--last)) .button {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
  }

  :host(.sl-button-group__button--inner) .button {
    border-radius: 0;
  }

  :host(.sl-button-group__button--last:not(.sl-button-group__button--first)) .button {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }

  /* All except the first */
  :host(.sl-button-group__button:not(.sl-button-group__button--first)) {
    margin-left: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(.sl-button-group__button:not(.sl-button-group__button--focus, .sl-button-group__button--first, [variant='default']):not(:hover, :active, :focus))
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host(.sl-button-group__button--hover) {
    z-index: 1;
  }

  :host(.sl-button-group__button--focus),
  :host(.sl-button-group__button[checked]) {
    z-index: 2;
  }
`;

// src/components/radio-button/radio-button.styles.ts
var radio_button_styles_default = r$5`
  ${button_styles_default}
  label {
    display: inline-block;
    position: relative;
  }
  /* We use a hidden input so constraint validation errors work, since they don't appear to show when used with buttons.
    We can't actually hide it, though, otherwise the messages will be suppressed by the browser. */
  .hidden-input {
    all: unset;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    outline: dotted 1px red;
    opacity: 0;
    z-index: -1;
  }
`;

// node_modules/lit-html/static.js
var r$4 = (t, ...e) => ({ _$litStatic$: e.reduce((e2, o, r2) => e2 + ((t2) => {
  if (t2._$litStatic$ !== void 0)
    return t2._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t2}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(o) + t[r2 + 1], t[0]) });
var i$5 = /* @__PURE__ */ new Map();
var a$2 = (t) => (e, ...o) => {
  var r2;
  const a2 = o.length;
  let l2, s2;
  const n = [], u = [];
  let c, $2 = 0, v = false;
  for (; $2 < a2; ) {
    for (c = e[$2]; $2 < a2 && (s2 = o[$2], l2 = (r2 = s2) === null || r2 === void 0 ? void 0 : r2._$litStatic$) !== void 0; )
      c += l2 + e[++$2], v = true;
    u.push(s2), n.push(c), $2++;
  }
  if ($2 === a2 && n.push(e[a2]), v) {
    const t2 = n.join("$$lit$$");
    (e = i$5.get(t2)) === void 0 && (n.raw = n, i$5.set(t2, e = n)), o = u;
  }
  return t(e, ...o);
};
var l$5 = a$2($$1);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

// src/internal/formdata-event-polyfill.ts
var FormDataEventPolyfill = class extends Event {
  constructor(formData) {
    super("formdata");
    this.formData = formData;
  }
};
var FormDataPolyfill = class extends FormData {
  constructor(form) {
    super(form);
    this.form = form;
    form.dispatchEvent(new FormDataEventPolyfill(this));
  }
  append(name, value) {
    let input = this.form.elements[name];
    if (!input) {
      input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      this.form.appendChild(input);
    }
    if (this.has(name)) {
      const entries = this.getAll(name);
      const index = entries.indexOf(input.value);
      if (index !== -1) {
        entries.splice(index, 1);
      }
      entries.push(value);
      this.set(name, entries);
    } else {
      super.append(name, value);
    }
    input.value = value;
  }
};
function supportsFormDataEvent() {
  const form = document.createElement("form");
  let isSupported = false;
  document.body.append(form);
  form.addEventListener("submit", (event) => {
    new FormData(event.target);
    event.preventDefault();
  });
  form.addEventListener("formdata", () => isSupported = true);
  form.dispatchEvent(new Event("submit", { cancelable: true }));
  form.remove();
  return isSupported;
}
function polyfillFormData() {
  if (!window.FormData || supportsFormDataEvent()) {
    return;
  }
  window.FormData = FormDataPolyfill;
  window.addEventListener("submit", (event) => {
    if (!event.defaultPrevented) {
      new FormData(event.target);
    }
  });
}
if (document.readyState === "complete") {
  polyfillFormData();
} else {
  window.addEventListener("DOMContentLoaded", () => polyfillFormData());
}

// src/internal/form.ts
var FormSubmitController = class {
  constructor(host, options) {
    (this.host = host).addController(this);
    this.options = __spreadValues({
      form: (input) => input.closest("form"),
      name: (input) => input.name,
      value: (input) => input.value,
      disabled: (input) => input.disabled,
      reportValidity: (input) => {
        return typeof input.reportValidity === "function" ? input.reportValidity() : true;
      }
    }, options);
    this.handleFormData = this.handleFormData.bind(this);
    this.handleFormSubmit = this.handleFormSubmit.bind(this);
  }
  hostConnected() {
    document.addEventListener("formdata", this.handleFormData, { capture: true });
    document.addEventListener("submit", this.handleFormSubmit, { capture: true });
  }
  hostDisconnected() {
    document.removeEventListener("formdata", this.handleFormData, { capture: true });
    document.removeEventListener("submit", this.handleFormSubmit, { capture: true });
  }
  handleFormData(event) {
    const disabled = this.options.disabled(this.host);
    const name = this.options.name(this.host);
    const value = this.options.value(this.host);
    if (!disabled && typeof name === "string" && typeof value !== "undefined") {
      if (Array.isArray(value)) {
        value.forEach((val) => {
          event.formData.append(name, val.toString());
        });
      } else {
        event.formData.append(name, value.toString());
      }
    }
  }
  handleFormSubmit(event) {
    const form = this.options.form(this.host);
    const disabled = this.options.disabled(this.host);
    const reportValidity = this.options.reportValidity;
    if (event.target === form && !disabled && !(form == null ? void 0 : form.noValidate) && !reportValidity(this.host)) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
  }
  submit(submitter) {
    const form = this.options.form(this.host);
    if (form) {
      const button = document.createElement("button");
      button.type = "submit";
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        ["formaction", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      form.append(button);
      button.click();
      button.remove();
    }
  }
};

// src/internal/slot.ts
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    (this.host = host).addController(this);
    this.slotNames = slotNames;
    this.handleSlotChange = this.handleSlotChange.bind(this);
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
  handleSlotChange(event) {
    const slot = event.target;
    if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
      this.host.requestUpdate();
    }
  }
};
function getTextContent(slot) {
  if (!slot) {
    return "";
  }
  const nodes = slot.assignedNodes({ flatten: true });
  let text = "";
  [...nodes].forEach((node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent;
    }
  });
  return text;
}

// node_modules/lit-html/directives/if-defined.js
var l$4 = (l2) => l2 != null ? l2 : w$1;
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

// src/internal/watch.ts
function watch(propName, options) {
  const resolvedOptions = __spreadValues({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update } = proto;
    if (propName in proto) {
      const propNameKey = propName;
      proto.update = function(changedProps) {
        if (changedProps.has(propNameKey)) {
          const oldValue = changedProps.get(propNameKey);
          const newValue = this[propNameKey];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
        update.call(this, changedProps);
      };
    }
  };
}

// src/internal/event.ts
function emit(el, name, options) {
  const event = new CustomEvent(name, __spreadValues({
    bubbles: true,
    cancelable: false,
    composed: true,
    detail: {}
  }, options));
  el.dispatchEvent(event);
  return event;
}
function waitForEvent(el, eventName) {
  return new Promise((resolve) => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}

// src/components/radio-button/radio-button.ts
var SlRadioButton = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this, {
      value: (control) => control.checked ? control.value : void 0
    });
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.hasFocus = false;
    this.disabled = false;
    this.checked = false;
    this.invalid = false;
    this.variant = "default";
    this.size = "medium";
    this.pill = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "radio");
  }
  click() {
    this.input.click();
  }
  focus(options) {
    this.input.focus(options);
  }
  blur() {
    this.input.blur();
  }
  reportValidity() {
    return this.hiddenInput.reportValidity();
  }
  setCustomValidity(message) {
    this.hiddenInput.setCustomValidity(message);
  }
  handleBlur() {
    this.hasFocus = false;
    emit(this, "sl-blur");
  }
  handleClick() {
    if (!this.disabled) {
      this.checked = true;
    }
  }
  handleFocus() {
    this.hasFocus = true;
    emit(this, "sl-focus");
  }
  handleCheckedChange() {
    this.setAttribute("aria-checked", this.checked ? "true" : "false");
    if (this.hasUpdated) {
      emit(this, "sl-change");
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
    if (this.hasUpdated) {
      this.input.disabled = this.disabled;
      this.invalid = !this.input.checkValidity();
    }
  }
  render() {
    return l$5`
      <div part="base">
        <input class="hidden-input" type="radio" aria-hidden="true" tabindex="-1" />
        <button
          part="button"
          class=${o$7({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--checked": this.checked,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--outline": true,
      "button--pill": this.pill,
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
          ?disabled=${this.disabled}
          type="button"
          name=${l$4(this.name)}
          value=${l$4(this.value)}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @click=${this.handleClick}
        >
          <span part="prefix" class="button__prefix">
            <slot name="prefix"></slot>
          </span>
          <span part="label" class="button__label">
            <slot></slot>
          </span>
          <span part="suffix" class="button__suffix">
            <slot name="suffix"></slot>
          </span>
        </button>
      </div>
    `;
  }
};
SlRadioButton.styles = radio_button_styles_default;
__decorateClass([
  i2(".button")
], SlRadioButton.prototype, "input", 2);
__decorateClass([
  i2(".hidden-input")
], SlRadioButton.prototype, "hiddenInput", 2);
__decorateClass([
  t$4()
], SlRadioButton.prototype, "hasFocus", 2);
__decorateClass([
  e$7()
], SlRadioButton.prototype, "name", 2);
__decorateClass([
  e$7()
], SlRadioButton.prototype, "value", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlRadioButton.prototype, "disabled", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlRadioButton.prototype, "checked", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlRadioButton.prototype, "invalid", 2);
__decorateClass([
  watch("checked")
], SlRadioButton.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlRadioButton.prototype, "handleDisabledChange", 1);
__decorateClass([
  e$7({ reflect: true })
], SlRadioButton.prototype, "variant", 2);
__decorateClass([
  e$7({ reflect: true })
], SlRadioButton.prototype, "size", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlRadioButton.prototype, "pill", 2);
SlRadioButton = __decorateClass([
  n$6("sl-radio-button")
], SlRadioButton);

// src/styles/form-control.styles.ts
var form_control_styles_default = r$5`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control_label {
    font-size: var(--sl-input-label-font-size-large);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
  }

  .form-control--has-help-text .form-control__help-text ::slotted(*) {
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }
`;

// src/components/input/input.styles.ts
var input_styles_default = r$5`
  ${component_styles_default}
  ${form_control_styles_default}

  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition: var(--sl-transition-fast) color, var(--sl-transition-fast) border, var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: var(--sl-focus-ring);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    box-shadow: var(--sl-focus-ring);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: none;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    padding-left: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    padding-right: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    padding-left: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    padding-right: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    padding-left: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    padding-right: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  .input--empty .input__clear {
    visibility: hidden;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }
`;

// node_modules/@shoelace-style/localize/dist/index.js
var connectedElements = /* @__PURE__ */ new Set();
var documentElementObserver = new MutationObserver(update);
var translations = /* @__PURE__ */ new Map();
var documentLanguage = document.documentElement.lang || navigator.language;
var fallback;
documentElementObserver.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ["lang"]
});
function registerTranslation(...translation2) {
  translation2.map((t) => {
    const code = t.$code.toLowerCase();
    translations.set(code, t);
    if (!fallback) {
      fallback = t;
    }
  });
  update();
}
function term(lang, key, ...args) {
  const code = lang.toLowerCase().slice(0, 2);
  const subcode = lang.length > 2 ? lang.toLowerCase() : "";
  const primary = translations.get(subcode);
  const secondary = translations.get(code);
  let term2;
  if (primary && primary[key]) {
    term2 = primary[key];
  } else if (secondary && secondary[key]) {
    term2 = secondary[key];
  } else if (fallback && fallback[key]) {
    term2 = fallback[key];
  } else {
    console.error(`No translation found for: ${key}`);
    return key;
  }
  if (typeof term2 === "function") {
    return term2(...args);
  }
  return term2;
}
function date(lang, dateToFormat, options) {
  dateToFormat = new Date(dateToFormat);
  return new Intl.DateTimeFormat(lang, options).format(dateToFormat);
}
function number(lang, numberToFormat, options) {
  numberToFormat = Number(numberToFormat);
  return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(lang, options).format(numberToFormat);
}
function relativeTime(lang, value, unit, options) {
  return new Intl.RelativeTimeFormat(lang, options).format(value, unit);
}
function update() {
  documentLanguage = document.documentElement.lang || navigator.language;
  [...connectedElements.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  term(key, ...args) {
    return term(this.host.lang || documentLanguage, key, ...args);
  }
  date(dateToFormat, options) {
    return date(this.host.lang || documentLanguage, dateToFormat, options);
  }
  number(numberToFormat, options) {
    return number(this.host.lang || documentLanguage, numberToFormat, options);
  }
  relativeTime(value, unit, options) {
    return relativeTime(this.host.lang || documentLanguage, value, unit, options);
  }
};

// src/translations/en.ts
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  clearEntry: "Clear entry",
  close: "Close",
  copy: "Copy",
  currentValue: "Current value",
  hidePassword: "Hide password",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  toggleColorFormat: "Toggle color format"
};
registerTranslation(translation);

// node_modules/lit-html/directive-helpers.js
var r$3 = (o) => o.strings === void 0;
var f$1 = {};
var s$4 = (o, i2 = f$1) => o._$AH = i2;

// node_modules/lit-html/directives/live.js
var l$3 = e$8(class extends i$7 {
  constructor(r2) {
    if (super(r2), r2.type !== t$5.PROPERTY && r2.type !== t$5.ATTRIBUTE && r2.type !== t$5.BOOLEAN_ATTRIBUTE)
      throw Error("The `live` directive is not allowed on child or event bindings");
    if (!r$3(r2))
      throw Error("`live` bindings can only contain a single expression");
  }
  render(r2) {
    return r2;
  }
  update(i2, [t2]) {
    if (t2 === b$1 || t2 === w$1)
      return t2;
    const o = i2.element, l2 = i2.name;
    if (i2.type === t$5.PROPERTY) {
      if (t2 === o[l2])
        return b$1;
    } else if (i2.type === t$5.BOOLEAN_ATTRIBUTE) {
      if (!!t2 === o.hasAttribute(l2))
        return b$1;
    } else if (i2.type === t$5.ATTRIBUTE && o.getAttribute(l2) === t2 + "")
      return b$1;
    return s$4(i2), t2;
  }
});
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

// src/components/input/input.ts
var SlInput = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController(this);
    this.hasFocus = false;
    this.isPasswordVisible = false;
    this.type = "text";
    this.size = "medium";
    this.value = "";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.helpText = "";
    this.clearable = false;
    this.togglePassword = false;
    this.disabled = false;
    this.readonly = false;
    this.required = false;
    this.invalid = false;
  }
  get valueAsDate() {
    var _a, _b;
    return (_b = (_a = this.input) == null ? void 0 : _a.valueAsDate) != null ? _b : null;
  }
  set valueAsDate(newValue) {
    this.updateComplete.then(() => {
      this.input.valueAsDate = newValue;
      this.value = this.input.value;
    });
  }
  get valueAsNumber() {
    var _a, _b;
    return (_b = (_a = this.input) == null ? void 0 : _a.valueAsNumber) != null ? _b : parseFloat(this.value);
  }
  set valueAsNumber(newValue) {
    this.updateComplete.then(() => {
      this.input.valueAsNumber = newValue;
      this.value = this.input.value;
    });
  }
  firstUpdated() {
    this.invalid = !this.input.checkValidity();
  }
  focus(options) {
    this.input.focus(options);
  }
  blur() {
    this.input.blur();
  }
  select() {
    this.input.select();
  }
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  setRangeText(replacement, start, end, selectMode = "preserve") {
    this.input.setRangeText(replacement, start, end, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
      emit(this, "sl-input");
      emit(this, "sl-change");
    }
  }
  reportValidity() {
    return this.input.reportValidity();
  }
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.invalid = !this.input.checkValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    emit(this, "sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    emit(this, "sl-change");
  }
  handleClearClick(event) {
    this.value = "";
    emit(this, "sl-clear");
    emit(this, "sl-input");
    emit(this, "sl-change");
    this.input.focus();
    event.stopPropagation();
  }
  handleDisabledChange() {
    this.input.disabled = this.disabled;
    this.invalid = !this.input.checkValidity();
  }
  handleFocus() {
    this.hasFocus = true;
    emit(this, "sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    emit(this, "sl-input");
  }
  handleInvalid() {
    this.invalid = true;
  }
  handleKeyDown(event) {
    const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
    if (event.key === "Enter" && !hasModifier) {
      this.formSubmitController.submit();
    }
  }
  handlePasswordToggle() {
    this.isPasswordVisible = !this.isPasswordVisible;
  }
  handleValueChange() {
    this.invalid = !this.input.checkValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return $$1`
      <div
        part="form-control"
        class=${o$7({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${o$7({
      input: true,
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": this.value.length === 0,
      "input--invalid": this.invalid
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.isPasswordVisible ? "text" : this.type}
              name=${l$4(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${l$4(this.placeholder)}
              minlength=${l$4(this.minlength)}
              maxlength=${l$4(this.maxlength)}
              min=${l$4(this.min)}
              max=${l$4(this.max)}
              step=${l$4(this.step)}
              .value=${l$3(this.value)}
              autocapitalize=${l$4(this.autocapitalize)}
              autocomplete=${l$4(this.autocomplete)}
              autocorrect=${l$4(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${l$4(this.spellcheck)}
              pattern=${l$4(this.pattern)}
              enterkeyhint=${l$4(this.enterkeyhint)}
              inputmode=${l$4(this.inputmode)}
              aria-describedby="help-text"
              aria-invalid=${this.invalid ? "true" : "false"}
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${this.clearable && this.value.length > 0 ? $$1`
                  <button
                    part="clear-button"
                    class="input__clear"
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.togglePassword ? $$1`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.isPasswordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.isPasswordVisible ? $$1`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : $$1`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = input_styles_default;
__decorateClass([
  i2(".input__control")
], SlInput.prototype, "input", 2);
__decorateClass([
  t$4()
], SlInput.prototype, "hasFocus", 2);
__decorateClass([
  t$4()
], SlInput.prototype, "isPasswordVisible", 2);
__decorateClass([
  e$7({ reflect: true })
], SlInput.prototype, "type", 2);
__decorateClass([
  e$7({ reflect: true })
], SlInput.prototype, "size", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "name", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "value", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlInput.prototype, "filled", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlInput.prototype, "pill", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "label", 2);
__decorateClass([
  e$7({ attribute: "help-text" })
], SlInput.prototype, "helpText", 2);
__decorateClass([
  e$7({ type: Boolean })
], SlInput.prototype, "clearable", 2);
__decorateClass([
  e$7({ attribute: "toggle-password", type: Boolean })
], SlInput.prototype, "togglePassword", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "placeholder", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlInput.prototype, "disabled", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlInput.prototype, "readonly", 2);
__decorateClass([
  e$7({ type: Number })
], SlInput.prototype, "minlength", 2);
__decorateClass([
  e$7({ type: Number })
], SlInput.prototype, "maxlength", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "min", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "max", 2);
__decorateClass([
  e$7({ type: Number })
], SlInput.prototype, "step", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "pattern", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlInput.prototype, "required", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlInput.prototype, "invalid", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "autocapitalize", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "autocorrect", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "autocomplete", 2);
__decorateClass([
  e$7({ type: Boolean })
], SlInput.prototype, "autofocus", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "enterkeyhint", 2);
__decorateClass([
  e$7({ type: Boolean })
], SlInput.prototype, "spellcheck", 2);
__decorateClass([
  e$7()
], SlInput.prototype, "inputmode", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleValueChange", 1);
SlInput = __decorateClass([
  n$6("sl-input")
], SlInput);

// src/utilities/base-path.ts
var basePath = "";
function setBasePath(path) {
  basePath = path;
}
function getBasePath() {
  return basePath.replace(/\/$/, "");
}
var scripts = [...document.getElementsByTagName("script")];
var configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
if (configScript) {
  setBasePath(configScript.getAttribute("data-shoelace"));
} else {
  const fallbackScript = scripts.find((s) => /shoelace(\.min)?\.js($|\?)/.test(s.src));
  let path = "";
  if (fallbackScript) {
    path = fallbackScript.getAttribute("src");
  }
  setBasePath(path.split("/").slice(0, -1).join("/"));
}

// src/components/icon/library.default.ts
var library = {
  name: "default",
  resolver: (name) => `${getBasePath()}/assets/icons/${name}.svg`
};
var library_default_default = library;

// src/components/icon/library.system.ts
var icons = {
  "check-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-lg" viewBox="0 0 16 16">
      <path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 0 1 0-1.06.733.733 0 0 1 1.047 0l3.052 3.093 5.4-6.425a.247.247 0 0 1 .02-.022Z"></path>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  x: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">
      <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary = {
  name: "system",
  resolver: (name) => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  }
};
var library_system_default = systemLibrary;

// src/components/icon/library.ts
var registry = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter((el) => el !== icon);
}
function getIconLibrary(name) {
  return registry.find((lib) => lib.name === name);
}

// src/components/include/request.ts
var includeFiles = /* @__PURE__ */ new Map();
function requestInclude(src, mode = "cors") {
  if (includeFiles.has(src)) {
    return includeFiles.get(src);
  }
  const fileDataPromise = fetch(src, { mode }).then(async (response) => {
    return {
      ok: response.ok,
      status: response.status,
      html: await response.text()
    };
  });
  includeFiles.set(src, fileDataPromise);
  return fileDataPromise;
}

// src/components/icon/request.ts
var iconFiles = /* @__PURE__ */ new Map();
async function requestIcon(url) {
  if (iconFiles.has(url)) {
    return iconFiles.get(url);
  }
  const fileData = await requestInclude(url);
  const iconFileData = {
    ok: fileData.ok,
    status: fileData.status,
    svg: null
  };
  if (fileData.ok) {
    const div = document.createElement("div");
    div.innerHTML = fileData.html;
    const svg = div.firstElementChild;
    iconFileData.svg = (svg == null ? void 0 : svg.tagName.toLowerCase()) === "svg" ? svg.outerHTML : "";
  }
  iconFiles.set(url, iconFileData);
  return iconFileData;
}

// src/components/icon/icon.styles.ts
var icon_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    contain: strict;
    box-sizing: content-box !important;
  }

  .icon,
  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

// node_modules/lit-html/directives/unsafe-html.js
var e3 = class extends i$7 {
  constructor(i2) {
    if (super(i2), this.it = w$1, i2.type !== t$5.CHILD)
      throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(r) {
    if (r === w$1 || r == null)
      return this.vt = void 0, this.it = r;
    if (r === b$1)
      return r;
    if (typeof r != "string")
      throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (r === this.it)
      return this.vt;
    this.it = r;
    const s2 = [r];
    return s2.raw = s2, this.vt = { _$litType$: this.constructor.resultType, strings: s2, values: [] };
  }
};
e3.directiveName = "unsafeHTML", e3.resultType = 1;

// node_modules/lit-html/directives/unsafe-svg.js
var t3 = class extends e3 {
};
t3.directiveName = "unsafeSVG", t3.resultType = 2;
var o2 = e$8(t3);

// src/components/icon/icon.ts
var parser = new DOMParser();
var SlIcon = class extends s4 {
  constructor() {
    super(...arguments);
    this.svg = "";
    this.label = "";
    this.library = "default";
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getUrl() {
    const library = getIconLibrary(this.library);
    if (this.name && library) {
      return library.resolver(this.name);
    }
    return this.src;
  }
  redraw() {
    this.setIcon();
  }
  async setIcon() {
    var _a;
    const library = getIconLibrary(this.library);
    const url = this.getUrl();
    if (url) {
      try {
        const file = await requestIcon(url);
        if (url !== this.getUrl()) {
          return;
        } else if (file.ok) {
          const doc = parser.parseFromString(file.svg, "text/html");
          const svgEl = doc.body.querySelector("svg");
          if (svgEl !== null) {
            (_a = library == null ? void 0 : library.mutator) == null ? void 0 : _a.call(library, svgEl);
            this.svg = svgEl.outerHTML;
            emit(this, "sl-load");
          } else {
            this.svg = "";
            emit(this, "sl-error");
          }
        } else {
          this.svg = "";
          emit(this, "sl-error");
        }
      } catch (e4) {
        emit(this, "sl-error");
      }
    } else if (this.svg.length > 0) {
      this.svg = "";
    }
  }
  handleChange() {
    this.setIcon();
  }
  render() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    return $$1` <div
      part="base"
      class="icon"
      role=${l$4(hasLabel ? "img" : void 0)}
      aria-label=${l$4(hasLabel ? this.label : void 0)}
      aria-hidden=${l$4(hasLabel ? void 0 : "true")}
    >
      ${o2(this.svg)}
    </div>`;
  }
};
SlIcon.styles = icon_styles_default;
__decorateClass([
  t$4()
], SlIcon.prototype, "svg", 2);
__decorateClass([
  e$7()
], SlIcon.prototype, "name", 2);
__decorateClass([
  e$7()
], SlIcon.prototype, "src", 2);
__decorateClass([
  e$7()
], SlIcon.prototype, "label", 2);
__decorateClass([
  e$7()
], SlIcon.prototype, "library", 2);
__decorateClass([
  watch("name"),
  watch("src"),
  watch("library")
], SlIcon.prototype, "setIcon", 1);
SlIcon = __decorateClass([
  n$6("sl-icon")
], SlIcon);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

// src/internal/tabbable.ts
function isTabbable(el) {
  const tag = el.tagName.toLowerCase();
  if (el.getAttribute("tabindex") === "-1") {
    return false;
  }
  if (el.hasAttribute("disabled")) {
    return false;
  }
  if (el.hasAttribute("aria-disabled") && el.getAttribute("aria-disabled") !== "false") {
    return false;
  }
  if (tag === "input" && el.getAttribute("type") === "radio" && !el.hasAttribute("checked")) {
    return false;
  }
  if (el.offsetParent === null) {
    return false;
  }
  if (window.getComputedStyle(el).visibility === "hidden") {
    return false;
  }
  if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) {
    return true;
  }
  if (el.hasAttribute("tabindex")) {
    return true;
  }
  if (el.hasAttribute("contenteditable") && el.getAttribute("contenteditable") !== "false") {
    return true;
  }
  return ["button", "input", "select", "textarea", "a", "audio", "video", "summary"].includes(tag);
}
function getTabbableBoundary(root) {
  var _a, _b;
  const allElements = [];
  function walk(el) {
    if (el instanceof HTMLElement) {
      allElements.push(el);
      if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
        walk(el.shadowRoot);
      }
    }
    [...el.querySelectorAll("*")].forEach((e) => walk(e));
  }
  walk(root);
  const start = (_a = allElements.find((el) => isTabbable(el))) != null ? _a : null;
  const end = (_b = allElements.reverse().find((el) => isTabbable(el))) != null ? _b : null;
  return { start, end };
}

// src/internal/modal.ts
var activeModals = [];
var Modal = class {
  constructor(element) {
    this.tabDirection = "forward";
    this.element = element;
    this.handleFocusIn = this.handleFocusIn.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleKeyUp = this.handleKeyUp.bind(this);
  }
  activate() {
    activeModals.push(this.element);
    document.addEventListener("focusin", this.handleFocusIn);
    document.addEventListener("keydown", this.handleKeyDown);
    document.addEventListener("keyup", this.handleKeyUp);
  }
  deactivate() {
    activeModals = activeModals.filter((modal) => modal !== this.element);
    document.removeEventListener("focusin", this.handleFocusIn);
    document.removeEventListener("keydown", this.handleKeyDown);
    document.removeEventListener("keyup", this.handleKeyUp);
  }
  isActive() {
    return activeModals[activeModals.length - 1] === this.element;
  }
  checkFocus() {
    if (this.isActive()) {
      if (!this.element.matches(":focus-within")) {
        const { start, end } = getTabbableBoundary(this.element);
        const target = this.tabDirection === "forward" ? start : end;
        if (typeof (target == null ? void 0 : target.focus) === "function") {
          target.focus({ preventScroll: true });
        }
      }
    }
  }
  handleFocusIn() {
    this.checkFocus();
  }
  handleKeyDown(event) {
    if (event.key === "Tab" && event.shiftKey) {
      this.tabDirection = "backward";
    }
    requestAnimationFrame(() => this.checkFocus());
  }
  handleKeyUp() {
    this.tabDirection = "forward";
  }
};

// src/internal/offset.ts
function getOffset(element, parent) {
  return {
    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
  };
}

// src/internal/scroll.ts
var locks = /* @__PURE__ */ new Set();
function lockBodyScrolling(lockingEl) {
  locks.add(lockingEl);
  document.body.classList.add("sl-scroll-lock");
}
function unlockBodyScrolling(lockingEl) {
  locks.delete(lockingEl);
  if (locks.size === 0) {
    document.body.classList.remove("sl-scroll-lock");
  }
}
function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
  const offset = getOffset(element, container);
  const offsetTop = offset.top + container.scrollTop;
  const offsetLeft = offset.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction === "horizontal" || direction === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({ left: offsetLeft, behavior });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (offsetTop < minY) {
      container.scrollTo({ top: offsetTop, behavior });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });
    }
  }
}

// src/components/dialog/dialog.styles.ts
var dialog_styles_default = r$5`
  ${component_styles_default}

  :host {
    --width: 31rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .dialog {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: var(--sl-z-index-dialog);
  }

  .dialog__panel {
    display: flex;
    flex-direction: column;
    z-index: 2;
    width: var(--width);
    max-width: calc(100% - var(--sl-spacing-2x-large));
    max-height: calc(100% - var(--sl-spacing-2x-large));
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    box-shadow: var(--sl-shadow-x-large);
  }

  .dialog__panel:focus {
    outline: none;
  }

  /* Ensure there's enough vertical padding for phones that don't update vh when chrome appears (e.g. iPhone) */
  @media screen and (max-width: 420px) {
    .dialog__panel {
      max-height: 80vh;
    }
  }

  .dialog--open .dialog__panel {
    display: flex;
    opacity: 1;
    transform: none;
  }

  .dialog__header {
    flex: 0 0 auto;
    display: flex;
  }

  .dialog__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .dialog__close {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-x-large);
    padding: 0 var(--header-spacing);
  }

  .dialog__body {
    flex: 1 1 auto;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .dialog__footer {
    flex: 0 0 auto;
    text-align: right;
    padding: var(--footer-spacing);
  }

  .dialog__footer ::slotted(sl-button:not(:first-of-type)) {
    margin-left: var(--sl-spacing-x-small);
  }

  .dialog:not(.dialog--has-footer) .dialog__footer {
    display: none;
  }

  .dialog__overlay {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
  }
`;

// src/internal/animate.ts
function animateTo(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps(__spreadValues({}, options), {
      duration: prefersReducedMotion() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function parseDuration(delay) {
  delay = delay.toString().toLowerCase();
  if (delay.indexOf("ms") > -1) {
    return parseFloat(delay);
  }
  if (delay.indexOf("s") > -1) {
    return parseFloat(delay) * 1e3;
  }
  return parseFloat(delay);
}
function prefersReducedMotion() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations(el) {
  return Promise.all(el.getAnimations().map((animation) => {
    return new Promise((resolve) => {
      const handleAnimationEvent = requestAnimationFrame(resolve);
      animation.addEventListener("cancel", () => handleAnimationEvent, { once: true });
      animation.addEventListener("finish", () => handleAnimationEvent, { once: true });
      animation.cancel();
    });
  }));
}
function shimKeyframesHeightAuto(keyframes, calculatedHeight) {
  return keyframes.map((keyframe) => __spreadProps(__spreadValues({}, keyframe), {
    height: keyframe.height === "auto" ? `${calculatedHeight}px` : keyframe.height
  }));
}

// src/utilities/animation-registry.ts
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
  return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return customAnimation[animationName];
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return defaultAnimation;
  }
  return {
    keyframes: [],
    options: { duration: 0 }
  };
}

// src/components/dialog/dialog.ts
var SlDialog = class extends s4 {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "footer");
    this.localize = new LocalizeController(this);
    this.open = false;
    this.label = "";
    this.noHeader = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.modal = new Modal(this);
  }
  firstUpdated() {
    this.dialog.hidden = !this.open;
    if (this.open) {
      this.modal.activate();
      lockBodyScrolling(this);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unlockBodyScrolling(this);
  }
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  requestClose(source) {
    const slRequestClose = emit(this, "sl-request-close", {
      cancelable: true,
      detail: { source }
    });
    if (slRequestClose.defaultPrevented) {
      const animation = getAnimation(this, "dialog.denyClose");
      animateTo(this.panel, animation.keyframes, animation.options);
      return;
    }
    this.hide();
  }
  handleKeyDown(event) {
    if (event.key === "Escape") {
      event.stopPropagation();
      this.requestClose("keyboard");
    }
  }
  async handleOpenChange() {
    if (this.open) {
      emit(this, "sl-show");
      this.originalTrigger = document.activeElement;
      this.modal.activate();
      lockBodyScrolling(this);
      const autoFocusTarget = this.querySelector("[autofocus]");
      if (autoFocusTarget) {
        autoFocusTarget.removeAttribute("autofocus");
      }
      await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]);
      this.dialog.hidden = false;
      requestAnimationFrame(() => {
        const slInitialFocus = emit(this, "sl-initial-focus", { cancelable: true });
        if (!slInitialFocus.defaultPrevented) {
          if (autoFocusTarget) {
            autoFocusTarget.focus({ preventScroll: true });
          } else {
            this.panel.focus({ preventScroll: true });
          }
        }
        if (autoFocusTarget) {
          autoFocusTarget.setAttribute("autofocus", "");
        }
      });
      const panelAnimation = getAnimation(this, "dialog.show");
      const overlayAnimation = getAnimation(this, "dialog.overlay.show");
      await Promise.all([
        animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),
        animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)
      ]);
      emit(this, "sl-after-show");
    } else {
      emit(this, "sl-hide");
      this.modal.deactivate();
      await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]);
      const panelAnimation = getAnimation(this, "dialog.hide");
      const overlayAnimation = getAnimation(this, "dialog.overlay.hide");
      await Promise.all([
        animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),
        animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)
      ]);
      this.dialog.hidden = true;
      unlockBodyScrolling(this);
      const trigger = this.originalTrigger;
      if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
        setTimeout(() => trigger.focus());
      }
      emit(this, "sl-after-hide");
    }
  }
  render() {
    return $$1`
      <div
        part="base"
        class=${o$7({
      dialog: true,
      "dialog--open": this.open,
      "dialog--has-footer": this.hasSlotController.test("footer")
    })}
        @keydown=${this.handleKeyDown}
      >
        <div part="overlay" class="dialog__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="dialog__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${l$4(this.noHeader ? this.label : void 0)}
          aria-labelledby=${l$4(!this.noHeader ? "title" : void 0)}
          tabindex="0"
        >
          ${!this.noHeader ? $$1`
                <header part="header" class="dialog__header">
                  <h2 part="title" class="dialog__title" id="title">
                    <slot name="label"> ${this.label.length > 0 ? this.label : String.fromCharCode(65279)} </slot>
                  </h2>
                  <sl-icon-button
                    part="close-button"
                    exportparts="base:close-button__base"
                    class="dialog__close"
                    name="x"
                    label=${this.localize.term("close")}
                    library="system"
                    @click="${() => this.requestClose("close-button")}"
                  ></sl-icon-button>
                </header>
              ` : ""}

          <div part="body" class="dialog__body">
            <slot></slot>
          </div>

          <footer part="footer" class="dialog__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDialog.styles = dialog_styles_default;
__decorateClass([
  i2(".dialog")
], SlDialog.prototype, "dialog", 2);
__decorateClass([
  i2(".dialog__panel")
], SlDialog.prototype, "panel", 2);
__decorateClass([
  i2(".dialog__overlay")
], SlDialog.prototype, "overlay", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlDialog.prototype, "open", 2);
__decorateClass([
  e$7({ reflect: true })
], SlDialog.prototype, "label", 2);
__decorateClass([
  e$7({ attribute: "no-header", type: Boolean, reflect: true })
], SlDialog.prototype, "noHeader", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlDialog.prototype, "handleOpenChange", 1);
SlDialog = __decorateClass([
  n$6("sl-dialog")
], SlDialog);
setDefaultAnimation("dialog.show", {
  keyframes: [
    { opacity: 0, transform: "scale(0.8)" },
    { opacity: 1, transform: "scale(1)" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("dialog.hide", {
  keyframes: [
    { opacity: 1, transform: "scale(1)" },
    { opacity: 0, transform: "scale(0.8)" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("dialog.denyClose", {
  keyframes: [{ transform: "scale(1)" }, { transform: "scale(1.02)" }, { transform: "scale(1)" }],
  options: { duration: 250 }
});
setDefaultAnimation("dialog.overlay.show", {
  keyframes: [{ opacity: 0 }, { opacity: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("dialog.overlay.hide", {
  keyframes: [{ opacity: 1 }, { opacity: 0 }],
  options: { duration: 250 }
});

// src/components/icon-button/icon-button.styles.ts
var icon_button_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-medium) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button${focusVisibleSelector} {
    box-shadow: var(--sl-focus-ring);
  }
`;

// src/components/icon-button/icon-button.ts
var SlIconButton = class extends s4 {
  constructor() {
    super(...arguments);
    this.label = "";
    this.disabled = false;
  }
  render() {
    const isLink = this.href ? true : false;
    const interior = $$1`
      <sl-icon
        name=${l$4(this.name)}
        library=${l$4(this.library)}
        src=${l$4(this.src)}
        aria-hidden="true"
      ></sl-icon>
    `;
    return isLink ? $$1`
          <a
            part="base"
            class="icon-button"
            href=${l$4(this.href)}
            target=${l$4(this.target)}
            download=${l$4(this.download)}
            rel=${l$4(this.target ? "noreferrer noopener" : void 0)}
            role="button"
            aria-disabled=${this.disabled ? "true" : "false"}
            aria-label="${this.label}"
            tabindex=${this.disabled ? "-1" : "0"}
          >
            ${interior}
          </a>
        ` : $$1`
          <button
            part="base"
            class=${o$7({
      "icon-button": true,
      "icon-button--disabled": this.disabled
    })}
            ?disabled=${this.disabled}
            type="button"
            aria-label=${this.label}
          >
            ${interior}
          </button>
        `;
  }
};
SlIconButton.styles = icon_button_styles_default;
__decorateClass([
  i2(".icon-button")
], SlIconButton.prototype, "button", 2);
__decorateClass([
  e$7()
], SlIconButton.prototype, "name", 2);
__decorateClass([
  e$7()
], SlIconButton.prototype, "library", 2);
__decorateClass([
  e$7()
], SlIconButton.prototype, "src", 2);
__decorateClass([
  e$7()
], SlIconButton.prototype, "href", 2);
__decorateClass([
  e$7()
], SlIconButton.prototype, "target", 2);
__decorateClass([
  e$7()
], SlIconButton.prototype, "download", 2);
__decorateClass([
  e$7()
], SlIconButton.prototype, "label", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlIconButton.prototype, "disabled", 2);
SlIconButton = __decorateClass([
  n$6("sl-icon-button")
], SlIconButton);

// src/components/menu-item/menu-item.styles.ts
var menu_item_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: block;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    text-align: left;
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    color: var(--sl-color-neutral-400);
    cursor: not-allowed;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix ::slotted(*) {
    margin-right: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix ::slotted(*) {
    margin-left: var(--sl-spacing-x-small);
  }

  :host(:focus) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'])) .menu-item,
  :host(${focusVisibleSelector}:not(.sl-focus-invisible):not([aria-disabled='true'])) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }
`;

// src/components/menu-item/menu-item.ts
var SlMenuItem = class extends s4 {
  constructor() {
    super(...arguments);
    this.checked = false;
    this.value = "";
    this.disabled = false;
  }
  firstUpdated() {
    this.setAttribute("role", "menuitem");
  }
  handleCheckedChange() {
    this.setAttribute("aria-checked", this.checked ? "true" : "false");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  render() {
    return $$1`
      <div
        part="base"
        class=${o$7({
      "menu-item": true,
      "menu-item--checked": this.checked,
      "menu-item--disabled": this.disabled,
      "menu-item--has-submenu": false
    })}
      >
        <span class="menu-item__check">
          <sl-icon name="check-lg" library="default" aria-hidden="true"></sl-icon>
        </span>

        <span part="prefix" class="menu-item__prefix">
          <slot name="prefix"></slot>
        </span>

        <span part="label" class="menu-item__label">
          <slot></slot>
        </span>

        <span part="suffix" class="menu-item__suffix">
          <slot name="suffix"></slot>
        </span>

        <span class="menu-item__chevron">
          <sl-icon name="chevron-right" library="default" aria-hidden="true"></sl-icon>
        </span>
      </div>
    `;
  }
};
SlMenuItem.styles = menu_item_styles_default;
__decorateClass([
  i2(".menu-item")
], SlMenuItem.prototype, "menuItem", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "checked", 2);
__decorateClass([
  e$7()
], SlMenuItem.prototype, "value", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "disabled", 2);
__decorateClass([
  watch("checked")
], SlMenuItem.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled")
], SlMenuItem.prototype, "handleDisabledChange", 1);
SlMenuItem = __decorateClass([
  n$6("sl-menu-item")
], SlMenuItem);

// src/components/select/select.styles.ts
var select_styles_default = r$5`
  ${component_styles_default}
  ${form_control_styles_default}

  :host {
    display: block;
  }

  .select {
    display: block;
  }

  .select__control {
    display: inline-flex;
    align-items: center;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    transition: var(--sl-transition-fast) color, var(--sl-transition-fast) border, var(--sl-transition-fast) box-shadow;
    cursor: pointer;
  }

  .select__menu {
    max-height: 50vh;
    overflow: auto;
  }

  /* Standard selects */
  .select--standard .select__control {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    color: var(--sl-input-color);
  }

  .select--standard:not(.select--disabled) .select__control:hover {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
    color: var(--sl-input-color-hover);
  }

  .select--standard.select--focused:not(.select--disabled) .select__control {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: var(--sl-focus-ring);
    outline: none;
    color: var(--sl-input-color-focus);
  }

  .select--standard.select--disabled .select__control {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  /* Filled selects */
  .select--filled .select__control {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__control {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--focused:not(.select--disabled) .select__control {
    outline: none;
    background-color: var(--sl-input-filled-background-color-focus);
    box-shadow: var(--sl-focus-ring);
  }

  .select--filled.select--disabled .select__control {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--disabled .select__tags,
  .select--disabled .select__clear {
    pointer-events: none;
  }

  .select__prefix {
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  .select__label {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
    user-select: none;
    overflow-x: auto;
    overflow-y: hidden;
    white-space: nowrap;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .select__label::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .select__clear {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    width: 1.25em;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__suffix {
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  .select__icon {
    flex: 0 0 auto;
    display: inline-flex;
    transition: var(--sl-transition-medium) transform ease;
  }

  .select--open .select__icon {
    transform: rotate(-180deg);
  }

  /* Placeholder */
  .select--placeholder-visible .select__label {
    color: var(--sl-input-placeholder-color);
  }

  .select--disabled.select--placeholder-visible .select__label {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Tags */
  .select__tags {
    display: inline-flex;
    align-items: center;
    flex-wrap: wrap;
    justify-content: left;
    margin-left: var(--sl-spacing-2x-small);
  }

  /* Hidden input (for form control validation to show) */
  .select__hidden-select {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    clip: rect(0 0 0 0);
    clip-path: inset(50%);
    overflow: hidden;
    white-space: nowrap;
  }

  /*
   * Size modifiers
   */

  /* Small */
  .select--small .select__control {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
  }

  .select--small .select__prefix ::slotted(*) {
    margin-left: var(--sl-input-spacing-small);
  }

  .select--small .select__label {
    margin: 0 var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-right: var(--sl-input-spacing-small);
  }

  .select--small .select__suffix ::slotted(*) {
    margin-right: var(--sl-input-spacing-small);
  }

  .select--small .select__icon {
    margin-right: var(--sl-input-spacing-small);
  }

  .select--small .select__tags {
    padding-bottom: 2px;
  }

  .select--small .select__tags sl-tag {
    padding-top: 2px;
  }

  .select--small .select__tags sl-tag:not(:last-of-type) {
    margin-right: var(--sl-spacing-2x-small);
  }

  .select--small.select--has-tags .select__label {
    margin-left: 0;
  }

  /* Medium */
  .select--medium .select__control {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
  }

  .select--medium .select__prefix ::slotted(*) {
    margin-left: var(--sl-input-spacing-medium);
  }

  .select--medium .select__label {
    margin: 0 var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-right: var(--sl-input-spacing-medium);
  }

  .select--medium .select__suffix ::slotted(*) {
    margin-right: var(--sl-input-spacing-medium);
  }

  .select--medium .select__icon {
    margin-right: var(--sl-input-spacing-medium);
  }

  .select--medium .select__tags {
    padding-bottom: 3px;
  }

  .select--medium .select__tags sl-tag {
    padding-top: 3px;
  }

  .select--medium .select__tags sl-tag:not(:last-of-type) {
    margin-right: var(--sl-spacing-2x-small);
  }

  .select--medium.select--has-tags .select__label {
    margin-left: 0;
  }

  /* Large */
  .select--large .select__control {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
  }

  .select--large .select__prefix ::slotted(*) {
    margin-left: var(--sl-input-spacing-large);
  }

  .select--large .select__label {
    margin: 0 var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-right: var(--sl-input-spacing-large);
  }

  .select--large .select__suffix ::slotted(*) {
    margin-right: var(--sl-input-spacing-large);
  }

  .select--large .select__icon {
    margin-right: var(--sl-input-spacing-large);
  }

  .select--large .select__tags {
    padding-bottom: 4px;
  }
  .select--large .select__tags sl-tag {
    padding-top: 4px;
  }

  .select--large .select__tags sl-tag:not(:last-of-type) {
    margin-right: var(--sl-spacing-2x-small);
  }

  .select--large.select--has-tags .select__label {
    margin-left: 0;
  }

  /*
   * Pill modifier
   */
  .select--pill.select--small .select__control {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__control {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__control {
    border-radius: var(--sl-input-height-large);
  }
`;

// src/components/select/select.ts
var SlSelect = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController(this);
    this.hasFocus = false;
    this.isOpen = false;
    this.displayLabel = "";
    this.displayTags = [];
    this.multiple = false;
    this.maxTagsVisible = 3;
    this.disabled = false;
    this.name = "";
    this.placeholder = "";
    this.size = "medium";
    this.hoist = false;
    this.value = "";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.placement = "bottom";
    this.helpText = "";
    this.required = false;
    this.clearable = false;
    this.invalid = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.handleMenuSlotChange = this.handleMenuSlotChange.bind(this);
    this.resizeObserver = new ResizeObserver(() => this.resizeMenu());
    this.updateComplete.then(() => {
      this.resizeObserver.observe(this);
      this.syncItemsFromValue();
    });
  }
  firstUpdated() {
    this.invalid = !this.input.checkValidity();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.resizeObserver.unobserve(this);
  }
  reportValidity() {
    return this.input.reportValidity();
  }
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.invalid = !this.input.checkValidity();
  }
  getItemLabel(item) {
    const slot = item.shadowRoot.querySelector("slot:not([name])");
    return getTextContent(slot);
  }
  getItems() {
    return [...this.querySelectorAll("sl-menu-item")];
  }
  getValueAsArray() {
    if (this.multiple && this.value === "") {
      return [];
    }
    return Array.isArray(this.value) ? this.value : [this.value];
  }
  focus(options) {
    this.control.focus(options);
  }
  blur() {
    this.control.blur();
  }
  handleBlur() {
    if (!this.isOpen) {
      this.hasFocus = false;
      emit(this, "sl-blur");
    }
  }
  handleClearClick(event) {
    event.stopPropagation();
    this.value = this.multiple ? [] : "";
    emit(this, "sl-clear");
    this.syncItemsFromValue();
  }
  handleDisabledChange() {
    if (this.disabled && this.isOpen) {
      this.dropdown.hide();
    }
    this.input.disabled = this.disabled;
    this.invalid = !this.input.checkValidity();
  }
  handleFocus() {
    if (!this.hasFocus) {
      this.hasFocus = true;
      emit(this, "sl-focus");
    }
  }
  handleKeyDown(event) {
    const target = event.target;
    const items = this.getItems();
    const firstItem = items[0];
    const lastItem = items[items.length - 1];
    if (target.tagName.toLowerCase() === "sl-tag") {
      return;
    }
    if (event.key === "Tab") {
      if (this.isOpen) {
        this.dropdown.hide();
      }
      return;
    }
    if (["ArrowDown", "ArrowUp"].includes(event.key)) {
      event.preventDefault();
      if (!this.isOpen) {
        this.dropdown.show();
      }
      if (event.key === "ArrowDown") {
        this.menu.setCurrentItem(firstItem);
        firstItem.focus();
        return;
      }
      if (event.key === "ArrowUp") {
        this.menu.setCurrentItem(lastItem);
        lastItem.focus();
        return;
      }
    }
    if (event.ctrlKey || event.metaKey) {
      return;
    }
    if (!this.isOpen && event.key.length === 1) {
      event.stopPropagation();
      event.preventDefault();
      this.dropdown.show();
      this.menu.typeToSelect(event);
    }
  }
  handleLabelClick() {
    this.focus();
  }
  handleMenuSelect(event) {
    const item = event.detail.item;
    if (this.multiple) {
      this.value = this.value.includes(item.value) ? this.value.filter((v) => v !== item.value) : [...this.value, item.value];
    } else {
      this.value = item.value;
    }
    this.syncItemsFromValue();
  }
  handleMenuShow() {
    this.resizeMenu();
    this.isOpen = true;
  }
  handleMenuHide() {
    this.isOpen = false;
    this.control.focus();
  }
  handleMultipleChange() {
    var _a;
    const value = this.getValueAsArray();
    this.value = this.multiple ? value : (_a = value[0]) != null ? _a : "";
    this.syncItemsFromValue();
  }
  async handleMenuSlotChange() {
    const items = this.getItems();
    const values = [];
    items.forEach((item) => {
      if (values.includes(item.value)) {
        console.error(`Duplicate value found in <sl-select> menu item: '${item.value}'`, item);
      }
      values.push(item.value);
    });
    await Promise.all(items.map((item) => item.render)).then(() => this.syncItemsFromValue());
  }
  handleTagInteraction(event) {
    const path = event.composedPath();
    const clearButton = path.find((el) => {
      if (el instanceof HTMLElement) {
        const element = el;
        return element.classList.contains("tag__remove");
      }
      return false;
    });
    if (clearButton) {
      event.stopPropagation();
    }
  }
  async handleValueChange() {
    this.syncItemsFromValue();
    await this.updateComplete;
    this.invalid = !this.input.checkValidity();
    emit(this, "sl-change");
  }
  resizeMenu() {
    this.menu.style.width = `${this.control.clientWidth}px`;
    this.dropdown.reposition();
  }
  syncItemsFromValue() {
    const items = this.getItems();
    const value = this.getValueAsArray();
    items.map((item) => item.checked = value.includes(item.value));
    if (this.multiple) {
      const checkedItems = items.filter((item) => value.includes(item.value));
      this.displayLabel = checkedItems.length > 0 ? this.getItemLabel(checkedItems[0]) : "";
      this.displayTags = checkedItems.map((item) => {
        return $$1`
          <sl-tag
            part="tag"
            exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button
            "
            variant="neutral"
            size=${this.size}
            ?pill=${this.pill}
            removable
            @click=${this.handleTagInteraction}
            @keydown=${this.handleTagInteraction}
            @sl-remove=${(event) => {
          event.stopPropagation();
          if (!this.disabled) {
            item.checked = false;
            this.syncValueFromItems();
          }
        }}
          >
            ${this.getItemLabel(item)}
          </sl-tag>
        `;
      });
      if (this.maxTagsVisible > 0 && this.displayTags.length > this.maxTagsVisible) {
        const total = this.displayTags.length;
        this.displayLabel = "";
        this.displayTags = this.displayTags.slice(0, this.maxTagsVisible);
        this.displayTags.push($$1`
          <sl-tag
            part="tag"
            exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button
            "
            variant="neutral"
            size=${this.size}
          >
            +${total - this.maxTagsVisible}
          </sl-tag>
        `);
      }
    } else {
      const checkedItem = items.find((item) => item.value === value[0]);
      this.displayLabel = checkedItem ? this.getItemLabel(checkedItem) : "";
      this.displayTags = [];
    }
  }
  syncValueFromItems() {
    const items = this.getItems();
    const checkedItems = items.filter((item) => item.checked);
    const checkedValues = checkedItems.map((item) => item.value);
    if (this.multiple) {
      this.value = this.value.filter((val) => checkedValues.includes(val));
    } else {
      this.value = checkedValues.length > 0 ? checkedValues[0] : "";
    }
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasSelection = this.multiple ? this.value.length > 0 : this.value !== "";
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return $$1`
      <div
        part="form-control"
        class=${o$7({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-dropdown
            part="base"
            .hoist=${this.hoist}
            .placement=${this.placement}
            .stayOpenOnSelect=${this.multiple}
            .containingElement=${this}
            ?disabled=${this.disabled}
            class=${o$7({
      select: true,
      "select--open": this.isOpen,
      "select--empty": this.value.length === 0,
      "select--focused": this.hasFocus,
      "select--clearable": this.clearable,
      "select--disabled": this.disabled,
      "select--multiple": this.multiple,
      "select--standard": !this.filled,
      "select--filled": this.filled,
      "select--has-tags": this.multiple && this.displayTags.length > 0,
      "select--placeholder-visible": this.displayLabel === "",
      "select--small": this.size === "small",
      "select--medium": this.size === "medium",
      "select--large": this.size === "large",
      "select--pill": this.pill,
      "select--invalid": this.invalid
    })}
            @sl-show=${this.handleMenuShow}
            @sl-hide=${this.handleMenuHide}
          >
            <div
              part="control"
              slot="trigger"
              id="input"
              class="select__control"
              role="combobox"
              aria-describedby="help-text"
              aria-haspopup="true"
              aria-disabled=${this.disabled ? "true" : "false"}
              aria-expanded=${this.isOpen ? "true" : "false"}
              aria-controls="menu"
              tabindex=${this.disabled ? "-1" : "0"}
              @blur=${this.handleBlur}
              @focus=${this.handleFocus}
              @keydown=${this.handleKeyDown}
            >
              <span part="prefix" class="select__prefix">
                <slot name="prefix"></slot>
              </span>

              <div part="display-label" class="select__label">
                ${this.displayTags.length > 0 ? $$1` <span part="tags" class="select__tags"> ${this.displayTags} </span> ` : this.displayLabel.length > 0 ? this.displayLabel : this.placeholder}
              </div>

              ${this.clearable && hasSelection ? $$1`
                    <button
                      part="clear-button"
                      class="select__clear"
                      @click=${this.handleClearClick}
                      aria-label=${this.localize.term("clearEntry")}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}

              <span part="suffix" class="select__suffix">
                <slot name="suffix"></slot>
              </span>

              <span part="icon" class="select__icon" aria-hidden="true">
                <sl-icon name="chevron-down" library="system"></sl-icon>
              </span>

              <!-- The hidden input tricks the browser's built-in validation so it works as expected. We use an input
              instead of a select because, otherwise, iOS will show a list of options during validation. The focus
              handler is used to move focus to the primary control when it's marked invalid.  -->
              <input
                class="select__hidden-select"
                aria-hidden="true"
                ?required=${this.required}
                .value=${hasSelection ? "1" : ""}
                tabindex="-1"
                @focus=${() => this.control.focus()}
              />
            </div>

            <sl-menu part="menu" id="menu" class="select__menu" @sl-select=${this.handleMenuSelect}>
              <slot @slotchange=${this.handleMenuSlotChange}></slot>
            </sl-menu>
          </sl-dropdown>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = select_styles_default;
__decorateClass([
  i2(".select")
], SlSelect.prototype, "dropdown", 2);
__decorateClass([
  i2(".select__control")
], SlSelect.prototype, "control", 2);
__decorateClass([
  i2(".select__hidden-select")
], SlSelect.prototype, "input", 2);
__decorateClass([
  i2(".select__menu")
], SlSelect.prototype, "menu", 2);
__decorateClass([
  t$4()
], SlSelect.prototype, "hasFocus", 2);
__decorateClass([
  t$4()
], SlSelect.prototype, "isOpen", 2);
__decorateClass([
  t$4()
], SlSelect.prototype, "displayLabel", 2);
__decorateClass([
  t$4()
], SlSelect.prototype, "displayTags", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSelect.prototype, "multiple", 2);
__decorateClass([
  e$7({ attribute: "max-tags-visible", type: Number })
], SlSelect.prototype, "maxTagsVisible", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSelect.prototype, "disabled", 2);
__decorateClass([
  e$7()
], SlSelect.prototype, "name", 2);
__decorateClass([
  e$7()
], SlSelect.prototype, "placeholder", 2);
__decorateClass([
  e$7()
], SlSelect.prototype, "size", 2);
__decorateClass([
  e$7({ type: Boolean })
], SlSelect.prototype, "hoist", 2);
__decorateClass([
  e$7()
], SlSelect.prototype, "value", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSelect.prototype, "filled", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSelect.prototype, "pill", 2);
__decorateClass([
  e$7()
], SlSelect.prototype, "label", 2);
__decorateClass([
  e$7()
], SlSelect.prototype, "placement", 2);
__decorateClass([
  e$7({ attribute: "help-text" })
], SlSelect.prototype, "helpText", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSelect.prototype, "required", 2);
__decorateClass([
  e$7({ type: Boolean })
], SlSelect.prototype, "clearable", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSelect.prototype, "invalid", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("multiple")
], SlSelect.prototype, "handleMultipleChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleValueChange", 1);
SlSelect = __decorateClass([
  n$6("sl-select")
], SlSelect);

// src/components/tag/tag.styles.ts
var tag_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    cursor: default;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--small .tag__remove {
    margin-left: var(--sl-spacing-2x-small);
    margin-right: calc(-1 * var(--sl-spacing-3x-small));
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag__remove {
    margin-left: var(--sl-spacing-2x-small);
    margin-right: calc(-1 * var(--sl-spacing-2x-small));
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    font-size: 1.4em;
    margin-left: var(--sl-spacing-2x-small);
    margin-right: calc(-1 * var(--sl-spacing-x-small));
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`;

// src/components/tag/tag.ts
var SlTag = class extends s4 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.variant = "neutral";
    this.size = "medium";
    this.pill = false;
    this.removable = false;
  }
  handleRemoveClick() {
    emit(this, "sl-remove");
  }
  render() {
    return $$1`
      <span
        part="base"
        class=${o$7({
      tag: true,
      "tag--primary": this.variant === "primary",
      "tag--success": this.variant === "success",
      "tag--neutral": this.variant === "neutral",
      "tag--warning": this.variant === "warning",
      "tag--danger": this.variant === "danger",
      "tag--text": this.variant === "text",
      "tag--small": this.size === "small",
      "tag--medium": this.size === "medium",
      "tag--large": this.size === "large",
      "tag--pill": this.pill,
      "tag--removable": this.removable
    })}
      >
        <span part="content" class="tag__content">
          <slot></slot>
        </span>

        ${this.removable ? $$1`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
              ></sl-icon-button>
            ` : ""}
      </span>
    `;
  }
};
SlTag.styles = tag_styles_default;
__decorateClass([
  e$7({ reflect: true })
], SlTag.prototype, "variant", 2);
__decorateClass([
  e$7({ reflect: true })
], SlTag.prototype, "size", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlTag.prototype, "pill", 2);
__decorateClass([
  e$7({ type: Boolean })
], SlTag.prototype, "removable", 2);
SlTag = __decorateClass([
  n$6("sl-tag")
], SlTag);

// src/components/menu/menu.styles.ts
var menu_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: block;
  }

  .menu {
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    background: var(--sl-panel-background-color);
    padding: var(--sl-spacing-x-small) 0;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`;

// src/components/menu/menu.ts
var SlMenu = class extends s4 {
  constructor() {
    super(...arguments);
    this.typeToSelectString = "";
  }
  firstUpdated() {
    this.setAttribute("role", "menu");
  }
  getAllItems(options = { includeDisabled: true }) {
    return [...this.defaultSlot.assignedElements({ flatten: true })].filter((el) => {
      if (el.getAttribute("role") !== "menuitem") {
        return false;
      }
      if (!options.includeDisabled && el.disabled) {
        return false;
      }
      return true;
    });
  }
  getCurrentItem() {
    return this.getAllItems({ includeDisabled: false }).find((i2) => i2.getAttribute("tabindex") === "0");
  }
  setCurrentItem(item) {
    const items = this.getAllItems({ includeDisabled: false });
    const activeItem = item.disabled ? items[0] : item;
    items.forEach((i2) => {
      i2.setAttribute("tabindex", i2 === activeItem ? "0" : "-1");
    });
  }
  typeToSelect(event) {
    var _a;
    const items = this.getAllItems({ includeDisabled: false });
    clearTimeout(this.typeToSelectTimeout);
    this.typeToSelectTimeout = window.setTimeout(() => this.typeToSelectString = "", 1e3);
    if (event.key === "Backspace") {
      if (event.metaKey || event.ctrlKey) {
        this.typeToSelectString = "";
      } else {
        this.typeToSelectString = this.typeToSelectString.slice(0, -1);
      }
    } else {
      this.typeToSelectString += event.key.toLowerCase();
    }
    if (!hasFocusVisible) {
      items.forEach((item) => item.classList.remove("sl-focus-invisible"));
    }
    for (const item of items) {
      const slot = (_a = item.shadowRoot) == null ? void 0 : _a.querySelector("slot:not([name])");
      const label = getTextContent(slot).toLowerCase().trim();
      if (label.startsWith(this.typeToSelectString)) {
        this.setCurrentItem(item);
        item.focus();
        break;
      }
    }
  }
  handleClick(event) {
    const target = event.target;
    const item = target.closest("sl-menu-item");
    if ((item == null ? void 0 : item.disabled) === false) {
      emit(this, "sl-select", { detail: { item } });
    }
  }
  handleKeyUp() {
    if (!hasFocusVisible) {
      const items = this.getAllItems();
      items.forEach((item) => {
        item.classList.remove("sl-focus-invisible");
      });
    }
  }
  handleKeyDown(event) {
    if (event.key === "Enter") {
      const item = this.getCurrentItem();
      event.preventDefault();
      item == null ? void 0 : item.click();
    }
    if (event.key === " ") {
      event.preventDefault();
    }
    if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
      const items = this.getAllItems({ includeDisabled: false });
      const activeItem = this.getCurrentItem();
      let index = activeItem ? items.indexOf(activeItem) : 0;
      if (items.length > 0) {
        event.preventDefault();
        if (event.key === "ArrowDown") {
          index++;
        } else if (event.key === "ArrowUp") {
          index--;
        } else if (event.key === "Home") {
          index = 0;
        } else if (event.key === "End") {
          index = items.length - 1;
        }
        if (index < 0) {
          index = items.length - 1;
        }
        if (index > items.length - 1) {
          index = 0;
        }
        this.setCurrentItem(items[index]);
        items[index].focus();
        return;
      }
    }
    this.typeToSelect(event);
  }
  handleMouseDown(event) {
    const target = event.target;
    if (target.getAttribute("role") === "menuitem") {
      this.setCurrentItem(target);
      if (!hasFocusVisible) {
        target.classList.add("sl-focus-invisible");
      }
    }
  }
  handleSlotChange() {
    const items = this.getAllItems({ includeDisabled: false });
    if (items.length > 0) {
      this.setCurrentItem(items[0]);
    }
  }
  render() {
    return $$1`
      <div
        part="base"
        class="menu"
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @keyup=${this.handleKeyUp}
        @mousedown=${this.handleMouseDown}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlMenu.styles = menu_styles_default;
__decorateClass([
  i2(".menu")
], SlMenu.prototype, "menu", 2);
__decorateClass([
  i2("slot")
], SlMenu.prototype, "defaultSlot", 2);
SlMenu = __decorateClass([
  n$6("sl-menu")
], SlMenu);

// node_modules/@floating-ui/core/dist/floating-ui.core.esm.js
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  const skippedMiddlewareNames = /* @__PURE__ */ new Set();
  for (let i = 0; i < middleware.length; i++) {
    const {
      name,
      fn
    } = middleware[i];
    if (skippedMiddlewareNames.has(name)) {
      continue;
    }
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)
    });
    if (reset) {
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        if (reset.skip !== false) {
          skippedMiddlewareNames.add(name);
        }
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return __spreadProps(__spreadValues({}, rect), {
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary
  }));
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? __spreadProps(__spreadValues({}, rects.floating), {
      x,
      y
    }) : rects.reference,
    offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]);
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min3 = paddingObject[minProp];
    const max3 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min3, center, max3);
    return {
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const _a = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true
      } = _a, detectOverflowOptions = __objRest(_a, [
        "mainAxis",
        "crossAxis",
        "fallbackPlacements",
        "fallbackStrategy",
        "flipAlignment"
      ]);
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              skip: false,
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$slice$;
            const placement2 = (_overflowsData$slice$ = overflowsData.slice().sort((a, b) => a.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0) - b.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        return {
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function convertValueToCoords(placement, rects, value, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  let crossAxisMulti = 1;
  if (alignment === "end") {
    crossAxisMulti = -1;
  }
  if (rtl && isVertical) {
    crossAxisMulti *= -1;
  }
  const rawValue = typeof value === "function" ? value(__spreadProps(__spreadValues({}, rects), {
    placement
  })) : value;
  const {
    mainAxis,
    crossAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0
  } : __spreadValues({
    mainAxis: 0,
    crossAxis: 0
  }, rawValue);
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement,
        rects,
        platform: platform2,
        elements
      } = middlewareArguments;
      const diffCoords = convertValueToCoords(placement, rects, value, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement
      } = middlewareArguments;
      const _a = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        }
      } = _a, detectOverflowOptions = __objRest(_a, [
        "mainAxis",
        "crossAxis",
        "limiter"
      ]);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, middlewareArguments), {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      }));
      return __spreadProps(__spreadValues({}, limitedCoords), {
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      });
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(middlewareArguments) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = middlewareArguments;
      const _a = options, {
        apply
      } = _a, detectOverflowOptions = __objRest(_a, [
        "apply"
      ]);
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const xMin = max(overflow.left, 0);
      const xMax = max(overflow.right, 0);
      const yMin = max(overflow.top, 0);
      const yMax = max(overflow.bottom, 0);
      const dimensions = {
        height: rects.floating.height - (["left", "right"].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),
        width: rects.floating.width - (["top", "bottom"].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])
      };
      apply == null ? void 0 : apply(__spreadValues(__spreadValues({}, dimensions), rects));
      return {
        reset: {
          rects: true
        }
      };
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false);
}
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  return {
    width: clientRect.width / scaleX,
    height: clientRect.height / scaleY,
    top: clientRect.top / scaleY,
    right: clientRect.right / scaleX,
    bottom: clientRect.bottom / scaleY,
    left: clientRect.left / scaleX,
    x: clientRect.left / scaleX,
    y: clientRect.top / scaleY
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isWindow(element)) {
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  if (isHTMLElement(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return __spreadProps(__spreadValues({}, rect), {
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  });
}
function getViewportRect(element) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getNearestOverflowAncestor(node) {
  if (["html", "body", "#document"].includes(getNodeName(node))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isOverflowElement(node)) {
    return node;
  }
  return getNearestOverflowAncestor(getParentNode(node));
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(getOverflowAncestors(getParentNode(target)));
}
function contains(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect(element) {
  const clientRect = getBoundingClientRect(element);
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingAncestor(element, clippingParent) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element));
  }
  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(getParentNode(element));
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingAncestors.filter((clippingAncestors2) => isElement(clippingAncestors2) && contains(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== "body");
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary
  } = _ref;
  const mainClippingAncestors = boundary === "clippingAncestors" ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
var platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: (_ref) => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: __spreadProps(__spreadValues({}, getDimensions(floating)), {
        x: 0,
        y: 0
      })
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize: _ancestorResize = true,
    elementResize: _elementResize = true,
    animationFrame = false
  } = options;
  let cleanedUp = false;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestorResize = _ancestorResize && !animationFrame;
  const elementResize = _elementResize && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...isElement(reference) ? getOverflowAncestors(reference) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  let observer = null;
  if (elementResize) {
    observer = new ResizeObserver(update);
    isElement(reference) && observer.observe(reference);
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    if (cleanedUp) {
      return;
    }
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  return () => {
    var _observer;
    cleanedUp = true;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => computePosition(reference, floating, __spreadValues({
  platform
}, options));

// src/components/dropdown/dropdown.styles.ts
var dropdown_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .dropdown {
    position: relative;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__positioner {
    position: absolute;
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    color: var(--color);
    box-shadow: var(--sl-shadow-large);
    overflow: auto;
    overscroll-behavior: none;
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    pointer-events: all;
  }

  .dropdown__positioner[data-placement^='top'] .dropdown__panel {
    transform-origin: bottom;
  }

  .dropdown__positioner[data-placement^='bottom'] .dropdown__panel {
    transform-origin: top;
  }

  .dropdown__positioner[data-placement^='left'] .dropdown__panel {
    transform-origin: right;
  }

  .dropdown__positioner[data-placement^='right'] .dropdown__panel {
    transform-origin: left;
  }
`;

// src/components/dropdown/dropdown.ts
var SlDropdown = class extends s4 {
  constructor() {
    super(...arguments);
    this.open = false;
    this.placement = "bottom-start";
    this.disabled = false;
    this.stayOpenOnSelect = false;
    this.distance = 0;
    this.skidding = 0;
    this.hoist = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.handleMenuItemActivate = this.handleMenuItemActivate.bind(this);
    this.handlePanelSelect = this.handlePanelSelect.bind(this);
    this.handleDocumentKeyDown = this.handleDocumentKeyDown.bind(this);
    this.handleDocumentMouseDown = this.handleDocumentMouseDown.bind(this);
    if (!this.containingElement) {
      this.containingElement = this;
    }
  }
  async firstUpdated() {
    this.panel.hidden = !this.open;
    if (this.open) {
      await this.updateComplete;
      this.addOpenListeners();
      this.startPositioner();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeOpenListeners();
    this.hide();
    this.stopPositioner();
  }
  focusOnTrigger() {
    const slot = this.trigger.querySelector("slot");
    const trigger = slot.assignedElements({ flatten: true })[0];
    if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
      trigger.focus();
    }
  }
  getMenu() {
    const slot = this.panel.querySelector("slot");
    return slot.assignedElements({ flatten: true }).find((el) => el.tagName.toLowerCase() === "sl-menu");
  }
  handleDocumentKeyDown(event) {
    var _a;
    if (event.key === "Escape") {
      this.hide();
      this.focusOnTrigger();
      return;
    }
    if (event.key === "Tab") {
      if (this.open && ((_a = document.activeElement) == null ? void 0 : _a.tagName.toLowerCase()) === "sl-menu-item") {
        event.preventDefault();
        this.hide();
        this.focusOnTrigger();
        return;
      }
      setTimeout(() => {
        var _a2, _b, _c;
        const activeElement = ((_a2 = this.containingElement) == null ? void 0 : _a2.getRootNode()) instanceof ShadowRoot ? (_c = (_b = document.activeElement) == null ? void 0 : _b.shadowRoot) == null ? void 0 : _c.activeElement : document.activeElement;
        if (!this.containingElement || (activeElement == null ? void 0 : activeElement.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) {
          this.hide();
        }
      });
    }
  }
  handleDocumentMouseDown(event) {
    const path = event.composedPath();
    if (this.containingElement && !path.includes(this.containingElement)) {
      this.hide();
    }
  }
  handleMenuItemActivate(event) {
    const item = event.target;
    scrollIntoView(item, this.panel);
  }
  handlePanelSelect(event) {
    const target = event.target;
    if (!this.stayOpenOnSelect && target.tagName.toLowerCase() === "sl-menu") {
      this.hide();
      this.focusOnTrigger();
    }
  }
  handlePopoverOptionsChange() {
    this.updatePositioner();
  }
  handleTriggerClick() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
    }
  }
  handleTriggerKeyDown(event) {
    if (event.key === "Escape") {
      this.focusOnTrigger();
      this.hide();
      return;
    }
    if ([" ", "Enter"].includes(event.key)) {
      event.preventDefault();
      this.handleTriggerClick();
      return;
    }
    const menu = this.getMenu();
    if (menu) {
      const menuItems = menu.defaultSlot.assignedElements({ flatten: true });
      const firstMenuItem = menuItems[0];
      const lastMenuItem = menuItems[menuItems.length - 1];
      if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
        event.preventDefault();
        if (!this.open) {
          this.show();
        }
        if (menuItems.length > 0) {
          requestAnimationFrame(() => {
            if (event.key === "ArrowDown" || event.key === "Home") {
              menu.setCurrentItem(firstMenuItem);
              firstMenuItem.focus();
            }
            if (event.key === "ArrowUp" || event.key === "End") {
              menu.setCurrentItem(lastMenuItem);
              lastMenuItem.focus();
            }
          });
        }
      }
      const ignoredKeys = ["Tab", "Shift", "Meta", "Ctrl", "Alt"];
      if (this.open && !ignoredKeys.includes(event.key)) {
        menu.typeToSelect(event);
      }
    }
  }
  handleTriggerKeyUp(event) {
    if (event.key === " ") {
      event.preventDefault();
    }
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  updateAccessibleTrigger() {
    const slot = this.trigger.querySelector("slot");
    const assignedElements = slot.assignedElements({ flatten: true });
    const accessibleTrigger = assignedElements.find((el) => getTabbableBoundary(el).start);
    let target;
    if (accessibleTrigger) {
      switch (accessibleTrigger.tagName.toLowerCase()) {
        case "sl-button":
        case "sl-icon-button":
          target = accessibleTrigger.button;
          break;
        default:
          target = accessibleTrigger;
      }
      target.setAttribute("aria-haspopup", "true");
      target.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  reposition() {
    this.updatePositioner();
  }
  addOpenListeners() {
    this.panel.addEventListener("sl-activate", this.handleMenuItemActivate);
    this.panel.addEventListener("sl-select", this.handlePanelSelect);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    this.panel.removeEventListener("sl-activate", this.handleMenuItemActivate);
    this.panel.removeEventListener("sl-select", this.handlePanelSelect);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = false;
      return;
    }
    this.updateAccessibleTrigger();
    if (this.open) {
      emit(this, "sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.startPositioner();
      this.panel.hidden = false;
      const { keyframes, options } = getAnimation(this, "dropdown.show");
      await animateTo(this.panel, keyframes, options);
      emit(this, "sl-after-show");
    } else {
      emit(this, "sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "dropdown.hide");
      await animateTo(this.panel, keyframes, options);
      this.panel.hidden = true;
      this.stopPositioner();
      emit(this, "sl-after-hide");
    }
  }
  startPositioner() {
    this.stopPositioner();
    this.updatePositioner();
    this.positionerCleanup = autoUpdate(this.trigger, this.positioner, this.updatePositioner.bind(this));
  }
  updatePositioner() {
    if (!this.open || !this.trigger || !this.positioner) {
      return;
    }
    computePosition2(this.trigger, this.positioner, {
      placement: this.placement,
      middleware: [
        offset({ mainAxis: this.distance, crossAxis: this.skidding }),
        flip(),
        shift(),
        size({
          apply: ({ width, height }) => {
            Object.assign(this.panel.style, {
              maxWidth: `${width}px`,
              maxHeight: `${height}px`
            });
          },
          padding: 8
        })
      ],
      strategy: this.hoist ? "fixed" : "absolute"
    }).then(({ x, y, placement }) => {
      this.positioner.setAttribute("data-placement", placement);
      Object.assign(this.positioner.style, {
        position: this.hoist ? "fixed" : "absolute",
        left: `${x}px`,
        top: `${y}px`
      });
    });
  }
  stopPositioner() {
    if (this.positionerCleanup) {
      this.positionerCleanup();
      this.positionerCleanup = void 0;
      this.positioner.removeAttribute("data-placement");
    }
  }
  render() {
    return $$1`
      <div
        part="base"
        id="dropdown"
        class=${o$7({
      dropdown: true,
      "dropdown--open": this.open
    })}
      >
        <span
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
        >
          <slot name="trigger" @slotchange=${this.handleTriggerSlotChange}></slot>
        </span>

        <!-- Position the panel with a wrapper since the popover makes use of translate. This let's us add animations
        on the panel without interfering with the position. -->
        <div class="dropdown__positioner">
          <div
            part="panel"
            class="dropdown__panel"
            aria-hidden=${this.open ? "false" : "true"}
            aria-labelledby="dropdown"
          >
            <slot></slot>
          </div>
        </div>
      </div>
    `;
  }
};
SlDropdown.styles = dropdown_styles_default;
__decorateClass([
  i2(".dropdown__trigger")
], SlDropdown.prototype, "trigger", 2);
__decorateClass([
  i2(".dropdown__panel")
], SlDropdown.prototype, "panel", 2);
__decorateClass([
  i2(".dropdown__positioner")
], SlDropdown.prototype, "positioner", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlDropdown.prototype, "open", 2);
__decorateClass([
  e$7({ reflect: true })
], SlDropdown.prototype, "placement", 2);
__decorateClass([
  e$7({ type: Boolean })
], SlDropdown.prototype, "disabled", 2);
__decorateClass([
  e$7({ attribute: "stay-open-on-select", type: Boolean, reflect: true })
], SlDropdown.prototype, "stayOpenOnSelect", 2);
__decorateClass([
  e$7({ attribute: false })
], SlDropdown.prototype, "containingElement", 2);
__decorateClass([
  e$7({ type: Number })
], SlDropdown.prototype, "distance", 2);
__decorateClass([
  e$7({ type: Number })
], SlDropdown.prototype, "skidding", 2);
__decorateClass([
  e$7({ type: Boolean })
], SlDropdown.prototype, "hoist", 2);
__decorateClass([
  watch("distance"),
  watch("hoist"),
  watch("placement"),
  watch("skidding")
], SlDropdown.prototype, "handlePopoverOptionsChange", 1);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlDropdown.prototype, "handleOpenChange", 1);
SlDropdown = __decorateClass([
  n$6("sl-dropdown")
], SlDropdown);
setDefaultAnimation("dropdown.show", {
  keyframes: [
    { opacity: 0, transform: "scale(0.9)" },
    { opacity: 1, transform: "scale(1)" }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("dropdown.hide", {
  keyframes: [
    { opacity: 1, transform: "scale(1)" },
    { opacity: 0, transform: "scale(0.9)" }
  ],
  options: { duration: 100, easing: "ease" }
});

// src/components/button/button.ts
var SlButton = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this, {
      form: (input) => {
        if (input.hasAttribute("form")) {
          const doc = input.getRootNode();
          const formId = input.getAttribute("form");
          return doc.getElementById(formId);
        }
        return input.closest("form");
      }
    });
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.hasFocus = false;
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
  }
  click() {
    this.button.click();
  }
  focus(options) {
    this.button.focus(options);
  }
  blur() {
    this.button.blur();
  }
  handleBlur() {
    this.hasFocus = false;
    emit(this, "sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    emit(this, "sl-focus");
  }
  handleClick(event) {
    if (this.disabled || this.loading) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    if (this.type === "submit") {
      this.formSubmitController.submit(this);
    }
  }
  render() {
    const isLink = this.href ? true : false;
    const tag = isLink ? r$4`a` : r$4`button`;
    return l$5`
      <${tag}
        part="base"
        class=${o$7({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${l$4(isLink ? void 0 : this.disabled)}
        type=${this.type}
        name=${l$4(isLink ? void 0 : this.name)}
        value=${l$4(isLink ? void 0 : this.value)}
        href=${l$4(this.href)}
        target=${l$4(this.target)}
        download=${l$4(this.download)}
        rel=${l$4(this.target ? "noreferrer noopener" : void 0)}
        role="button"
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <span part="prefix" class="button__prefix">
          <slot name="prefix"></slot>
        </span>
        <span part="label" class="button__label">
          <slot></slot>
        </span>
        <span part="suffix" class="button__suffix">
          <slot name="suffix"></slot>
        </span>
        ${this.caret ? l$5`
                <span part="caret" class="button__caret">
                  <svg
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </span>
              ` : ""}
        ${this.loading ? l$5`<sl-spinner></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton.styles = button_styles_default;
__decorateClass([
  i2(".button")
], SlButton.prototype, "button", 2);
__decorateClass([
  t$4()
], SlButton.prototype, "hasFocus", 2);
__decorateClass([
  e$7({ reflect: true })
], SlButton.prototype, "variant", 2);
__decorateClass([
  e$7({ reflect: true })
], SlButton.prototype, "size", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlButton.prototype, "caret", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlButton.prototype, "disabled", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlButton.prototype, "loading", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlButton.prototype, "outline", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlButton.prototype, "pill", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlButton.prototype, "circle", 2);
__decorateClass([
  e$7()
], SlButton.prototype, "type", 2);
__decorateClass([
  e$7()
], SlButton.prototype, "name", 2);
__decorateClass([
  e$7()
], SlButton.prototype, "value", 2);
__decorateClass([
  e$7()
], SlButton.prototype, "href", 2);
__decorateClass([
  e$7()
], SlButton.prototype, "target", 2);
__decorateClass([
  e$7()
], SlButton.prototype, "download", 2);
__decorateClass([
  e$7()
], SlButton.prototype, "form", 2);
__decorateClass([
  e$7({ attribute: "formaction" })
], SlButton.prototype, "formAction", 2);
__decorateClass([
  e$7({ attribute: "formmethod" })
], SlButton.prototype, "formMethod", 2);
__decorateClass([
  e$7({ attribute: "formnovalidate", type: Boolean })
], SlButton.prototype, "formNoValidate", 2);
__decorateClass([
  e$7({ attribute: "formtarget" })
], SlButton.prototype, "formTarget", 2);
SlButton = __decorateClass([
  n$6("sl-button")
], SlButton);

// src/components/spinner/spinner.styles.ts
var spinner_styles_default = r$5`
  ${component_styles_default}

  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
    mix-blend-mode: multiply;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.01em, 2.75em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.01em, 2.75em;
    }
  }
`;

// src/components/spinner/spinner.ts
var SlSpinner = class extends s4 {
  render() {
    return $$1`
      <svg part="base" class="spinner" role="status">
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = spinner_styles_default;
SlSpinner = __decorateClass([
  n$6("sl-spinner")
], SlSpinner);

// src/components/split-panel/split-panel.styles.ts
var split_panel_styles_default = r$5`
  ${component_styles_default}

  :host {
    --divider-width: 4px;
    --divider-hit-area: 12px;
    --min: 0%;
    --max: 100%;

    display: grid;
  }

  .start,
  .end {
    overflow: hidden;
  }

  .divider {
    flex: 0 0 var(--divider-width);
    display: flex;
    position: relative;
    align-items: center;
    justify-content: center;
    background-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-900);
    z-index: 1;
  }

  .divider:focus {
    outline: none;
  }

  :host(:not([disabled])) .divider${focusVisibleSelector} {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  :host([disabled]) .divider {
    cursor: not-allowed;
  }

  /* Horizontal */
  :host(:not([vertical], [disabled])) .divider {
    cursor: col-resize;
  }

  :host(:not([vertical])) .divider::after {
    display: flex;
    content: '';
    position: absolute;
    height: 100%;
    left: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    width: var(--divider-hit-area);
  }

  /* Vertical */
  :host([vertical]) {
    flex-direction: column;
  }

  :host([vertical]:not([disabled])) .divider {
    cursor: row-resize;
  }

  :host([vertical]) .divider::after {
    content: '';
    position: absolute;
    width: 100%;
    top: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    height: var(--divider-hit-area);
  }
`;

// src/internal/drag.ts
function drag(container, onMove) {
  function move(pointerEvent) {
    const dims = container.getBoundingClientRect();
    const defaultView = container.ownerDocument.defaultView;
    const offsetX = dims.left + defaultView.pageXOffset;
    const offsetY = dims.top + defaultView.pageYOffset;
    const x = pointerEvent.pageX - offsetX;
    const y = pointerEvent.pageY - offsetY;
    onMove(x, y);
  }
  function stop() {
    document.removeEventListener("pointermove", move);
    document.removeEventListener("pointerup", stop);
  }
  document.addEventListener("pointermove", move, { passive: true });
  document.addEventListener("pointerup", stop);
}

// src/internal/math.ts
function clamp(value, min, max) {
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
}

// src/components/split-panel/split-panel.ts
var SlSplitPanel = class extends s4 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.position = 50;
    this.vertical = false;
    this.disabled = false;
    this.snapThreshold = 12;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver((entries) => this.handleResize(entries));
    this.updateComplete.then(() => this.resizeObserver.observe(this));
    this.detectSize();
    this.cachedPositionInPixels = this.percentageToPixels(this.position);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.resizeObserver.unobserve(this);
  }
  detectSize() {
    const { width, height } = this.getBoundingClientRect();
    this.size = this.vertical ? height : width;
  }
  percentageToPixels(value) {
    return this.size * (value / 100);
  }
  pixelsToPercentage(value) {
    return value / this.size * 100;
  }
  handleDrag(event) {
    if (this.disabled) {
      return;
    }
    event.preventDefault();
    drag(this, (x, y) => {
      let newPositionInPixels = this.vertical ? y : x;
      if (this.primary === "end") {
        newPositionInPixels = this.size - newPositionInPixels;
      }
      if (this.snap) {
        const snaps = this.snap.split(" ");
        snaps.forEach((value) => {
          let snapPoint;
          if (value.endsWith("%")) {
            snapPoint = this.size * (parseFloat(value) / 100);
          } else {
            snapPoint = parseFloat(value);
          }
          if (newPositionInPixels >= snapPoint - this.snapThreshold && newPositionInPixels <= snapPoint + this.snapThreshold) {
            newPositionInPixels = snapPoint;
          }
        });
      }
      this.position = clamp(this.pixelsToPercentage(newPositionInPixels), 0, 100);
    });
  }
  handleKeyDown(event) {
    if (this.disabled) {
      return;
    }
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
      let newPosition = this.position;
      const incr = (event.shiftKey ? 10 : 1) * (this.primary === "end" ? -1 : 1);
      event.preventDefault();
      if (event.key === "ArrowLeft" && !this.vertical || event.key === "ArrowUp" && this.vertical) {
        newPosition -= incr;
      }
      if (event.key === "ArrowRight" && !this.vertical || event.key === "ArrowDown" && this.vertical) {
        newPosition += incr;
      }
      if (event.key === "Home") {
        newPosition = this.primary === "end" ? 100 : 0;
      }
      if (event.key === "End") {
        newPosition = this.primary === "end" ? 0 : 100;
      }
      this.position = clamp(newPosition, 0, 100);
    }
  }
  handlePositionChange() {
    this.cachedPositionInPixels = this.percentageToPixels(this.position);
    this.positionInPixels = this.percentageToPixels(this.position);
    emit(this, "sl-reposition");
  }
  handlePositionInPixelsChange() {
    this.position = this.pixelsToPercentage(this.positionInPixels);
  }
  handleVerticalChange() {
    this.detectSize();
  }
  handleResize(entries) {
    const { width, height } = entries[0].contentRect;
    this.size = this.vertical ? height : width;
    if (this.primary) {
      this.position = this.pixelsToPercentage(this.cachedPositionInPixels);
    }
  }
  render() {
    const gridTemplate = this.vertical ? "gridTemplateRows" : "gridTemplateColumns";
    const gridTemplateAlt = this.vertical ? "gridTemplateColumns" : "gridTemplateRows";
    const primary = `
      clamp(
        0%,
        clamp(
          var(--min),
          ${this.position}% - var(--divider-width) / 2,
          var(--max)
        ),
        calc(100% - var(--divider-width))
      )
    `;
    const secondary = "auto";
    if (this.primary === "end") {
      this.style[gridTemplate] = `${secondary} var(--divider-width) ${primary}`;
    } else {
      this.style[gridTemplate] = `${primary} var(--divider-width) ${secondary}`;
    }
    this.style[gridTemplateAlt] = "";
    return $$1`
      <div part="panel start" class="start">
        <slot name="start"></slot>
      </div>

      <div
        part="divider"
        class="divider"
        tabindex=${l$4(this.disabled ? void 0 : "0")}
        role="separator"
        aria-label=${this.localize.term("resize")}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleDrag}
        @touchstart=${this.handleDrag}
      >
        <slot name="handle"></slot>
      </div>

      <div part="panel end" class="end">
        <slot name="end"></slot>
      </div>
    `;
  }
};
SlSplitPanel.styles = split_panel_styles_default;
__decorateClass([
  i2(".divider")
], SlSplitPanel.prototype, "divider", 2);
__decorateClass([
  e$7({ type: Number, reflect: true })
], SlSplitPanel.prototype, "position", 2);
__decorateClass([
  e$7({ attribute: "position-in-pixels", type: Number })
], SlSplitPanel.prototype, "positionInPixels", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSplitPanel.prototype, "vertical", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSplitPanel.prototype, "disabled", 2);
__decorateClass([
  e$7()
], SlSplitPanel.prototype, "primary", 2);
__decorateClass([
  e$7()
], SlSplitPanel.prototype, "snap", 2);
__decorateClass([
  e$7({ type: Number, attribute: "snap-threshold" })
], SlSplitPanel.prototype, "snapThreshold", 2);
__decorateClass([
  watch("position")
], SlSplitPanel.prototype, "handlePositionChange", 1);
__decorateClass([
  watch("positionInPixels")
], SlSplitPanel.prototype, "handlePositionInPixelsChange", 1);
__decorateClass([
  watch("vertical")
], SlSplitPanel.prototype, "handleVerticalChange", 1);
SlSplitPanel = __decorateClass([
  n$6("sl-split-panel")
], SlSplitPanel);

// src/components/radio/radio.styles.ts
var radio_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .radio {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .radio__icon {
    display: inline-flex;
    width: var(--sl-toggle-size);
    height: var(--sl-toggle-size);
  }

  .radio__icon svg {
    width: 100%;
    height: 100%;
  }

  .radio__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--sl-toggle-size);
    height: var(--sl-toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 50%;
    background-color: var(--sl-input-background-color);
    color: transparent;
    transition: var(--sl-transition-fast) border-color, var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color, var(--sl-transition-fast) box-shadow;
  }

  .radio__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .radio:not(.radio--checked):not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .radio:not(.radio--checked):not(.radio--disabled) .radio__input${focusVisibleSelector} ~ .radio__control {
    border-color: var(--sl-input-border-color-focus);
    background-color: var(--sl-input-background-color-focus);
    box-shadow: var(--sl-focus-ring);
  }

  /* Checked */
  .radio--checked .radio__control {
    color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked + hover */
  .radio.radio--checked:not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked + focus */
  .radio.radio--checked:not(.radio--disabled) .radio__input${focusVisibleSelector} ~ .radio__control {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  /* Disabled */
  .radio--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When the control isn't checked, hide the circle for Windows High Contrast mode a11y */
  .radio:not(.radio--checked) svg circle {
    opacity: 0;
  }

  .radio__label {
    line-height: var(--sl-toggle-size);
    margin-left: 0.5em;
    user-select: none;
  }
`;

// src/components/radio/radio.ts
var SlRadio = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this, {
      value: (control) => control.checked ? control.value : void 0
    });
    this.hasFocus = false;
    this.disabled = false;
    this.checked = false;
    this.invalid = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "radio");
  }
  click() {
    this.input.click();
  }
  focus(options) {
    this.input.focus(options);
  }
  blur() {
    this.input.blur();
  }
  reportValidity() {
    return this.input.reportValidity();
  }
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.invalid = !this.input.checkValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    emit(this, "sl-blur");
  }
  handleClick() {
    if (!this.disabled) {
      this.checked = true;
    }
  }
  handleFocus() {
    this.hasFocus = true;
    emit(this, "sl-focus");
  }
  handleCheckedChange() {
    this.setAttribute("aria-checked", this.checked ? "true" : "false");
    if (this.hasUpdated) {
      emit(this, "sl-change");
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
    if (this.hasUpdated) {
      this.input.disabled = this.disabled;
      this.invalid = !this.input.checkValidity();
    }
  }
  render() {
    return $$1`
      <label
        part="base"
        class=${o$7({
      radio: true,
      "radio--checked": this.checked,
      "radio--disabled": this.disabled,
      "radio--focused": this.hasFocus
    })}
      >
        <input
          class="radio__input"
          type="radio"
          name=${l$4(this.name)}
          value=${l$4(this.value)}
          .checked=${l$3(this.checked)}
          .disabled=${this.disabled}
          @click=${this.handleClick}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
        />
        <span part="control" class="radio__control">
          <span part="checked-icon" class="radio__icon">
            <svg viewBox="0 0 16 16">
              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                <g fill="currentColor">
                  <circle cx="8" cy="8" r="3.42857143"></circle>
                </g>
              </g>
            </svg>
          </span>
        </span>

        <span part="label" class="radio__label">
          <slot></slot>
        </span>
      </label>
    `;
  }
};
SlRadio.styles = radio_styles_default;
__decorateClass([
  i2(".radio__input")
], SlRadio.prototype, "input", 2);
__decorateClass([
  t$4()
], SlRadio.prototype, "hasFocus", 2);
__decorateClass([
  e$7()
], SlRadio.prototype, "name", 2);
__decorateClass([
  e$7()
], SlRadio.prototype, "value", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlRadio.prototype, "disabled", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlRadio.prototype, "checked", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlRadio.prototype, "invalid", 2);
__decorateClass([
  watch("checked")
], SlRadio.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlRadio.prototype, "handleDisabledChange", 1);
SlRadio = __decorateClass([
  n$6("sl-radio")
], SlRadio);

// src/components/details/details.styles.ts
var details_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: block;
  }

  .details {
    border: solid 1px var(--sl-color-neutral-200);
    border-radius: var(--sl-border-radius-medium);
    background-color: var(--sl-color-neutral-0);
    overflow-anchor: none;
  }

  .details--disabled {
    opacity: 0.5;
  }

  .details__header {
    display: flex;
    align-items: center;
    border-radius: inherit;
    padding: var(--sl-spacing-medium);
    user-select: none;
    cursor: pointer;
  }

  .details__header:focus {
    outline: none;
  }

  .details__header${focusVisibleSelector} {
    box-shadow: var(--sl-focus-ring);
  }

  .details--disabled .details__header {
    cursor: not-allowed;
  }

  .details--disabled .details__header${focusVisibleSelector} {
    outline: none;
    box-shadow: none;
  }

  .details__summary {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
  }

  .details__summary-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) transform ease;
  }

  .details--open .details__summary-icon {
    transform: rotate(90deg);
  }

  .details__body {
    overflow: hidden;
  }

  .details__content {
    padding: var(--sl-spacing-medium);
  }
`;

// src/components/details/details.ts
var SlDetails = class extends s4 {
  constructor() {
    super(...arguments);
    this.open = false;
    this.disabled = false;
  }
  firstUpdated() {
    this.body.hidden = !this.open;
    this.body.style.height = this.open ? "auto" : "0";
  }
  async show() {
    if (this.open || this.disabled) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  async hide() {
    if (!this.open || this.disabled) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  handleSummaryClick() {
    if (!this.disabled) {
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
      this.header.focus();
    }
  }
  handleSummaryKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
    }
    if (event.key === "ArrowUp" || event.key === "ArrowLeft") {
      event.preventDefault();
      this.hide();
    }
    if (event.key === "ArrowDown" || event.key === "ArrowRight") {
      event.preventDefault();
      this.show();
    }
  }
  async handleOpenChange() {
    if (this.open) {
      emit(this, "sl-show");
      await stopAnimations(this.body);
      this.body.hidden = false;
      const { keyframes, options } = getAnimation(this, "details.show");
      await animateTo(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
      this.body.style.height = "auto";
      emit(this, "sl-after-show");
    } else {
      emit(this, "sl-hide");
      await stopAnimations(this.body);
      const { keyframes, options } = getAnimation(this, "details.hide");
      await animateTo(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
      this.body.hidden = true;
      this.body.style.height = "auto";
      emit(this, "sl-after-hide");
    }
  }
  render() {
    return $$1`
      <div
        part="base"
        class=${o$7({
      details: true,
      "details--open": this.open,
      "details--disabled": this.disabled
    })}
      >
        <header
          part="header"
          id="header"
          class="details__header"
          role="button"
          aria-expanded=${this.open ? "true" : "false"}
          aria-controls="content"
          aria-disabled=${this.disabled ? "true" : "false"}
          tabindex=${this.disabled ? "-1" : "0"}
          @click=${this.handleSummaryClick}
          @keydown=${this.handleSummaryKeyDown}
        >
          <div part="summary" class="details__summary">
            <slot name="summary">${this.summary}</slot>
          </div>

          <span part="summary-icon" class="details__summary-icon">
            <sl-icon name="chevron-right" library="system"></sl-icon>
          </span>
        </header>

        <div class="details__body">
          <div part="content" id="content" class="details__content" role="region" aria-labelledby="header">
            <slot></slot>
          </div>
        </div>
      </div>
    `;
  }
};
SlDetails.styles = details_styles_default;
__decorateClass([
  i2(".details")
], SlDetails.prototype, "details", 2);
__decorateClass([
  i2(".details__header")
], SlDetails.prototype, "header", 2);
__decorateClass([
  i2(".details__body")
], SlDetails.prototype, "body", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlDetails.prototype, "open", 2);
__decorateClass([
  e$7()
], SlDetails.prototype, "summary", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlDetails.prototype, "disabled", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlDetails.prototype, "handleOpenChange", 1);
SlDetails = __decorateClass([
  n$6("sl-details")
], SlDetails);
setDefaultAnimation("details.show", {
  keyframes: [
    { height: "0", opacity: "0" },
    { height: "auto", opacity: "1" }
  ],
  options: { duration: 250, easing: "linear" }
});
setDefaultAnimation("details.hide", {
  keyframes: [
    { height: "auto", opacity: "1" },
    { height: "0", opacity: "0" }
  ],
  options: { duration: 250, easing: "linear" }
});

// src/components/checkbox/checkbox.styles.ts
var checkbox_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .checkbox {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--sl-toggle-size);
    height: var(--sl-toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition: var(--sl-transition-fast) border-color, var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color, var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__control .checkbox__icon {
    display: inline-flex;
    width: var(--sl-toggle-size);
    height: var(--sl-toggle-size);
  }

  .checkbox__control .checkbox__icon svg {
    width: 100%;
    height: 100%;
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled)
    .checkbox__input${focusVisibleSelector}
    ~ .checkbox__control {
    border-color: var(--sl-input-border-color-focus);
    background-color: var(--sl-input-background-color-focus);
    box-shadow: var(--sl-focus-ring);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input${focusVisibleSelector} ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled)
    .checkbox__input${focusVisibleSelector}
    ~ .checkbox__control {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    line-height: var(--sl-toggle-size);
    margin-left: 0.5em;
    user-select: none;
  }
`;

// src/components/checkbox/checkbox.ts
var SlCheckbox = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this, {
      value: (control) => control.checked ? control.value : void 0
    });
    this.hasFocus = false;
    this.disabled = false;
    this.required = false;
    this.checked = false;
    this.indeterminate = false;
    this.invalid = false;
  }
  firstUpdated() {
    this.invalid = !this.input.checkValidity();
  }
  click() {
    this.input.click();
  }
  focus(options) {
    this.input.focus(options);
  }
  blur() {
    this.input.blur();
  }
  reportValidity() {
    return this.input.reportValidity();
  }
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.invalid = !this.input.checkValidity();
  }
  handleClick() {
    this.checked = !this.checked;
    this.indeterminate = false;
    emit(this, "sl-change");
  }
  handleBlur() {
    this.hasFocus = false;
    emit(this, "sl-blur");
  }
  handleDisabledChange() {
    this.input.disabled = this.disabled;
    this.invalid = !this.input.checkValidity();
  }
  handleFocus() {
    this.hasFocus = true;
    emit(this, "sl-focus");
  }
  handleStateChange() {
    this.invalid = !this.input.checkValidity();
  }
  render() {
    return $$1`
      <label
        part="base"
        class=${o$7({
      checkbox: true,
      "checkbox--checked": this.checked,
      "checkbox--disabled": this.disabled,
      "checkbox--focused": this.hasFocus,
      "checkbox--indeterminate": this.indeterminate
    })}
      >
        <input
          class="checkbox__input"
          type="checkbox"
          name=${l$4(this.name)}
          value=${l$4(this.value)}
          .indeterminate=${l$3(this.indeterminate)}
          .checked=${l$3(this.checked)}
          .disabled=${this.disabled}
          .required=${this.required}
          aria-checked=${this.checked ? "true" : "false"}
          @click=${this.handleClick}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
        />

        <span part="control" class="checkbox__control">
          ${this.checked ? $$1`
                <span part="checked-icon" class="checkbox__icon">
                  <svg viewBox="0 0 16 16">
                    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
                      <g stroke="currentColor" stroke-width="2">
                        <g transform="translate(3.428571, 3.428571)">
                          <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
                          <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
                        </g>
                      </g>
                    </g>
                  </svg>
                </span>
              ` : ""}
          ${!this.checked && this.indeterminate ? $$1`
                <span part="indeterminate-icon" class="checkbox__icon">
                  <svg viewBox="0 0 16 16">
                    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
                      <g stroke="currentColor" stroke-width="2">
                        <g transform="translate(2.285714, 6.857143)">
                          <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
                        </g>
                      </g>
                    </g>
                  </svg>
                </span>
              ` : ""}
        </span>

        <span part="label" class="checkbox__label">
          <slot></slot>
        </span>
      </label>
    `;
  }
};
SlCheckbox.styles = checkbox_styles_default;
__decorateClass([
  i2('input[type="checkbox"]')
], SlCheckbox.prototype, "input", 2);
__decorateClass([
  t$4()
], SlCheckbox.prototype, "hasFocus", 2);
__decorateClass([
  e$7()
], SlCheckbox.prototype, "name", 2);
__decorateClass([
  e$7()
], SlCheckbox.prototype, "value", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "disabled", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "required", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "checked", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "indeterminate", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "invalid", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("checked", { waitUntilFirstUpdate: true }),
  watch("indeterminate", { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleStateChange", 1);
SlCheckbox = __decorateClass([
  n$6("sl-checkbox")
], SlCheckbox);

// src/components/switch/switch.styles.ts
var switch_styles_default = r$5`
  ${component_styles_default}

  :host {
    --height: var(--sl-toggle-size);
    --thumb-size: calc(var(--sl-toggle-size) + 4px);
    --width: calc(var(--height) * 2);

    display: inline-block;
  }

  .switch {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .switch__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--width);
    height: var(--height);
    background-color: var(--sl-color-neutral-400);
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    border-radius: var(--height);
    transition: var(--sl-transition-fast) border-color, var(--sl-transition-fast) background-color;
  }

  .switch__control .switch__thumb {
    width: var(--thumb-size);
    height: var(--thumb-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: 50%;
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    transform: translateX(calc((var(--width) - var(--height)) / -2));
    transition: var(--sl-transition-fast) transform ease, var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) border-color, var(--sl-transition-fast) box-shadow;
  }

  .switch__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-400);
  }

  /* Focus */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__input${focusVisibleSelector} ~ .switch__control {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled)
    .switch__input${focusVisibleSelector}
    ~ .switch__control
    .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    box-shadow: var(--sl-focus-ring);
  }

  /* Checked */
  .switch--checked .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch--checked .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    transform: translateX(calc((var(--width) - var(--height)) / 2));
  }

  /* Checked + hover */
  .switch.switch--checked:not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
  }

  /* Checked + focus */
  .switch.switch--checked:not(.switch--disabled) .switch__input${focusVisibleSelector} ~ .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled)
    .switch__input${focusVisibleSelector}
    ~ .switch__control
    .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    box-shadow: var(--sl-focus-ring);
  }

  /* Disabled */
  .switch--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .switch__label {
    line-height: var(--height);
    margin-left: 0.5em;
    user-select: none;
  }
`;

// src/components/switch/switch.ts
var SlSwitch = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this, {
      value: (control) => control.checked ? control.value : void 0
    });
    this.hasFocus = false;
    this.disabled = false;
    this.required = false;
    this.checked = false;
    this.invalid = false;
  }
  firstUpdated() {
    this.invalid = !this.input.checkValidity();
  }
  click() {
    this.input.click();
  }
  focus(options) {
    this.input.focus(options);
  }
  blur() {
    this.input.blur();
  }
  reportValidity() {
    return this.input.reportValidity();
  }
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.invalid = !this.input.checkValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    emit(this, "sl-blur");
  }
  handleCheckedChange() {
    this.input.checked = this.checked;
    this.invalid = !this.input.checkValidity();
  }
  handleClick() {
    this.checked = !this.checked;
    emit(this, "sl-change");
  }
  handleDisabledChange() {
    this.input.disabled = this.disabled;
    this.invalid = !this.input.checkValidity();
  }
  handleFocus() {
    this.hasFocus = true;
    emit(this, "sl-focus");
  }
  handleKeyDown(event) {
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.checked = false;
      emit(this, "sl-change");
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.checked = true;
      emit(this, "sl-change");
    }
  }
  render() {
    return $$1`
      <label
        part="base"
        class=${o$7({
      switch: true,
      "switch--checked": this.checked,
      "switch--disabled": this.disabled,
      "switch--focused": this.hasFocus
    })}
      >
        <input
          class="switch__input"
          type="checkbox"
          name=${l$4(this.name)}
          value=${l$4(this.value)}
          .checked=${l$3(this.checked)}
          .disabled=${this.disabled}
          .required=${this.required}
          role="switch"
          aria-checked=${this.checked ? "true" : "false"}
          @click=${this.handleClick}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @keydown=${this.handleKeyDown}
        />

        <span part="control" class="switch__control">
          <span part="thumb" class="switch__thumb"></span>
        </span>

        <span part="label" class="switch__label">
          <slot></slot>
        </span>
      </label>
    `;
  }
};
SlSwitch.styles = switch_styles_default;
__decorateClass([
  i2('input[type="checkbox"]')
], SlSwitch.prototype, "input", 2);
__decorateClass([
  t$4()
], SlSwitch.prototype, "hasFocus", 2);
__decorateClass([
  e$7()
], SlSwitch.prototype, "name", 2);
__decorateClass([
  e$7()
], SlSwitch.prototype, "value", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSwitch.prototype, "disabled", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSwitch.prototype, "required", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSwitch.prototype, "checked", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlSwitch.prototype, "invalid", 2);
__decorateClass([
  watch("checked", { waitUntilFirstUpdate: true })
], SlSwitch.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlSwitch.prototype, "handleDisabledChange", 1);
SlSwitch = __decorateClass([
  n$6("sl-switch")
], SlSwitch);

// src/components/tooltip/tooltip.styles.ts
var tooltip_styles_default = r$5`
  ${component_styles_default}

  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip-target {
    display: contents;
  }

  .tooltip-positioner {
    position: absolute;
    z-index: var(--sl-z-index-tooltip);
    pointer-events: none;
  }

  .tooltip-positioner[data-placement^='top'] .tooltip {
    transform-origin: bottom;
  }

  .tooltip-positioner[data-placement^='bottom'] .tooltip {
    transform-origin: top;
  }

  .tooltip-positioner[data-placement^='left'] .tooltip {
    transform-origin: right;
  }

  .tooltip-positioner[data-placement^='right'] .tooltip {
    transform-origin: left;
  }

  .tooltip__content {
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
  }

  .tooltip__arrow {
    position: absolute;
    background: var(--sl-tooltip-background-color);
    width: calc(var(--sl-tooltip-arrow-size) * 2);
    height: calc(var(--sl-tooltip-arrow-size) * 2);
    transform: rotate(45deg);
    z-index: -1;
  }
`;

// src/components/tooltip/tooltip.ts
var SlTooltip = class extends s4 {
  constructor() {
    super(...arguments);
    this.content = "";
    this.placement = "top";
    this.disabled = false;
    this.distance = 10;
    this.open = false;
    this.skidding = 0;
    this.trigger = "hover focus";
    this.hoist = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.handleBlur = this.handleBlur.bind(this);
    this.handleClick = this.handleClick.bind(this);
    this.handleFocus = this.handleFocus.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleMouseOver = this.handleMouseOver.bind(this);
    this.handleMouseOut = this.handleMouseOut.bind(this);
    this.updateComplete.then(() => {
      this.addEventListener("blur", this.handleBlur, true);
      this.addEventListener("focus", this.handleFocus, true);
      this.addEventListener("click", this.handleClick);
      this.addEventListener("keydown", this.handleKeyDown);
      this.addEventListener("mouseover", this.handleMouseOver);
      this.addEventListener("mouseout", this.handleMouseOut);
      this.target = this.getTarget();
    });
  }
  async firstUpdated() {
    this.tooltip.hidden = !this.open;
    if (this.open) {
      await this.updateComplete;
      this.updatePositioner();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("blur", this.handleBlur, true);
    this.removeEventListener("focus", this.handleFocus, true);
    this.removeEventListener("click", this.handleClick);
    this.removeEventListener("keydown", this.handleKeyDown);
    this.removeEventListener("mouseover", this.handleMouseOver);
    this.removeEventListener("mouseout", this.handleMouseOut);
    this.stopPositioner();
  }
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  getTarget() {
    const target = [...this.children].find((el) => el.tagName.toLowerCase() !== "style" && el.getAttribute("slot") !== "content");
    if (!target) {
      throw new Error("Invalid tooltip target: no child element was found.");
    }
    return target;
  }
  handleBlur() {
    if (this.hasTrigger("focus")) {
      this.hide();
    }
  }
  handleClick() {
    if (this.hasTrigger("click")) {
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
    }
  }
  handleFocus() {
    if (this.hasTrigger("focus")) {
      this.show();
    }
  }
  handleKeyDown(event) {
    if (this.open && event.key === "Escape") {
      event.stopPropagation();
      this.hide();
    }
  }
  handleMouseOver() {
    if (this.hasTrigger("hover")) {
      const delay = parseDuration(getComputedStyle(this).getPropertyValue("--show-delay"));
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = window.setTimeout(() => void this.show(), delay);
    }
  }
  handleMouseOut() {
    if (this.hasTrigger("hover")) {
      const delay = parseDuration(getComputedStyle(this).getPropertyValue("--hide-delay"));
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = window.setTimeout(() => void this.hide(), delay);
    }
  }
  async handleOpenChange() {
    if (this.disabled) {
      return;
    }
    if (this.open) {
      emit(this, "sl-show");
      await stopAnimations(this.tooltip);
      this.startPositioner();
      this.tooltip.hidden = false;
      const { keyframes, options } = getAnimation(this, "tooltip.show");
      await animateTo(this.tooltip, keyframes, options);
      emit(this, "sl-after-show");
    } else {
      emit(this, "sl-hide");
      await stopAnimations(this.tooltip);
      const { keyframes, options } = getAnimation(this, "tooltip.hide");
      await animateTo(this.tooltip, keyframes, options);
      this.tooltip.hidden = true;
      this.stopPositioner();
      emit(this, "sl-after-hide");
    }
  }
  handleOptionsChange() {
    this.updatePositioner();
  }
  handleDisabledChange() {
    if (this.disabled && this.open) {
      this.hide();
    }
  }
  hasTrigger(triggerType) {
    const triggers = this.trigger.split(" ");
    return triggers.includes(triggerType);
  }
  startPositioner() {
    this.stopPositioner();
    this.updatePositioner();
    this.positionerCleanup = autoUpdate(this.target, this.positioner, this.updatePositioner.bind(this));
  }
  updatePositioner() {
    if (!this.open || !this.target || !this.positioner) {
      return;
    }
    computePosition2(this.target, this.positioner, {
      placement: this.placement,
      middleware: [
        offset({ mainAxis: this.distance, crossAxis: this.skidding }),
        flip(),
        shift(),
        arrow({
          element: this.arrow,
          padding: 10
        })
      ],
      strategy: this.hoist ? "fixed" : "absolute"
    }).then(({ x, y, middlewareData, placement }) => {
      const arrowX = middlewareData.arrow.x;
      const arrowY = middlewareData.arrow.y;
      const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
      this.positioner.setAttribute("data-placement", placement);
      Object.assign(this.positioner.style, {
        position: this.hoist ? "fixed" : "absolute",
        left: `${x}px`,
        top: `${y}px`
      });
      Object.assign(this.arrow.style, {
        left: typeof arrowX === "number" ? `${arrowX}px` : "",
        top: typeof arrowY === "number" ? `${arrowY}px` : "",
        right: "",
        bottom: "",
        [staticSide]: "calc(var(--sl-tooltip-arrow-size) * -1)"
      });
    });
  }
  stopPositioner() {
    if (this.positionerCleanup) {
      this.positionerCleanup();
      this.positionerCleanup = void 0;
      this.positioner.removeAttribute("data-placement");
    }
  }
  render() {
    return $$1`
      <div class="tooltip-target" aria-describedby="tooltip">
        <slot></slot>
      </div>

      <div class="tooltip-positioner">
        <div
          part="base"
          id="tooltip"
          class=${o$7({
      tooltip: true,
      "tooltip--open": this.open
    })}
          role="tooltip"
          aria-hidden=${this.open ? "false" : "true"}
        >
          <div class="tooltip__arrow"></div>
          <div class="tooltip__content" aria-live=${this.open ? "polite" : "off"}>
            <slot name="content"> ${this.content} </slot>
          </div>
        </div>
      </div>
    `;
  }
};
SlTooltip.styles = tooltip_styles_default;
__decorateClass([
  i2(".tooltip-positioner")
], SlTooltip.prototype, "positioner", 2);
__decorateClass([
  i2(".tooltip")
], SlTooltip.prototype, "tooltip", 2);
__decorateClass([
  i2(".tooltip__arrow")
], SlTooltip.prototype, "arrow", 2);
__decorateClass([
  e$7()
], SlTooltip.prototype, "content", 2);
__decorateClass([
  e$7()
], SlTooltip.prototype, "placement", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlTooltip.prototype, "disabled", 2);
__decorateClass([
  e$7({ type: Number })
], SlTooltip.prototype, "distance", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlTooltip.prototype, "open", 2);
__decorateClass([
  e$7({ type: Number })
], SlTooltip.prototype, "skidding", 2);
__decorateClass([
  e$7()
], SlTooltip.prototype, "trigger", 2);
__decorateClass([
  e$7({ type: Boolean })
], SlTooltip.prototype, "hoist", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlTooltip.prototype, "handleOpenChange", 1);
__decorateClass([
  watch("content"),
  watch("distance"),
  watch("hoist"),
  watch("placement"),
  watch("skidding")
], SlTooltip.prototype, "handleOptionsChange", 1);
__decorateClass([
  watch("disabled")
], SlTooltip.prototype, "handleDisabledChange", 1);
SlTooltip = __decorateClass([
  n$6("sl-tooltip")
], SlTooltip);
setDefaultAnimation("tooltip.show", {
  keyframes: [
    { opacity: 0, transform: "scale(0.8)" },
    { opacity: 1, transform: "scale(1)" }
  ],
  options: { duration: 150, easing: "ease" }
});
setDefaultAnimation("tooltip.hide", {
  keyframes: [
    { opacity: 1, transform: "scale(1)" },
    { opacity: 0, transform: "scale(0.8)" }
  ],
  options: { duration: 150, easing: "ease" }
});

// src/components/card/card.styles.ts
var card_styles_default = r$5`
  ${component_styles_default}

  :host {
    --border-color: var(--sl-color-neutral-200);
    --border-radius: var(--sl-border-radius-medium);
    --border-width: 1px;
    --padding: var(--sl-spacing-large);

    display: inline-block;
  }

  .card {
    display: flex;
    flex-direction: column;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-small);
    border: solid var(--border-width) var(--border-color);
    border-radius: var(--border-radius);
  }

  .card__image {
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
    margin: calc(-1 * var(--border-width));
    overflow: hidden;
  }

  .card__image ::slotted(img) {
    display: block;
    width: 100%;
  }

  .card:not(.card--has-image) .card__image {
    display: none;
  }

  .card__header {
    border-bottom: solid var(--border-width) var(--border-color);
    padding: calc(var(--padding) / 2) var(--padding);
  }

  .card:not(.card--has-header) .card__header {
    display: none;
  }

  .card__body {
    padding: var(--padding);
  }

  .card--has-footer .card__footer {
    border-top: solid var(--border-width) var(--border-color);
    padding: var(--padding);
  }

  .card:not(.card--has-footer) .card__footer {
    display: none;
  }
`;

// src/components/card/card.ts
var SlCard = class extends s4 {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "footer", "header", "image");
  }
  render() {
    return $$1`
      <div
        part="base"
        class=${o$7({
      card: true,
      "card--has-footer": this.hasSlotController.test("footer"),
      "card--has-image": this.hasSlotController.test("image"),
      "card--has-header": this.hasSlotController.test("header")
    })}
      >
        <div part="image" class="card__image">
          <slot name="image"></slot>
        </div>

        <div part="header" class="card__header">
          <slot name="header"></slot>
        </div>

        <div part="body" class="card__body">
          <slot></slot>
        </div>

        <div part="footer" class="card__footer">
          <slot name="footer"></slot>
        </div>
      </div>
    `;
  }
};
SlCard.styles = card_styles_default;
SlCard = __decorateClass([
  n$6("sl-card")
], SlCard);

const Delta$2 = Quill.import('delta');
class ModuloAspasCurvas {
    constructor(quill, options) {
        this.enabled = true;
        this.quill = quill;
        this.options = options;
        this.quill.root.addEventListener('keydown', (event) => {
            var _a;
            const range = (_a = this.quill) === null || _a === void 0 ? void 0 : _a.getSelection();
            const key = event.key;
            if (!this.enabled || !range || !['"', "'"].includes(key))
                return;
            this.tratarAspas(range, key);
            event.preventDefault();
        });
        // O código abaixo é uma outra forma de fazer a mesma coisa.
        // Se o código abaixo for usado, o código acima (addEventListener e todo o seu conteúdo) deve ser comentado.
        // this.quill.keyboard.addBinding({ key: 192 }, { shiftKey: true }, (range: any, context: any): boolean => this.tratarAspas(range, '"'));
        // this.quill.keyboard.addBinding({ key: 192 }, { shiftKey: false }, (range: any, context: any): boolean => this.tratarAspas(range, "'"));
    }
    // Imita autoformação de aspas curvas do Word
    tratarAspas(range, caracter) {
        var _a, _b, _c, _d, _e, _f;
        if (!this.enabled)
            return true;
        const isAspasDuplas = caracter === '"';
        const abreAspas = isAspasDuplas ? '“' : '‘';
        const fechaAspas = isAspasDuplas ? '”' : '’';
        const texto = (_a = this.quill) === null || _a === void 0 ? void 0 : _a.getText().substring(0, range.index);
        const aspasTransformada = !texto || (texto === null || texto === void 0 ? void 0 : texto.match(/\s$/g)) ? abreAspas : fechaAspas;
        const format = (_b = this.quill) === null || _b === void 0 ? void 0 : _b.getFormat(range);
        // Insere o caracter normalmente
        let delta = new Delta$2().retain(range.index).delete(range.length).insert(caracter, format);
        (_c = this.quill) === null || _c === void 0 ? void 0 : _c.updateContents(delta, Quill.sources.USER);
        (_d = this.quill) === null || _d === void 0 ? void 0 : _d.history.cutoff();
        // Troca por aspas curvas
        delta = new Delta$2().retain(range.index).delete(1).insert(aspasTransformada, format);
        (_e = this.quill) === null || _e === void 0 ? void 0 : _e.updateContents(delta, Quill.sources.USER);
        (_f = this.quill) === null || _f === void 0 ? void 0 : _f.setSelection(range.index + 1, Quill.sources.SILENT);
        return false;
    }
    setEnabled(enabled) {
        this.enabled = enabled;
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3=window.ShadowRoot&&(void 0===window.ShadyCSS||window.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,e$6=Symbol(),n$5=new Map;class s$3{constructor(t,n){if(this._$cssResult$=!0,n!==e$6)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t;}get styleSheet(){let e=n$5.get(this.cssText);return t$3&&void 0===e&&(n$5.set(this.cssText,e=new CSSStyleSheet),e.replaceSync(this.cssText)),e}toString(){return this.cssText}}const o$5=t=>new s$3("string"==typeof t?t:t+"",e$6),r$2=(t,...n)=>{const o=1===t.length?t[0]:n.reduce(((e,n,s)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(n)+t[s+1]),t[0]);return new s$3(o,e$6)},i$4=(e,n)=>{t$3?e.adoptedStyleSheets=n.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):n.forEach((t=>{const n=document.createElement("style"),s=window.litNonce;void 0!==s&&n.setAttribute("nonce",s),n.textContent=t.cssText,e.appendChild(n);}));},S$1=t$3?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const n of t.cssRules)e+=n.cssText;return o$5(e)})(t):t;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var s$2;const e$5=window.trustedTypes,r$1=e$5?e$5.emptyScript:"",h$1=window.reactiveElementPolyfillSupport,o$4={toAttribute(t,i){switch(i){case Boolean:t=t?r$1:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,i){let s=t;switch(i){case Boolean:s=null!==t;break;case Number:s=null===t?null:Number(t);break;case Object:case Array:try{s=JSON.parse(t);}catch(t){s=null;}}return s}},n$4=(t,i)=>i!==t&&(i==i||t==t),l$2={attribute:!0,type:String,converter:o$4,reflect:!1,hasChanged:n$4};class a$1 extends HTMLElement{constructor(){super(),this._$Et=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Ei=null,this.o();}static addInitializer(t){var i;null!==(i=this.l)&&void 0!==i||(this.l=[]),this.l.push(t);}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((i,s)=>{const e=this._$Eh(s,i);void 0!==e&&(this._$Eu.set(e,s),t.push(e));})),t}static createProperty(t,i=l$2){if(i.state&&(i.attribute=!1),this.finalize(),this.elementProperties.set(t,i),!i.noAccessor&&!this.prototype.hasOwnProperty(t)){const s="symbol"==typeof t?Symbol():"__"+t,e=this.getPropertyDescriptor(t,s,i);void 0!==e&&Object.defineProperty(this.prototype,t,e);}}static getPropertyDescriptor(t,i,s){return {get(){return this[i]},set(e){const r=this[t];this[i]=e,this.requestUpdate(t,r,s);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||l$2}static finalize(){if(this.hasOwnProperty("finalized"))return !1;this.finalized=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),this.elementProperties=new Map(t.elementProperties),this._$Eu=new Map,this.hasOwnProperty("properties")){const t=this.properties,i=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const s of i)this.createProperty(s,t[s]);}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(i){const s=[];if(Array.isArray(i)){const e=new Set(i.flat(1/0).reverse());for(const i of e)s.unshift(S$1(i));}else void 0!==i&&s.push(S$1(i));return s}static _$Eh(t,i){const s=i.attribute;return !1===s?void 0:"string"==typeof s?s:"string"==typeof t?t.toLowerCase():void 0}o(){var t;this._$Ep=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$Em(),this.requestUpdate(),null===(t=this.constructor.l)||void 0===t||t.forEach((t=>t(this)));}addController(t){var i,s;(null!==(i=this._$Eg)&&void 0!==i?i:this._$Eg=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(s=t.hostConnected)||void 0===s||s.call(t));}removeController(t){var i;null===(i=this._$Eg)||void 0===i||i.splice(this._$Eg.indexOf(t)>>>0,1);}_$Em(){this.constructor.elementProperties.forEach(((t,i)=>{this.hasOwnProperty(i)&&(this._$Et.set(i,this[i]),delete this[i]);}));}createRenderRoot(){var t;const s=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return i$4(s,this.constructor.elementStyles),s}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostConnected)||void 0===i?void 0:i.call(t)}));}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostDisconnected)||void 0===i?void 0:i.call(t)}));}attributeChangedCallback(t,i,s){this._$AK(t,s);}_$ES(t,i,s=l$2){var e,r;const h=this.constructor._$Eh(t,s);if(void 0!==h&&!0===s.reflect){const n=(null!==(r=null===(e=s.converter)||void 0===e?void 0:e.toAttribute)&&void 0!==r?r:o$4.toAttribute)(i,s.type);this._$Ei=t,null==n?this.removeAttribute(h):this.setAttribute(h,n),this._$Ei=null;}}_$AK(t,i){var s,e,r;const h=this.constructor,n=h._$Eu.get(t);if(void 0!==n&&this._$Ei!==n){const t=h.getPropertyOptions(n),l=t.converter,a=null!==(r=null!==(e=null===(s=l)||void 0===s?void 0:s.fromAttribute)&&void 0!==e?e:"function"==typeof l?l:null)&&void 0!==r?r:o$4.fromAttribute;this._$Ei=n,this[n]=a(i,t.type),this._$Ei=null;}}requestUpdate(t,i,s){let e=!0;void 0!==t&&(((s=s||this.constructor.getPropertyOptions(t)).hasChanged||n$4)(this[t],i)?(this._$AL.has(t)||this._$AL.set(t,i),!0===s.reflect&&this._$Ei!==t&&(void 0===this._$EC&&(this._$EC=new Map),this._$EC.set(t,s))):e=!1),!this.isUpdatePending&&e&&(this._$Ep=this._$E_());}async _$E_(){this.isUpdatePending=!0;try{await this._$Ep;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this._$Et&&(this._$Et.forEach(((t,i)=>this[i]=t)),this._$Et=void 0);let i=!1;const s=this._$AL;try{i=this.shouldUpdate(s),i?(this.willUpdate(s),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostUpdate)||void 0===i?void 0:i.call(t)})),this.update(s)):this._$EU();}catch(t){throw i=!1,this._$EU(),t}i&&this._$AE(s);}willUpdate(t){}_$AE(t){var i;null===(i=this._$Eg)||void 0===i||i.forEach((t=>{var i;return null===(i=t.hostUpdated)||void 0===i?void 0:i.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$EU(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$Ep}shouldUpdate(t){return !0}update(t){void 0!==this._$EC&&(this._$EC.forEach(((t,i)=>this._$ES(i,this[i],t))),this._$EC=void 0),this._$EU();}updated(t){}firstUpdated(t){}}a$1.finalized=!0,a$1.elementProperties=new Map,a$1.elementStyles=[],a$1.shadowRootOptions={mode:"open"},null==h$1||h$1({ReactiveElement:a$1}),(null!==(s$2=globalThis.reactiveElementVersions)&&void 0!==s$2?s$2:globalThis.reactiveElementVersions=[]).push("1.3.1");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var t$2;const i$3=globalThis.trustedTypes,s$1=i$3?i$3.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$4=`lit$${(Math.random()+"").slice(9)}$`,o$3="?"+e$4,n$3=`<${o$3}>`,l$1=document,h=(t="")=>l$1.createComment(t),r=t=>null===t||"object"!=typeof t&&"function"!=typeof t,d=Array.isArray,u=t=>{var i;return d(t)||"function"==typeof(null===(i=t)||void 0===i?void 0:i[Symbol.iterator])},c=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,a=/>/g,f=/>|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g,_=/'/g,m=/"/g,g=/^(?:script|style|textarea|title)$/i,p=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),$=p(1),b=Symbol.for("lit-noChange"),w=Symbol.for("lit-nothing"),T=new WeakMap,x=(t,i,s)=>{var e,o;const n=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new N(i.insertBefore(h(),t),t,void 0,null!=s?s:{});}return l._$AI(t),l},A=l$1.createTreeWalker(l$1,129,null,!1),C$1=(t,i)=>{const o=t.length-1,l=[];let h,r=2===i?"<svg>":"",d=c;for(let i=0;i<o;i++){const s=t[i];let o,u,p=-1,$=0;for(;$<s.length&&(d.lastIndex=$,u=d.exec(s),null!==u);)$=d.lastIndex,d===c?"!--"===u[1]?d=v:void 0!==u[1]?d=a:void 0!==u[2]?(g.test(u[2])&&(h=RegExp("</"+u[2],"g")),d=f):void 0!==u[3]&&(d=f):d===f?">"===u[0]?(d=null!=h?h:c,p=-1):void 0===u[1]?p=-2:(p=d.lastIndex-u[2].length,o=u[1],d=void 0===u[3]?f:'"'===u[3]?m:_):d===m||d===_?d=f:d===v||d===a?d=c:(d=f,h=void 0);const y=d===f&&t[i+1].startsWith("/>")?" ":"";r+=d===c?s+n$3:p>=0?(l.push(o),s.slice(0,p)+"$lit$"+s.slice(p)+e$4+y):s+e$4+(-2===p?(l.push(void 0),i):y);}const u=r+(t[o]||"<?>")+(2===i?"</svg>":"");if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return [void 0!==s$1?s$1.createHTML(u):u,l]};class E{constructor({strings:t,_$litType$:s},n){let l;this.parts=[];let r=0,d=0;const u=t.length-1,c=this.parts,[v,a]=C$1(t,s);if(this.el=E.createElement(v,n),A.currentNode=this.el.content,2===s){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes);}for(;null!==(l=A.nextNode())&&c.length<u;){if(1===l.nodeType){if(l.hasAttributes()){const t=[];for(const i of l.getAttributeNames())if(i.endsWith("$lit$")||i.startsWith(e$4)){const s=a[d++];if(t.push(i),void 0!==s){const t=l.getAttribute(s.toLowerCase()+"$lit$").split(e$4),i=/([.?@])?(.*)/.exec(s);c.push({type:1,index:r,name:i[2],strings:t,ctor:"."===i[1]?M$1:"?"===i[1]?H:"@"===i[1]?I$1:S});}else c.push({type:6,index:r});}for(const i of t)l.removeAttribute(i);}if(g.test(l.tagName)){const t=l.textContent.split(e$4),s=t.length-1;if(s>0){l.textContent=i$3?i$3.emptyScript:"";for(let i=0;i<s;i++)l.append(t[i],h()),A.nextNode(),c.push({type:2,index:++r});l.append(t[s],h());}}}else if(8===l.nodeType)if(l.data===o$3)c.push({type:2,index:r});else {let t=-1;for(;-1!==(t=l.data.indexOf(e$4,t+1));)c.push({type:7,index:r}),t+=e$4.length-1;}r++;}}static createElement(t,i){const s=l$1.createElement("template");return s.innerHTML=t,s}}function P(t,i,s=t,e){var o,n,l,h;if(i===b)return i;let d=void 0!==e?null===(o=s._$Cl)||void 0===o?void 0:o[e]:s._$Cu;const u=r(i)?void 0:i._$litDirective$;return (null==d?void 0:d.constructor)!==u&&(null===(n=null==d?void 0:d._$AO)||void 0===n||n.call(d,!1),void 0===u?d=void 0:(d=new u(t),d._$AT(t,s,e)),void 0!==e?(null!==(l=(h=s)._$Cl)&&void 0!==l?l:h._$Cl=[])[e]=d:s._$Cu=d),void 0!==d&&(i=P(t,d._$AS(t,i.values),d,e)),i}class V$1{constructor(t,i){this.v=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}p(t){var i;const{el:{content:s},parts:e}=this._$AD,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:l$1).importNode(s,!0);A.currentNode=o;let n=A.nextNode(),h=0,r=0,d=e[0];for(;void 0!==d;){if(h===d.index){let i;2===d.type?i=new N(n,n.nextSibling,this,t):1===d.type?i=new d.ctor(n,d.name,d.strings,this,t):6===d.type&&(i=new L$1(n,this,t)),this.v.push(i),d=e[++r];}h!==(null==d?void 0:d.index)&&(n=A.nextNode(),h++);}return o}m(t){let i=0;for(const s of this.v)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class N{constructor(t,i,s,e){var o;this.type=2,this._$AH=w,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cg=null===(o=null==e?void 0:e.isConnected)||void 0===o||o;}get _$AU(){var t,i;return null!==(i=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==i?i:this._$Cg}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=P(this,t,i),r(t)?t===w||null==t||""===t?(this._$AH!==w&&this._$AR(),this._$AH=w):t!==this._$AH&&t!==b&&this.$(t):void 0!==t._$litType$?this.T(t):void 0!==t.nodeType?this.k(t):u(t)?this.S(t):this.$(t);}M(t,i=this._$AB){return this._$AA.parentNode.insertBefore(t,i)}k(t){this._$AH!==t&&(this._$AR(),this._$AH=this.M(t));}$(t){this._$AH!==w&&r(this._$AH)?this._$AA.nextSibling.data=t:this.k(l$1.createTextNode(t)),this._$AH=t;}T(t){var i;const{values:s,_$litType$:e}=t,o="number"==typeof e?this._$AC(t):(void 0===e.el&&(e.el=E.createElement(e.h,this.options)),e);if((null===(i=this._$AH)||void 0===i?void 0:i._$AD)===o)this._$AH.m(s);else {const t=new V$1(o,this),i=t.p(this.options);t.m(s),this.k(i),this._$AH=t;}}_$AC(t){let i=T.get(t.strings);return void 0===i&&T.set(t.strings,i=new E(t)),i}S(t){d(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const o of t)e===i.length?i.push(s=new N(this.M(h()),this.M(h()),this,this.options)):s=i[e],s._$AI(o),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){var i;void 0===this._$AM&&(this._$Cg=t,null===(i=this._$AP)||void 0===i||i.call(this,t));}}class S{constructor(t,i,s,e,o){this.type=1,this._$AH=w,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=o,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=w;}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,i=this,s,e){const o=this.strings;let n=!1;if(void 0===o)t=P(this,t,i,0),n=!r(t)||t!==this._$AH&&t!==b,n&&(this._$AH=t);else {const e=t;let l,h;for(t=o[0],l=0;l<o.length-1;l++)h=P(this,e[s+l],i,l),h===b&&(h=this._$AH[l]),n||(n=!r(h)||h!==this._$AH[l]),h===w?t=w:t!==w&&(t+=(null!=h?h:"")+o[l+1]),this._$AH[l]=h;}n&&!e&&this.C(t);}C(t){t===w?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"");}}class M$1 extends S{constructor(){super(...arguments),this.type=3;}C(t){this.element[this.name]=t===w?void 0:t;}}const k=i$3?i$3.emptyScript:"";class H extends S{constructor(){super(...arguments),this.type=4;}C(t){t&&t!==w?this.element.setAttribute(this.name,k):this.element.removeAttribute(this.name);}}class I$1 extends S{constructor(t,i,s,e,o){super(t,i,s,e,o),this.type=5;}_$AI(t,i=this){var s;if((t=null!==(s=P(this,t,i,0))&&void 0!==s?s:w)===b)return;const e=this._$AH,o=t===w&&e!==w||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,n=t!==w&&(e===w||o);o&&this.element.removeEventListener(this.name,this,e),n&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){var i,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t);}}class L$1{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){P(this,t);}}const z=window.litHtmlPolyfillSupport;null==z||z(E,N),(null!==(t$2=globalThis.litHtmlVersions)&&void 0!==t$2?t$2:globalThis.litHtmlVersions=[]).push("2.2.2");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var l,o$2;class s extends a$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Dt=void 0;}createRenderRoot(){var t,e;const i=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=i.firstChild),i}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Dt=x(i,this.renderRoot,this.renderOptions);}connectedCallback(){var t;super.connectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!0);}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!1);}render(){return b}}s.finalized=!0,s._$litElement$=!0,null===(l=globalThis.litElementHydrateSupport)||void 0===l||l.call(globalThis,{LitElement:s});const n$2=globalThis.litElementPolyfillSupport;null==n$2||n$2({LitElement:s});(null!==(o$2=globalThis.litElementVersions)&&void 0!==o$2?o$2:globalThis.litElementVersions=[]).push("3.2.0");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const n$1=n=>e=>"function"==typeof e?((n,e)=>(window.customElements.define(n,e),e))(n,e):((n,e)=>{const{kind:t,elements:i}=e;return {kind:t,elements:i,finisher(e){window.customElements.define(n,e);}}})(n,e);

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const i$2=(i,e)=>"method"===e.kind&&e.descriptor&&!("value"in e.descriptor)?{...e,finisher(n){n.createProperty(e.key,i);}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:e.key,initializer(){"function"==typeof e.initializer&&(this[e.key]=e.initializer.call(this));},finisher(n){n.createProperty(e.key,i);}};function e$3(e){return (n,t)=>void 0!==t?((i,e,n)=>{e.constructor.createProperty(n,i);})(e,n,t):i$2(e,n)}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function t$1(t){return e$3({...t,state:!0})}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$1=({finisher:e,descriptor:t})=>(o,n)=>{var r;if(void 0===n){const n=null!==(r=o.originalKey)&&void 0!==r?r:o.key,i=null!=t?{kind:"method",placement:"prototype",key:n,descriptor:t(o.key)}:{...o,key:n};return null!=e&&(i.finisher=function(t){e(t,n);}),i}{const r=o.constructor;void 0!==t&&Object.defineProperty(o,n,t(n)),null==e||e(r,n);}};

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function i$1(i,n){return o$1({descriptor:o=>{const t={get(){var o,n;return null!==(n=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==n?n:null},enumerable:!0,configurable:!0};if(n){const n="symbol"==typeof o?Symbol():"__"+o;t.get=function(){var o,t;return void 0===this[n]&&(this[n]=null!==(t=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==t?t:null),this[n]};}return t}})}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function e$2(e){return o$1({descriptor:r=>({get(){var r,o;return null!==(o=null===(r=this.renderRoot)||void 0===r?void 0:r.querySelectorAll(e))&&void 0!==o?o:[]},enumerable:!0,configurable:!0})})}

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var n;null!=(null===(n=window.HTMLSlotElement)||void 0===n?void 0:n.prototype.assignedElements)?(o,n)=>o.assignedElements(n):(o,n)=>o.assignedNodes(n).filter((o=>o.nodeType===Node.ELEMENT_NODE));

/**
@license
Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
  This is a JavaScript mixin that you can use to connect a Custom Element base
  class to a Redux store. The `stateChanged(state)` method will be called when
  the state is updated.

  Example:

      import { connect } from 'pwa-helpers/connect-mixin.js';

      class MyElement extends connect(store)(HTMLElement) {
        stateChanged(state) {
          this.textContent = state.data.count.toString();
        }
      }
*/
const connect = (store) => (baseElement) => class extends baseElement {
    connectedCallback() {
        if (super.connectedCallback) {
            super.connectedCallback();
        }
        this._storeUnsubscribe = store.subscribe(() => this.stateChanged(store.getState()));
        this.stateChanged(store.getState());
    }
    disconnectedCallback() {
        this._storeUnsubscribe();
        if (super.disconnectedCallback) {
            super.disconnectedCallback();
        }
    }
    /**
     * The `stateChanged(state)` method will be called when the state is updated.
     */
    stateChanged(_state) { }
};

class LexmlEmendaConfig {
    constructor() {
        this.urlConsultaParlamentares = 'api/parlamentares';
        this.urlAutocomplete = 'api/autocomplete-norma';
    }
}

/**
 * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
 *
 * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
 * during build.
 * @param {number} code
 */
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
}

// Inlined version of the `symbol-observable` polyfill
var $$observable = (function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
})();

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
function miniKindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';
  var type = typeof val;

  switch (type) {
    case 'boolean':
    case 'string':
    case 'number':
    case 'symbol':
    case 'function':
      {
        return type;
      }
  }

  if (Array.isArray(val)) return 'array';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  var constructorName = ctorName(val);

  switch (constructorName) {
    case 'Symbol':
    case 'Promise':
    case 'WeakMap':
    case 'WeakSet':
    case 'Map':
    case 'Set':
      return constructorName;
  } // other


  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
}

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isError(val) {
  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
}

function kindOf(val) {
  var typeOfVal = typeof val;

  if (process.env.NODE_ENV !== 'production') {
    typeOfVal = miniKindOf(val);
  }

  return typeOfVal;
}

/**
 * @deprecated
 *
 * **We recommend using the `configureStore` method
 * of the `@reduxjs/toolkit` package**, which replaces `createStore`.
 *
 * Redux Toolkit is our recommended approach for writing Redux logic today,
 * including store setup, reducers, data fetching, and more.
 *
 * **For more details, please read this Redux docs page:**
 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
 *
 * `configureStore` from Redux Toolkit is an improved version of `createStore` that
 * simplifies setup and helps avoid common bugs.
 *
 * You should not be using the `redux` core package by itself today, except for learning purposes.
 * The `createStore` method from the core `redux` package will not be removed, but we encourage
 * all users to migrate to using Redux Toolkit for all Redux code.
 *
 * If you want to use `createStore` without this visual deprecation warning, use
 * the `legacy_createStore` import instead:
 *
 * `import { legacy_createStore as createStore} from 'redux'`
 *
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(0) : 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(3) : 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
    }

    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(5) : 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(6) : 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    }

    if (typeof action.type === 'undefined') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }

    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(9) : 'Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + kindOf(inputState) + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(12) : "The slice reducer for key \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(13) : "The slice reducer for key \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle '" + ActionTypes.INIT + "' or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        warning("No reducer provided for key \"" + key + "\"");
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (process.env.NODE_ENV !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

      if (warningMessage) {
        warning(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var actionType = action && action.type;
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(14) : "When called with an action of type " + (actionType ? "\"" + String(actionType) + "\"" : '(unknown type)') + ", the slice reducer for key \"" + _key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.");
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
}

const appReducer = (state = {}, action) => {
    switch (action.type) {
        default:
            return state;
    }
};

const ADICIONAR_AGRUPADOR_ARTIGO = 'ADICIONAR_AGRUPADOR_ARTIGO';
class AdicionarAgrupadorArtigo {
    constructor(posicao) {
        this.hotkey = '(Ctrl+Alt+G)';
        this.descricao = 'Adicionar Título, Capítulo, Seção e outros' + (posicao ? ' ' + posicao : '');
        this.posicao = posicao;
    }
    execute(atual, tipo, refAux, posicao, manterNoMesmoGrupoDeAspas) {
        return {
            type: ADICIONAR_AGRUPADOR_ARTIGO,
            atual,
            novo: {
                tipo,
                posicao,
                manterNoMesmoGrupoDeAspas,
            },
        };
    }
}
const adicionarAgrupadorArtigoAction = new AdicionarAgrupadorArtigo();
const adicionarAgrupadorArtigoAntesAction = new AdicionarAgrupadorArtigo('antes');

const ADICIONAR_ALERTA = 'ADICIONAR_ALERTA';
function adicionarAlerta$1(alerta) {
    return {
        type: ADICIONAR_ALERTA,
        alerta: {
            id: alerta.id,
            tipo: alerta.tipo,
            mensagem: alerta.mensagem,
            podeFechar: alerta.podeFechar,
            exibirComandoEmenda: alerta.exibirComandoEmenda,
        },
    };
}

const LIMPAR_ALERTAS = 'LIMPAR_ALERTAS';
function limparAlertas$1() {
    return {
        type: 'LIMPAR_ALERTAS',
    };
}

const REMOVER_ALERTA = 'REMOVER_ALERTA';
function removerAlerta(id) {
    return {
        type: 'REMOVER_ALERTA',
        id,
    };
}

const ASSISTENTE_ALTERACAO = 'ASSISTENTE_ALTERACAO';
class AdicionarAlteracaoComAssistenteAction {
    constructor() {
        this.descricao = 'Alteração com Assistente';
    }
    execute(atual, norma, dispositivos) {
        return {
            type: ASSISTENTE_ALTERACAO,
            atual,
            norma,
            dispositivos,
        };
    }
}
const adicionarAlteracaoComAssistenteAction = new AdicionarAlteracaoComAssistenteAction();

const TipoDispositivo = {
    agrupadorGenerico: {
        tipo: 'DispositivoAgrupadorGenerico',
        name: undefined,
        tagId: 'dg',
        descricao: undefined,
        descricaoPlural: undefined,
        tiposPermitidosPai: ['Articulacao', 'Parte', 'Livro', 'Titulo', 'Capitulo', 'Secao'],
        tiposPermitidosFilhos: ['Parte', 'Livro', 'Titulo', 'Capitulo', 'Secao', 'Artigo'],
        tipoProvavelFilho: 'Artigo',
        INDICADOR_SEQUENCIA: ['NA'],
        INDICADOR_FIM_SEQUENCIA: [''],
        INDICADOR_DESDOBRAMENTO: ['NA'],
    },
    alinea: {
        tipo: 'Alinea',
        name: 'Alinea',
        tagId: 'ali',
        descricao: 'Alínea',
        descricaoPlural: 'Alíneas',
        tiposPermitidosPai: ['Inciso'],
        tiposPermitidosFilhos: ['Item'],
        tipoProvavelFilho: 'Item',
        INDICADOR_SEQUENCIA: [';', '; e', '; ou'],
        INDICADOR_FIM_SEQUENCIA: ['.'],
        INDICADOR_DESDOBRAMENTO: [':'],
    },
    articulacao: {
        tipo: 'Articulacao',
        name: 'Articulacao',
        tagId: '',
        descricao: 'Articulação',
        descricaoPlural: 'Articulações',
        tiposPermitidosPai: [],
        tiposPermitidosFilhos: ['Parte', 'Livro', 'Titulo', 'Capitulo', 'Secao', 'Artigo'],
        tipoProvavelFilho: 'Artigo',
        INDICADOR_SEQUENCIA: ['.'],
        INDICADOR_FIM_SEQUENCIA: ['NA'],
        INDICADOR_DESDOBRAMENTO: [':'],
    },
    artigo: {
        tipo: 'Artigo',
        name: 'Artigo',
        tagId: 'art',
        descricao: 'Artigo',
        descricaoPlural: 'Artigos',
        tiposPermitidosPai: ['Articulacao', 'Parte', 'Livro', 'Titulo', 'Capitulo', 'Secao', 'Subsecao'],
        tiposPermitidosFilhos: ['Paragrafo', 'Inciso'],
        tipoProvavelFilho: 'Inciso',
        INDICADOR_SEQUENCIA: ['.'],
        INDICADOR_FIM_SEQUENCIA: ['NA'],
        INDICADOR_DESDOBRAMENTO: [':'],
    },
    capitulo: {
        tipo: 'Capitulo',
        name: 'Capitulo',
        tagId: 'cap',
        descricao: 'Capítulo',
        descricaoPlural: 'Capítulos',
        tiposPermitidosPai: ['Articulacao', 'Parte', 'Livro', 'Titulo'],
        tiposPermitidosFilhos: ['Secao', 'Artigo'],
        tipoProvavelFilho: 'Artigo',
        INDICADOR_SEQUENCIA: ['NA'],
        INDICADOR_FIM_SEQUENCIA: [''],
        INDICADOR_DESDOBRAMENTO: ['NA'],
    },
    caput: {
        tipo: 'Caput',
        name: 'Caput',
        tagId: 'cpt',
        descricao: 'Caput',
        descricaoPlural: 'Capita',
        tiposPermitidosPai: ['Artigo'],
        tiposPermitidosFilhos: ['Inciso'],
        tipoProvavelFilho: 'Inciso',
        INDICADOR_SEQUENCIA: ['.'],
        INDICADOR_FIM_SEQUENCIA: ['NA'],
        INDICADOR_DESDOBRAMENTO: [':'],
    },
    generico: {
        tipo: 'DispositivoGenerico',
        name: undefined,
        tagId: 'gen',
        descricao: 'Dispositivo genérico',
        descricaoPlural: 'Dispositivos genéricos',
        tiposPermitidosPai: ['Articulacao', 'Parte', 'Livro', 'Titulo', 'Capitulo', 'Secao', 'Subsecao'],
        tiposPermitidosFilhos: ['Paragrafo', 'Inciso', 'Alinea', 'Item'],
        tipoProvavelFilho: 'DispositivoGenerico',
        INDICADOR_SEQUENCIA: [';', '; e', '; ou'],
        INDICADOR_FIM_SEQUENCIA: ['.'],
        INDICADOR_DESDOBRAMENTO: [':'],
    },
    inciso: {
        tipo: 'Inciso',
        name: 'Inciso',
        tagId: 'inc',
        descricao: 'Inciso',
        descricaoPlural: 'Incisos',
        tiposPermitidosPai: ['Artigo', 'Caput', 'Paragrafo'],
        tiposPermitidosFilhos: ['Alinea'],
        tipoProvavelFilho: 'Alinea',
        INDICADOR_SEQUENCIA: [';', '; e', '; ou'],
        INDICADOR_FIM_SEQUENCIA: ['.'],
        INDICADOR_DESDOBRAMENTO: [':'],
    },
    item: {
        tipo: 'Item',
        name: 'Item',
        tagId: 'ite',
        descricao: 'Item',
        descricaoPlural: 'Itens',
        tiposPermitidosPai: ['Alinea'],
        tiposPermitidosFilhos: [],
        tipoProvavelFilho: 'DispositivoGenerico',
        INDICADOR_SEQUENCIA: [';', '; e', '; ou'],
        INDICADOR_FIM_SEQUENCIA: ['.'],
        INDICADOR_DESDOBRAMENTO: [':'],
    },
    livro: {
        tipo: 'Livro',
        name: 'Livro',
        tagId: 'liv',
        descricao: 'Livro',
        descricaoPlural: 'Livros',
        tiposPermitidosPai: ['Articulacao', 'Parte'],
        tiposPermitidosFilhos: ['Titulo', 'Capitulo', 'Secao', 'Artigo'],
        tipoProvavelFilho: 'Artigo',
        INDICADOR_SEQUENCIA: ['NA'],
        INDICADOR_FIM_SEQUENCIA: [''],
        INDICADOR_DESDOBRAMENTO: ['NA'],
    },
    omissis: {
        tipo: 'Omissis',
        name: 'Omissis',
        tagId: 'omi',
        descricao: 'Linha pontilhada (omissis)',
        descricaoPlural: 'Linhas pontilhadas (omissis)',
        tiposPermitidosPai: ['Articulacao', 'Parte', 'Livro', 'Titulo', 'Capitulo', 'Secao', 'Subsecao', 'Artigo', 'Caput', 'Paragrafo', 'Alinea', 'Inciso'],
        tiposPermitidosFilhos: ['Parte', 'Livro', 'Titulo', 'Capitulo', 'Secao', 'Subsecao', 'Artigo', 'Paragrafo', 'Alinea', 'Inciso', 'Item'],
        tipoProvavelFilho: undefined,
        INDICADOR_SEQUENCIA: ['NA'],
        INDICADOR_FIM_SEQUENCIA: ['NA'],
        INDICADOR_DESDOBRAMENTO: ['NA'],
    },
    paragrafo: {
        tipo: 'Paragrafo',
        name: 'Paragrafo',
        tagId: 'par',
        descricao: 'Parágrafo',
        descricaoPlural: 'Parágrafos',
        tiposPermitidosPai: ['Artigo'],
        tiposPermitidosFilhos: ['Inciso'],
        tipoProvavelFilho: 'Inciso',
        INDICADOR_SEQUENCIA: ['.'],
        INDICADOR_FIM_SEQUENCIA: ['NA'],
        INDICADOR_DESDOBRAMENTO: [':'],
    },
    parte: {
        tipo: 'Parte',
        name: 'Parte',
        tagId: 'prt',
        descricao: 'Parte',
        descricaoPlural: 'Partes',
        tiposPermitidosPai: ['Articulacao'],
        tiposPermitidosFilhos: ['Livro', 'Titulo', 'Capitulo', 'Secao', 'Artigo'],
        tipoProvavelFilho: 'Artigo',
        INDICADOR_SEQUENCIA: ['NA'],
        INDICADOR_FIM_SEQUENCIA: [''],
        INDICADOR_DESDOBRAMENTO: ['NA'],
    },
    secao: {
        tipo: 'Secao',
        name: 'Secao',
        tagId: 'sec',
        descricao: 'Seção',
        descricaoPlural: 'Seções',
        tiposPermitidosPai: ['Articulacao', 'Parte', 'Livro', 'Titulo', 'Capitulo'],
        tiposPermitidosFilhos: ['Subsecao', 'Artigo'],
        tipoProvavelFilho: 'Artigo',
        INDICADOR_SEQUENCIA: ['NA'],
        INDICADOR_FIM_SEQUENCIA: [''],
        INDICADOR_DESDOBRAMENTO: ['NA'],
    },
    subsecao: {
        tipo: 'Subsecao',
        name: 'Subsecao',
        tagId: 'sub',
        descricao: 'Subseção',
        descricaoPlural: 'Subseções',
        tiposPermitidosPai: ['Secao'],
        tiposPermitidosFilhos: ['Artigo'],
        tipoProvavelFilho: 'Artigo',
        INDICADOR_SEQUENCIA: ['NA'],
        INDICADOR_FIM_SEQUENCIA: [''],
        INDICADOR_DESDOBRAMENTO: ['NA'],
    },
    titulo: {
        tipo: 'Titulo',
        name: 'Titulo',
        tagId: 'tit',
        descricao: 'Título',
        descricaoPlural: 'Títulos',
        tiposPermitidosPai: ['Articulacao', 'Parte', 'Livro'],
        tiposPermitidosFilhos: ['Capitulo', 'Secao', 'Artigo'],
        tipoProvavelFilho: 'Artigo',
        INDICADOR_SEQUENCIA: ['NA'],
        INDICADOR_FIM_SEQUENCIA: [''],
        INDICADOR_DESDOBRAMENTO: ['NA'],
    },
    ementa: {
        tipo: 'Ementa',
        name: 'Ementa',
        tagId: 'eme',
        descricao: 'Ementa',
        descricaoPlural: 'Ementas',
        tiposPermitidosPai: ['Articulacao'],
        tiposPermitidosFilhos: [],
        tipoProvavelFilho: undefined,
        INDICADOR_SEQUENCIA: ['NA'],
        INDICADOR_FIM_SEQUENCIA: ['NA'],
        INDICADOR_DESDOBRAMENTO: ['NA'],
    },
};

const ADICIONAR_ELEMENTO = 'ADICIONAR_ELEMENTO';
class AdicionarElemento {
    constructor(tipo, posicao) {
        var _a, _b;
        this.isDispositivoAlteracao = false;
        this.descricao = `Adicionar ${(_b = (_a = tipo === null || tipo === void 0 ? void 0 : tipo.descricao) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : ''} ${posicao && posicao !== 'filho' ? posicao : ''}`;
        this.tipo = tipo === null || tipo === void 0 ? void 0 : tipo.tipo;
        this.posicao = posicao;
    }
    execute(atual, conteudo, tipo, hasDesmembramento = false) {
        return {
            type: ADICIONAR_ELEMENTO,
            atual,
            novo: {
                tipo: tipo !== null && tipo !== void 0 ? tipo : this.tipo,
                isDispositivoAlteracao: this.isDispositivoAlteracao,
                conteudo: {
                    texto: conteudo,
                },
            },
            hasDesmembramento,
            posicao: this.posicao,
        };
    }
}
const adicionarElementoAction = new AdicionarElemento();
const adicionarArtigo = new AdicionarElemento(TipoDispositivo.artigo);
const adicionarArtigoAntes = new AdicionarElemento(TipoDispositivo.artigo, 'antes');
const adicionarArtigoDepois = new AdicionarElemento(TipoDispositivo.artigo, 'depois');
new AdicionarElemento(TipoDispositivo.artigo, 'filho');
const adicionarAlinea = new AdicionarElemento(TipoDispositivo.alinea);
const adicionarAlineaAntes = new AdicionarElemento(TipoDispositivo.alinea, 'antes');
const adicionarAlineaDepois = new AdicionarElemento(TipoDispositivo.alinea, 'depois');
const adicionarAlineaFilho = new AdicionarElemento(TipoDispositivo.alinea, 'filho');
const adicionarInciso = new AdicionarElemento(TipoDispositivo.inciso);
const adicionarIncisoAntes = new AdicionarElemento(TipoDispositivo.inciso, 'antes');
const adicionarIncisoDepois = new AdicionarElemento(TipoDispositivo.inciso, 'depois');
const adicionarIncisoFilho = new AdicionarElemento(TipoDispositivo.inciso, 'filho');
const adicionarItem = new AdicionarElemento(TipoDispositivo.item);
const adicionarItemAntes = new AdicionarElemento(TipoDispositivo.item, 'antes');
const adicionarItemDepois = new AdicionarElemento(TipoDispositivo.item, 'depois');
const adicionarItemFilho = new AdicionarElemento(TipoDispositivo.item, 'filho');
const omissis = new AdicionarElemento(TipoDispositivo.omissis);
const adicionarParagrafo = new AdicionarElemento(TipoDispositivo.paragrafo);
const adicionarParagrafoAntes = new AdicionarElemento(TipoDispositivo.paragrafo, 'antes');
const adicionarParagrafoDepois = new AdicionarElemento(TipoDispositivo.paragrafo, 'depois');
const adicionarParagrafoFilho = new AdicionarElemento(TipoDispositivo.paragrafo, 'filho');

const ADICIONAR_ELEMENTOS_FROM_CLIPBOARD = 'ADICIONAR_ELEMENTOS_FROM_CLIPBOARD';
class AdicionarElementosFromClipboardAction {
    constructor() {
        this.descricao = `Adicionar Elemento from Clipboard`;
    }
    execute(atual, conteudo, _, isDispositivoAlteracao = false, isColarSubstituindo = true, posicao = 'depois') {
        return {
            type: ADICIONAR_ELEMENTOS_FROM_CLIPBOARD,
            atual,
            novo: {
                isDispositivoAlteracao,
                conteudo: {
                    texto: conteudo,
                },
            },
            isColarSubstituindo,
            posicao,
        };
    }
}
const adicionarElementoFromClipboardAction = new AdicionarElementosFromClipboardAction();

const AGRUPAR_ELEMENTO = 'AGRUPAR_ELEMENTO';
class AgruparElemento {
    constructor(tipo) {
        this.descricao = 'Adicionar ' + tipo.descricao;
        this.tipo = tipo.tipo;
    }
    execute(atual, uuid) {
        return {
            type: AGRUPAR_ELEMENTO,
            atual,
            novo: {
                tipo: this.tipo,
                uuid: +uuid,
            },
        };
    }
}
const adicionarParte = new AgruparElemento(TipoDispositivo.parte);
const adicionarLivro = new AgruparElemento(TipoDispositivo.livro);
const adicionarTitulo = new AgruparElemento(TipoDispositivo.titulo);
const adicionarCapitulo = new AgruparElemento(TipoDispositivo.capitulo);
const adicionarSecao = new AgruparElemento(TipoDispositivo.secao);
const adicionarSubsecao = new AgruparElemento(TipoDispositivo.subsecao);

const APLICAR_ALTERACOES_EMENDA = 'APLICAR_ALTERACOES_EMENDA';
class AplicarAlteracoesEmenda {
    constructor() {
        this.descricao = 'Atualizar';
    }
    execute(alteracoesEmenda, revisoes = []) {
        return {
            type: APLICAR_ALTERACOES_EMENDA,
            alteracoesEmenda,
            revisoes,
        };
    }
}
const aplicarAlteracoesEmendaAction = new AplicarAlteracoesEmenda();

const ATUALIZAR_ELEMENTO = 'ATUALIZAR_ELEMENTO';

const ATUALIZAR_REFERENCIA_ELEMENTO = 'ATUALIZAR_REFERENCIA_ELEMENTO';
class AtualizarReferenciaElemento {
    constructor() {
        this.descricao = 'Atualizar Norma Referenciada';
    }
    execute(atual) {
        this.tipo = atual.tipo;
        return {
            type: ATUALIZAR_REFERENCIA_ELEMENTO,
            atual,
        };
    }
}
const atualizarReferenciaElementoAction = new AtualizarReferenciaElemento();

const ATUALIZAR_TEXTO_ELEMENTO = 'ATUALIZAR_TEXTO_ELEMENTO';
class AtualizarTextoElemento {
    constructor() {
        this.descricao = 'Atualizar dispositivo';
    }
    execute(atual) {
        this.tipo = atual.tipo;
        return {
            type: ATUALIZAR_TEXTO_ELEMENTO,
            atual,
        };
    }
}
const atualizarTextoElementoAction = new AtualizarTextoElemento();

const AUTO_FIX = 'AUTO_FIX';
class AutoFixAction {
    constructor() {
        this.descricao = 'Corrigir automaticamente';
    }
    execute(atual, mensagem) {
        return {
            type: AUTO_FIX,
            atual,
            mensagem,
        };
    }
}
const autofixAction = new AutoFixAction();

const ELEMENTO_SELECIONADO = 'ELEMENTO_SELECIONADO';
class ElementoSelecionado {
    constructor() {
        this.descricao = 'Elemento selecionado';
    }
    execute(atual) {
        return {
            type: ELEMENTO_SELECIONADO,
            atual,
        };
    }
}
const elementoSelecionadoAction = new ElementoSelecionado();

const INFORMAR_DADOS_ASSISTENTE = 'INFORMAR_DADOS_ASSISTENTE';
class InformarDadosAssistente {
    constructor() {
        this.descricao = 'Adicionar artigo para alterar outra norma';
    }
    execute(atual) {
        return {
            type: INFORMAR_DADOS_ASSISTENTE,
            atual,
        };
    }
}
const InformarDadosAssistenteAction = new InformarDadosAssistente();

const INFORMAR_EXISTENCIA_NA_NORMA = 'INFORMAR_EXISTENCIA_NA_NORMA';
class InformarExistenciaDoElementoNaNorma {
    constructor(descricao, nomeAcao, hotkey, existeNaNormaAlterada) {
        this.descricao = descricao;
        this.nomeAcao = nomeAcao;
        this.hotkey = hotkey;
        this.existeNaNormaAlterada = existeNaNormaAlterada;
    }
    execute(atual) {
        return {
            type: INFORMAR_EXISTENCIA_NA_NORMA,
            subType: this.nomeAcao,
            atual,
            existeNaNormaAlterada: this.existeNaNormaAlterada,
        };
    }
}
const considerarElementoExistenteNaNorma = new InformarExistenciaDoElementoNaNorma('Considerar existente na norma', 'considerarExistenteNaNorma', '(Ctrl+Alt+X)', true);
const considerarElementoNovoNaNorma = new InformarExistenciaDoElementoNaNorma('Considerar novo na norma', 'considerarNovoNaNorma', '(Ctrl+Alt+X)', false);

const INFORMAR_NORMA = 'INFORMAR_NORMA';
class InformarNorma {
    constructor() {
        this.descricao = 'Informar norma alterada';
    }
    execute(atual) {
        return {
            type: INFORMAR_NORMA,
            atual,
        };
    }
}
const informarNormaAction = new InformarNorma();

const MOVER_ELEMENTO_ABAIXO = 'Mover para baixo';
class MoverElementoAbaixo {
    constructor() {
        this.hotkey = '(Alt+⇣)';
        this.descricao = 'Mover para baixo';
    }
    execute(atual) {
        return {
            type: MOVER_ELEMENTO_ABAIXO,
            atual,
        };
    }
}
const moverElementoAbaixoAction = new MoverElementoAbaixo();

const MOVER_ELEMENTO_ACIMA = 'Mover para cima';
class MoverElementoAcima {
    constructor() {
        this.hotkey = '(Alt+⇡)';
        this.descricao = 'Mover para cima';
    }
    execute(atual) {
        return {
            type: MOVER_ELEMENTO_ACIMA,
            atual,
        };
    }
}
const moverElementoAcimaAction = new MoverElementoAcima();

const ABRIR_ARTICULACAO = 'ABRIR_ARTICULACAO';
const openArticulacaoAction = (articulacao, classificacao) => {
    return {
        type: ABRIR_ARTICULACAO,
        classificacao,
        articulacao,
    };
};

const REDO = 'REDO';
const redoAction = () => {
    return {
        type: REDO,
    };
};

const REMOVER_ELEMENTO = 'REMOVER_ELEMENTO';
class RemoverElemento {
    constructor() {
        this.hotkey = '(Ctrl+D)';
        this.descricao = 'Remover';
    }
    execute(atual, elementoLinhaAnterior) {
        return {
            type: REMOVER_ELEMENTO,
            atual,
            elementoLinhaAnterior,
        };
    }
}
const removerElementoAction = new RemoverElemento();

const RENUMERAR_ELEMENTO = 'RENUMERAR_ELEMENTO';
class RenumerarElemento {
    constructor() {
        this.hotkey = '(Ctrl+Alt+N)';
        this.descricao = 'Numerar dispositivo';
    }
    execute(atual, numero) {
        this.tipo = atual.tipo;
        return {
            type: RENUMERAR_ELEMENTO,
            atual,
            novo: {
                numero,
            },
        };
    }
}
const renumerarElementoAction = new RenumerarElemento();

const RESTAURAR_ELEMENTO = 'RESTAURAR_ELEMENTO';
class RestaurarElemento {
    constructor() {
        this.descricao = 'Abandonar modificações';
    }
    execute(atual) {
        return {
            type: RESTAURAR_ELEMENTO,
            atual,
        };
    }
}
const restaurarElementoAction = new RestaurarElemento();

const SHIFT_TAB = 'SHIFT_TAB';
const shiftTabAction = (atual) => {
    return {
        type: SHIFT_TAB,
        atual,
    };
};

const SUPRIMIR_AGRUPADOR = 'SUPRIMIR_AGRUPADOR';
class SuprimirAgrupador {
    constructor() {
        this.descricao = 'Suprimir apenas o Agrupador';
    }
    execute(atual) {
        return {
            type: SUPRIMIR_AGRUPADOR,
            atual,
        };
    }
}
const suprimirAgrupadorAction = new SuprimirAgrupador();

const SUPRIMIR_ELEMENTO = 'SUPRIMIR_ELEMENTO';
class SuprimirElemento {
    constructor() {
        this.descricao = 'Suprimir';
    }
    execute(atual) {
        return {
            type: SUPRIMIR_ELEMENTO,
            atual,
        };
    }
}
const suprimirElementoAction = new SuprimirElemento();

const TAB = 'TAB';
const tabAction = (atual) => {
    return {
        type: TAB,
        atual,
    };
};

const TRANSFORMAR_TIPO_ELEMENTO = 'TRANSFORMAR_TIPO_ELEMENTO';
class TransformarElemento {
    constructor(tipo, descricao, nomeAcao, hotkey) {
        this.descricao = descricao;
        this.tipo = tipo.tipo;
        this.nomeAcao = nomeAcao;
        this.hotkey = hotkey;
    }
    execute(atual) {
        return {
            type: TRANSFORMAR_TIPO_ELEMENTO,
            subType: this.nomeAcao,
            atual,
            novo: {
                tipo: this.tipo,
            },
        };
    }
}
const transformarEmOmissisAlinea = new TransformarElemento(TipoDispositivo.omissis, 'Omitir Alíneas', 'transformarAlineaEmOmissisAlinea', '(Ctrl+Alt+O)');
const transformarEmOmissisIncisoCaput = new TransformarElemento(TipoDispositivo.omissis, 'Omitir Incisos', 'transformarIncisoCaputEmOmissisIncisoCaput', '(Ctrl+Alt+O)');
const transformarEmOmissisItem = new TransformarElemento(TipoDispositivo.omissis, 'Omitir Itens', 'transformarItemEmOmissisItem', '(Ctrl+Alt+O)');
const transformarEmOmissisParagrafo = new TransformarElemento(TipoDispositivo.omissis, 'Omitir Parágrafos', 'transformarParagrafoEmOmissisParagrafo', '(Ctrl+Alt+O)');
const transformarEmOmissisIncisoParagrafo = new TransformarElemento(TipoDispositivo.omissis, 'Omitir Incisos', 'transformarIncisoParagrafoEmOmissisIncisoParagrafo', '(Ctrl+Alt+O)');
const transformarAlineaEmIncisoCaput = new TransformarElemento(TipoDispositivo.inciso, 'Transformar em Inciso', 'transformarAlineaEmIncisoCaput', '(Shift+Tab)');
const transformarAlineaEmIncisoParagrafo = new TransformarElemento(TipoDispositivo.inciso, 'Transformar em Inciso', 'transformarAlineaEmIncisoParagrafo', '(Shift+Tab)');
const transformaAlineaEmItem = new TransformarElemento(TipoDispositivo.item, 'Transformar em Item', 'transformarAlineaEmItem', '(Tab)');
const transformarArtigoEmParagrafo = new TransformarElemento(TipoDispositivo.paragrafo, 'Transformar em Parágrafo', 'transformarArtigoEmParagrafo', '(Tab)');
const transformarGenericoEmInciso = new TransformarElemento(TipoDispositivo.inciso, 'Transformar em Inciso', 'transformarDispositivoGenericoEmInciso');
const transformarGenericoEmAlinea = new TransformarElemento(TipoDispositivo.alinea, 'Transformar em Alínea', 'transformarDispositivoGenericoEmAlinea');
const transformarGenericoEmItem = new TransformarElemento(TipoDispositivo.item, 'Transformar em Item', 'transformarDispositivoGenericoEmItem');
const transformarIncisoParagrafoEmParagrafo = new TransformarElemento(TipoDispositivo.paragrafo, 'Transformar em Parágrafo', 'transformarIncisoParagrafoEmParagrafo', '(Shift+Tab)');
const transformarIncisoCaputEmParagrafo = new TransformarElemento(TipoDispositivo.paragrafo, 'Transformar em Parágrafo', 'transformarIncisoCaputEmParagrafo', '(Shift+Tab)');
const transformarIncisoCaputEmAlinea = new TransformarElemento(TipoDispositivo.alinea, 'Transformar em Alínea', 'transformarIncisoCaputEmAlinea', '(Tab)');
const transformarIncisoParagrafoEmAlinea = new TransformarElemento(TipoDispositivo.alinea, 'Transformar em Alínea', 'transformarIncisoParagrafoEmAlinea', '(Tab)');
const transformarOmissisEmAlinea = new TransformarElemento(TipoDispositivo.alinea, 'Transformar em Alínea', 'transformarOmissisEmAlinea');
const transformarOmissisEmArtigo = new TransformarElemento(TipoDispositivo.artigo, 'Transformar em Artigo', 'transformarOmissisEmArtigo');
const transformarOmissisEmIncisoCaput = new TransformarElemento(TipoDispositivo.inciso, 'Transformar em Inciso', 'transformarOmissisEmIncisoCaput');
const transformarOmissisEmIncisoParagrafo = new TransformarElemento(TipoDispositivo.inciso, 'Transformar em Inciso', 'transformarOmissisEmIncisoParagrafo');
const transformarOmissisEmItem = new TransformarElemento(TipoDispositivo.item, 'Transformar em Item', 'transformarOmissisEmItem');
const transformarOmissisEmParagrafo = new TransformarElemento(TipoDispositivo.paragrafo, 'Transformar em Parágrafo', 'transformarOmissisEmParagrafo');
const transformarItemEmAlinea = new TransformarElemento(TipoDispositivo.alinea, 'Transformar em Alínea', 'transformarItemEmAlinea', '(Shift+Tab)');
const transformarParagrafoEmArtigo = new TransformarElemento(TipoDispositivo.artigo, 'Transformar em Artigo', 'transformarParagrafoEmArtigo', '(Shift+Tab)');
const transformarParagrafoEmIncisoParagrafo = new TransformarElemento(TipoDispositivo.inciso, 'Transformar em Inciso', 'transformarParagrafoEmIncisoParagrafo', '(Tab)');
const transformarParagrafoEmIncisoCaput = new TransformarElemento(TipoDispositivo.inciso, 'Transformar em Inciso', 'transformarParagrafoEmIncisoCaput', '(Tab)');

const UNDO = 'UNDO';
const UndoAction = () => {
    return {
        type: UNDO,
    };
};

const VALIDAR_ARTICULACAO = 'VALIDAR_ARTICULACAO';
class ValidarArticulacao {
    constructor() {
        this.descricao = 'Articulação validada';
    }
    execute() {
        return {
            type: VALIDAR_ARTICULACAO,
        };
    }
}
const validarArticulacaAction = new ValidarArticulacao();

const VALIDAR_ELEMENTO = 'VALIDAR_ELEMENTO';
class ValidarElemento {
    constructor() {
        this.descricao = 'Elemento validado';
    }
    execute(atual) {
        return {
            type: VALIDAR_ELEMENTO,
            atual,
        };
    }
}
const validarElementoAction = new ValidarElemento();

const ATUALIZAR_NOTA_ALTERACAO = 'ATUALIZAR_NOTA_ALTERACAO';
class AtualizarNotaAlteracao {
    constructor() {
        this.descricao = 'Atualizar nota de alteração';
    }
    execute(atual, notaAlteracao) {
        this.tipo = atual.tipo;
        return {
            type: ATUALIZAR_NOTA_ALTERACAO,
            atual,
            notaAlteracao,
        };
    }
}
const atualizarNotaAlteracaoAction = new AtualizarNotaAlteracao();

const REMOVER_ELEMENTO_SEM_TEXTO = 'REMOVER_ELEMENTO_SEM_TEXTO';
class RemoverElementoSemTexto {
    constructor() {
        this.descricao = 'Remover dispositivo sem texto';
    }
    execute(atual, key) {
        return {
            type: REMOVER_ELEMENTO_SEM_TEXTO,
            atual,
            key,
        };
    }
}
const removerElementoSemTextoAction = new RemoverElementoSemTexto();

var DescricaoSituacao;
(function (DescricaoSituacao) {
    DescricaoSituacao["DISPOSITIVO_ADICIONADO"] = "Dispositivo Adicionado";
    DescricaoSituacao["DISPOSITIVO_NOVO"] = "Dispositivo Novo";
    DescricaoSituacao["DISPOSITIVO_MODIFICADO"] = "Dispositivo Modificado";
    DescricaoSituacao["DISPOSITIVO_ORIGINAL"] = "Dispositivo Original";
    DescricaoSituacao["DISPOSITIVO_SUPRIMIDO"] = "Dispositivo Suprimido";
})(DescricaoSituacao || (DescricaoSituacao = {}));
const isSituacaoExclusivaDispositivoEmenda = (dispositivo) => {
    return [DescricaoSituacao.DISPOSITIVO_ADICIONADO.toString(), DescricaoSituacao.DISPOSITIVO_MODIFICADO.toString(), DescricaoSituacao.DISPOSITIVO_SUPRIMIDO.toString()].includes(dispositivo.situacao.descricaoSituacao);
};

// export const TEXTO_OMISSIS = '...........................................................................................';
const TEXTO_OMISSIS = '.................................................................................................................................................................................................................................................................................';

const isArticulacao = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.articulacao.tipo;
};
const isDispositivoGenerico = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.generico.tipo;
};
const isArtigo = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.artigo.tipo;
};
const isCaput = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.caput.tipo;
};
const isParagrafo = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.paragrafo.tipo;
};
const isInciso = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.inciso.tipo;
};
const isIncisoCaput = (dispositivo) => {
    return isInciso(dispositivo) && isCaput(dispositivo.pai);
};
const isIncisoParagrafo = (dispositivo) => {
    return isInciso(dispositivo) && isParagrafo(dispositivo.pai);
};
const isAlinea = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.alinea.tipo;
};
const isItem = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.item.tipo;
};
const isOmissis = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.omissis.tipo;
};
const isLivro = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.livro.tipo;
};
const isTitulo = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.titulo.tipo;
};
const isParte = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.parte.tipo;
};
const isCapitulo = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.capitulo.tipo;
};
const isAgrupador = (dispositivo) => {
    return [
        TipoDispositivo.articulacao.tipo,
        TipoDispositivo.agrupadorGenerico.tipo,
        TipoDispositivo.capitulo.tipo,
        TipoDispositivo.livro.tipo,
        TipoDispositivo.parte.tipo,
        TipoDispositivo.secao.tipo,
        TipoDispositivo.subsecao.tipo,
        TipoDispositivo.titulo.tipo,
    ].includes(dispositivo.tipo);
};
const isAgrupadorNaoArticulacao = (dispositivo) => {
    return isAgrupador(dispositivo) && !isArticulacao(dispositivo);
};
const isAgrupadorGenerico = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.agrupadorGenerico.tipo;
};
const isDispositivoDeArtigo = (dispositivo) => {
    return [TipoDispositivo.paragrafo.tipo, TipoDispositivo.inciso.tipo, TipoDispositivo.alinea.tipo, TipoDispositivo.item.tipo].includes(dispositivo.tipo);
};
const isEmenta = (dispositivo) => {
    return dispositivo.tipo === TipoDispositivo.ementa.tipo;
};
const isTextoMaiusculo = (dispositivo) => {
    if (dispositivo === undefined) {
        return false;
    }
    return isCapitulo(dispositivo) || isParte(dispositivo) || isLivro(dispositivo) || isTitulo(dispositivo);
};
const isTextoOmitido = (d) => {
    return isOmissis(d) || d.texto.startsWith(TEXTO_OMISSIS) || d.texto.indexOf(TEXTO_OMISSIS) > -1;
};

var ClassificacaoDocumento;
(function (ClassificacaoDocumento) {
    ClassificacaoDocumento["EMENDA"] = "emenda";
    ClassificacaoDocumento["EMENDA_ARTIGO_ONDE_COUBER"] = "emendaArtigoOndeCouber";
    ClassificacaoDocumento["NORMA"] = "norma";
    ClassificacaoDocumento["PROJETO"] = "projeto";
})(ClassificacaoDocumento || (ClassificacaoDocumento = {}));

function getArticulacao(dispositivo) {
    if (!dispositivo) {
        return dispositivo;
    }
    if (isArticulacao(dispositivo)) {
        return dispositivo;
    }
    if (dispositivo.pai === undefined) {
        throw new Error('Não foi encontrada a articulação');
    }
    return getArticulacao(dispositivo.pai);
}
function getDispositivo(uuid, dispositivo) {
    if (dispositivo.uuid === uuid) {
        return dispositivo;
    }
    else if (dispositivo.filhos !== null) {
        let result = null;
        const filhos = dispositivo.hasAlteracao() ? dispositivo.alteracoes.filhos : dispositivo.filhos;
        for (let i = 0; result === null && i < filhos.length; i++) {
            result = getDispositivo(uuid, filhos[i]);
        }
        return result;
    }
    return null;
}
const findDispositivoByUuid = (dispositivo, uuid) => {
    if (uuid === undefined) {
        throw new Error('uuid não foi informado');
    }
    return getDispositivo(uuid, dispositivo);
};
const getUltimoFilho = (dispositivo) => {
    var _a;
    if (hasFilhos(dispositivo)) {
        return getUltimoFilho(dispositivo.filhos[dispositivo.filhos.length - 1]);
    }
    else if ((dispositivo === null || dispositivo === void 0 ? void 0 : dispositivo.hasAlteracao()) && ((_a = dispositivo.alteracoes) === null || _a === void 0 ? void 0 : _a.filhos.length)) {
        return getUltimoFilho(dispositivo.alteracoes.filhos[dispositivo.alteracoes.filhos.length - 1]);
    }
    else {
        return dispositivo;
    }
};
const getFilhosEstiloLexML = (d) => {
    if (isArtigo(d)) {
        const artigo = d;
        return [artigo.caput, ...artigo.filhos.filter(f => isParagrafo(f) || (isOmissis(f) && !isCaput(f.pai)))];
    }
    return [...d.filhos];
};
const irmaosMesmoTipo = (dispositivo) => {
    return isArtigo(dispositivo)
        ? getArticulacao(dispositivo).artigos.filter(f => f.tipo === dispositivo.tipo)
        : dispositivo.pai
            ? dispositivo.pai.filhos.filter(f => f.tipo === dispositivo.tipo)
            : [dispositivo];
};
const getAgrupadoresAcima = (pai, referencia, agrupadores) => {
    if (pai === null || pai === void 0 ? void 0 : pai.filhos) {
        for (let i = pai === null || pai === void 0 ? void 0 : pai.indexOf(referencia); i >= 0; i--) {
            const d = pai === null || pai === void 0 ? void 0 : pai.filhos[i];
            if (isAgrupador(d)) {
                agrupadores.push(d);
            }
        }
        if (pai === null || pai === void 0 ? void 0 : pai.pai) {
            return getAgrupadoresAcima(pai.pai, referencia.pai, agrupadores);
        }
    }
    return agrupadores;
};
const hasAgrupador$1 = (pai) => {
    return pai.filhos.filter(a => isAgrupador(a)).length > 0;
};
const hasAgrupadoresAcima = (dispositivo) => {
    var _a;
    const agrupadores = [];
    if (((_a = dispositivo.pai) === null || _a === void 0 ? void 0 : _a.pai) === undefined) {
        return false;
    }
    return getAgrupadoresAcima(dispositivo.pai.pai, dispositivo.pai, agrupadores).length > 0;
};
const getArtigo = (dispositivo) => {
    if (isArtigo(dispositivo.pai)) {
        return dispositivo.pai;
    }
    return getArtigo(dispositivo.pai);
};
const getArtigoDoProjeto = (dispositivo) => {
    const pai = dispositivo.pai;
    if (isArtigo(pai) && !isDispositivoAlteracao(pai)) {
        return dispositivo.pai;
    }
    return getArtigoDoProjeto(dispositivo.pai);
};
const getArtigosAnterioresIndependenteAgrupador = (dispositivo) => {
    const pos = getArticulacao(dispositivo).indexOfArtigo(dispositivo);
    if (pos < 1) {
        return [];
    }
    return getArticulacao(dispositivo).artigos.filter((artigo, index) => index < pos);
};
const getArtigosPosterioresIndependenteAgrupador = (dispositivo) => {
    const pos = getArticulacao(dispositivo).indexOfArtigo(dispositivo);
    if (pos === -1 || getArticulacao(dispositivo).artigos.length === pos + 1) {
        return [];
    }
    return getArticulacao(dispositivo).artigos.filter((artigo, index) => index > pos);
};
// Retorna o dispositivo imediatamente anterior na sequência de leitura ou primeiro dispositivo anterior aceito por "accept" na sequência de leitura
// Considera caput. Não considera incisos de caput como filhos de artigo.
const getDispositivoAnteriorNaSequenciaDeLeitura = (disp, accept) => {
    if (!disp.pai) {
        return undefined;
    }
    if (isArticulacaoAlteracao(disp)) {
        const anterior = disp.pai.caput;
        return !accept || accept(anterior) ? anterior : getDispositivoAnteriorNaSequenciaDeLeitura(anterior, accept);
    }
    const irmaos = isArtigo(disp.pai) ? getFilhosArtigoEstiloLexML(disp.pai) : disp.pai.filhos;
    const pos = irmaos.indexOf(disp);
    // Busca dispositivo mais à direita na árvore do irmão anterior ou o pai se não houver irmão anterior
    const anterior = pos ? getUltimoFilho(irmaos[pos - 1]) : disp.pai;
    return !accept || accept(anterior) ? anterior : getDispositivoAnteriorNaSequenciaDeLeitura(anterior, accept);
};
// Retorna o dispositivo imediatamente posterior na sequência de leitura ou primeiro dispositivo posterior aceito por "accept" na sequência de leitura
// Considera caput. Não considera incisos de caput como filhos de artigo.
const getDispositivoPosteriorNaSequenciaDeLeitura = (disp, accept, aPartirDe) => {
    if (!disp) {
        return undefined;
    }
    let proximo = undefined;
    if (aPartirDe) {
        proximo = getIrmaoPosteriorIndependenteDeTipo(aPartirDe);
    }
    else {
        const filhos = isArtigo(disp) ? getFilhosArtigoEstiloLexML(disp) : disp.filhos;
        if (filhos.length) {
            proximo = filhos[0];
        }
    }
    if (!proximo && !isDispositivoRaiz(disp)) {
        return getDispositivoPosteriorNaSequenciaDeLeitura(disp.pai, accept, disp);
    }
    return proximo ? (!accept || accept(proximo) ? proximo : getDispositivoPosteriorNaSequenciaDeLeitura(proximo, accept)) : undefined;
};
const getFilhosArtigoEstiloLexML = (art) => {
    // Adiciona o caput e remove os incisos do caput
    return [art.caput, ...getParagrafosEOmissis(art)];
};
const getProximoArtigoAnterior = (pai, referencia) => {
    if (pai === null || pai === void 0 ? void 0 : pai.filhos) {
        for (let i = (pai === null || pai === void 0 ? void 0 : pai.indexOf(referencia)) - 1; i >= 0; i--) {
            const d = pai === null || pai === void 0 ? void 0 : pai.filhos[i];
            if (isArtigo(d)) {
                return d;
            }
            if (isAgrupador(d)) {
                return buscaArtigoAnteriorAbaixo(d);
            }
        }
        if (pai === null || pai === void 0 ? void 0 : pai.pai) {
            return getProximoArtigoAnterior(pai.pai, referencia.pai);
        }
    }
    return undefined;
};
const buscaArtigoAnteriorAbaixo = (dispositivo) => {
    if (dispositivo === undefined) {
        return undefined;
    }
    if (dispositivo.filhos) {
        for (let i = dispositivo.filhos.length - 1; i >= 0; i--) {
            const d = dispositivo.filhos[i];
            if (isArtigo(d)) {
                return d;
            }
            if (isAgrupador(d)) {
                return buscaArtigoAnteriorAbaixo(d);
            }
        }
    }
    return undefined;
};
const getAgrupadorPosterior = (dispositivo) => {
    const pos = dispositivo.pai.indexOf(dispositivo);
    return dispositivo.pai.filhos.filter((d, i) => i > pos && isAgrupador(d))[0];
};
const hasAgrupadoresPosteriores = (dispositivo) => {
    const pos = dispositivo.pai.indexOf(dispositivo);
    return dispositivo.pai.filhos.filter((d, i) => i > pos && isAgrupador(d)).length > 0;
};
const hasFilhoGenerico = (dispositivo) => {
    var _a;
    return ((_a = dispositivo.filhos) === null || _a === void 0 ? void 0 : _a.filter(d => isDispositivoGenerico(d)).length) > 0;
};
const isUnicoMesmoTipo = (dispositivo) => {
    const f = irmaosMesmoTipo(dispositivo);
    return f.length === 1;
};
const isUltimoMesmoTipo = (dispositivo) => {
    const f = irmaosMesmoTipo(dispositivo);
    return f[f.length - 1] === dispositivo;
};
const isPrimeiroMesmoTipo = (dispositivo) => {
    const f = irmaosMesmoTipo(dispositivo);
    return f[0] === dispositivo;
};
const hasFilhos = (dispositivo) => {
    return dispositivo.filhos && dispositivo.filhos.length > 0;
};
const getDispositivoAnterior = (dispositivo) => {
    var _a;
    const pos = (_a = dispositivo.pai) === null || _a === void 0 ? void 0 : _a.indexOf(dispositivo);
    return pos && pos > 0 ? dispositivo.pai.filhos[pos - 1] : undefined;
};
const getDispositivoAnteriorMesmoTipo = (dispositivo) => {
    const irmaos = irmaosMesmoTipo(dispositivo);
    const pos = irmaos.indexOf(dispositivo);
    return pos > 0 ? irmaos[pos - 1] : undefined;
};
const getDispositivoAnteriorMesmoTipoInclusiveOmissis = (dispositivo) => {
    const pos = dispositivo.pai.indexOf(dispositivo);
    if (pos === 0) {
        return undefined;
    }
    const irmaos = dispositivo.pai.filhos.filter((f, index) => index < pos && (f.tipo === dispositivo.tipo || f.tipo === omissis.tipo));
    return irmaos.pop();
};
// Diferencia do getDispositivoAnteriorMesmoTipoInclusiveOmissis por identificar dispositivo irmão anterior de omissis
// [FRAGO] Provavelmente o ideal seria alterar o outro método mas não tive confiança nem tempo para verificar as implicações.
const getIrmaoAnteriorIndependenteDeTipo = (dispositivo) => {
    const pos = dispositivo.pai.indexOf(dispositivo);
    if (pos === 0) {
        return undefined;
    }
    // A restrição pelo mesmo pai diferencia incisos de caput (e omissis) de parágrafos (e omissis).
    const irmaos = dispositivo.pai.filhos.filter((f, index) => index < pos && f.pai === dispositivo.pai);
    return irmaos.pop();
};
// Retorna dispositivo imediatamente anterior na sequência de leitura.
const getDispositivoAnteriorDireto = (d) => {
    const pai = d.pai;
    const irmaos = getFilhosEstiloLexML(pai);
    const i = irmaos.indexOf(d);
    if (i > 0) {
        d = irmaos[i - 1];
    }
    else {
        return pai;
    }
    let filhos = getFilhosEstiloLexML(d);
    while (filhos.length) {
        d = filhos[filhos.length - 1];
        filhos = getFilhosEstiloLexML(d);
    }
    return d;
};
const getDispositivoPosterior = (dispositivo) => {
    if (!dispositivo.pai) {
        return undefined;
    }
    const pos = dispositivo.pai.indexOf(dispositivo);
    return pos < dispositivo.pai.filhos.length - 1 ? dispositivo.pai.filhos[pos + 1] : undefined;
};
const getDispositivoPosteriorMesmoTipo = (dispositivo) => {
    const irmaos = irmaosMesmoTipo(dispositivo);
    const pos = irmaos.indexOf(dispositivo);
    return pos < irmaos.length - 1 ? irmaos[pos + 1] : undefined;
};
const getDispositivosAnterioresMesmoTipo = (dispositivo) => {
    var _a, _b, _c;
    const pos = (_a = dispositivo.pai) === null || _a === void 0 ? void 0 : _a.indexOf(dispositivo);
    return (_c = (_b = dispositivo.pai) === null || _b === void 0 ? void 0 : _b.filhos.filter((f, index) => index < pos && f.tipo === dispositivo.tipo && f.pai === dispositivo.pai)) !== null && _c !== void 0 ? _c : [];
};
const getDispositivosPosterioresMesmoTipo = (dispositivo) => {
    var _a, _b, _c;
    const pos = (_a = dispositivo.pai) === null || _a === void 0 ? void 0 : _a.indexOf(dispositivo);
    return (_c = (_b = dispositivo.pai) === null || _b === void 0 ? void 0 : _b.filhos.filter((f, index) => index > pos && f.tipo === dispositivo.tipo)) !== null && _c !== void 0 ? _c : [];
};
const getDispositivoPosteriorMesmoTipoInclusiveOmissis = (dispositivo) => {
    const pos = dispositivo.pai.indexOf(dispositivo);
    if (pos === dispositivo.pai.filhos.length - 1) {
        return undefined;
    }
    const irmaos = dispositivo.pai.filhos.filter((f, index) => index > pos && (f.tipo === dispositivo.tipo || f.tipo === omissis.tipo));
    return irmaos[0];
};
// Diferencia do getDispositivoPosteriorMesmoTipoInclusiveOmissis por identificar dispositivo irmão posterior de omissis
// [FRAGO] Provavelmente o ideal seria alterar o outro método mas não tive confiança nem tempo para verificar as implicações.
const getIrmaoPosteriorIndependenteDeTipo = (dispositivo) => {
    const pos = dispositivo.pai.indexOf(dispositivo);
    if (pos === dispositivo.pai.filhos.length - 1) {
        return undefined;
    }
    // A restrição pelo mesmo pai diferencia incisos de caput (e omissis) de parágrafos (e omissis).
    const irmaos = dispositivo.pai.filhos.filter((f, index) => index > pos && f.pai === dispositivo.pai);
    return irmaos[0];
};
const getDispositivosPosteriores = (dispositivo, isExclusao = false) => {
    if (isArtigo(dispositivo)) {
        const articulacao = getArticulacao(dispositivo);
        const pos = getArticulacao(dispositivo).indexOfArtigo(dispositivo);
        return articulacao.artigos.filter((artigo, index) => index > pos);
    }
    const pos = dispositivo.pai.indexOf(dispositivo);
    return dispositivo.pai.filhos.filter((disp, index) => (isExclusao ? index > pos : index >= pos)).filter(d => dispositivo.tipo === d.tipo);
};
const isArtigoUnico = (dispositivo) => {
    return isArtigo(dispositivo) && isUnicoMesmoTipo(dispositivo);
};
const isParagrafoUnico = (dispositivo) => {
    return isParagrafo(dispositivo) && isUnicoMesmoTipo(dispositivo);
};
const getDispositivoCabecaAlteracao = (dispositivo) => {
    return dispositivo.cabecaAlteracao || isDispositivoCabecaAlteracao(dispositivo) ? dispositivo : getDispositivoCabecaAlteracao(dispositivo.pai);
};
const isDispositivoCabecaAlteracao = (dispositivo) => {
    return !!dispositivo.pai && isArticulacaoAlteracao(dispositivo.pai);
};
const isAntesDoPrimeiroDispositivoOriginal = (dispositivo) => {
    return getDispositivosPosterioresMesmoTipo(dispositivo).filter(d => isOriginal(d) && d.numero === '1').length > 0;
};
const isUltimaAlteracao = (dispositivo) => {
    const atual = getDispositivoCabecaAlteracao(dispositivo);
    const lista = getDispositivoAndFilhosAsLista(atual);
    const ultimoLista = lista[lista.length - 1];
    const dispTeste = isCaput(dispositivo) ? dispositivo.pai : dispositivo;
    if (ultimoLista === dispTeste) {
        if (atual.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO && !isArticulacaoAlteracao(atual.pai)) {
            const proximo = getDispositivoPosteriorNaSequenciaDeLeitura(atual, d => {
                return isArtigo(d) || isAgrupadorNaoArticulacao(d) || !isDispositivoAlteracao(d);
            });
            return !(proximo &&
                isDispositivoAlteracao(proximo) &&
                !isArticulacaoAlteracao(proximo.pai) &&
                proximo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO);
        }
        return true;
    }
    return false;
};
const buscaDispositivoDeArtigoPosterior = (pai, index) => {
    if (pai === undefined || isArtigo(pai)) {
        return undefined;
    }
    for (let i = index + 1; i < pai.filhos.length; i++) {
        const d = pai.filhos[i];
        if (isDispositivoDeArtigo(d)) {
            return d;
        }
    }
    return buscaDispositivoDeArtigoPosterior(pai.pai, pai.pai.indexOf(pai));
};
const isUltimaEnumeracao = (dispositivo) => {
    if (getDispositivoPosterior(dispositivo)) {
        return false;
    }
    if (isParagrafo(dispositivo) || !isDispositivoDeArtigo(dispositivo)) {
        return false;
    }
    const proximoDispositivoDeArtigo = buscaDispositivoDeArtigoPosterior(dispositivo.pai, dispositivo.pai.indexOf(dispositivo));
    if (!proximoDispositivoDeArtigo || isParagrafo(proximoDispositivoDeArtigo)) {
        return true;
    }
    return false;
};
// Verifica se todos os filhos dos tipos (inciso, alínea ou item) estão suprimidos.
const isTodosFilhosTipoEnumeracaoSuprimidos = (dispositivo) => {
    if (isAgrupador(dispositivo)) {
        // Não deveria ser chamado para agrupadores
        return false;
    }
    if (isArtigo(dispositivo)) {
        // Evita listar parágrafos
        dispositivo = dispositivo.caput;
    }
    return !getSomenteFilhosDispositivoAsLista([], dispositivo.filhos).some(d => !isSuprimido(d));
};
const isArticulacaoAlteracao = (articulacao) => {
    return isArticulacao(articulacao) && articulacao.pai !== undefined;
};
const isDispositivoAlteracao = (dispositivo) => {
    const r = !!dispositivo.isDispositivoAlteracao;
    if (r) {
        return true;
    }
    try {
        return getArticulacao(dispositivo).pai !== undefined;
    }
    catch (error) {
        return false;
    }
};
const isOriginal = (dispositivo) => {
    return dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ORIGINAL;
};
const isAdicionado = (dispositivo) => {
    return dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO || dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_NOVO;
};
const isModificado = (dispositivo) => {
    return dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO;
};
const isSuprimido = (dispositivo) => {
    return dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO;
};
const isModificadoOuSuprimido = (dispositivo) => {
    return isModificado(dispositivo) || isSuprimido(dispositivo);
};
const getSomenteFilhosDispositivoAsLista = (dispositivos, filhos) => {
    filhos === null || filhos === void 0 ? void 0 : filhos.forEach(f => {
        dispositivos.push(f);
        if (hasFilhos(f)) {
            getSomenteFilhosDispositivoAsLista(dispositivos, f.filhos);
        }
    });
    return dispositivos;
};
const getDispositivoAndFilhosAsLista = (dispositivo) => {
    return buildListaDispositivos(dispositivo, []);
};
const buildListaDispositivos = (dispositivo, dispositivos) => {
    dispositivos.push(dispositivo);
    const filhos = dispositivo.hasAlteracao() ? dispositivo.alteracoes.filhos : dispositivo.filhos;
    filhos.length ? filhos.forEach(d => buildListaDispositivos(d, dispositivos)) : undefined;
    return dispositivos;
};
const percorreHierarquiaDispositivos = (d, visit) => {
    if (!d)
        return;
    visit(d);
    if (d.tipo === TipoDispositivo.artigo.tipo) {
        const artigo = d;
        if (artigo.caput) {
            percorreHierarquiaDispositivos(artigo.caput, visit);
            if (d.alteracoes) {
                percorreHierarquiaDispositivos(d.alteracoes, visit);
            }
            d.filhos
                .filter(f => isParagrafo(f) || (isOmissis(f) && !isCaput(f.pai)))
                .forEach(f => {
                percorreHierarquiaDispositivos(f, visit);
            });
        }
    }
    else {
        if (d.alteracoes) {
            percorreHierarquiaDispositivos(d.alteracoes, visit);
        }
        d.filhos.forEach(f => {
            percorreHierarquiaDispositivos(f, visit);
        });
    }
};
const buscaNaHierarquiaDispositivos = (d, visit) => {
    if (!d)
        return undefined;
    let ret = visit(d);
    if (ret)
        return ret;
    if (d.tipo === TipoDispositivo.artigo.tipo) {
        const artigo = d;
        if (artigo.caput) {
            ret = buscaNaHierarquiaDispositivos(artigo.caput, visit);
            if (ret)
                return ret;
            if (d.alteracoes) {
                ret = buscaNaHierarquiaDispositivos(d.alteracoes, visit);
                if (ret)
                    return ret;
            }
            for (const f of d.filhos.filter(f => isParagrafo(f) || (isOmissis(f) && !isCaput(f.pai)))) {
                ret = buscaNaHierarquiaDispositivos(f, visit);
                if (ret)
                    return ret;
            }
        }
    }
    else {
        if (d.alteracoes) {
            ret = buscaNaHierarquiaDispositivos(d.alteracoes, visit);
            if (ret)
                return ret;
        }
        for (const f of d.filhos) {
            ret = buscaNaHierarquiaDispositivos(f, visit);
            if (ret)
                return ret;
        }
    }
};
const isDispositivoRaiz = (d) => {
    return d && !d.pai && d.tipo === TipoDispositivo.articulacao.tipo;
};
const buscaDispositivoById = (articulacao, id) => {
    var _a;
    if (id === 'ementa') {
        return (_a = articulacao.projetoNorma) === null || _a === void 0 ? void 0 : _a.ementa;
    }
    const idArtigo = extraiIdArtigo(id);
    let raiz = articulacao;
    if (idArtigo) {
        const artigo = articulacao.artigos.find(a => idArtigo === a.id);
        if (artigo) {
            if (id === idArtigo || id === idArtigo + '_cpt') {
                return artigo;
            }
            else {
                raiz = artigo;
            }
        }
    }
    return buscaNaHierarquiaDispositivos(raiz, d => {
        return id === d.id ? d : undefined;
    });
};
const extraiIdArtigo = (id) => {
    const l = /^art\d+(-\d+)*/.exec(id);
    return (l === null || l === void 0 ? void 0 : l.length) ? l[0] : undefined;
};
const isAscendente = (d, dAscendente) => {
    if (!d || !dAscendente) {
        return false;
    }
    let pai = d.pai;
    while (pai) {
        if (pai === dAscendente) {
            return true;
        }
        pai = pai.pai;
    }
    return false;
};
const isDescendenteDeSuprimido = (d) => {
    if (!d) {
        return false;
    }
    let pai = d.pai;
    while (pai) {
        if (pai.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
            return true;
        }
        pai = pai.pai;
    }
    return false;
};
// export const validaOrdemDispositivo = (anterior: Dispositivo, atual: Dispositivo): boolean => {
//   if (anterior.numero!.indexOf('-') === -1 && atual.numero!.indexOf('-') === -1) {
//     return +anterior.numero! + 1 === +atual.numero!;
//   }
//   const partesA = anterior.numero!.split('-');
//   const partesB = atual.numero!.split('-');
//   const [numA, ...remainingA] = partesA!;
//   const [numB, ...remainingB] = partesB!;
//   if (+numA + 1 === +numB) {
//     return true;
//   }
//   for (let i = 0; i < 3; i++) {
//     const rA = i >= remainingA?.length ? 0 : remainingA[i];
//     for (let j = 0; i < 3; i++) {
//       const rB = j >= remainingB?.length ? 0 : remainingB[j];
//       if (+rA === +rB) {
//         continue;
//       }
//       if (+rA + 1 === +rB) {
//         return true;
//       }
//       return false;
//     }
//   }
//   return true;
// };
const validaOrdemDispositivo = (anterior, atual) => {
    if (anterior.numero.indexOf('-') === -1 && atual.numero.indexOf('-') === -1) {
        return +anterior.numero + 1 === +atual.numero;
    }
    const partesA = anterior.numero.split('-');
    const partesB = atual.numero.split('-');
    if (partesB.length > partesA.length) {
        // dispositivo atual possui mais um nível de sufixo de encaixe
        const numB = partesB.pop();
        return partesA.join('-') === partesB.join('-') && numB === '1';
    }
    else {
        if (partesA.length > partesB.length) {
            // dispositivo atual possui menos um nível de sufixo de encaixe
            partesA.pop();
        }
        const numA = partesA.pop();
        const numB = partesB.pop();
        return partesA.join('-') === partesB.join('-') && +numA + 1 === +numB;
    }
};
const buscaProximoOmissis = (dispositivo) => {
    if (!dispositivo || !dispositivo.pai || isAgrupador(dispositivo.pai)) {
        return undefined;
    }
    const posterior = getDispositivoPosterior(dispositivo);
    if (posterior && isOmissis(posterior)) {
        return posterior;
    }
    if (isCaput(dispositivo)) {
        const p = dispositivo.pai.filhos.filter(f => isParagrafo(f) || isOmissis(f));
        if (p.length > 0 && isOmissis(p[0])) {
            return p[0];
        }
        return undefined;
    }
    return dispositivo.pai ? buscaProximoOmissis(dispositivo.pai) : undefined;
};
const isDispositivoNovoNaNormaAlterada = (dispositivo) => {
    var _a;
    const value = dispositivo.situacao.existeNaNormaAlterada;
    if (!isDispositivoAlteracao(dispositivo) || value === undefined) {
        return;
    }
    const situacoes = [DescricaoSituacao.DISPOSITIVO_ADICIONADO + ''];
    return situacoes.includes((_a = dispositivo.situacao) === null || _a === void 0 ? void 0 : _a.descricaoSituacao) && !value;
};
const podeRenumerarFilhosAutomaticamente = (dispositivo) => {
    var _a;
    const d = dispositivo.tipo === 'Caput' ? dispositivo.pai : dispositivo;
    return !isDispositivoAlteracao(d) || ((_a = isDispositivoNovoNaNormaAlterada(d)) !== null && _a !== void 0 ? _a : false);
};
const podeEditarNotaAlteracao = (dispositivo) => {
    const isUltAlteracao = dispositivo.tipo !== 'Articulacao' && isDispositivoAlteracao(dispositivo) && isUltimaAlteracao(dispositivo);
    if (!isUltAlteracao) {
        return false;
    }
    else {
        const cabecaAlteracao = getDispositivoCabecaAlteracao(dispositivo);
        return cabecaAlteracao.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO;
    }
};
const isDispositivosSequenciais = (dispositivo1, dispositivo2) => {
    const pos1 = dispositivo1.pai.indexOf(dispositivo1);
    const pos2 = dispositivo2.pai.indexOf(dispositivo2);
    return pos1 + 1 === pos2;
};
const isDispositivosSequenciaisMesmoPai = (dispositivo1, dispositivo2) => {
    return dispositivo1.pai === dispositivo2.pai && isDispositivosSequenciais(dispositivo1, dispositivo2);
};
// Retorna o primeiro agrupador de artigo (não articulação) que segue um agrupador de artigo na sequência de leitura
const getProximoAgrupadorAposAgrupador = (d, ignorarFilhos = false) => {
    if (!isAgrupador(d)) {
        return undefined;
    }
    if (!ignorarFilhos) {
        const filhoAgrupador = d.filhos.find(f => isAgrupadorNaoArticulacao(f));
        if (filhoAgrupador) {
            return filhoAgrupador;
        }
    }
    if (d.pai) {
        const proximoIrmao = getDispositivoPosteriorMesmoTipo(d);
        if (proximoIrmao) {
            return proximoIrmao;
        }
        return getProximoAgrupadorAposAgrupador(d.pai, true);
    }
    return undefined;
};
// Retorna o primeiro agrupador de artigo (não articulação) que segue um artigo na sequência contrária de leitura
const getProximoAgrupadorAposArtigo = (art) => {
    return getProximoAgrupadorAposAgrupador(art.pai);
};
const getTiposAgrupadorArtigoOrdenados = () => ['Parte', 'Livro', 'Titulo', 'Capitulo', 'Secao', 'Subsecao'];
const getTiposAgrupadorArtigoPermitidosNaArticulacao = () => ['Parte', 'Livro', 'Titulo', 'Capitulo'];
const getTiposAgrupadoresQuePodemSerInseridosDepois = (dispositivo) => {
    var _a, _b;
    if (!isAgrupador(dispositivo) && !isArtigo(dispositivo) && !isEmenta(dispositivo)) {
        return [];
    }
    if (isDispositivoAlteracao(dispositivo)) {
        return getTiposAgrupadorArtigoOrdenados();
    }
    const primeiroAgrupador = getPrimeiroAgrupadorNaArticulacao(dispositivo);
    if (!primeiroAgrupador) {
        return getTiposAgrupadorArtigoPermitidosNaArticulacao();
    }
    const agrupadorDepois = getPrimeiroAgrupadorDepois(dispositivo);
    if (!isAgrupador(dispositivo) && agrupadorDepois === primeiroAgrupador) {
        return [primeiroAgrupador.tipo, getTipoAgrupadorNivelAcima(primeiroAgrupador.tipo)].filter(Boolean);
    }
    const agrupadorRef = isAgrupador(dispositivo) ? dispositivo : dispositivo.pai;
    if (!agrupadorDepois) {
        return getRangeTiposAgrupador(primeiroAgrupador.tipo, (_a = getTipoAgrupadorNivelAbaixo(agrupadorRef.tipo)) !== null && _a !== void 0 ? _a : agrupadorRef.tipo);
    }
    const tipos = getRangeTiposAgrupador(getTipoAgrupadorNivelAcima(agrupadorDepois.tipo), (_b = getTipoAgrupadorNivelAbaixo(agrupadorRef.tipo)) !== null && _b !== void 0 ? _b : agrupadorRef.tipo);
    const indexPrimeiroAgrupador = getIndexTipoAgrupador(primeiroAgrupador.tipo);
    return tipos.filter(t => t && getIndexTipoAgrupador(t) >= indexPrimeiroAgrupador);
};
const getTiposAgrupadoresQuePodemSerInseridosAntes = (dispositivo) => {
    const result = [];
    if (isEmenta(dispositivo)) {
        return [];
    }
    if (!isAgrupador(dispositivo)) {
        return getTiposAgrupadoresQuePodemSerInseridosDepois(dispositivo);
    }
    if (isDispositivoAlteracao(dispositivo)) {
        return getTiposAgrupadorArtigoOrdenados();
    }
    result.push(dispositivo.tipo);
    const primeiroAgrupador = getPrimeiroAgrupadorNaArticulacao(dispositivo);
    const tipoAgrupadorNivelAcima = getTipoAgrupadorNivelAcima(dispositivo.tipo);
    if (!primeiroAgrupador || dispositivo === primeiroAgrupador || getIndexTipoAgrupador(tipoAgrupadorNivelAcima !== null && tipoAgrupadorNivelAcima !== void 0 ? tipoAgrupadorNivelAcima : '') >= getIndexTipoAgrupador(primeiroAgrupador.tipo)) {
        result.push(tipoAgrupadorNivelAcima);
    }
    const getAgrupadorAntes = (d) => {
        const dispositivos = getDispositivoAndFilhosAsLista(getArticulacao(d)).filter(isAgrupador);
        return dispositivos[dispositivos.indexOf(d) - 1];
    };
    const agrupadorAntes = getAgrupadorAntes(dispositivo);
    if (agrupadorAntes) {
        result.push(...getTiposAgrupadoresQuePodemSerInseridosDepois(agrupadorAntes));
    }
    return [...new Set(result)];
};
const getRangeTiposAgrupador = (tipoInicial = '', tipoFinal = '') => {
    return getTiposAgrupadorArtigoOrdenados().slice(getIndexTipoAgrupador(tipoInicial), getIndexTipoAgrupador(tipoFinal) + 1);
};
const getIndexTipoAgrupador = (tipo) => {
    return getTiposAgrupadorArtigoOrdenados().indexOf(tipo);
};
const getTipoAgrupadorNivelAcima = (tipoAgrupador) => {
    const tiposAgrupadorArtigoOrdenados = getTiposAgrupadorArtigoOrdenados();
    return tiposAgrupadorArtigoOrdenados[tiposAgrupadorArtigoOrdenados.indexOf(tipoAgrupador) - 1];
};
const getTipoAgrupadorNivelAbaixo = (tipoAgrupador) => {
    const tiposAgrupadorArtigoOrdenados = getTiposAgrupadorArtigoOrdenados();
    const index = tiposAgrupadorArtigoOrdenados.indexOf(tipoAgrupador);
    return index === -1 ? undefined : tiposAgrupadorArtigoOrdenados[index + 1];
};
const getPrimeiroAgrupadorDepois = (d) => {
    const dispositivos = getDispositivoAndFilhosAsLista(getArticulacao(d));
    const indexRef = dispositivos.indexOf(d);
    return dispositivos.filter((d, index) => index > indexRef && isAgrupador(d) && !isArticulacao(d))[0];
};
const getAgrupadorAntes = (d) => {
    const dispositivos = getDispositivoAndFilhosAsLista(getArticulacao(d));
    const indexRef = dispositivos.indexOf(d);
    return dispositivos.filter((d, index) => index < indexRef && isAgrupador(d) && !isArticulacao(d)).reverse()[0];
};
const getPrimeiroAgrupadorNaArticulacao = (d) => {
    return getArticulacao(d).filhos.filter(isAgrupador)[0];
};
const getParagrafosEOmissis = (art) => {
    // Os incisos e omissis de incisos de caput são filhos do caput
    return art.filhos.filter(d => d.pai === art);
};
const hasEmenta = (referencia) => {
    var _a, _b;
    return !!((_b = (_a = getArticulacao(referencia).projetoNorma) === null || _a === void 0 ? void 0 : _a.ementa) === null || _b === void 0 ? void 0 : _b.texto);
};
const isEmendaArtigoOndeCouber = (referencia) => {
    return getDispositivoAndFilhosAsLista(getArticulacao(referencia)).some(d => d.situacao.tipoEmenda === ClassificacaoDocumento.EMENDA_ARTIGO_ONDE_COUBER);
};
const findDispositivoByUuid2 = (dispositivo, uuid2) => {
    if (!uuid2) {
        throw new Error('uuid não foi informado');
    }
    return getDispositivoByUuid2(dispositivo, uuid2);
};
function getDispositivoByUuid2(dispositivo, uuid2) {
    if (dispositivo.uuid2 === uuid2) {
        return dispositivo;
    }
    else if (dispositivo.filhos !== null) {
        let result = null;
        const filhos = dispositivo.hasAlteracao() ? dispositivo.alteracoes.filhos : dispositivo.filhos;
        for (let i = 0; result === null && i < filhos.length; i++) {
            result = getDispositivoByUuid2(filhos[i], uuid2);
        }
        return result;
    }
    return null;
}

function Diff() {}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;

    if (options.maxEditLength) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }

    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath = void 0;

        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced, or until the edit length exceeds options.maxEditLength (if given),
    // in which case it will return undefined.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split('');
  },
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var lastComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}

var characterDiff = new Diff();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}

function generateOptions(options, defaults) {
  if (typeof options === 'function') {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      /* istanbul ignore else */
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }

  return defaults;
}

//
// Ranges and exceptions:
// Latin-1 Supplement, 0080–00FF
//  - U+00D7  × Multiplication sign
//  - U+00F7  ÷ Division sign
// Latin Extended-A, 0100–017F
// Latin Extended-B, 0180–024F
// IPA Extensions, 0250–02AF
// Spacing Modifier Letters, 02B0–02FF
//  - U+02C7  ˇ &#711;  Caron
//  - U+02D8  ˘ &#728;  Breve
//  - U+02D9  ˙ &#729;  Dot Above
//  - U+02DA  ˚ &#730;  Ring Above
//  - U+02DB  ˛ &#731;  Ogonek
//  - U+02DC  ˜ &#732;  Small Tilde
//  - U+02DD  ˝ &#733;  Double Acute Accent
// Latin Extended Additional, 1E00–1EFF

var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();

wordDiff.equals = function (left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }

  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};

wordDiff.tokenize = function (value) {
  // All whitespace symbols except newline group into one token, each newline - in separate token
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

  for (var i = 0; i < tokens.length - 1; i++) {
    // If we have an empty string in the next field and we have only word chars before and after, merge
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }

  return tokens;
};

function diffWords(oldStr, newStr, options) {
  options = generateOptions(options, {
    ignoreWhitespace: true
  });
  return wordDiff.diff(oldStr, newStr, options);
}

var lineDiff = new Diff();

lineDiff.tokenize = function (value) {
  var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  } // Merge the content and line separators into single tokens


  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];

    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }

      retLines.push(line);
    }
  }

  return retLines;
};

var sentenceDiff = new Diff();

sentenceDiff.tokenize = function (value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};

var cssDiff = new Diff();

cssDiff.tokenize = function (value) {
  return value.split(/([{}:;,]|\s+)/);
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;

jsonDiff.castInput = function (value) {
  var _this$options = this.options,
      undefinedReplacement = _this$options.undefinedReplacement,
      _this$options$stringi = _this$options.stringifyReplacer,
      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
    return typeof v === 'undefined' ? undefinedReplacement : v;
  } : _this$options$stringi;
  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
};

jsonDiff.equals = function (left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
};
// object that is already on the "stack" of items being processed. Accepts an optional replacer

function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];

  if (replacer) {
    obj = replacer(key, obj);
  }

  var i;

  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }

  var canonicalizedObj;

  if ('[object Array]' === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);

    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }

    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }

  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }

  if (_typeof(obj) === 'object' && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);

    var sortedKeys = [],
        _key;

    for (_key in obj) {
      /* istanbul ignore else */
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }

    sortedKeys.sort();

    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }

    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }

  return canonicalizedObj;
}

var arrayDiff = new Diff();

arrayDiff.tokenize = function (value) {
  return value.slice();
};

arrayDiff.join = arrayDiff.removeEmpty = function (value) {
  return value;
};

function containsTags(text) {
    return /<.+>/g.test(text === null || text === void 0 ? void 0 : text.trim());
}
function endsWithPunctuation(texto) {
    return /[.,:]\s*$/.test(texto);
}
function isValidHTML(html) {
    const doc = document.createElement('div');
    doc.innerHTML = html;
    return doc.innerHTML === html;
}
function getTextoSemHtml(html) {
    return removeEspacosDuplicados(html.replace(/(<([^>]+)>)/gi, '').trim());
}
function endsWithWord(texto, indicadores) {
    return indicadores.map(word => new RegExp(addSpaceRegex(escapeRegex(word)) + '\\s*$').test(texto)).filter(r => r)[0] === true;
}
function converteIndicadorParaTexto(indicadores) {
    switch (indicadores[0].trim()) {
        case '.':
            return 'ponto';
        case ':':
            return 'dois pontos';
        case ';':
            return 'ponto e vírgula';
        case ',':
            return 'vírgula';
        default:
            return indicadores[0].trim();
    }
}
function escapeRegex(str) {
    return str.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
}
function addSpaceRegex(str) {
    return str.replace(/\s+/g, '\\s+');
}
function primeiraLetraMaiuscula(str) {
    if (!str) {
        return '';
    }
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}
function join(list) {
    let str = '';
    list.forEach(s => {
        str += s;
    });
    return str;
}
function removeEspacosDuplicados(str) {
    return str.replace(/\s{2,}/g, ' ');
}
function removeAllHtmlTags(texto) {
    return texto.replace(/(<([^>]+)>)/gi, '');
}
const removeAllHtmlTagsExcept = (texto, tags) => {
    // const regex = new RegExp(`(<(?!${tags.join('|')})[^>]+>)`, 'gi');
    const regex = new RegExp(`<(?!(?:/?(${tags.join('|')})\\b))[^>]*>`, 'gi');
    return texto.replace(regex, '');
};
class StringBuilder {
    constructor(str) {
        this.strs = new Array();
        if (str) {
            this.append(str);
        }
    }
    append(str) {
        if (str) {
            this.strs.push(str);
        }
    }
    toString() {
        return join(this.strs);
    }
}
const REGEX_ACCENTS = /[\u0300-\u036f]/g;
const removeTagEConteudo = (texto, tag) => {
    return texto.replace(new RegExp(`<${tag}[^<]*(?:(?!</${tag}>)<[^<]*)*</${tag}>`, 'gi'), '');
};
const removeTagStyle = (texto) => removeTagEConteudo(texto, 'style');
const removeTagScript = (texto) => removeTagEConteudo(texto, 'script');
const removeTagHead = (texto) => removeTagEConteudo(texto, 'head');
const getIniciais = (texto = '') => {
    var _a;
    return (((_a = texto
        .match(/\b[A-Z][a-z]*\b/g)) === null || _a === void 0 ? void 0 : _a.map(word => word.charAt(0)).filter((_, i, arr) => i === 0 || i === arr.length - 1).join('')) || '');
};
const textoDiffAsHtml = (texto1, texto2, typeDiff) => {
    const fn = typeDiff === 'diffChars' ? diffChars : diffWords;
    const buildPartAdded = (str) => `<ins>${str}</ins>`; //`<span class="texto-inserido">${str}</span>`;
    const buildPartRemoved = (str) => `<del>${str}</del>`; //`<span classs="texto-removido">${str}</span>`;
    const diff = fn(texto1, texto2);
    return diff.map(part => (part.added ? buildPartAdded(part.value) : part.removed ? buildPartRemoved(part.value) : part.value)).join('');
};
const substituiEspacosEntreTagsPorNbsp = (texto, tags) => {
    if (tags) {
        const regex = new RegExp(`(?<=<(${tags.join('|')})>) +(?=</\\1>)`, 'gi');
        return texto.replace(regex, texto => texto.replace(/ /g, '&nbsp;'));
    }
    else {
        return texto.replace(/ /g, '&nbsp;');
    }
};
const substituiMultiplosEspacosPorNbsp = (texto) => {
    return texto.replace(/ +/g, texto => texto.replace(/ /g, '&nbsp;'));
};

// Tipo string para salvar o nome em vez do índice
var TipoMensagem;
(function (TipoMensagem) {
    TipoMensagem["INFO"] = "INFO";
    TipoMensagem["WARNING"] = "WARNING";
    TipoMensagem["ERROR"] = "ERROR";
})(TipoMensagem || (TipoMensagem = {}));
var AutoFix;
(function (AutoFix) {
    AutoFix["INFORMAR_NORMA"] = "\u00C9 necess\u00E1rio informar a norma a ser alterada";
    AutoFix["OMISSIS_ANTES"] = "\u00C9 necess\u00E1rio um omissis antes deste dispositivo";
    AutoFix["OMISSIS_SEQUENCIAIS"] = "N\u00E3o pode haver mais de um omissis sequencialmente";
    AutoFix["RENUMERAR_DISPOSITIVO"] = "Numere o dispositivo";
})(AutoFix || (AutoFix = {}));

const hasIndicativoDesdobramento = (dispositivo) => {
    var _a;
    const d = isArtigo(dispositivo) ? dispositivo.caput : dispositivo;
    return endsWithWord(d.texto, (_a = d.INDICADOR_DESDOBRAMENTO) !== null && _a !== void 0 ? _a : []);
};
const hasIndicativoFinalSequencia = (dispositivo) => {
    var _a;
    const d = isArtigo(dispositivo) ? dispositivo.caput : dispositivo;
    return endsWithWord(d.texto, (_a = d.INDICADOR_FIM_SEQUENCIA) !== null && _a !== void 0 ? _a : []);
};
const hasIndicativoContinuacaoSequencia = (dispositivo) => {
    var _a;
    const d = isArtigo(dispositivo) ? dispositivo.caput : dispositivo;
    return endsWithWord(d.texto, (_a = d.INDICADOR_SEQUENCIA) !== null && _a !== void 0 ? _a : []);
};
const TEXTO_DEFAULT_DISPOSITIVO_ALTERACAO = TEXTO_OMISSIS; // + '.” (NR)';
const hasIndicativoInicioAlteracao = (texto) => {
    return (new RegExp(addSpaceRegex(escapeRegex('o seguinte acréscimo:')) + '\\s*$').test(texto) ||
        new RegExp(addSpaceRegex(escapeRegex('os seguintes acréscimos:')) + '\\s*$').test(texto) ||
        new RegExp(addSpaceRegex(escapeRegex('passa a vigorar com a seguinte alteração:')) + '\\s*$').test(texto) ||
        new RegExp(addSpaceRegex(escapeRegex('passa a vigorar com as seguintes alterações:')) + '\\s*$').test(texto));
};
const normalizaSeForOmissis = (texto) => {
    if (/^[.]*(?:\s*)["”“]?(\s*)?\(NR\)\s*$/.test(texto)) {
        return TEXTO_DEFAULT_DISPOSITIVO_ALTERACAO;
    }
    if (/["”]?(\s*)?\(NR\)?\s*$/.test(texto)) {
        return texto.replace(/["“](?!.*["”])/, '”');
    }
    if (texto === TEXTO_OMISSIS || texto === TEXTO_DEFAULT_DISPOSITIVO_ALTERACAO || !new RegExp('^[.]+$').test(texto)) {
        return texto;
    }
    return TEXTO_OMISSIS;
};
const hasIndicativoFimAlteracao = (texto) => {
    return /\.["”](?:\s*\(NR\))\s*$/.test(texto);
};

const hasCitacaoAoFinalFrase = (texto) => {
    return texto !== undefined && /.*:[\s]{1,2}["”“].*[.]["”“]$/.test(texto);
};
const validaTextoAgrupador = (dispositivo) => {
    var _a, _b, _c;
    const mensagens = [];
    if (!isArticulacao(dispositivo) && (!dispositivo.texto || dispositivo.texto.trim().length === 0)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `Não foi informado um texto para ${dispositivo.artigoDefinido} ${(_a = dispositivo.descricao) === null || _a === void 0 ? void 0 : _a.toLowerCase()}.`);
    }
    if (!isArticulacao(dispositivo) && dispositivo.texto && endsWithPunctuation(dispositivo.texto)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `Não pode haver sinal de pontuação ao final do texto d${dispositivo.artigoDefinido} ${(_b = dispositivo.descricao) === null || _b === void 0 ? void 0 : _b.toLowerCase()}.`);
    }
    if (!isArticulacao(dispositivo) && containsTags(dispositivo.texto)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `Texto d${dispositivo.artigoDefinido} ${(_c = dispositivo.descricao) === null || _c === void 0 ? void 0 : _c.toLowerCase()} não pode possuir formatação.`);
    }
    return mensagens;
};
const validaTextoDispositivo = (dispositivo) => {
    var _a, _b;
    const mensagens = [];
    //
    // validações comuns a dispositivos de texto
    //
    if ((!isArticulacao(dispositivo) && !dispositivo.texto) || dispositivo.texto.trim().length === 0) {
        addMensagem(mensagens, TipoMensagem.ERROR, `Não foi informado um texto para ${dispositivo.artigoDefinido + ' ' + ((_a = dispositivo.descricao) === null || _a === void 0 ? void 0 : _a.toLowerCase())}.`);
    }
    if (!isArticulacao(dispositivo) && dispositivo.texto && !isValidHTML(dispositivo.texto)) {
        addMensagem(mensagens, TipoMensagem.ERROR, 'O conteúdo do dispositivo não é um HTML válido.');
    }
    if (!isArticulacao(dispositivo) && dispositivo.texto && dispositivo.texto.trim().length > 500) {
        addMensagem(mensagens, TipoMensagem.WARNING, `Pelo princípio da concisão, o texto dos dispositivos não deve ser extenso, devendo ser utilizadas frases curtas e concisas.`);
    }
    // Verifica se o texto tem r$ (com letra minuscula)
    if (dispositivo.texto && dispositivo.texto.indexOf('r$') !== -1) {
        addMensagem(mensagens, TipoMensagem.WARNING, `O texto do dispositivo possui r$ (real brasileiro) com letra minúscula. Deveria ser R$ com letra maiúscula.`);
    }
    //
    // validações comuns a dispositivos de artigo
    //
    if (isDispositivoDeArtigo(dispositivo) &&
        !isParagrafo(dispositivo) &&
        dispositivo.texto &&
        /^[A-ZÀ-Ú]/.test(getTextoSemHtml(dispositivo.texto)) &&
        dispositivo.texto.indexOf('R$') !== 0) {
        addMensagem(mensagens, TipoMensagem.WARNING, `${dispositivo.descricao} deveria iniciar com letra minúscula, a não ser que se trate de uma situação especial, como nome próprio.`);
    }
    if (isDispositivoDeArtigo(dispositivo) &&
        !isParagrafo(dispositivo) &&
        !isOmissis(dispositivo) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !/^[.]+$/.test(dispositivo.texto) &&
        (!hasFilhos(dispositivo) || isTodosFilhosTipoEnumeracaoSuprimidos(dispositivo)) &&
        !isUltimaEnumeracao(dispositivo) &&
        dispositivo.INDICADOR_SEQUENCIA !== undefined &&
        !hasIndicativoContinuacaoSequencia(dispositivo)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `${dispositivo.descricao} deveria terminar com ponto e vírgula.`);
    }
    //
    // validações comuns a Artigo e Parágrafo
    //
    if ((isArtigo(dispositivo) || isParagrafo(dispositivo)) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !/^[.]+$/.test(dispositivo.texto) &&
        !/^[...]{3,}/.test(dispositivo.texto) &&
        !/^[A-ZÀ-Ú]/.test(getTextoSemHtml(dispositivo.texto))) {
        addMensagem(mensagens, TipoMensagem.ERROR, `${dispositivo.descricao} deveria iniciar com letra maiúscula.`);
    }
    //
    // validações de dispositivos que não sejam de alteração
    //
    if (!isDispositivoAlteracao(dispositivo) &&
        !isAgrupador(dispositivo) &&
        !isOmissis(dispositivo) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !isTodosFilhosTipoEnumeracaoSuprimidos(dispositivo) &&
        !/^[.]+$/.test(dispositivo.texto) &&
        ((!isArtigo(dispositivo) && hasFilhos(dispositivo)) || (isArtigo(dispositivo) && hasFilhos(dispositivo.caput))) &&
        !hasIndicativoDesdobramento(dispositivo)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `${dispositivo.descricao} deveria terminar com ${converteIndicadorParaTexto(dispositivo.INDICADOR_DESDOBRAMENTO)}.`);
    }
    // dispositivos de artigo
    if (!isDispositivoAlteracao(dispositivo) &&
        isDispositivoDeArtigo(dispositivo) &&
        !isParagrafo(dispositivo) &&
        dispositivo.texto &&
        !hasFilhoGenerico(dispositivo.pai) &&
        (!hasFilhos(dispositivo) || isTodosFilhosTipoEnumeracaoSuprimidos(dispositivo)) &&
        isUltimaEnumeracao(dispositivo) &&
        !hasIndicativoFinalSequencia(dispositivo)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `Último dispositivo de uma sequência deveria terminar com ${converteIndicadorParaTexto(dispositivo.INDICADOR_FIM_SEQUENCIA)}.`);
    }
    // Artigo e Parágrafo
    if (!isDispositivoAlteracao(dispositivo) &&
        (isArtigo(dispositivo) || isParagrafo(dispositivo)) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !/^[.]+$/.test(dispositivo.texto) &&
        (!hasFilhos(dispositivo) || isTodosFilhosTipoEnumeracaoSuprimidos(dispositivo)) &&
        !dispositivo.alteracoes &&
        !hasIndicativoContinuacaoSequencia(dispositivo) &&
        !hasCitacaoAoFinalFrase(dispositivo.texto)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `${dispositivo.descricao} deveria terminar com ${converteIndicadorParaTexto(dispositivo.INDICADOR_SEQUENCIA)}.`);
    }
    // Artigo
    if (!isDispositivoAlteracao(dispositivo) &&
        isArtigo(dispositivo) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !isTodosFilhosTipoEnumeracaoSuprimidos(dispositivo) &&
        !/^[.]+$/.test(dispositivo.texto) &&
        dispositivo.hasAlteracao() &&
        !hasIndicativoDesdobramento(dispositivo) &&
        !hasIndicativoInicioAlteracao(dispositivo.texto)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `${dispositivo.descricao} deveria terminar com ${converteIndicadorParaTexto(dispositivo.INDICADOR_DESDOBRAMENTO)}.`);
    }
    if (!isDispositivoAlteracao(dispositivo) &&
        isArtigo(dispositivo) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !/^[.]+$/.test(dispositivo.texto) &&
        !dispositivo.alteracoes &&
        (!hasFilhos(dispositivo) || !hasFilhos(dispositivo.caput)) &&
        !isDispositivoCabecaAlteracao(dispositivo) &&
        hasIndicativoDesdobramento(dispositivo)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `${dispositivo.descricao} deveria terminar com ${converteIndicadorParaTexto(dispositivo.INDICADOR_SEQUENCIA)}.`);
    }
    if (isArtigo(dispositivo) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !/^[.]+$/.test(dispositivo.texto) &&
        (!hasFilhos(dispositivo) || !hasFilhos(dispositivo.caput)) &&
        dispositivo.alteracoes &&
        !dispositivo.hasAlteracao() &&
        hasIndicativoDesdobramento(dispositivo)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `${dispositivo.descricao} deveria informar alterações propostas.`);
    }
    if (!isDispositivoAlteracao(dispositivo) && isArtigo(dispositivo) && dispositivo.hasAlteracao() && !((_b = dispositivo.alteracoes) === null || _b === void 0 ? void 0 : _b.base)) {
        addMensagem(mensagens, TipoMensagem.ERROR, AutoFix.INFORMAR_NORMA, true);
    }
    //
    // Validações de dispositivos de alteração
    //
    if (isDispositivoAlteracao(dispositivo) &&
        !isAgrupador(dispositivo) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !isTodosFilhosTipoEnumeracaoSuprimidos(dispositivo) &&
        !/^[.]+$/.test(dispositivo.texto) &&
        !isArtigo(dispositivo) &&
        hasFilhos(dispositivo) &&
        !hasIndicativoDesdobramento(dispositivo)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `${dispositivo.descricao} deveria terminar com ${converteIndicadorParaTexto(dispositivo.INDICADOR_DESDOBRAMENTO)}.`);
    }
    if (isDispositivoAlteracao(dispositivo) &&
        !isAgrupador(dispositivo) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !isTodosFilhosTipoEnumeracaoSuprimidos(dispositivo) &&
        !/^[.]+$/.test(dispositivo.texto) &&
        isArtigo(dispositivo) &&
        hasFilhos(dispositivo.caput) &&
        !hasIndicativoDesdobramento(dispositivo)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `${dispositivo.descricao} deveria terminar com ${converteIndicadorParaTexto(dispositivo.INDICADOR_DESDOBRAMENTO)}.`);
    }
    if (isDispositivoAlteracao(dispositivo) &&
        !isAgrupador(dispositivo) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !isTodosFilhosTipoEnumeracaoSuprimidos(dispositivo) &&
        !/^[.]+$/.test(dispositivo.texto) &&
        hasIndicativoDesdobramento(dispositivo) &&
        ((isArtigo(dispositivo) && !hasFilhos(dispositivo.caput)) || !hasFilhos(dispositivo))) {
        addMensagem(mensagens, TipoMensagem.ERROR, `${dispositivo.descricao} não deveria terminar com ${converteIndicadorParaTexto(dispositivo.INDICADOR_DESDOBRAMENTO)}.`);
    }
    if (isDispositivoAlteracao(dispositivo) &&
        isParagrafo(dispositivo) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !/^[.]+$/.test(dispositivo.texto) &&
        !hasFilhos(dispositivo) &&
        !isUnicoMesmoTipo(dispositivo) &&
        !isUltimoMesmoTipo(dispositivo) &&
        !hasIndicativoContinuacaoSequencia(dispositivo) &&
        (!getDispositivoPosterior(dispositivo) || !isOmissis(getDispositivoPosterior(dispositivo)))) {
        addMensagem(mensagens, TipoMensagem.ERROR, `${dispositivo.descricao} deveria terminar com ${converteIndicadorParaTexto(dispositivo.INDICADOR_SEQUENCIA)}.`);
    }
    if (isDispositivoAlteracao(dispositivo) &&
        dispositivo.texto &&
        dispositivo === getDispositivoCabecaAlteracao(dispositivo) &&
        dispositivo.filhos.length === 0 &&
        (dispositivo.texto === TEXTO_DEFAULT_DISPOSITIVO_ALTERACAO || dispositivo.texto.indexOf(TEXTO_OMISSIS) >= 0)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `Não foi informada nenhuma alteração.`);
    }
    if (isDispositivoAlteracao(dispositivo) &&
        dispositivo.texto &&
        dispositivo.texto.indexOf(TEXTO_OMISSIS) === -1 &&
        !/^[.]+$/.test(dispositivo.texto) &&
        isDispositivoDeArtigo(dispositivo) &&
        !isParagrafo(dispositivo) &&
        !isOmissis(dispositivo) &&
        dispositivo.pai.filhos.filter(d => isOmissis(d)).length === 0 &&
        !hasFilhoGenerico(dispositivo.pai) &&
        (!hasFilhos(dispositivo) || isTodosFilhosTipoEnumeracaoSuprimidos(dispositivo)) &&
        !hasIndicativoFinalSequencia(dispositivo) &&
        !isUltimaAlteracao(dispositivo) &&
        isUltimaEnumeracao(dispositivo) &&
        !isSeguidoDeOmissis(dispositivo)) {
        addMensagem(mensagens, TipoMensagem.ERROR, `Último dispositivo de uma sequência deveria terminar com ${converteIndicadorParaTexto(dispositivo.INDICADOR_FIM_SEQUENCIA)}.`);
    }
    return [...new Set(mensagens)];
};
const isSeguidoDeOmissis = (dispositivo) => {
    const proximo = getDispositivoPosteriorNaSequenciaDeLeitura(dispositivo);
    if (proximo !== undefined) {
        return proximo.tipo === TipoDispositivo.omissis.name;
    }
    return false;
};
const addMensagem = (mensagens, tipo, descricao, fix) => {
    const existe = mensagens.filter(m => m.descricao === descricao).length > 0;
    if (!existe) {
        if (fix === undefined) {
            mensagens.push({ tipo, descricao });
        }
        else {
            mensagens.push({ tipo, descricao, fix });
        }
    }
};
const validaTexto = (dispositivo) => {
    return isAgrupador(dispositivo) ? validaTextoAgrupador(dispositivo) : validaTextoDispositivo(dispositivo);
};

var TipoGenero;
(function (TipoGenero) {
    TipoGenero["MASCULINO"] = "masculino";
    TipoGenero["FEMININO"] = "feminino";
    TipoGenero["INDEFINIDO"] = "indefinido";
})(TipoGenero || (TipoGenero = {}));
function GeneroFeminino(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.tipoGenero = 'feminino';
            this.artigoDefinido = 'a';
            this.pronomePossessivoSingular = ' da ';
            this.pronomePossessivoPlural = ' das ';
            this.artigoDefinidoSingular = ' a ';
            this.artigoDefinidoPlural = ' as ';
            this.artigoIndefinidoSingular = ' uma ';
            this.artigoDefinidoPrecedidoPreposicaoASingular = ' à ';
            this.artigoDefinidoPrecedidoPreposicaoAPlural = ' às ';
            this.contracaoEmArtigoDefinidoSingular = ' na ';
        }
    };
}
function GeneroIndefinido(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.tipoGenero = 'indefinido';
            this.artigoDefinido = '';
            this.pronomePossessivoSingular = '';
            this.pronomePossessivoPlural = '';
            this.artigoDefinidoSingular = '';
            this.artigoDefinidoPlural = '';
            this.artigoIndefinidoSingular = '';
            this.artigoDefinidoPrecedidoPreposicaoASingular = '';
            this.artigoDefinidoPrecedidoPreposicaoAPlural = '';
            this.contracaoEmArtigoDefinidoSingular = '';
        }
    };
}
function GeneroMasculino(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.tipoGenero = 'masculino';
            this.artigoDefinido = 'o';
            this.pronomePossessivoSingular = ' do ';
            this.pronomePossessivoPlural = ' dos ';
            this.artigoDefinidoSingular = ' o ';
            this.artigoDefinidoPlural = ' os ';
            this.artigoIndefinidoSingular = ' um ';
            this.artigoDefinidoPrecedidoPreposicaoASingular = ' ao ';
            this.artigoDefinidoPrecedidoPreposicaoAPlural = ' aos ';
            this.contracaoEmArtigoDefinidoSingular = ' no ';
        }
    };
}
const generoFeminino = new (GeneroFeminino(Object))();
const generoMasculino = new (GeneroMasculino(Object))();
const generoIndefinido = new (GeneroIndefinido(Object))();
const generoFromLetra = (letraGenero) => {
    return letraGenero === 'F' ? generoFeminino : letraGenero === 'M' ? generoMasculino : generoIndefinido;
};
class NomeComGenero {
    constructor(nome, genero) {
        this.nome = nome;
        this.genero = typeof genero === 'string' ? generoFromLetra(genero) : genero;
    }
}

const VOCABULARIO = {
    autoridades: [
        {
            urn: 'federal',
            descricao: 'Federal',
        },
        {
            urn: 'senado.federal',
            descricao: 'Senado Federal',
        },
        {
            urn: 'congresso.nacional',
            descricao: 'Congresso Nacional',
        },
    ],
    tiposDocumento: [
        {
            urn: 'lei',
            descricao: 'Lei',
            genero: 'F',
        },
        {
            urn: 'lei.complementar',
            descricao: 'Lei Complementar',
            genero: 'F',
        },
        {
            urn: 'lei.delegada',
            descricao: 'Lei Delegada',
            genero: 'F',
        },
        {
            urn: 'decreto.legislativo',
            descricao: 'Decreto Legislativo',
            genero: 'M',
        },
        {
            urn: 'decreto.lei',
            descricao: 'Decreto-Lei',
            genero: 'M',
        },
        {
            urn: 'decreto',
            descricao: 'Decreto',
            genero: 'M',
        },
        {
            urn: 'consolidacao.leis.trabalho',
            descricao: 'Consolidação das Leis do Trabalho',
            genero: 'F',
        },
        {
            urn: 'resolucao',
            descricao: 'Resolução',
            genero: 'F',
        },
        {
            urn: 'regimento.interno',
            descricao: 'Regimento Interno',
            genero: 'M',
        },
        {
            urn: 'constituicao',
            descricao: 'Constituição',
            genero: 'F',
        },
        {
            urn: 'ato.disposicoes.constitucionais.transitorias',
            descricao: 'Ato das Disposições Constitucionais Transitórias',
            genero: 'M',
        },
        {
            urn: 'medida.provisoria',
            descricao: 'Medida Provisória',
            genero: 'F',
        },
        {
            urn: 'medida.provisoria;mpv',
            descricao: 'Medida Provisória',
            genero: 'F',
        },
        {
            urn: 'emenda.constitucional',
            descricao: 'Emenda Constitucional',
            genero: 'F',
        },
        {
            urn: 'emenda.constitucional.revisao',
            descricao: 'Emenda Constitucional de Revisão',
            genero: 'F',
        },
        {
            urn: 'proposta.emenda.constitucional;pec',
            descricao: 'Proposta de Emenda Constitucional',
            genero: 'F',
        },
        {
            urn: 'projeto.lei;pl',
            descricao: 'Projeto de Lei',
            genero: 'M',
        },
        {
            urn: 'projeto.lei;pls',
            descricao: 'Projeto de Lei do Senado',
            genero: 'M',
        },
        {
            urn: 'projeto.lei.complementar;plp',
            descricao: 'Projeto de Lei Complementar',
            genero: 'M',
        },
        {
            urn: 'projeto.lei.complementar;pls',
            descricao: 'Projeto de Lei Complementar do Senado',
            genero: 'M',
        },
        {
            urn: 'projeto.lei;plc',
            descricao: 'Projeto de Lei da Câmara',
            genero: 'M',
        },
        {
            urn: 'projeto.lei.complementar;plc',
            descricao: 'Projeto de Lei Complementar da Câmara',
            genero: 'M',
        },
        {
            urn: 'projeto.lei.conversao;plv',
            descricao: 'Projeto de Lei de Conversão',
            genero: 'M',
        },
        {
            urn: 'projeto.resolucao;prs',
            descricao: 'Projeto de Resolução do Senado',
            genero: 'M',
        },
        {
            urn: 'projeto.decreto.legislativo;pds',
            descricao: 'Projeto de Decreto Legislativo',
            genero: 'M',
        },
        {
            urn: 'projeto.decreto.legislativo;pdl',
            descricao: 'Projeto de Decreto Legislativo',
            genero: 'M',
        },
        {
            urn: 'substitutivo.projeto.lei.senado;scd',
            descricao: 'Substitutivo da Câmara dos Deputados',
            genero: 'M',
        },
        {
            urn: 'emenda.projeto.lei.senado;ecd',
            descricao: 'Emenda(s) da Câmara dos Deputados',
            genero: 'F',
        },
    ],
    fakeUrns: [
        {
            sigla: 'PEC',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'proposta.emenda.constitucional;pec',
        },
        {
            sigla: 'PL',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'projeto.lei;pl',
        },
        {
            sigla: 'PLS',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'projeto.lei;pls',
        },
        {
            sigla: 'PLP',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'projeto.lei.complementar;plp',
        },
        {
            sigla: 'PLC',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'projeto.lei;plc',
        },
        {
            sigla: 'PLV',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'projeto.lei.conversao;plv',
        },
        {
            sigla: 'PRS',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'projeto.resolucao;prs',
        },
        {
            sigla: 'PDS',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'projeto.decreto.legislativo;pds',
        },
        {
            sigla: 'PDL',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'projeto.decreto.legislativo;pdl',
        },
        {
            sigla: 'SCD',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'substitutivo.projeto.lei.senado;scd',
        },
        {
            sigla: 'ECD',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'emenda.projeto.lei.senado;ecd',
        },
        {
            sigla: 'MPV',
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'medida.provisoria;mpv',
        },
    ],
    siglas: [
        {
            urnAutoridade: 'federal',
            urnTipoDocumento: 'medida.provisoria',
            sigla: 'MPV',
        },
        {
            urnAutoridade: 'congresso.nacional',
            urnTipoDocumento: 'projeto.lei',
            sigla: 'PLN',
        },
        {
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'projeto.lei',
            sigla: 'PLS',
        },
        {
            urnAutoridade: 'congresso.nacional',
            urnTipoDocumento: 'medida.provisoria',
            sigla: 'MPV',
        },
        {
            urnAutoridade: 'senado.federal',
            urnTipoDocumento: 'projeto.lei.senado.federal',
            sigla: 'PLS',
        },
        {
            urnAutoridade: 'camara.deputados',
            urnTipoDocumento: 'projeto.lei',
            sigla: 'PLC',
        },
    ],
    atalhosUrn: [
        {
            urnTipoDocumento: 'constituicao',
            urnAutoridade: 'federal',
            urn: 'urn:lex:br:federal:constituicao:1988-10-05;1988',
            nome: 'Constituição Federal',
        },
        {
            urnTipoDocumento: 'ato.disposicoes.constitucionais.transitorias',
            urnAutoridade: 'federal',
            urn: 'urn:lex:br:federal:ato.disposicoes.constitucionais.transitorias:1988-10-05;1988',
            nome: 'Ato das Disposições Constitucionais Transitórias - ADCT',
        },
        {
            urnTipoDocumento: 'consolidacao.leis.trabalho',
            urnAutoridade: 'federal',
            urn: 'urn:lex:br:federal:decreto.lei:1943-05-01;5452',
            nome: 'Consolidação das Leis do Trabalho - CLT, aprovada pelo Decreto-Lei nº 5.452, de 1º de maio de 1943',
            genero: 'F',
        },
        {
            urnTipoDocumento: 'regimento.interno',
            urnAutoridade: 'senado.federal',
            urn: 'urn:lex:br:senado.federal:resolucao:1970-11-27;93',
            nome: 'Regimento Interno do Senado Federal',
            genero: 'M',
        },
        {
            urnTipoDocumento: 'regimento.interno',
            urnAutoridade: 'congresso.nacional',
            urn: 'urn:lex:br:congresso.nacional:resolucao:1970-08-11;1',
            nome: 'Regimento Comum do Congresso Nacional',
            genero: 'M',
        },
    ],
    eventos: [
        {
            urn: 'leitura',
            tipoTextoProcessoLegislativo: 'Texto inicial',
            genero: 'M',
        },
        {
            urn: 'aprovacao.substitutivo.decisao.terminativa',
            tipoTextoProcessoLegislativo: 'Redação do vencido em turno suplementar na Comissão',
            substitutivo: 's',
            genero: 'F',
        },
        {
            urn: 'aprovacao.substitutivo',
            tipoTextoProcessoLegislativo: 'Redação do vencido em turno suplementar no Plenário',
            substitutivo: 's',
            genero: 'F',
        },
        {
            urn: 'apresentacao.substitutivo',
            tipoTextoProcessoLegislativo: 'Texto do substitutivo',
            substitutivo: 's',
            genero: 'M',
        },
    ],
};

const getAutoridade = (urn) => {
    var _a;
    const partes = (_a = urn.replace('urn:lex:br:', '')) === null || _a === void 0 ? void 0 : _a.split(':');
    return VOCABULARIO.autoridades.filter(t => t.urn === partes[0])[0];
};
const getSigla = (urn) => {
    var _a, _b, _c, _d, _e;
    const tipo = (_a = getTipo$1(urn)) !== null && _a !== void 0 ? _a : {};
    const fnProcurarPorUrnTipoDocumento = (item) => item.urnTipoDocumento === tipo.urn;
    return (_e = (_c = (_b = VOCABULARIO.siglas.find(fnProcurarPorUrnTipoDocumento)) === null || _b === void 0 ? void 0 : _b.sigla) !== null && _c !== void 0 ? _c : (_d = VOCABULARIO.fakeUrns.find(fnProcurarPorUrnTipoDocumento)) === null || _d === void 0 ? void 0 : _d.sigla) !== null && _e !== void 0 ? _e : '';
};
const getTipo$1 = (urn) => {
    var _a;
    const tipo = (_a = urn.replace('urn:lex:br:', '')) === null || _a === void 0 ? void 0 : _a.split(':');
    return VOCABULARIO.tiposDocumento.filter(t => t.urn === tipo[1])[0];
};
const getNumero = (urn) => {
    var _a, _b, _c;
    const partes = (_a = urn.replace('urn:lex:br:', '')) === null || _a === void 0 ? void 0 : _a.split(':');
    return ((_b = partes[2]) === null || _b === void 0 ? void 0 : _b.indexOf(';')) > -1 ? (_c = partes[2]) === null || _c === void 0 ? void 0 : _c.substring(partes[2].indexOf(';') + 1) : '';
};
const formataNumero = (numero) => {
    return new Intl.NumberFormat('pt-BR', { style: 'decimal' }).format(+numero);
};
const getData = (urn) => {
    var _a, _b, _c, _d;
    const partes = (_a = urn.replace('urn:lex:br:', '')) === null || _a === void 0 ? void 0 : _a.split(':');
    if (partes.length < 3) {
        return '';
    }
    // Sem identificação (nem data nem número)
    // Ex: federal:lei:LEXML_URN_ID
    if (partes[2] === 'LEXML_URN_ID') {
        return '';
    }
    // Apenas ano
    // Ex: federal:lei:2020;123
    if (/^\d{4};$/.test(partes[2])) {
        return partes[2].split(';')[0];
    }
    // Data completa
    // Ex: federal:lei:2020-10-22;123
    const d = (_d = (_c = (_b = partes[2]) === null || _b === void 0 ? void 0 : _b.substring(0, partes[2].indexOf(';'))) === null || _c === void 0 ? void 0 : _c.split('-')) === null || _d === void 0 ? void 0 : _d.reverse();
    return d ? d.join('/') : '';
};
const getDataPorExtenso = (urn) => {
    var _a, _b, _c, _d, _e;
    const mes = ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'];
    const partes = (_a = urn.replace('urn:lex:br:', '')) === null || _a === void 0 ? void 0 : _a.split(':');
    const dataInformada = (_b = partes[2]) === null || _b === void 0 ? void 0 : _b.substring(0, partes[2].indexOf(';'));
    if (/^\d{4}$/.test(dataInformada) || /\d{4}$/.test(dataInformada)) {
        return dataInformada;
    }
    const d = (_e = (_d = (_c = partes[2]) === null || _c === void 0 ? void 0 : _c.substring(0, partes[2].indexOf(';'))) === null || _d === void 0 ? void 0 : _d.split('-')) === null || _e === void 0 ? void 0 : _e.reverse();
    if (d) {
        d[1] = mes[+d[1] - 1];
        return d.join(' de ');
    }
    return '';
};
const getAno = (urn) => (/^\d{4}$/.test(getData(urn)) ? getData(urn) : getData(urn).split('/').slice(-1)[0]);
const retiraFragmento = (urn) => {
    const i = urn.indexOf('!');
    if (i !== -1) {
        return urn.substring(0, i);
    }
    return urn;
};
const converteDataFormatoBrasileiroParaUrn = (data) => {
    const dataRegex = data.match(/^(0[1-9]|[12][0-9]|3[01])[-/](0[1-9]|1[012])[-/](\d{4})$/);
    return dataRegex ? `${dataRegex[3]}-${dataRegex[2]}-${dataRegex[1]}` : '';
};
const buildUrn = (autoridade, tipo, numero, data) => {
    const dataPadrao = /\d{4}[-]/.test(data) || /^\d{4}$/.test(data) ? data : converteDataFormatoBrasileiroParaUrn(data);
    return `urn:lex:br:${autoridade}:${tipo}:${dataPadrao};${numero}`;
};
// Para inicialização de edição de emenda sem texto lexml
const buildFakeUrn = (sigla, numero, ano) => {
    const fake = VOCABULARIO.fakeUrns.find(f => f.sigla === sigla.toUpperCase());
    if (fake) {
        return buildUrn(fake.urnAutoridade, fake.urnTipoDocumento, numero, ano);
    }
    throw `Sigla '${sigla}' não encontrada no vocabulário para montagem da urn.`;
};
const validaUrn = (urn) => {
    var _a, _b;
    const autoridade = (_a = getAutoridade(urn)) === null || _a === void 0 ? void 0 : _a.urn;
    const tipo = (_b = getTipo$1(urn)) === null || _b === void 0 ? void 0 : _b.urn;
    const numero = /^\d{1,5}$/.test(getNumero(urn));
    const data = /\d{4}[-]/.test(getData(urn)) || /^\d{4}$/.test(getData(urn)) ? getData(urn) : converteDataFormatoBrasileiroParaUrn(getData(urn));
    return (urn === null || urn === void 0 ? void 0 : urn.startsWith('urn:lex:br:')) && autoridade && tipo && numero && data;
};
const getNomeExtenso = (urn) => {
    var _a;
    const u = retiraFragmento(urn);
    const numero = getNumero(u);
    const tipo = (_a = getTipo$1(u)) === null || _a === void 0 ? void 0 : _a.descricao;
    const data = getData(u);
    return (tipo ? tipo : '') + (numero ? ' nº ' + numero : '') + (data.length > 7 ? ' de ' + data : '');
};
const getNomeExtensoComDataExtenso = (urn) => {
    var _a;
    const atalho = VOCABULARIO.atalhosUrn.find(a => a.urn === urn);
    if (atalho) {
        return atalho.nome;
    }
    const u = retiraFragmento(urn);
    const numero = getNumero(u);
    const tipo = (_a = getTipo$1(u)) === null || _a === void 0 ? void 0 : _a.descricao;
    const dataString = getData(u);
    const [diaOuApenasAno, mes, ano] = dataString.split('/').map(p => parseInt(p));
    const dataExtenso = dataString.includes('/') ? getDataExtenso(new Date(ano, mes - 1, diaOuApenasAno)) : diaOuApenasAno;
    return (tipo ? tipo : '') + (numero ? ' nº ' + parseInt(numero).toLocaleString('pt-BR') : '') + ', de ' + dataExtenso;
};
const buildHtmlLink = (urn) => {
    const nomeExtenso = getNomeExtensoComDataExtenso(urn);
    return `<a href="${urn}">${nomeExtenso}</a>`;
};
const getDataExtenso = (data) => {
    return data ? data.getDate() + ' de ' + data.toLocaleDateString('pt-BR', { month: 'long' }) + ' de ' + data.getFullYear() : undefined;
};
const getRefGenericaProjeto = (urn) => {
    const tipo = getTipo$1(urn);
    let genero = generoFromLetra(tipo.genero);
    let nome = 'Projeto';
    if (genero === generoFeminino) {
        if (tipo.urn.startsWith('medida.provisoria')) {
            nome = 'Medida Provisória';
        }
        else {
            nome = 'Proposta';
        }
    }
    return new NomeComGenero(nome, genero);
};
const getGeneroUrnNorma = (urn) => {
    const tipo = getTipo$1(urn);
    return generoFromLetra(tipo.genero);
};

const I = 1, V = 5, X = 10, L = 50, C = 100, D = 500, M = 1000;
const ALGARISMOS_ROMANOS = {
    M: 1000,
    CM: 900,
    D: 500,
    CD: 400,
    C: 100,
    XC: 90,
    L: 50,
    XL: 40,
    X: 10,
    IX: 9,
    V: 5,
    IV: 4,
    I: 1,
};
const isNumeracaoZero = (numero) => {
    return /^0(-[a-z]+)?$/i.test(numero);
};
const isNumero = (numero) => {
    return /^\d+$/.test(numero);
};
const isNumeracaoValida = (numero) => {
    return /^\d{1,}(([-]?[1-9]+){0,2})$/.test(numero);
};
const isLetra = (letra) => {
    return /[a-zA-Z]+/.test(letra);
};
const isRomano = (numero) => {
    return /^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$/i.test(numero);
};
const converteLetraParaNumeroArabico = (s) => {
    if (!isLetra(s)) {
        return s;
    }
    s = s.toLowerCase();
    let acumulador = 0;
    [...s].forEach(atual => (acumulador = atual.toLowerCase().charCodeAt(0) - 97 + 1 + acumulador * 26));
    return acumulador.toString();
};
const converteNumeroArabicoParaLetra = (strNumero) => {
    const number = parseInt(strNumero);
    return number ? intToAlpha(number) : strNumero;
};
const intToAlpha = (numero) => {
    let str = '';
    let d = 0;
    while (numero > 0) {
        d = (numero - 1) % 26;
        numero = (numero - d - 1) / 26;
        str = str.replace(/^/, String.fromCharCode(97 + d));
    }
    return str;
};
const converteNumeroRomanoParaArabico = (numeroRomano) => {
    if (numeroRomano.startsWith('0')) {
        return '0';
    }
    if (!isRomano(numeroRomano)) {
        throw new Error("O valor '" + numeroRomano + "' não é um número em algarismo romano válido.");
    }
    numeroRomano = numeroRomano.toLowerCase();
    let tot = 0;
    let mode = I;
    for (let i = numeroRomano.length - 1; i >= 0; i--) {
        const value = numberCharToInt(numeroRomano.charAt(i));
        if (value > mode) {
            mode = value;
        }
        if (value < mode) {
            tot -= value;
        }
        else {
            tot += value;
        }
    }
    return tot.toString();
};
const numberCharToInt = (numeroRomano) => {
    switch (numeroRomano.toLowerCase()) {
        case 'i':
            return I;
        case 'v':
            return V;
        case 'x':
            return X;
        case 'l':
            return L;
        case 'c':
            return C;
        case 'd':
            return D;
        case 'm':
            return M;
        default:
            return 0;
    }
};
const converteNumeroArabicoParaRomano = (numero) => {
    let resultado = '';
    let temp;
    let num = numero.search(/-/) === -1 ? parseInt(numero) : parseInt(numero.substring(0, numero.search(/-/)));
    const resto = numero.search(/-/) === -1 ? '' : numero.substring(numero.search(/-/));
    for (const key in ALGARISMOS_ROMANOS) {
        temp = Math.floor(num / ALGARISMOS_ROMANOS[key]);
        if (temp >= 0) {
            for (let i = 0; i < temp; i++) {
                resultado += key;
            }
        }
        num = num % ALGARISMOS_ROMANOS[key];
    }
    return resultado + resto;
};
const trataNumeroAndComplemento = (numero, funcNumero, funcComplemento) => {
    const num = numero.search(/-/) === -1 ? numero.replace('º', '') : numero.substring(0, numero.search(/-/)).replace('º', '');
    const resto = numero.search(/-/) === -1 ? '' : numero.substring(numero.search(/-/));
    const converted = num === '0' ? '0' : funcNumero ? funcNumero(num) : num;
    return converted + (resto ? (funcComplemento ? funcComplemento(resto) : resto) : '');
};
const converteNumerosComplementoParaLetra = (numero) => {
    const partes = numero === null || numero === void 0 ? void 0 : numero.split('-');
    const novo = partes === null || partes === void 0 ? void 0 : partes.map(r => { var _a; return r && (isNumero(r) ? (_a = converteNumeroArabicoParaLetra(r)) === null || _a === void 0 ? void 0 : _a.toUpperCase() : r); });
    return (novo === null || novo === void 0 ? void 0 : novo.length) > 0 ? novo === null || novo === void 0 ? void 0 : novo.join('-') : '';
};
const converteLetrasComplementoParaNumero = (numero) => {
    const partes = numero === null || numero === void 0 ? void 0 : numero.split('-');
    const novo = partes === null || partes === void 0 ? void 0 : partes.map(r => r && (isLetra(r) ? converteLetraParaNumeroArabico(r) : r));
    return (novo === null || novo === void 0 ? void 0 : novo.length) > 0 ? novo === null || novo === void 0 ? void 0 : novo.join('-') : '';
};
const comparaNumeracao = (a, b) => {
    if (a === b) {
        return 0;
    }
    const partesA = a === null || a === void 0 ? void 0 : a.split('-');
    const partesB = b === null || b === void 0 ? void 0 : b.split('-');
    const [numA, ...remainingA] = partesA;
    const [numB, ...remainingB] = partesB;
    if (!numA || (numB && parseInt(numA) < parseInt(numB))) {
        return 1;
    }
    if (!numB || (numA && parseInt(numA) > parseInt(numB))) {
        return -1;
    }
    if (a && b && b.includes(a)) {
        return 1;
    }
    for (let i = 0; i < 3; i++) {
        const rA = i >= (remainingA === null || remainingA === void 0 ? void 0 : remainingA.length) ? 0 : remainingA[i];
        const rB = i >= (remainingB === null || remainingB === void 0 ? void 0 : remainingB.length) ? 0 : remainingB[i];
        if (+rA > +rB) {
            return -1;
        }
        if (+rA < +rB) {
            return 1;
        }
    }
    return 0;
};
const rotuloParaEdicao = (texto) => {
    return texto
        .replace(/\./g, '')
        .replace(/["“]/g, '')
        .replace(/^Parte/i, '')
        .replace(/^Livro/i, '')
        .replace(/^T[ií]tulo/i, '')
        .replace(/^Cap[iíÍ]tulo/i, '')
        .replace(/^Se[cçÇ][aãÃ]o/i, '')
        .replace(/^Subse[cçÇ][aãÃ]o/i, '')
        .replace(/^Artigo$/i, '')
        .replace(/^Par[aáÁ]grafo$/i, '')
        .replace(/^Inciso$/i, '')
        .replace(/^Al[iíÍ]nea$/i, '')
        .replace(/^Item$/i, '')
        .replace(/Art/i, '')
        .replace(/§/i, '')
        .replace(/§/i, '')
        .replace(/[º]/i, '')
        .replace(/[–-][/s]*$/, '')
        .replace(/[)][/s]*$/, '')
        .trim();
};
const podeRenumerar = (articulacao, elemento) => {
    var _a, _b, _c, _d;
    const dispositivo = getDispositivoFromElemento(articulacao, elemento);
    if (dispositivo === undefined) {
        return false;
    }
    if (isOmissis(dispositivo)) {
        return false;
    }
    return (((_b = (_a = elemento.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.uuidAlteracao) !== undefined &&
        elemento.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL &&
        elemento.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_MODIFICADO &&
        elemento.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_SUPRIMIDO &&
        !(isDispositivoAlteracao(dispositivo) &&
            dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO &&
            ((_c = getDispositivoPosteriorMesmoTipo(dispositivo)) === null || _c === void 0 ? void 0 : _c.numero) === '1' &&
            ((_d = getDispositivoPosteriorMesmoTipo(dispositivo)) === null || _d === void 0 ? void 0 : _d.situacao.descricaoSituacao) !== DescricaoSituacao.DISPOSITIVO_ADICIONADO));
};
const contaIrmaosNaoOriginaisConsecutivosAte = (d) => {
    let i = 0;
    const tipo = d.tipo;
    while (d !== undefined && !isOriginal(d) && !isModificadoOuSuprimido(d) && d.tipo === tipo) {
        i++;
        d = isArtigo(d) ? getProximoArtigoAnterior(d.pai, d) : getDispositivoAnterior(d);
    }
    return i;
};
const calculaNumeracao = (d) => {
    return getNumeracao(d);
};
const mapValidacaoNumeracao = {
    Artigo: (numero) => isNumero(numero.replace('º', '')) || /^(artigo )?[uúÚ]nico$/i.test(numero),
    Paragrafo: (numero) => isNumero(numero.replace('º', '')) || /^(par[aáÁ]grafo )?[uúÚ]nico$/i.test(numero),
    Inciso: isRomano,
    Alinea: isLetra,
    Item: isNumero,
};
const isNumeracaoValidaPorTipo = (numero, tipo) => {
    const partes = numero.split('-');
    const partePrincipal = partes[0];
    const parteSufixo = '-' + partes.slice(1, partes.length).join('-');
    const fnValidacao = mapValidacaoNumeracao[tipo] || isRomano;
    const resultPartePrincipal = fnValidacao(partePrincipal) && partePrincipal !== '0';
    const regexSufixoEncaixeComAteDuasLetrasEAteDoisNiveis = /^(-[a-z]{1,2}){1,2}$/i;
    return partes.length === 1 ? resultPartePrincipal : resultPartePrincipal && regexSufixoEncaixeComAteDuasLetrasEAteDoisNiveis.test(parteSufixo);
};
//
//
//
const getProximoNumero = (numero) => {
    const partes = numero === null || numero === void 0 ? void 0 : numero.split('-');
    if (numero && isNumero(partes[0]) && partes.length === 1) {
        partes[0] = '' + (+partes[0] + 1);
        return partes.join('-');
    }
    if (numero && isNumero(partes[partes.length - 1])) {
        partes[partes.length - 1] = '' + (+partes[partes.length - 1] + 1);
        return partes.join('-');
    }
    return numero;
};
const getNumeroAbaixo = (numero) => {
    const partes = numero === null || numero === void 0 ? void 0 : numero.split('-');
    if (numero && isNumero(partes[partes.length - 1])) {
        partes[partes.length - 1] = '' + partes[partes.length - 1] + '-1';
        return partes.join('-');
    }
    return numero;
};
const getNumeracao = (d) => {
    const dispositivosAnteriores = isArtigo(d) ? getArtigosAnterioresIndependenteAgrupador(d) : getDispositivosAnterioresMesmoTipo(d);
    const dispositivoPosteriores = isArtigo(d) ? getArtigosPosterioresIndependenteAgrupador(d) : getDispositivosPosterioresMesmoTipo(d);
    const dispositivoOriginalAnterior = dispositivosAnteriores && dispositivosAnteriores.filter(f => isOriginal(f) || isModificadoOuSuprimido(f)).reverse()[0];
    const dispositivoOriginalPosterior = dispositivoPosteriores && dispositivoPosteriores.filter(f => isOriginal(f) || isModificadoOuSuprimido(f))[0];
    const dispositivoAnteriorAdicionado = dispositivosAnteriores === null || dispositivosAnteriores === void 0 ? void 0 : dispositivosAnteriores.filter(f => f.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO).reverse()[0];
    if (!getDispositivoAnteriorMesmoTipo(d) && !dispositivoOriginalPosterior) {
        return '1';
    }
    if (!dispositivoOriginalAnterior && dispositivoOriginalPosterior) {
        return dispositivoAnteriorAdicionado ? (dispositivoAnteriorAdicionado.numero === '0' ? getNumeroAbaixo('0') : getProximoNumero(dispositivoAnteriorAdicionado.numero)) : '0';
    }
    if (dispositivoOriginalAnterior && !dispositivoOriginalPosterior) {
        return getProximoNumero(getDispositivoAnteriorMesmoTipo(d).numero);
    }
    if (dispositivoOriginalAnterior && dispositivoOriginalPosterior) {
        if (dispositivoOriginalAnterior === getDispositivoAnteriorMesmoTipo(d)) {
            return getNumeroAbaixo(dispositivoOriginalAnterior.numero);
        }
        return getProximoNumero(getDispositivoAnteriorMesmoTipo(d).numero);
    }
    const seqDispEmenda = contaIrmaosNaoOriginaisConsecutivosAte(d);
    return '' + seqDispEmenda;
};

const validaHierarquia = (dispositivo) => {
    var _a, _b, _c, _d;
    const mensagens = [];
    if (dispositivo === null) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'O dispositivo não foi informado',
        });
    }
    if (dispositivo !== null && dispositivo.filhos.length > 0 && dispositivo.tiposPermitidosFilhos.length === 0) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: `Segundo a Legislação vigente, ${dispositivo.descricao} não poderia possuir filhos`,
        });
    }
    if (dispositivo !== null &&
        isDispositivoAlteracao(dispositivo) &&
        dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO &&
        (((_a = getDispositivoPosteriorMesmoTipo(dispositivo)) === null || _a === void 0 ? void 0 : _a.numero) === '1' || ((_b = getDispositivoPosteriorMesmoTipo(dispositivo)) === null || _b === void 0 ? void 0 : _b.numero) === '1u') &&
        ((_c = getDispositivoPosteriorMesmoTipo(dispositivo)) === null || _c === void 0 ? void 0 : _c.situacao.descricaoSituacao) !== DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: `Não é permitido um dispositivo de alteração da norma antes do primeiro dispositivo`,
        });
    }
    if (dispositivo !== null && (isDispositivoGenerico(dispositivo) || isAgrupadorGenerico(dispositivo))) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: `Não foi possível validar a natureza deste dispositivo com base na legislação vigente`,
        });
    }
    if (dispositivo !== null &&
        dispositivo.pai &&
        !isAgrupadorGenerico(dispositivo.pai) &&
        !isOmissis(dispositivo) &&
        !isDispositivoGenerico(dispositivo) &&
        !dispositivo.tiposPermitidosPai.includes(dispositivo.pai.tipo)) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: `Segundo a Legislação vigente, ${dispositivo.descricao} somente poderia pertencer a ${dispositivo.tiposPermitidosPai.join(', ')}`,
        });
    }
    if (dispositivo !== null &&
        !isDispositivoGenerico &&
        dispositivo.filhos.length > 0 &&
        (dispositivo.tiposPermitidosFilhos.length === 0 || dispositivo.filhos.filter(filho => !dispositivo.tiposPermitidosFilhos.includes(filho.tipo)).length > 0)) {
        const relacaoFilhos = dispositivo.tiposPermitidosFilhos.length === 0 ? 'não poderia possuir filhos' : `somente poderia possuir ${dispositivo.tiposPermitidosFilhos.join(', ')}`;
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: `Segundo a Legislação vigente, ${dispositivo.descricao} ${relacaoFilhos}`,
        });
    }
    if (dispositivo !== null &&
        isOmissis(dispositivo) &&
        getDispositivoAnterior(dispositivo) !== undefined &&
        isOmissis(getUltimoFilho(getDispositivoAnterior(dispositivo)) || isOmissis(getDispositivoAnterior(dispositivo)))) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'Não pode haver mais de um omissis sequencialmente',
        });
    }
    if (dispositivo !== null &&
        dispositivo.pai &&
        isOmissis(dispositivo) &&
        isCaput(dispositivo.pai) &&
        getDispositivoPosterior(dispositivo) === undefined &&
        TipoDispositivo.omissis.tipo === ((_d = dispositivo.pai.pai.filhos.filter(f => !isCaput(f.pai))[0]) === null || _d === void 0 ? void 0 : _d.tipo)) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: AutoFix.OMISSIS_SEQUENCIAIS,
            fix: true,
        });
    }
    if (dispositivo !== null &&
        isOmissis(dispositivo) &&
        dispositivo.pai &&
        !getDispositivoPosterior(dispositivo) &&
        dispositivo.pai &&
        getDispositivoPosterior(isCaput(dispositivo.pai) ? dispositivo.pai.pai : dispositivo.pai) !== undefined &&
        isOmissis(getDispositivoPosterior(isCaput(dispositivo.pai) ? dispositivo.pai.pai : dispositivo.pai))) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: AutoFix.OMISSIS_SEQUENCIAIS,
            fix: true,
        });
    }
    if (dispositivo !== null &&
        isOmissis(dispositivo) &&
        dispositivo.pai &&
        getDispositivoPosteriorMesmoTipoInclusiveOmissis(dispositivo) !== undefined &&
        isOmissis(getDispositivoPosteriorMesmoTipoInclusiveOmissis(dispositivo)) &&
        isDispositivosSequenciaisMesmoPai(dispositivo, getDispositivoPosteriorMesmoTipoInclusiveOmissis(dispositivo))) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: AutoFix.OMISSIS_SEQUENCIAIS,
            fix: true,
        });
    }
    if (dispositivo !== null &&
        isOmissis(dispositivo) &&
        getDispositivoAnterior(dispositivo) !== undefined &&
        isOriginal(getDispositivoAnterior(dispositivo)) &&
        getDispositivoAnterior(dispositivo).numero !== undefined &&
        getDispositivoPosterior(dispositivo) !== undefined &&
        isOriginal(getDispositivoPosterior(dispositivo)) &&
        getDispositivoPosterior(dispositivo).numero !== undefined &&
        comparaNumeracao('' + (+getDispositivoAnterior(dispositivo).numero + 1), getDispositivoPosterior(dispositivo).numero) === 0) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'Não pode haver omissis entre dispositivos originais sequenciais',
        });
    }
    return mensagens;
};

const validaNumeracaoDispositivo = (dispositivo) => {
    const mensagens = [];
    if (dispositivo === null) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'O dispositivo não foi informado',
        });
    }
    if (dispositivo !== null && dispositivo.numero && dispositivo.numero.trim().length === 0) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'O dispositivo não contém numeração',
        });
    }
    if (dispositivo !== null && !isOmissis(dispositivo) && dispositivo.rotulo && dispositivo.rotulo.trim().length === 0) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'O dispositivo não contém rótulo',
        });
    }
    return mensagens;
};
const validaNumeracaoDispositivoAlteracao = (dispositivo) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const mensagens = [];
    if (dispositivo === null) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'O dispositivo não foi informado',
        });
    }
    if (dispositivo !== null && dispositivo.numero !== undefined && dispositivo.numero.trim().length === 0) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'O dispositivo não contém numeração',
        });
    }
    if (dispositivo !== null && !isOmissis(dispositivo) && ((_a = dispositivo.rotulo) === null || _a === void 0 ? void 0 : _a.trim().length) === 0) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'O dispositivo não contém rótulo',
        });
    }
    if (dispositivo !== null &&
        !isDispositivoGenerico(dispositivo) &&
        (((_b = dispositivo.rotulo) === null || _b === void 0 ? void 0 : _b.endsWith(dispositivo.tipo)) || ((_c = dispositivo.rotulo) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === ((_d = TipoDispositivo[dispositivo.tipo.toLowerCase()].descricao) === null || _d === void 0 ? void 0 : _d.toLowerCase())) &&
        !(dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO &&
            ((_e = getDispositivoPosteriorMesmoTipo(dispositivo)) === null || _e === void 0 ? void 0 : _e.numero) === '1' &&
            ((_f = getDispositivoPosteriorMesmoTipo(dispositivo)) === null || _f === void 0 ? void 0 : _f.situacao.descricaoSituacao) !== DescricaoSituacao.DISPOSITIVO_ADICIONADO)) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: AutoFix.RENUMERAR_DISPOSITIVO,
            fix: true,
        });
    }
    if (dispositivo !== null && isDispositivoAlteracao(dispositivo) && isParagrafo(dispositivo) && !isUnicoMesmoTipo(dispositivo) && ((_g = dispositivo.rotulo) === null || _g === void 0 ? void 0 : _g.endsWith('único.'))) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: `Quando houver mais de um ${dispositivo.descricao}, não pode se tratar de '${dispositivo.descricao} único'`,
        });
    }
    if (dispositivo !== null &&
        !isDispositivoCabecaAlteracao(dispositivo) &&
        dispositivo.numero !== undefined &&
        isPrimeiroMesmoTipo(dispositivo) &&
        !isOmissis(dispositivo) &&
        (!getDispositivoAnterior(dispositivo) || (getDispositivoAnterior(dispositivo) !== undefined && !isOmissis(getUltimoFilho(getDispositivoAnterior(dispositivo))))) &&
        dispositivo.numero !== '1' &&
        dispositivo.numero !== '1u') {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: AutoFix.OMISSIS_ANTES,
            fix: true,
        });
    }
    if (dispositivo !== null &&
        !isDispositivoCabecaAlteracao(dispositivo) &&
        dispositivo.numero !== undefined &&
        dispositivo.pai.indexOf(dispositivo) > 0 &&
        getDispositivoAnteriorMesmoTipo(dispositivo) &&
        dispositivo.tipo !== ((_h = getDispositivoAnteriorMesmoTipo(dispositivo)) === null || _h === void 0 ? void 0 : _h.rotulo) &&
        !isOmissis(getDispositivoAnterior(dispositivo)) &&
        !validaOrdemDispositivo(getDispositivoAnterior(dispositivo), dispositivo) &&
        dispositivo.numero !== ((_j = getDispositivoAnteriorMesmoTipo(dispositivo)) === null || _j === void 0 ? void 0 : _j.numero)) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: AutoFix.OMISSIS_ANTES,
            fix: true,
        });
    }
    if (dispositivo !== null &&
        dispositivo.numero !== undefined &&
        dispositivo.pai.indexOf(dispositivo) > 0 &&
        getDispositivosAnterioresMesmoTipo(dispositivo)
            .filter(d => d.numero !== undefined)
            .filter(d => d !== dispositivo)
            .filter(anterior => dispositivo.numero !== anterior.numero && comparaNumeracao(dispositivo.numero, anterior.numero) === 1).length > 0) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'O dispositivo tem número menor ao de algum dispositivo anterior',
        });
    }
    if (dispositivo !== null &&
        dispositivo.numero !== undefined &&
        !dispositivo.pai.isLastFilho(dispositivo) &&
        getDispositivosPosteriores(dispositivo)
            .filter(d => d !== dispositivo && dispositivo.pai === d.pai && d.numero !== undefined)
            .filter(posterior => comparaNumeracao(posterior.numero, dispositivo.numero) === 1).length > 0) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'O dispositivo tem número maior do que algum dispositivo posterior',
        });
    }
    if (dispositivo !== null && dispositivo.numero !== undefined && irmaosMesmoTipo(dispositivo).filter(d => d.numero && d.numero === dispositivo.numero).length > 1) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: 'O dispositivo tem número igual ao de outro dispositivo',
        });
    }
    return mensagens;
};
const validaNumeracao = (dispositivo) => {
    return isDispositivoAlteracao(dispositivo) ? validaNumeracaoDispositivoAlteracao(dispositivo) : validaNumeracaoDispositivo(dispositivo);
};

const validaReferencia = (dispositivo) => {
    const mensagens = [];
    if (!dispositivo.alteracoes || !dispositivo.alteracoes.base) {
        return [];
    }
    if (!validaUrn(dispositivo.alteracoes.base)) {
        mensagens.push({
            tipo: TipoMensagem.ERROR,
            descricao: `Não foi informada uma norma alterada válida`,
        });
    }
    return mensagens;
};
const validaDispositivo = (dispositivo) => {
    if ((isArticulacao(dispositivo) && dispositivo.pai === undefined) ||
        isOriginal(dispositivo) ||
        dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
        return [];
    }
    return validaHierarquia(dispositivo).concat(validaTexto(dispositivo), validaNumeracao(dispositivo), validaReferencia(dispositivo));
};

class DispositivoSuprimido {
    constructor(dispositivoOriginal) {
        this.descricaoSituacao = DescricaoSituacao.DISPOSITIVO_SUPRIMIDO;
        this.dispositivoOriginal = dispositivoOriginal;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAcoesPermitidas(dispositivo, acoes) {
        const a = [];
        if ((isIncisoCaput(dispositivo) ? dispositivo.pai.pai : dispositivo.pai).situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
            a.push(restaurarElementoAction);
            a.push(...acoes.filter(acao => acao.descricao.startsWith('Adicionar') && dispositivo.tipo === acao.tipo));
        }
        return a;
    }
}

const buildHref = (dispositivo) => {
    if (isArticulacao(dispositivo)) {
        return 'cpt_alt1';
    }
    if (dispositivo.tagId) {
        return (dispositivo.tagId +
            (isCaput(dispositivo)
                ? ''
                : isOmissis(dispositivo)
                    ? calculaSequencialOmissis(dispositivo)
                    : dispositivo.numero
                        ? (isArtigo(dispositivo) || isParagrafo(dispositivo)) && dispositivo.numero === '1' && isUnicoMesmoTipo(dispositivo)
                            ? '1u'
                            : dispositivo.numero
                        : `[sn:${dispositivo.uuid}]`));
    }
    return undefined;
};
function calculaSequencialOmissis(dispositivo) {
    if (dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
        // Diferencia omissis de incisos de caput de omissis de parágrafo
        const irmaos = irmaosMesmoTipo(dispositivo).filter(d => d.pai === dispositivo.pai);
        // Dispositivos não adicionados primeiro.
        irmaos.sort((d1, d2) => {
            const s1 = d1.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO ? 1 : 0;
            const s2 = d2.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO ? 1 : 0;
            const order = s1 - s2;
            return order ? order : dispositivo.pai.indexOf(d1) - dispositivo.pai.indexOf(d2);
        });
        return irmaos.indexOf(dispositivo) + 1;
    }
    return getDispositivosAnterioresMesmoTipo(dispositivo).length + 1;
}
const buildHierarquia = (dispositivo, idArray = []) => {
    if (isArticulacao(dispositivo) && dispositivo.pai === undefined) {
        return;
    }
    const href = buildHref(dispositivo);
    if (href) {
        idArray.unshift(href);
    }
    // ID de artigo e de dispositivos de artigo não incluem ids de agrupadores de artigo.
    if (isArtigo(dispositivo)) {
        if (isDispositivoAlteracao(dispositivo)) {
            // Pula agrupadores de artigo dentro do bloco de alteração
            const alteracao = getArticulacao(dispositivo);
            buildHierarquia(alteracao, idArray);
        }
        return;
    }
    buildHierarquia(dispositivo.pai, idArray);
};
const buildId = (dispositivo) => {
    const idArray = [];
    buildHierarquia(dispositivo, idArray);
    return idArray.join('_');
};
const buildIdAlteracao = (dispositivo) => {
    const idArray = [];
    buildHierarquia(dispositivo, idArray);
    return idArray.join('_') + '_alt1';
};
/* export const gHref = (dispositivo: Dispositivo): string => {
  if (!dispositivo.numero && dispositivo.rotulo) {
    dispositivo.createNumeroFromRotulo(dispositivo.rotulo);
  }
  return dispositivo.numero ?? '';
}; */

const isElementoDispositivoAlteracao = (elemento) => {
    var _a, _b;
    return ((_b = (_a = elemento.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.uuidAlteracao) !== undefined || elemento.uuidAlteracao !== undefined;
};
const getNivel = (dispositivo, atual = 0) => {
    if ((dispositivo === null || dispositivo === void 0 ? void 0 : dispositivo.pai) === undefined || isAgrupador(dispositivo)) {
        return atual;
    }
    if (isArtigo(dispositivo)) {
        return isDispositivoAlteracao(dispositivo) ? ++atual : atual;
    }
    atual = isDispositivoCabecaAlteracao(dispositivo === null || dispositivo === void 0 ? void 0 : dispositivo.pai) ? atual + 2 : ++atual;
    return isArtigo(dispositivo === null || dispositivo === void 0 ? void 0 : dispositivo.pai) ? atual : getNivel(dispositivo.pai, atual);
};
const buildElementoPai = (dispositivo) => {
    var _a;
    const pai = dispositivo.pai ? (isCaput(dispositivo.pai) ? dispositivo.pai.pai : dispositivo.pai) : undefined;
    const articulacaoAlteracao = pai && isDispositivoAlteracao(dispositivo) ? getArticulacao(dispositivo).pai : undefined;
    return {
        tipo: pai === null || pai === void 0 ? void 0 : pai.tipo,
        uuid: pai === null || pai === void 0 ? void 0 : pai.uuid,
        uuid2: pai === null || pai === void 0 ? void 0 : pai.uuid2,
        lexmlId: pai === null || pai === void 0 ? void 0 : pai.id,
        uuidAlteracao: articulacaoAlteracao === null || articulacaoAlteracao === void 0 ? void 0 : articulacaoAlteracao.uuid,
        uuid2Alteracao: articulacaoAlteracao === null || articulacaoAlteracao === void 0 ? void 0 : articulacaoAlteracao.uuid2,
        existeNaNormaAlterada: pai && isAdicionado(pai) ? pai.situacao.existeNaNormaAlterada : undefined,
        descricaoSituacao: (_a = pai === null || pai === void 0 ? void 0 : pai.situacao) === null || _a === void 0 ? void 0 : _a.descricaoSituacao,
    };
};
const createElemento = (dispositivo, acoes = true, procurarElementoAnterior = false) => {
    var _a, _b, _c;
    const pai = dispositivo.pai;
    const fechaAspas = dispositivo.tipo !== 'Articulacao' && isDispositivoAlteracao(dispositivo) && isUltimaAlteracao(dispositivo);
    let notaAlteracao;
    let podeEditarNotaAlteracao;
    if (fechaAspas) {
        const cabecaAlteracao = getDispositivoCabecaAlteracao(dispositivo);
        notaAlteracao = cabecaAlteracao.notaAlteracao;
        podeEditarNotaAlteracao = cabecaAlteracao.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO;
    }
    let elementoAnteriorNaSequenciaDeLeitura;
    if (procurarElementoAnterior) {
        let dispositivoAnteriorNaSequenciaDeLeitura = getDispositivoAnteriorNaSequenciaDeLeitura(dispositivo);
        if (dispositivoAnteriorNaSequenciaDeLeitura) {
            if (isArticulacao(dispositivoAnteriorNaSequenciaDeLeitura) &&
                !isArticulacaoAlteracao(dispositivoAnteriorNaSequenciaDeLeitura) &&
                hasEmenta(dispositivoAnteriorNaSequenciaDeLeitura)) {
                dispositivoAnteriorNaSequenciaDeLeitura = dispositivoAnteriorNaSequenciaDeLeitura.projetoNorma.ementa;
            }
            elementoAnteriorNaSequenciaDeLeitura = createElemento(isCaput(dispositivoAnteriorNaSequenciaDeLeitura) || isArticulacaoAlteracao(dispositivoAnteriorNaSequenciaDeLeitura)
                ? dispositivoAnteriorNaSequenciaDeLeitura.pai
                : dispositivoAnteriorNaSequenciaDeLeitura);
        }
    }
    return {
        tipo: dispositivo.tipo,
        nivel: getNivel(dispositivo),
        agrupador: isAgrupador(dispositivo),
        hierarquia: {
            pai: pai ? buildElementoPai(dispositivo) : undefined,
            posicao: pai ? pai.indexOf(dispositivo) : undefined,
            numero: dispositivo.numero,
        },
        editavel: isArticulacao(dispositivo) || dispositivo.situacao instanceof DispositivoSuprimido ? false : true,
        sendoEditado: false,
        uuid: dispositivo.uuid,
        uuid2: dispositivo.uuid2,
        lexmlId: (dispositivo.numero && buildId(dispositivo)) || dispositivo.id,
        numero: dispositivo.numero,
        rotulo: (_a = dispositivo.rotulo) !== null && _a !== void 0 ? _a : '',
        conteudo: {
            texto: dispositivo.texto,
        },
        norma: (_b = dispositivo.alteracoes) === null || _b === void 0 ? void 0 : _b.base,
        existeNaNormaAlterada: isAdicionado(dispositivo) ? dispositivo.situacao.existeNaNormaAlterada : undefined,
        index: 0,
        acoesPossiveis: acoes ? dispositivo.getAcoesPossiveis(dispositivo) : [],
        descricaoSituacao: (_c = dispositivo.situacao) === null || _c === void 0 ? void 0 : _c.descricaoSituacao,
        mensagens: isOriginal(dispositivo) ? [] : dispositivo.mensagens,
        abreAspas: isDispositivoCabecaAlteracao(dispositivo),
        fechaAspas,
        notaAlteracao,
        dispositivoAlteracao: isDispositivoAlteracao(dispositivo),
        tipoOmissis: dispositivo.tipo === 'Omissis' ? tipoOmissis(pai) : undefined,
        podeEditarNotaAlteracao,
        tiposAgrupadoresQuePodemSerInseridosAntes: getTiposAgrupadoresQuePodemSerInseridosAntes(dispositivo),
        tiposAgrupadoresQuePodemSerInseridosDepois: getTiposAgrupadoresQuePodemSerInseridosDepois(dispositivo),
        artigoDefinido: dispositivo.artigoDefinido,
        elementoAnteriorNaSequenciaDeLeitura,
    };
};
const createElementoValidado = (dispositivo, procurarElementoAnterior = false) => {
    const el = createElemento(dispositivo, true, procurarElementoAnterior);
    el.mensagens = validaDispositivo(dispositivo);
    return el;
};
const createElementos = (elementos, dispositivo, validados = false, procurarElementoAnterior = false) => {
    const fnCreateElemento = validados ? createElementoValidado : createElemento;
    if (dispositivo.filhos === undefined) {
        return;
    }
    dispositivo.filhos.forEach(d => {
        var _a;
        const el = fnCreateElemento(d, true, procurarElementoAnterior);
        if (isArtigo(d)) {
            el.conteudo.texto = d.caput.texto;
        }
        elementos.push(el);
        if (isArtigo(d) && d.hasAlteracao()) {
            (_a = d.alteracoes) === null || _a === void 0 ? void 0 : _a.filhos.forEach(f => {
                elementos.push(fnCreateElemento(f, true, procurarElementoAnterior));
                createElementos(elementos, f, validados, procurarElementoAnterior);
            });
        }
        createElementos(elementos, d, validados, procurarElementoAnterior);
    });
};
const getElementos = (dispositivo, validados = false, procurarElementoAnterior = false) => {
    var _a;
    const fnCreateElemento = validados ? createElementoValidado : createElemento;
    const elementos = [];
    elementos.push(fnCreateElemento(dispositivo, true, procurarElementoAnterior));
    if (isArticulacao(dispositivo) && !isDispositivoAlteracao(dispositivo) && hasEmenta(dispositivo) && !isEmendaArtigoOndeCouber(dispositivo)) {
        elementos.push(fnCreateElemento(dispositivo.projetoNorma.ementa, true));
    }
    if (isArtigo(dispositivo) && dispositivo.hasAlteracao()) {
        if (isArtigo(dispositivo) && dispositivo.hasAlteracao()) {
            (_a = dispositivo.alteracoes) === null || _a === void 0 ? void 0 : _a.filhos.forEach(f => {
                elementos.push(fnCreateElemento(f, true, procurarElementoAnterior));
                createElementos(elementos, f, validados, procurarElementoAnterior);
            });
        }
    }
    createElementos(elementos, dispositivo, validados, procurarElementoAnterior);
    return elementos;
};
const getArticulacaoFromElemento = (articulacao, elemento) => {
    var _a, _b;
    if (!isElementoDispositivoAlteracao(elemento) || isArticulacaoAlteracao(articulacao)) {
        return articulacao;
    }
    return ((_b = (_a = getDispositivoFromElemento(articulacao, {
        uuid: elemento.hierarquia ? elemento.hierarquia.pai.uuidAlteracao : elemento.uuidAlteracao,
    })) === null || _a === void 0 ? void 0 : _a.alteracoes) !== null && _b !== void 0 ? _b : articulacao);
};
const getDispositivoFromElemento = (art, referencia, ignorarElementoAlteracao = false) => {
    var _a, _b;
    if (referencia.tipo === 'Ementa') {
        return (_a = art.projetoNorma) === null || _a === void 0 ? void 0 : _a.ementa;
    }
    const articulacao = getArticulacaoFromElemento(art, referencia);
    if (!ignorarElementoAlteracao && isElementoDispositivoAlteracao(referencia)) {
        const ref = articulacao.pai
            ? articulacao.pai
            : getDispositivoFromElemento(articulacao, {
                uuid: referencia.hierarquia ? referencia.hierarquia.pai.uuidAlteracao : referencia.uuidAlteracao,
            });
        if (!(ref === null || ref === void 0 ? void 0 : ref.alteracoes)) {
            return undefined;
        }
        return (_b = ref.alteracoes) === null || _b === void 0 ? void 0 : _b.filhos.flatMap(f => {
            const lista = [];
            buildListaDispositivos(f, lista);
            return lista;
        }).filter((el) => el.uuid === referencia.uuid)[0];
    }
    if ((referencia === null || referencia === void 0 ? void 0 : referencia.tipo) === TipoDispositivo.artigo.tipo) {
        const artigo = articulacao.filhos.find(a => a.uuid === referencia.uuid);
        if (artigo) {
            return artigo;
        }
    }
    const dispositivo = (referencia === null || referencia === void 0 ? void 0 : referencia.tipo) === TipoDispositivo.articulacao.tipo || (referencia === null || referencia === void 0 ? void 0 : referencia.uuid) === undefined ? articulacao : findDispositivoByUuid(articulacao, referencia.uuid);
    if (dispositivo === null) {
        return undefined;
    }
    return dispositivo;
};
const criaElementoValidadoSeNecessario = (validados, dispositivo, incluiAcoes) => {
    var _a;
    const mensagens = validaDispositivo(dispositivo);
    if (mensagens.length > 0 || (dispositivo.mensagens && ((_a = dispositivo.mensagens) === null || _a === void 0 ? void 0 : _a.length) > 0)) {
        dispositivo.mensagens = mensagens;
        const elemento = createElemento(dispositivo, incluiAcoes);
        elemento.mensagens = validaDispositivo(dispositivo);
        validados.push(elemento);
    }
};
const criaListaElementosAfinsValidados = (dispositivo, incluiDispositivo = true) => {
    const validados = [];
    if (!dispositivo) {
        return [];
    }
    if (isDispositivoAlteracao(dispositivo) && hasFilhos(dispositivo) && dispositivo.filhos.filter(d => d.tipo === TipoDispositivo.omissis.tipo).length > 0) {
        criaElementoValidadoSeNecessario(validados, dispositivo);
        dispositivo.filhos.filter(d => d.tipo === TipoDispositivo.omissis.tipo).forEach(o => criaElementoValidadoSeNecessario(validados, o));
    }
    if (isDispositivoDeArtigo(dispositivo) || isDispositivoGenerico(dispositivo)) {
        const parent = isIncisoCaput(dispositivo) ? dispositivo.pai.pai : dispositivo.pai;
        criaElementoValidadoSeNecessario(validados, parent);
        if (isAgrupador(parent)) {
            criaElementoValidadoSeNecessario(validados, isIncisoCaput(dispositivo) ? dispositivo.pai.pai : dispositivo.pai);
        }
        irmaosMesmoTipo(dispositivo).forEach(filho => {
            !incluiDispositivo && filho === dispositivo ? undefined : criaElementoValidadoSeNecessario(validados, filho, true);
        });
    }
    else if (incluiDispositivo && !isArticulacao(dispositivo) && !isAgrupador(dispositivo)) {
        criaElementoValidadoSeNecessario(validados, dispositivo, true);
    }
    const anterior = getDispositivoAnterior(dispositivo);
    if (anterior !== undefined && isOmissis(anterior)) {
        criaElementoValidadoSeNecessario(validados, anterior, false);
    }
    return validados;
};
const listaDispositivosRenumerados = (dispositivo) => {
    return (isArtigo(dispositivo) || isParagrafo(dispositivo)) && irmaosMesmoTipo(dispositivo).length <= 2
        ? irmaosMesmoTipo(dispositivo).filter(d => dispositivo.uuid !== d.uuid)
        : getDispositivosPosteriores(dispositivo, true).filter(d => d.tipo === dispositivo.tipo);
};
const buildListaElementosRenumerados = (dispositivo) => {
    return listaDispositivosRenumerados(dispositivo).map(d => {
        d.mensagens = validaDispositivo(d);
        const el = createElemento(d);
        return el;
    });
};
const tipoOmissis = (pai) => {
    switch (pai === null || pai === void 0 ? void 0 : pai.tipo) {
        case 'Caput':
            return 'inciso-caput';
        case 'Inciso':
            return 'alinea';
        case 'Alinea':
            return 'item';
        case 'Artigo':
            return 'paragrafo';
        case 'Paragrafo':
            return 'inciso-paragrafo';
        default:
            return '';
    }
};
const podeAdicionarAtributoDeExistencia = (elemento) => {
    var _a, _b, _c;
    if (!elemento.dispositivoAlteracao ||
        elemento.existeNaNormaAlterada === undefined ||
        elemento.tipo === 'Omissis' ||
        elemento.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
        return false;
    }
    else if (elemento.tipo === 'Artigo') {
        return true;
    }
    else {
        return (_c = (_b = (_a = elemento.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.existeNaNormaAlterada) !== null && _c !== void 0 ? _c : true;
    }
};

var StateType;
(function (StateType) {
    StateType["ArticulacaoAtualizada"] = "ArticulacaoAtualizada";
    StateType["ComandoEmendaGerado"] = "ComandoEmendaGerado";
    StateType["DocumentoCarregado"] = "DocumentoCarregado";
    StateType["InformarDadosAssistente"] = "InformarDadosAssistente";
    StateType["InformarNorma"] = "InformarNorma";
    StateType["ElementoModificado"] = "ElementoModificado";
    StateType["ElementoIncluido"] = "ElementoIncluido";
    StateType["ElementoRemovido"] = "ElementoRemovido";
    StateType["ElementoRenumerado"] = "ElementoRenumerado";
    StateType["ElementoRestaurado"] = "ElementoRestaurado";
    StateType["ElementoSuprimido"] = "ElementoSuprimido";
    StateType["ElementoValidado"] = "ElementoValidado";
    StateType["ElementoSelecionado"] = "ElementoSelecionado";
    StateType["ElementoMarcado"] = "ElementoMarcado";
    StateType["SituacaoElementoModificada"] = "SituacaoElementoModificada";
    StateType["AtualizacaoAlertas"] = "AtualizacaoAlertas";
    StateType["ElementoReferenciado"] = "ElementoReferenciado";
    StateType["RevisaoAtivada"] = "RevisaoAtivada";
    StateType["RevisaoDesativada"] = "RevisaoDesativada";
    StateType["AtualizaUsuario"] = "AtualizaUsuario";
    StateType["RevisaoAceita"] = "RevisaoAceita";
    StateType["RevisaoRejeitada"] = "RevisaoRejeitada";
    StateType["RevisaoAdicionalRejeitada"] = "RevisaoAdicionalRejeitada";
    StateType["AdicionarAnexoEmendaTextoLivre"] = "AdicionarAnexoEmendaTextoLivre";
    StateType["RemoverAnexoEmendaTextoLivre"] = "RemoverAnexoEmendaTextoLivre";
})(StateType || (StateType = {}));

const load = (articulacao, modo) => {
    const elementos = getElementos(articulacao);
    return {
        articulacao,
        modo,
        past: [],
        present: [],
        future: [],
        ui: {
            events: [
                {
                    stateType: StateType.DocumentoCarregado,
                    elementos: elementos,
                },
            ],
            alertas: [],
        },
        revisoes: [],
        numEventosPassadosAntesDaRevisao: 0,
    };
};

const abreArticulacao = (state, action) => {
    return load(action.articulacao, action.classificacao);
};

function generateId(init = 0) {
    return {
        next: () => ++init,
    };
}
const Counter = generateId();

const generateUUID = () => {
    let uuid = '';
    for (let i = 0; i < 32; i++) {
        const randomNumber = (Math.random() * 16) | 0;
        const value = (i === 12 ? 4 : i === 16 ? (randomNumber & 3) | 8 : randomNumber).toString(16);
        uuid += (i === 8 || i === 12 || i === 16 || i === 20 ? '-' : '') + value;
    }
    return uuid;
};

function ValidacaoDispositivo(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.mensagens = [];
        }
    };
}

const INICIAR_BLOCO = 'INICIAR_BLOCO';
const FINALIZAR_BLOCO = 'FINALIZAR_BLOCO';
class BlocoAlteracao {
    constructor(tipoAcao) {
        this.tipoAcao = tipoAcao;
        this.isDispositivoAlteracao = true;
        this.descricao = tipoAcao === INICIAR_BLOCO ? `Adicionar alteração de norma` : `Finalizar alteração de norma`;
    }
    execute(atual, conteudo, tipo, hasDesmembramento = false) {
        return {
            type: ADICIONAR_ELEMENTO,
            subType: this.tipoAcao,
            atual,
            novo: {
                tipo,
                isDispositivoAlteracao: this.isDispositivoAlteracao,
                conteudo: {
                    texto: conteudo,
                },
            },
            hasDesmembramento,
        };
    }
}
const iniciarBlocoAlteracao = new BlocoAlteracao(INICIAR_BLOCO);
const finalizarBlocoAlteracao = new BlocoAlteracao(FINALIZAR_BLOCO);

function BlocoAlteracaoNaoPermitido(Base) {
    return class extends Base {
        get alteracoes() {
            return undefined;
        }
        hasAlteracao() {
            return false;
        }
    };
}

function BlocoAlteracaoPermitido(Base) {
    return class extends Base {
        hasAlteracao() {
            var _a;
            return this.alteracoes ? ((_a = this.alteracoes.filhos) === null || _a === void 0 ? void 0 : _a.length) > 0 : false;
        }
    };
}

var TipoConteudo;
(function (TipoConteudo) {
    TipoConteudo["ConteudoTexto"] = "Conte\u00FAdo de Texto";
})(TipoConteudo || (TipoConteudo = {}));

function ConteudoDispositivo(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.tipoConteudo = TipoConteudo.ConteudoTexto;
            this.texto = '';
        }
    };
}

function ConteudoOmissis(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.tipoConteudo = TipoConteudo.ConteudoTexto;
            this._texto = TEXTO_OMISSIS;
        }
        get texto() {
            return this._texto;
        }
        set texto(texto) {
            const t = normalizaSeForOmissis(texto);
            this._texto = t === TEXTO_DEFAULT_DISPOSITIVO_ALTERACAO ? TEXTO_DEFAULT_DISPOSITIVO_ALTERACAO : TEXTO_OMISSIS;
        }
    };
}

function HierarquiaAgrupador(Base) {
    return class extends Base {
        addFilho(filho, referencia) {
            if (referencia && this.filhos.indexOf(referencia) >= 0) {
                const posicao = this.filhos.indexOf(referencia) + 1;
                this.isLastFilho(referencia) ? this.filhos.push(filho) : this.filhos.splice(posicao, 0, filho);
            }
            else {
                this.filhos.push(filho);
            }
            isArtigo(filho) ? getArticulacao(filho).addArtigo(filho, referencia) : null;
        }
        addFilhoOnPosition(filho, posicao) {
            var _a;
            filho.pai = this;
            this.filhos.splice(posicao, 0, filho);
            if (isArtigo(filho)) {
                const anterior = (_a = getDispositivoAnterior(filho)) !== null && _a !== void 0 ? _a : getProximoArtigoAnterior(filho.pai.pai, filho.pai);
                const articulacao = getArticulacao(filho);
                const pos = anterior ? articulacao.indexOfArtigo(anterior) + 1 : 0;
                articulacao.addArtigoOnPosition(filho, pos);
            }
        }
        hasArtigos() {
            return this.filhos.filter(f => isArtigo(f)).length > 0;
        }
        isLastFilho(filho) {
            return this.filhos.indexOf(filho) === this.filhos.length - 1;
        }
        get filhos() {
            var _a;
            this._filhos = (_a = this._filhos) !== null && _a !== void 0 ? _a : [];
            return this._filhos;
        }
        indexOf(filho) {
            return this.filhos.indexOf(filho);
        }
        removeFilho(filho) {
            this._filhos = this.filhos.filter(f => f.uuid !== filho.uuid);
            isArtigo(filho) ? getArticulacao(filho).removeArtigo(filho) : null;
        }
        renumeraFilhos() {
            var _a;
            if (!podeRenumerarFilhosAutomaticamente(this)) {
                return;
            }
            this.filhos
                .filter(f => (isDispositivoAlteracao(f) && isAntesDoPrimeiroDispositivoOriginal(f)) ||
                f.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_NOVO ||
                f.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO)
                .filter(f => !isArtigo(f))
                .forEach(filho => {
                filho.numero = calculaNumeracao(filho);
                filho.createRotulo(filho);
                filho.id = buildId(filho);
            });
            (_a = getArticulacao(this.filhos[0])) === null || _a === void 0 ? void 0 : _a.renumeraArtigos();
        }
    };
}

function HierarquiaArtigo(Base) {
    return class extends Base {
        get filhos() {
            const incisos = this.getIncisosCaput();
            const paragrafos = this.paragrafos;
            return incisos.concat(paragrafos);
        }
        getIncisosCaput() {
            var _a, _b;
            return (_b = (_a = this.caput) === null || _a === void 0 ? void 0 : _a.filhos) !== null && _b !== void 0 ? _b : [];
        }
        get paragrafos() {
            var _a;
            this._paragrafos = (_a = this._paragrafos) !== null && _a !== void 0 ? _a : [];
            return this._paragrafos;
        }
        addFilhoOnPosition(filho, posicao) {
            if (isInciso(filho)) {
                this.caput.addFilhoOnPosition(filho, posicao);
            }
            else {
                filho.pai = this;
                this.paragrafos.splice(posicao - this.getIncisosCaput().length, 0, filho);
            }
        }
        addFilho(filho, referencia) {
            isCaput(filho) ? (this.caput = filho) : isInciso(filho) ? this.addIncisoCaput(filho, referencia) : this.addParagrafo(filho, referencia);
        }
        removeFilho(filho) {
            var _a;
            isInciso(filho) ? (_a = this.caput) === null || _a === void 0 ? void 0 : _a.removeFilho(filho) : this.removeParagrafo(filho);
        }
        addIncisoCaput(filho, referencia) {
            this.caput.addFilho(filho, referencia);
        }
        addParagrafo(filho, referencia) {
            if (referencia) {
                const posicao = this.paragrafos.indexOf(referencia) + 1;
                this.isLastFilho(referencia) ? this.paragrafos.push(filho) : this.paragrafos.splice(posicao, 0, filho);
            }
            else {
                this.paragrafos.push(filho);
            }
        }
        removeParagrafo(filho) {
            var _a;
            this._paragrafos = (_a = this._paragrafos) === null || _a === void 0 ? void 0 : _a.filter(f => (f.uuid !== filho.uuid ? f : (f.pai = undefined)));
        }
        isLastFilho(filho) {
            return this.paragrafos.indexOf(filho) === this.paragrafos.length - 1;
        }
        indexOf(filho) {
            return isInciso(filho) ? this.caput.indexOf(filho) : this.filhos.indexOf(filho);
        }
        renumeraIncisos() {
            var _a;
            (_a = this.caput) === null || _a === void 0 ? void 0 : _a.renumeraFilhos();
        }
        renumeraParagrafos() {
            this.paragrafos.forEach(filho => {
                if ((isDispositivoAlteracao(filho) && isAntesDoPrimeiroDispositivoOriginal(filho)) ||
                    filho.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_NOVO ||
                    filho.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                    filho.numero = calculaNumeracao(filho);
                    filho.createRotulo(filho);
                    filho.id = buildId(filho);
                }
                else {
                    filho.createRotulo(filho);
                }
            });
        }
        isParagrafoUnico() {
            return this.paragrafos.length === 1;
        }
        renumeraFilhos() {
            if (!podeRenumerarFilhosAutomaticamente(this)) {
                return;
            }
            this.renumeraIncisos();
            this.renumeraParagrafos();
        }
    };
}

function HierarquiaDispositivo(Base) {
    return class extends Base {
        addFilho(filho, referencia) {
            if (referencia) {
                const posicao = this.filhos.indexOf(referencia) + 1;
                this.isLastFilho(referencia) ? this.filhos.push(filho) : this.filhos.splice(posicao, 0, filho);
            }
            else {
                this.filhos.push(filho);
            }
        }
        addFilhoOnPosition(filho, posicao) {
            filho.pai = this;
            this.filhos.splice(posicao, 0, filho);
        }
        hasArtigos() {
            return this.filhos.filter(f => isArtigo(f)).length > 0;
        }
        isLastFilho(filho) {
            return this.filhos.indexOf(filho) === this.filhos.length - 1;
        }
        get filhos() {
            var _a;
            this._filhos = (_a = this._filhos) !== null && _a !== void 0 ? _a : [];
            return this._filhos;
        }
        indexOf(filho) {
            return this.filhos.indexOf(filho);
        }
        removeFilho(filho) {
            this._filhos = this.filhos.filter(f => f.uuid !== filho.uuid);
        }
        renumeraFilhos() {
            if (!podeRenumerarFilhosAutomaticamente(this)) {
                return;
            }
            this.filhos.forEach(filho => {
                if ((isDispositivoAlteracao(filho) && isAntesDoPrimeiroDispositivoOriginal(filho)) ||
                    filho.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_NOVO ||
                    filho.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                    filho.numero = calculaNumeracao(filho);
                    filho.createRotulo(filho);
                    const novoId = buildId(filho);
                    if (filho.id !== novoId) {
                        getDispositivoAndFilhosAsLista(filho).forEach(d => (d.id = buildId(d)));
                    }
                }
            });
        }
    };
}

// import { TipoDispositivo } from './../tipo/tipoDispositivo';
function NumeracaoAgrupador(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.type = 'NumeracaoAgrupadorLcp95';
            this.informouAgrupadorUnico = false;
        }
        getNomeAgrupadorUnico(dispositivo) {
            const label = `${dispositivo.descricao} Únic${dispositivo.artigoDefinido}`;
            return !['Secao', 'Subsecao'].includes(dispositivo.tipo) ? label.toUpperCase() : label;
        }
        normalizaNumeracao(numero) {
            var _a;
            const numeracao = (_a = numero.split(' ')[1]) !== null && _a !== void 0 ? _a : numero;
            const num = /[CDILMVX]+(-[a-zA-Z]+)*/.exec(numeracao);
            return num ? num[0] : addSpaceRegex(numeracao).trim().replace(/-$/, '').trim();
        }
        createNumeroFromRotulo(rotulo) {
            if (!rotulo || ['parte', 'livro', 'título', 'capítulo', 'seção', 'subseção'].some(s => s === rotulo.toLowerCase())) {
                return;
            }
            this.informouAgrupadorUnico = /.*[uú]nic[ao]/i.test(rotulo);
            if (this.informouAgrupadorUnico) {
                this.numero = '1';
            }
            else {
                const numAux = this.normalizaNumeracao(rotulo);
                if (!numAux) {
                    this.numero = undefined;
                    return;
                }
                const temp = trataNumeroAndComplemento(numAux, isNumeracaoZero(rotulo) ? null : converteNumeroRomanoParaArabico, converteLetrasComplementoParaNumero);
                this.numero = isNumeracaoValida(temp) ? temp : undefined;
            }
        }
        createRotulo(dispositivo) {
            var _a, _b, _c;
            // const prefixo = dispositivo.descricao === undefined ? dispositivo.name ?? '' : dispositivo.descricao.toLocaleUpperCase();
            const prefixo = dispositivo.descricao === undefined
                ? (_a = dispositivo.name) !== null && _a !== void 0 ? _a : ''
                : ['Secao', 'Subsecao'].includes(dispositivo.tipo)
                    ? dispositivo.descricao
                    : dispositivo.descricao.toLocaleUpperCase();
            if (this.numero === undefined ||
                (dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO &&
                    dispositivo.situacao.tipoEmenda === ClassificacaoDocumento.EMENDA_ARTIGO_ONDE_COUBER &&
                    ((_b = dispositivo.pai) === null || _b === void 0 ? void 0 : _b.tipo) === 'Articulacao')) {
                this.rotulo = prefixo; //TipoDispositivo[dispositivo.tipo.toLowerCase()].descricao?.toUpperCase() ?? dispositivo.tipo;
            }
            else if (this.numero !== undefined && !isNumeracaoValida(this.numero)) {
                this.rotulo = prefixo + ' ' + this.numero;
            }
            else if (dispositivo.isDispositivoAlteracao && isDispositivoCabecaAlteracao(dispositivo)) {
                this.rotulo = this.informouAgrupadorUnico
                    ? this.getNomeAgrupadorUnico(dispositivo)
                    : prefixo +
                        ' ' +
                        trataNumeroAndComplemento(this.numero, converteNumeroArabicoParaRomano, dispositivo.isDispositivoAlteracao ? converteNumerosComplementoParaLetra : undefined);
            }
            else {
                irmaosMesmoTipo(dispositivo).length === 1 && !((_c = dispositivo.pai) === null || _c === void 0 ? void 0 : _c.situacao).existeNaNormaAlterada
                    ? (this.rotulo = this.getNomeAgrupadorUnico(dispositivo))
                    : (this.rotulo =
                        prefixo +
                            ' ' +
                            trataNumeroAndComplemento(this.numero, converteNumeroArabicoParaRomano, dispositivo.isDispositivoAlteracao ? converteNumerosComplementoParaLetra : undefined));
            }
        }
        setMaiusculaPrimeiraLetraDaDescricao(s) {
            const partes = s.split('-');
            const [main, ...remaining] = partes;
            const palavras = main.toLocaleLowerCase().split(' ');
            for (let i = 0; i < palavras.length; i++) {
                palavras[i] = isRomano(palavras[i]) ? palavras[1].toUpperCase() : primeiraLetraMaiuscula(palavras[i]);
            }
            return palavras.join(' ') + (remaining.length > 0 ? '-' + remaining.join('') : '');
        }
        getNumeracaoParaComandoEmenda() {
            if (this.numero === undefined) {
                return '[ainda não numerado]';
            }
            const numeracao = this.rotulo.trim().replace(/^.+? +/, '');
            return numeracao.toLowerCase().startsWith('únic') ? this.setMaiusculaPrimeiraLetraDaDescricao(numeracao) : numeracao;
        }
        getNumeracaoComRotuloParaComandoEmenda() {
            const sb = new StringBuilder();
            sb.append(this.setMaiusculaPrimeiraLetraDaDescricao(this.rotulo));
            return sb.toString();
        }
    };
}

function NumeracaoAlinea(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.type = 'NumeracaoAlineaLcp95';
            this.SUFIXO = ')';
        }
        normalizaNumeracao(numero) {
            const num = /[a-z]+(-[a-zA-Z0-9]+)*/.exec(numero.trim());
            return num ? num[0] : addSpaceRegex(numero).trim().replace(/\)$/, '').trim();
        }
        createNumeroFromRotulo(rotulo) {
            this.numero = trataNumeroAndComplemento(this.normalizaNumeracao(rotulo), isNumeracaoZero(rotulo) ? null : converteLetraParaNumeroArabico, converteLetrasComplementoParaNumero);
        }
        createRotulo(dispositivo) {
            this.rotulo =
                this.numero === undefined
                    ? TipoDispositivo.alinea.name
                    : trataNumeroAndComplemento(this.numero, converteNumeroArabicoParaLetra, dispositivo.isDispositivoAlteracao ? converteNumerosComplementoParaLetra : undefined) +
                        this.SUFIXO;
        }
        getNumeracaoParaComandoEmenda() {
            if (this.numero === undefined) {
                return '[ainda não numerada]'; // TipoDispositivo.alinea.descricao?.toLocaleLowerCase() + '';
            }
            return '“' + this.rotulo.trim().replace(this.SUFIXO, '') + '”';
        }
        getNumeracaoComRotuloParaComandoEmenda() {
            var _a, _b;
            if (this.numero === undefined) {
                return ((_a = TipoDispositivo.alinea.descricao) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) + ' [ainda não numerada]';
            }
            return ((_b = TipoDispositivo.alinea.descricao) === null || _b === void 0 ? void 0 : _b.toLocaleLowerCase()) + ' ' + this.getNumeracaoParaComandoEmenda();
        }
    };
}

function NumeracaoArtigo(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.type = 'NumeracaoArtigoLcp95';
            this.PREFIXO = 'Art. ';
            this.SUFIXO = 'º';
            this.ARTIGO_UNICO = 'Artigo único.';
            this.informouArtigoUnico = false;
        }
        normalizaNumeracao(numero) {
            return numero
                .replace(/["”“]/g, '')
                .replace(/\./g, '')
                .replace(/artigo [uú]nico/i, '1')
                .replace(/(art[.]{0,1})/i, '')
                .replace(/[º]/i, '')
                .trim();
        }
        isNumeracaoComComplementoAlfabetico(numero) {
            return /^\d{1,}[º]?(([-]?[a-zA-Z]+){0,2})$/.test(numero);
        }
        isNumeracaoComComplementoNumerico(numero) {
            return /^\d{1,}[º]?(([-]?[1-9]+){0,2})$/.test(numero);
        }
        createNumeroFromRotulo(rotulo) {
            const temp = this.normalizaNumeracao(rotulo);
            this.informouArtigoUnico = /.*[uú]nico/i.test(rotulo);
            this.numero = this.informouArtigoUnico
                ? '1'
                : this.isNumeracaoComComplementoAlfabetico(temp)
                    ? trataNumeroAndComplemento(temp, undefined, converteLetrasComplementoParaNumero)
                    : this.isNumeracaoComComplementoNumerico(temp)
                        ? temp
                        : undefined;
        }
        createRotulo(dispositivo) {
            if (dispositivo === undefined) {
                this.rotulo = TipoDispositivo.artigo.descricao;
            }
            else if (dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO &&
                dispositivo.situacao.tipoEmenda === ClassificacaoDocumento.EMENDA_ARTIGO_ONDE_COUBER &&
                !isDispositivoAlteracao(dispositivo)) {
                this.rotulo = 'Art.';
            }
            else if (this.numero === undefined) {
                this.rotulo = dispositivo.tipo;
            }
            else if (this.numero !== undefined && !isNumeracaoValida(this.numero)) {
                this.rotulo = this.PREFIXO + this.numero + this.SUFIXO;
            }
            else if (isDispositivoCabecaAlteracao(dispositivo)) {
                this.rotulo = this.informouArtigoUnico ? this.ARTIGO_UNICO : this.PREFIXO + this.getNumeroAndSufixoNumeracao(dispositivo);
            }
            else {
                getArticulacao(dispositivo).artigos.length === 1
                    ? (this.rotulo = this.ARTIGO_UNICO)
                    : (this.rotulo = this.PREFIXO + this.numero === undefined ? undefined : this.PREFIXO + this.getNumeroAndSufixoNumeracao(dispositivo));
            }
        }
        getNumeroAndSufixoNumeracao(dispositivo, paraComandoEmenda = false) {
            var _a;
            const partes = (_a = this.numero) === null || _a === void 0 ? void 0 : _a.split('-');
            const [num, ...remaining] = partes;
            const ordinal = +(num !== null && num !== void 0 ? num : '1') > 0 && parseInt(num !== null && num !== void 0 ? num : '1', 10) < 10;
            return ((ordinal ? num + this.SUFIXO : num) +
                (remaining.length > 0
                    ? '-' +
                        (remaining === null || remaining === void 0 ? void 0 : remaining.map(str => (dispositivo.isDispositivoAlteracao ? converteNumeroArabicoParaLetra(str) : str)).join('-').toUpperCase())
                    : '') +
                (!paraComandoEmenda && (!ordinal || remaining.length) ? '.' : ''));
        }
        getNumeracaoParaComandoEmenda(dispositivo) {
            if (this.numero === undefined) {
                return '[ainda não numerado]'; //TipoDispositivo.artigo.descricao?.toLowerCase() + '';
            }
            if (this.informouArtigoUnico) {
                return 'artigo único';
            }
            return this.getNumeroAndSufixoNumeracao(dispositivo, true);
        }
        getNumeracaoComRotuloParaComandoEmenda(dispositivo) {
            var _a;
            if (this.numero === undefined) {
                return ((_a = TipoDispositivo.artigo.descricao) === null || _a === void 0 ? void 0 : _a.toLowerCase()) + ' [ainda não numerado]';
            }
            if (this.informouArtigoUnico) {
                return 'artigo único';
            }
            return 'art. ' + this.getNumeroAndSufixoNumeracao(dispositivo, true);
        }
    };
}

function NumeracaoCaput(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.type = 'NumeracaoIndisponivel';
        }
        createRotulo() {
            this.rotulo = undefined;
        }
        createNumeroFromRotulo() {
            //
        }
        getNumeracaoParaComandoEmenda() {
            return '';
        }
        getNumeracaoComRotuloParaComandoEmenda() {
            return 'caput';
        }
    };
}

function NumeracaoGenerico(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.type = 'NumeracaoDispositivoGenericoLcp95';
            this.SUFIXO = ' -';
        }
        createNumeroFromRotulo() {
            //
        }
        createRotulo() {
            this.rotulo = this.numero === undefined ? 'dg' : this.numero + this.SUFIXO;
        }
        getNumeracaoParaComandoEmenda() {
            return this.numero === undefined ? 'dg' : this.numero;
        }
        getNumeracaoComRotuloParaComandoEmenda() {
            return this.getNumeracaoParaComandoEmenda();
        }
    };
}

function NumeracaoInciso(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.type = 'NumeracaoIncisoLcp95';
            this.SUFIXO = ' –';
        }
        normalizaNumeracao(numero) {
            const num = /[CDILMVX]+(-[a-zA-Z0-9]+)*/.exec(numero);
            return num ? num[0] : addSpaceRegex(numero).trim().replace(/-$/, '').trim();
        }
        createNumeroFromRotulo(rotulo) {
            const temp = trataNumeroAndComplemento(this.normalizaNumeracao(rotulo), isNumeracaoZero(rotulo) ? null : converteNumeroRomanoParaArabico, converteLetrasComplementoParaNumero);
            this.numero = isNumeracaoValida(temp) ? temp : undefined;
        }
        createRotulo(dispositivo) {
            this.rotulo =
                this.numero === undefined
                    ? TipoDispositivo.inciso.name
                    : trataNumeroAndComplemento(this.numero, converteNumeroArabicoParaRomano, dispositivo.isDispositivoAlteracao ? converteNumerosComplementoParaLetra : undefined) +
                        this.SUFIXO;
        }
        getNumeracaoParaComandoEmenda(dispositivo) {
            if (this.numero === undefined) {
                return '[ainda não numerado]'; // TipoDispositivo.inciso.descricao?.toLocaleLowerCase() + '';
            }
            return trataNumeroAndComplemento(this.numero, converteNumeroArabicoParaRomano, dispositivo.isDispositivoAlteracao ? converteNumerosComplementoParaLetra : undefined);
        }
        getNumeracaoComRotuloParaComandoEmenda(dispositivo) {
            var _a, _b;
            if (this.numero === undefined) {
                return ((_a = TipoDispositivo.inciso.descricao) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) + ' [ainda não numerado]';
            }
            return ((_b = TipoDispositivo.inciso.descricao) === null || _b === void 0 ? void 0 : _b.toLocaleLowerCase()) + ' ' + this.getNumeracaoParaComandoEmenda(dispositivo);
        }
    };
}

function NumeracaoIndisponivel(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.type = 'NumeracaoIndisponivel';
        }
        createRotulo() {
            this.rotulo = undefined;
        }
        createNumeroFromRotulo() {
            //
        }
        getNumeracaoParaComandoEmenda() {
            return '';
        }
        getNumeracaoComRotuloParaComandoEmenda() {
            return '';
        }
    };
}

function NumeracaoItem(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.type = 'NumeracaoItemLcp95';
            this.SUFIXO = '.';
        }
        normalizaNumeracao(numero) {
            const num = /\d+(-[a-zA-Z0-9]+)*/.exec(numero.trim());
            return num ? num[0] : addSpaceRegex(numero).trim().replace(/\.$/, '').trim();
        }
        isNumeracaoValidaParaRotulo(numero) {
            return /^\d{1,}(([-]?[a-zA-Z0-9]+){0,2})$/.test(numero);
        }
        createNumeroFromRotulo(rotulo) {
            const temp = this.normalizaNumeracao(rotulo);
            this.numero = this.isNumeracaoValidaParaRotulo(temp) ? trataNumeroAndComplemento(temp, undefined, converteLetrasComplementoParaNumero) : undefined;
        }
        createRotulo(dispositivo) {
            this.rotulo =
                this.numero === undefined
                    ? TipoDispositivo.item.name
                    : trataNumeroAndComplemento(this.numero, undefined, dispositivo.isDispositivoAlteracao ? converteNumerosComplementoParaLetra : undefined) + this.SUFIXO;
        }
        getNumeracaoParaComandoEmenda() {
            if (this.numero === undefined) {
                return '[ainda não numerado]'; // TipoDispositivo.item.descricao?.toLowerCase() + '';
            }
            return this.rotulo.trim().replace('.', '');
        }
        getNumeracaoComRotuloParaComandoEmenda() {
            var _a, _b;
            if (this.numero === undefined) {
                return ((_a = TipoDispositivo.item.descricao) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) + ' [ainda não numerado]';
            }
            return ((_b = TipoDispositivo.item.descricao) === null || _b === void 0 ? void 0 : _b.toLocaleLowerCase()) + ' ' + this.getNumeracaoParaComandoEmenda();
        }
    };
}

function NumeracaoParagrafo(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.type = 'NumeracaoParagrafoLcp95';
            this.PREFIXO = '§ ';
            this.SUFIXO = 'º';
            this.PARAGRAFO_UNICO = 'Parágrafo único.';
            this.informouParagrafoUnico = false;
        }
        normalizaNumeracao(numero) {
            return numero
                .trim()
                .replace(/\./g, '')
                .replace(/§/i, '')
                .replace(/par[aá]grafo [uú]nico/i, '1')
                .replace(/[º]/i, '')
                .trim();
        }
        isNumeracaoComComplementoAlfabetico(numero) {
            return /^\d{1,}[º]?(([-]?[a-zA-Z]+){0,2})$/.test(numero);
        }
        isNumeracaoComComplementoNumerico(numero) {
            return /^\d{1,}[º]?(([-]?[1-9]+){0,2})$/.test(numero);
        }
        createNumeroFromRotulo(rotulo) {
            const temp = this.normalizaNumeracao(rotulo);
            this.informouParagrafoUnico = /.*[uú]nico/i.test(rotulo);
            this.numero = this.informouParagrafoUnico
                ? '1'
                : this.isNumeracaoComComplementoAlfabetico(temp)
                    ? trataNumeroAndComplemento(temp, undefined, converteLetrasComplementoParaNumero)
                    : this.isNumeracaoComComplementoNumerico(temp)
                        ? temp
                        : undefined;
        }
        createRotulo(dispositivo) {
            var _a, _b;
            if (this.numero === undefined || !dispositivo) {
                this.rotulo = TipoDispositivo.paragrafo.name;
            }
            else if (!isNumeracaoValida(this.numero)) {
                this.rotulo = this.getNumeroAndSufixoNumeracao(dispositivo);
            }
            else if (dispositivo.isDispositivoAlteracao) {
                if (isDispositivoNovoNaNormaAlterada(dispositivo)) {
                    ((_a = dispositivo.pai) === null || _a === void 0 ? void 0 : _a.filhos.filter(f => isParagrafo(f)).length) === 1
                        ? (this.rotulo = this.PARAGRAFO_UNICO)
                        : (this.rotulo = this.PREFIXO + this.numero === undefined ? undefined : this.PREFIXO + this.getNumeroAndSufixoNumeracao(dispositivo));
                }
                else {
                    this.rotulo = this.informouParagrafoUnico ? this.PARAGRAFO_UNICO : this.PREFIXO + this.getNumeroAndSufixoNumeracao(dispositivo);
                }
            }
            else {
                ((_b = dispositivo.pai) === null || _b === void 0 ? void 0 : _b.filhos.filter(f => isParagrafo(f)).length) === 1
                    ? (this.rotulo = this.PARAGRAFO_UNICO)
                    : (this.rotulo = this.PREFIXO + this.numero === undefined ? undefined : this.PREFIXO + this.getNumeroAndSufixoNumeracao(dispositivo));
            }
        }
        getNumeroAndSufixoNumeracao(dispositivo, paraComandoEmenda = false) {
            var _a;
            const partes = (_a = this.numero) === null || _a === void 0 ? void 0 : _a.split('-');
            const [num, ...remaining] = partes;
            const ordinal = parseInt(num !== null && num !== void 0 ? num : '1', 10) < 10;
            return ((ordinal ? num + this.SUFIXO : num) +
                (remaining.length > 0
                    ? '-' +
                        (remaining === null || remaining === void 0 ? void 0 : remaining.map(str => (dispositivo.isDispositivoAlteracao ? converteNumeroArabicoParaLetra(str) : str)).join('-').toUpperCase())
                    : '') +
                (!paraComandoEmenda && (!ordinal || remaining.length) ? '.' : ''));
        }
        getNumeracaoParaComandoEmenda(dispositivo) {
            if (this.numero === undefined) {
                return '[ainda não numerado]'; // TipoDispositivo.paragrafo.descricao?.toLocaleLowerCase() + '';
            }
            return this.isParagrafoUnico() ? 'parágrafo único' : this.getNumeroAndSufixoNumeracao(dispositivo, true);
        }
        getNumeracaoComRotuloParaComandoEmenda(dispositivo) {
            var _a;
            if (this.numero === undefined) {
                return ((_a = TipoDispositivo.paragrafo.descricao) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) + ' [ainda não numerado]';
            }
            return this.isParagrafoUnico() ? 'parágrafo único' : '§ ' + this.getNumeroAndSufixoNumeracao(dispositivo, true);
        }
        isParagrafoUnico() {
            var _a, _b;
            return (this.isDispositivoAlteracao && ((_a = this.rotulo) === null || _a === void 0 ? void 0 : _a.includes('único'))) || (!this.isDispositivoAlteracao && ((_b = this.pai) === null || _b === void 0 ? void 0 : _b.filhos.filter(f => isParagrafo(f)).length) === 1);
        }
    };
}

class AdicionarTextoOmissisAction {
    constructor() {
        this.descricao = 'Linha pontilhada';
    }
    execute(atual) {
        atual.conteudo.texto = TEXTO_OMISSIS;
        return atualizarTextoElementoAction.execute(atual);
    }
}
const adicionarTextoOmissisAction = new AdicionarTextoOmissisAction();

class RemoverTextoOmissisAction {
    constructor() {
        this.descricao = 'Remover linha pontilhada';
    }
    execute(atual) {
        atual.conteudo.texto = '';
        return atualizarTextoElementoAction.execute(atual);
    }
}
const removerTextoOmissisAction = new RemoverTextoOmissisAction();

const ACEITAR_REVISAO = 'ACEITAR_REVISAO';
class AceitarRevisao {
    constructor() {
        this.descricao = 'Aceitar revisão';
    }
    execute(elemento, revisao) {
        return {
            type: ACEITAR_REVISAO,
            elemento,
            revisao,
        };
    }
}
const aceitarRevisaoAction = new AceitarRevisao();

const REJEITAR_REVISAO = 'REJEITAR_REVISAO';
class RejeitarRevisao {
    constructor() {
        this.descricao = 'Rejeitar revisão';
    }
    execute(elemento, revisao) {
        return {
            type: REJEITAR_REVISAO,
            elemento,
            revisao,
        };
    }
}
const rejeitarRevisaoAction = new RejeitarRevisao();

const EXIBIR_DIFERENCA = 'EXIBIR_DIFERENCA';
class ExibirDiferenca {
    constructor() {
        this.descricao = 'Exibir diferenças';
    }
    execute(elemento) {
        return {
            type: EXIBIR_DIFERENCA,
            elemento,
        };
    }
}
const exibirDiferencaAction = new ExibirDiferenca();

const acoesMenu = [];
acoesMenu.push(informarNormaAction);
acoesMenu.push(InformarDadosAssistenteAction);
acoesMenu.push(considerarElementoExistenteNaNorma);
acoesMenu.push(considerarElementoNovoNaNorma);
acoesMenu.push(atualizarNotaAlteracaoAction);
acoesMenu.push(moverElementoAbaixoAction);
acoesMenu.push(moverElementoAcimaAction);
acoesMenu.push(renumerarElementoAction);
acoesMenu.push(iniciarBlocoAlteracao);
acoesMenu.push(finalizarBlocoAlteracao);
acoesMenu.push(transformarEmOmissisAlinea);
acoesMenu.push(transformarEmOmissisIncisoCaput);
acoesMenu.push(transformarEmOmissisItem);
acoesMenu.push(transformarEmOmissisParagrafo);
acoesMenu.push(transformarEmOmissisIncisoParagrafo);
acoesMenu.push(transformarAlineaEmIncisoCaput);
acoesMenu.push(transformarAlineaEmIncisoParagrafo);
acoesMenu.push(transformaAlineaEmItem);
acoesMenu.push(transformarArtigoEmParagrafo);
acoesMenu.push(transformarGenericoEmInciso);
acoesMenu.push(transformarGenericoEmAlinea);
acoesMenu.push(transformarGenericoEmItem);
acoesMenu.push(transformarIncisoParagrafoEmAlinea);
acoesMenu.push(transformarIncisoParagrafoEmParagrafo);
acoesMenu.push(transformarItemEmAlinea);
acoesMenu.push(transformarIncisoCaputEmParagrafo);
acoesMenu.push(transformarIncisoCaputEmAlinea);
acoesMenu.push(transformarOmissisEmAlinea);
acoesMenu.push(transformarOmissisEmArtigo);
acoesMenu.push(transformarOmissisEmIncisoCaput);
acoesMenu.push(transformarOmissisEmIncisoParagrafo);
acoesMenu.push(transformarOmissisEmItem);
acoesMenu.push(transformarOmissisEmParagrafo);
acoesMenu.push(transformarParagrafoEmArtigo);
acoesMenu.push(transformarParagrafoEmIncisoParagrafo);
acoesMenu.push(transformarParagrafoEmIncisoCaput);
acoesMenu.push(removerElementoAction);
acoesMenu.push(restaurarElementoAction);
acoesMenu.push(suprimirElementoAction);
acoesMenu.push(suprimirAgrupadorAction);
acoesMenu.push(validarElementoAction);
acoesMenu.push(adicionarParte);
acoesMenu.push(adicionarLivro);
acoesMenu.push(adicionarTitulo);
acoesMenu.push(adicionarCapitulo);
acoesMenu.push(adicionarSecao);
acoesMenu.push(adicionarSubsecao);
acoesMenu.push(adicionarArtigoAntes);
acoesMenu.push(adicionarArtigoDepois);
acoesMenu.push(adicionarIncisoAntes);
acoesMenu.push(adicionarIncisoDepois);
acoesMenu.push(adicionarIncisoFilho);
acoesMenu.push(adicionarAlineaAntes);
acoesMenu.push(adicionarAlineaDepois);
acoesMenu.push(adicionarAlineaFilho);
acoesMenu.push(adicionarItemAntes);
acoesMenu.push(adicionarItemDepois);
acoesMenu.push(adicionarItemFilho);
acoesMenu.push(adicionarParagrafoAntes);
acoesMenu.push(adicionarParagrafoDepois);
acoesMenu.push(adicionarParagrafoFilho);
acoesMenu.push(adicionarAgrupadorArtigoAction);
acoesMenu.push(adicionarAgrupadorArtigoAntesAction);
acoesMenu.push(adicionarTextoOmissisAction);
acoesMenu.push(removerTextoOmissisAction);
acoesMenu.push(aceitarRevisaoAction);
acoesMenu.push(rejeitarRevisaoAction);
acoesMenu.push(exibirDiferencaAction);
const acoesExclusivasEdicao = [];
acoesExclusivasEdicao.push(adicionarElementoAction);
acoesExclusivasEdicao.push(adicionarArtigo);
acoesExclusivasEdicao.push(adicionarInciso);
acoesExclusivasEdicao.push(adicionarParagrafo);
acoesExclusivasEdicao.push(adicionarItem);
acoesExclusivasEdicao.push(adicionarAlinea);
const isAcaoMenu = (acao) => {
    return acoesMenu.includes(acao);
};
const acoesDisponiveis = [...acoesMenu, ...acoesExclusivasEdicao, validarArticulacaAction];
const getAcaoAgrupamento = (tipo) => {
    return acoesDisponiveis.filter(acao => acao instanceof AgruparElemento && acao.tipo === tipo)[0];
};

const podeConverterEmOmissis = (dispositivo) => {
    var _a, _b;
    return (isDispositivoAlteracao(dispositivo.pai) &&
        dispositivo.filhos.length === 0 &&
        dispositivo.tipo !== TipoDispositivo.omissis.name &&
        ((_a = getDispositivoAnterior(dispositivo)) === null || _a === void 0 ? void 0 : _a.tipo) !== TipoDispositivo.omissis.name &&
        ((_b = getDispositivoPosterior(dispositivo)) === null || _b === void 0 ? void 0 : _b.tipo) !== TipoDispositivo.omissis.name);
};
var MotivosOperacaoNaoPermitida;
(function (MotivosOperacaoNaoPermitida) {
    MotivosOperacaoNaoPermitida["AGRUPADOR"] = "N\u00E3o \u00E9 poss\u00EDvel mover agrupadores de artigo.";
    MotivosOperacaoNaoPermitida["ORIGINAL"] = "N\u00E3o \u00E9 poss\u00EDvel mover um dispositivo original.";
    MotivosOperacaoNaoPermitida["PROXIMO_DIFERENTE_PARAGRAFO"] = "O pr\u00F3ximo dispositivo n\u00E3o \u00E9 um par\u00E1grafo.";
    MotivosOperacaoNaoPermitida["PROXIMO_DIFERENTE_ARTIGO_ALTERACAO_NORMA"] = "O tipo do pr\u00F3ximo dispositivo n\u00E3o corresponde ao tipo do dispositivo atual (altera\u00E7\u00E3o de norma).";
    MotivosOperacaoNaoPermitida["PROXIMO_DIFERENTE_ALINEA"] = "O pr\u00F3ximo dispositivo n\u00E3o \u00E9 uma al\u00EDnea.";
    MotivosOperacaoNaoPermitida["PROXIMO_DIFERENTE_INCISO"] = "O pr\u00F3ximo dispositivo n\u00E3o \u00E9 um inciso.";
})(MotivosOperacaoNaoPermitida || (MotivosOperacaoNaoPermitida = {}));

const buildPast = (state, events) => {
    const past = state.past ? state.past : [];
    past.push(JSON.parse(JSON.stringify(events)));
    return past;
};
const buildFuture = (state, events) => {
    const future = state.future ? state.future : [];
    future.push(JSON.parse(JSON.stringify(events)));
    return future;
};
const retornaEstadoAtualComMensagem = (state, mensagem) => {
    var _a;
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: state.present,
        future: state.future,
        ui: {
            events: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.events,
            message: mensagem,
        },
        emRevisao: state.emRevisao,
        usuario: state.usuario,
        revisoes: state.revisoes,
        numEventosPassadosAntesDaRevisao: state.numEventosPassadosAntesDaRevisao,
    };
};

const normalizaNomeAcaoTransformacao = (dispositivo, tipo) => {
    var _a;
    let t;
    if (tipo.endsWith('EmOmissis')) {
        const tipoDispositivo = tipo.replace('transformar', '').replace('EmOmissis', '');
        t = 'transformar' + tipoDispositivo + 'EmOmissis' + tipoDispositivo;
    }
    else {
        t = tipo;
    }
    const acoes = dispositivo
        .getAcoesPossiveis(dispositivo)
        .filter(a => a instanceof TransformarElemento)
        .filter((a) => a.nomeAcao === tipo || a.nomeAcao.replaceAll('IncisoCaput', 'Inciso').replaceAll('IncisoParagrafo', 'Inciso') === t);
    return (_a = acoes[0]) === null || _a === void 0 ? void 0 : _a.nomeAcao;
};
const isAcaoPermitida = (dispositivo, tipo) => {
    return dispositivo.getAcoesPossiveis(dispositivo).filter(a => a instanceof tipo).length > 0;
};
const isAcaoTransformacaoPermitida = (dispositivo, action) => {
    const nomeAcao = normalizaNomeAcaoTransformacao(dispositivo, action.subType);
    return dispositivo.getAcoesPossiveis(dispositivo).filter(a => a instanceof TransformarElemento && a.nomeAcao && a.nomeAcao === nomeAcao).length > 0;
};
const montaEMostraMensagensErro = (dispositivo, state) => {
    if (dispositivo.situacao.descricaoSituacao === 'Dispositivo Original') {
        verificaExistenciaEAdicionaMotivoOperacaoNaoPermitida(dispositivo, MotivosOperacaoNaoPermitida.ORIGINAL);
    }
    return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.ERROR, descricao: 'Operação não permitida. <br>' + buildMessages$1(dispositivo.motivosOperacaoNaoPermitida) });
};
const buildMessages$1 = (mensagens) => (mensagens !== undefined ? mensagens.join('<br>') : '');
const verificaExistenciaEAdicionaMotivoOperacaoNaoPermitida = (dispositivo, motivo) => {
    if (dispositivo.motivosOperacaoNaoPermitida !== undefined) {
        if (!dispositivo.motivosOperacaoNaoPermitida.includes(motivo)) {
            dispositivo.motivosOperacaoNaoPermitida.push(motivo);
        }
    }
    else {
        dispositivo.motivosOperacaoNaoPermitida = [];
        dispositivo.motivosOperacaoNaoPermitida.push(motivo);
    }
};

function RegrasAgrupadores(Base) {
    return class extends Base {
        getAcoesPossiveis(dispositivo) {
            var _a, _b, _c, _d;
            const acoes = [];
            if (!isAgrupador(dispositivo)) {
                return [];
            }
            acoes.push(adicionarArtigoAntes);
            acoes.push(adicionarArtigoDepois);
            if (getDispositivosAnterioresMesmoTipo(dispositivo).length === 0 &&
                getDispositivosPosterioresMesmoTipo(dispositivo).length > 0 &&
                hasAgrupador$1(dispositivo) &&
                dispositivo.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO) ;
            else {
                acoes.push(removerElementoAction);
            }
            if (dispositivo.pai && isArticulacao(dispositivo.pai) && isAgrupador(dispositivo.pai) && getDispositivoAnteriorMesmoTipo(dispositivo) === undefined) {
                const pos = (_a = dispositivo.tiposPermitidosPai) === null || _a === void 0 ? void 0 : _a.indexOf(dispositivo.pai.tipo);
                (_b = dispositivo.tiposPermitidosPai) === null || _b === void 0 ? void 0 : _b.filter((tipo, index) => index > pos).forEach(t => acoes.push(getAcaoAgrupamento(t)));
            }
            if (dispositivo.pai && !isArticulacao(dispositivo.pai) && isAgrupador(dispositivo.pai) && dispositivo.pai.indexOf(dispositivo) === 0) {
                const pos = (_c = dispositivo.tiposPermitidosPai) === null || _c === void 0 ? void 0 : _c.indexOf(dispositivo.pai.tipo);
                (_d = dispositivo.tiposPermitidosPai) === null || _d === void 0 ? void 0 : _d.filter((tipo, index) => index > pos).forEach(t => acoes.push(getAcaoAgrupamento(t)));
            }
            /*       if (dispositivo.pai && dispositivo.pai!.indexOf(dispositivo) > 0 && isAgrupador(dispositivo.pai!) && !isArticulacao(dispositivo.pai)) {
              acoes.push(getAcaoAgrupamento(dispositivo.pai!.tipo));
            } */
            if (isDispositivoAlteracao(dispositivo)) {
                acoes.push(renumerarElementoAction);
            }
            acoes.push(adicionarAgrupadorArtigoAction);
            if (isDispositivoAlteracao(dispositivo) && dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                dispositivo.situacao.existeNaNormaAlterada ? acoes.push(considerarElementoNovoNaNorma) : acoes.push(considerarElementoExistenteNaNorma);
            }
            verificaExistenciaEAdicionaMotivoOperacaoNaoPermitida(dispositivo, MotivosOperacaoNaoPermitida.AGRUPADOR);
            return dispositivo.getAcoesPermitidas(dispositivo, acoes);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getAcaoPossivelTab(dispositivo) {
            return undefined;
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getAcaoPossivelShiftTab(dispositivo) {
            return undefined;
        }
    };
}

function RegrasAlinea(Base) {
    return class extends Base {
        getAcoesPossiveis(dispositivo) {
            const acoes = [];
            if (!isAlinea(dispositivo)) {
                return [];
            }
            acoes.push(removerElementoAction);
            if (!isDispositivoAlteracao(dispositivo) || dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO || dispositivo.numero !== '1') {
                acoes.push(adicionarAlineaAntes);
            }
            acoes.push(adicionarAlineaDepois);
            if (getDispositivoPosteriorMesmoTipoInclusiveOmissis(dispositivo) !== undefined) {
                acoes.push(moverElementoAbaixoAction);
            }
            else {
                verificaExistenciaEAdicionaMotivoOperacaoNaoPermitida(dispositivo, MotivosOperacaoNaoPermitida.PROXIMO_DIFERENTE_ALINEA);
            }
            if (getDispositivoAnteriorMesmoTipoInclusiveOmissis(dispositivo) !== undefined) {
                acoes.push(moverElementoAcimaAction);
            }
            else {
                verificaExistenciaEAdicionaMotivoOperacaoNaoPermitida(dispositivo, MotivosOperacaoNaoPermitida.PROXIMO_DIFERENTE_ALINEA);
            }
            if (isDispositivoAlteracao(dispositivo) && !isDispositivoNovoNaNormaAlterada(dispositivo.pai)) {
                acoes.push(renumerarElementoAction);
            }
            if (isDispositivoAlteracao(dispositivo) && isUltimaAlteracao(dispositivo)) {
                acoes.push(iniciarBlocoAlteracao);
            }
            if (!isSuprimido(dispositivo)) {
                acoes.push(adicionarItemFilho);
            }
            if (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo)) {
                acoes.push(isParagrafo(dispositivo.pai.pai) ? transformarAlineaEmIncisoParagrafo : transformarAlineaEmIncisoCaput);
            }
            if (!isPrimeiroMesmoTipo(dispositivo) || (getDispositivoAnterior(dispositivo) !== undefined && !isOmissis(getDispositivoAnterior(dispositivo)))) {
                acoes.push(transformaAlineaEmItem);
            }
            if (podeConverterEmOmissis(dispositivo)) {
                acoes.push(transformarEmOmissisAlinea);
            }
            if (isDispositivoAlteracao(dispositivo) && dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                dispositivo.situacao.existeNaNormaAlterada ? acoes.push(considerarElementoNovoNaNorma) : acoes.push(considerarElementoExistenteNaNorma);
            }
            if (podeEditarNotaAlteracao(dispositivo)) {
                acoes.push(atualizarNotaAlteracaoAction);
            }
            if (dispositivo.isDispositivoAlteracao && !isTextoOmitido(dispositivo) && !isSuprimido(dispositivo)) {
                acoes.push(adicionarTextoOmissisAction);
            }
            if (dispositivo.isDispositivoAlteracao && isTextoOmitido(dispositivo) && !isSuprimido(dispositivo)) {
                acoes.push(removerTextoOmissisAction);
            }
            return dispositivo.getAcoesPermitidas(dispositivo, acoes);
        }
        getAcaoPossivelTab(dispositivo) {
            var _a;
            if (!isAlinea(dispositivo)) {
                return undefined;
            }
            return (_a = dispositivo.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.map(tipo => {
                const acao = 'transformar' + dispositivo.tipo + 'Em' + tipo;
                return dispositivo
                    .getAcoesPossiveis(dispositivo)
                    .filter(a => a instanceof TransformarElemento)
                    .filter(a => a instanceof TransformarElemento && a.nomeAcao && acao && a.nomeAcao === acao)[0];
            })[0];
        }
        getAcaoPossivelShiftTab(dispositivo) {
            var _a;
            if (!isAlinea(dispositivo)) {
                return undefined;
            }
            if (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo)) {
                return isParagrafo(dispositivo.pai.pai) ? transformarAlineaEmIncisoParagrafo : transformarAlineaEmIncisoCaput;
            }
            return (_a = dispositivo.tiposPermitidosPai) === null || _a === void 0 ? void 0 : _a.map(tipo => {
                const acao = 'transformar' + dispositivo.tipo + 'Em' + tipo;
                return dispositivo
                    .getAcoesPossiveis(dispositivo)
                    .filter(a => a instanceof TransformarElemento)
                    .filter(a => a instanceof TransformarElemento && a.nomeAcao && acao && a.nomeAcao === acao)[0];
            })[0];
        }
    };
}

function RegrasArtigo(Base) {
    return class extends Base {
        getAcoesPossiveis(dispositivo) {
            var _a, _b, _c, _d, _e, _f, _g;
            const acoes = [];
            if (!isArtigo(dispositivo)) {
                return [];
            }
            acoes.push(adicionarElementoAction);
            acoes.push(removerElementoAction);
            if (getDispositivoPosteriorMesmoTipoInclusiveOmissis(dispositivo) || getProximoAgrupadorAposArtigo(dispositivo)) {
                acoes.push(moverElementoAbaixoAction);
            }
            else {
                verificaExistenciaEAdicionaMotivoOperacaoNaoPermitida(dispositivo, MotivosOperacaoNaoPermitida.PROXIMO_DIFERENTE_ARTIGO_ALTERACAO_NORMA);
            }
            if (getDispositivoAnteriorMesmoTipoInclusiveOmissis(dispositivo) || isAgrupadorNaoArticulacao(dispositivo.pai)) {
                acoes.push(moverElementoAcimaAction);
            }
            else {
                verificaExistenciaEAdicionaMotivoOperacaoNaoPermitida(dispositivo, MotivosOperacaoNaoPermitida.PROXIMO_DIFERENTE_ARTIGO_ALTERACAO_NORMA);
            }
            if (!isDispositivoCabecaAlteracao(dispositivo) ||
                !isDispositivoAlteracao(dispositivo) ||
                dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO ||
                dispositivo.numero !== '1') {
                acoes.push(adicionarArtigoAntes);
            }
            acoes.push(adicionarArtigoDepois);
            if (!isSuprimido(dispositivo)) {
                acoes.push(adicionarParagrafoFilho);
                acoes.push(adicionarIncisoFilho);
            }
            if (!isDispositivoAlteracao(dispositivo)) {
                acoes.push(InformarDadosAssistenteAction);
            }
            if (isDispositivoAlteracao(dispositivo)) {
                acoes.push(renumerarElementoAction);
            }
            if (dispositivo.alteracoes && dispositivo.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_MODIFICADO) {
                acoes.push(informarNormaAction);
            }
            if (!dispositivo.hasAlteracao() && !isDispositivoAlteracao(dispositivo) && (dispositivo.texto.length === 0 || !hasIndicativoDesdobramento(dispositivo))) {
                acoes.push(adicionarArtigo);
            }
            if (dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO &&
                !dispositivo.hasAlteracao() &&
                !isDispositivoAlteracao(dispositivo) &&
                !hasFilhos(dispositivo)) {
                acoes.push(iniciarBlocoAlteracao);
            }
            if (dispositivo.pai.indexOf(dispositivo) > 0 &&
                getDispositivoAnterior(dispositivo) !== undefined &&
                !((_a = getDispositivoAnterior(dispositivo)) === null || _a === void 0 ? void 0 : _a.hasAlteracao()) &&
                !isOmissis(getDispositivoAnterior(dispositivo))) {
                acoes.push(transformarArtigoEmParagrafo);
            }
            if (dispositivo.pai && !isDispositivoAlteracao(dispositivo) && isArticulacao(dispositivo.pai) && dispositivo.pai.filhos.filter(d => isAgrupador(d)).length === 0) {
                acoes.push(adicionarCapitulo);
            }
            if (dispositivo.pai && isDispositivoAlteracao(dispositivo) && isAgrupador(dispositivo.pai)) {
                acoes.push(adicionarCapitulo);
            }
            if (!isDispositivoAlteracao(dispositivo) && dispositivo.pai && hasAgrupadoresPosteriores(dispositivo)) {
                acoes.push(getAcaoAgrupamento(getAgrupadorPosterior(dispositivo).tipo));
            }
            if (!isDispositivoAlteracao(dispositivo) && isAgrupador(dispositivo.pai)) {
                const pos = (_c = (_b = dispositivo.tiposPermitidosPai) === null || _b === void 0 ? void 0 : _b.indexOf(dispositivo.pai.tipo)) !== null && _c !== void 0 ? _c : 0;
                (_d = dispositivo.tiposPermitidosPai) === null || _d === void 0 ? void 0 : _d.filter(() => pos > 0).filter((tipo, index) => (dispositivo.pai.indexOf(dispositivo) > 0 ? index >= pos : index > pos)).forEach(t => acoes.push(getAcaoAgrupamento(t)));
            }
            if (!isDispositivoAlteracao(dispositivo) &&
                isAgrupador(dispositivo.pai) &&
                !isArticulacao(dispositivo.pai) &&
                dispositivo.pai.indexOf(dispositivo) > 0 &&
                hasAgrupadoresAcima(dispositivo)) {
                const pos = (_f = (_e = dispositivo.tiposPermitidosPai) === null || _e === void 0 ? void 0 : _e.indexOf(dispositivo.pai.tipo)) !== null && _f !== void 0 ? _f : 0;
                const tiposExistentes = getAgrupadoresAcima(dispositivo.pai.pai, dispositivo.pai, []).reduce((lista, dispositivo) => lista.includes(dispositivo.tipo) && getAgrupadorPosterior(dispositivo) !== undefined ? lista : lista.concat(dispositivo.tipo), []);
                (_g = dispositivo.tiposPermitidosPai) === null || _g === void 0 ? void 0 : _g.filter(() => pos > 0).filter(t => tiposExistentes.includes(t)).forEach(t => acoes.push(getAcaoAgrupamento(t)));
            }
            if (isDispositivoAlteracao(dispositivo) && dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                dispositivo.situacao.existeNaNormaAlterada ? acoes.push(considerarElementoNovoNaNorma) : acoes.push(considerarElementoExistenteNaNorma);
            }
            if (podeEditarNotaAlteracao(dispositivo)) {
                acoes.push(atualizarNotaAlteracaoAction);
            }
            acoes.push(adicionarAgrupadorArtigoAntesAction);
            if (dispositivo.isDispositivoAlteracao && !isTextoOmitido(dispositivo) && !isSuprimido(dispositivo)) {
                acoes.push(adicionarTextoOmissisAction);
            }
            if (dispositivo.isDispositivoAlteracao && isTextoOmitido(dispositivo) && !isSuprimido(dispositivo)) {
                acoes.push(removerTextoOmissisAction);
            }
            return dispositivo.getAcoesPermitidas(dispositivo, acoes);
        }
        getAcaoPossivelTab(dispositivo) {
            var _a;
            if (!isArtigo(dispositivo)) {
                return undefined;
            }
            return (_a = dispositivo.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.map(tipo => {
                const acao = 'transformar' + dispositivo.tipo + 'Em' + tipo;
                return dispositivo
                    .getAcoesPossiveis(dispositivo)
                    .filter(a => a instanceof TransformarElemento)
                    .filter(a => a instanceof TransformarElemento && a.nomeAcao && acao && a.nomeAcao === acao)[0];
            })[0];
        }
        getAcaoPossivelShiftTab(dispositivo) {
            var _a;
            if (!dispositivo.tiposPermitidosFilhos) {
                return undefined;
            }
            if (isIncisoCaput(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo))) {
                return transformarIncisoCaputEmParagrafo;
            }
            if (isIncisoParagrafo(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo))) {
                return transformarIncisoParagrafoEmParagrafo;
            }
            if (isAlinea(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo))) {
                return isParagrafo(dispositivo.pai.pai) ? transformarAlineaEmIncisoParagrafo : transformarAlineaEmIncisoCaput;
            }
            return (_a = dispositivo.tiposPermitidosPai) === null || _a === void 0 ? void 0 : _a.map(tipo => {
                const acao = 'transformar' + dispositivo.tipo + 'Em' + tipo;
                return dispositivo
                    .getAcoesPossiveis(dispositivo)
                    .filter(a => a instanceof TransformarElemento)
                    .filter(a => a instanceof TransformarElemento && a.nomeAcao && acao && a.nomeAcao === acao)[0];
            })[0];
        }
    };
}

function RegrasCaput(Base) {
    return class extends Base {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getAcoesPossiveis(dispositivo) {
            return [];
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getAcaoPossivelTab(dispositivo) {
            return undefined;
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getAcaoPossivelShiftTab(dispositivo) {
            return undefined;
        }
    };
}

function RegrasDispositivoGenerico(Base) {
    return class extends Base {
        getAcoesPossiveis(dispositivo) {
            const acoes = [];
            if (!isDispositivoGenerico(dispositivo)) {
                return [];
            }
            acoes.push(removerElementoAction);
            if (isDispositivoAlteracao(dispositivo) && isUltimaAlteracao(dispositivo)) {
                acoes.push(iniciarBlocoAlteracao);
            }
            if ((isParagrafo(dispositivo.pai) || isCaput(dispositivo.pai) || isInciso(dispositivo.pai) || isAlinea(dispositivo.pai)) &&
                dispositivo.pai.tipoProvavelFilho.length > 0) {
                acoes.push(acoesDisponiveis.filter(a => a instanceof TransformarElemento && a.nomeAcao === 'transformarDispositivoGenericoEm' + dispositivo.pai.tipoProvavelFilho)[0]);
            }
            return dispositivo.getAcoesPermitidas(dispositivo, acoes);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getAcaoPossivelTab(dispositivo) {
            return undefined;
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getAcaoPossivelShiftTab(dispositivo) {
            return undefined;
        }
    };
}

function RegrasEmenta(Base) {
    return class extends Base {
        getAcoesPossiveis(dispositivo) {
            const acoes = [];
            if (!isEmenta(dispositivo)) {
                return [];
            }
            acoes.push(adicionarArtigoDepois);
            acoes.push(adicionarAgrupadorArtigoAction);
            return dispositivo.getAcoesPermitidas(dispositivo, acoes);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getAcaoPossivelTab(dispositivo) {
            return undefined;
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getAcaoPossivelShiftTab(dispositivo) {
            return undefined;
        }
    };
}

function RegrasInciso(Base) {
    return class extends Base {
        getAcoesPossiveis(dispositivo) {
            const acoes = [];
            if (!isInciso(dispositivo)) {
                return [];
            }
            acoes.push(adicionarElementoAction);
            acoes.push(removerElementoAction);
            if (!isDispositivoAlteracao(dispositivo) || dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO || dispositivo.numero !== '1') {
                acoes.push(adicionarIncisoAntes);
            }
            acoes.push(adicionarIncisoDepois);
            if (getDispositivoPosteriorMesmoTipoInclusiveOmissis(dispositivo) !== undefined) {
                acoes.push(moverElementoAbaixoAction);
            }
            else {
                verificaExistenciaEAdicionaMotivoOperacaoNaoPermitida(dispositivo, MotivosOperacaoNaoPermitida.PROXIMO_DIFERENTE_INCISO);
            }
            if (getDispositivoAnteriorMesmoTipoInclusiveOmissis(dispositivo) !== undefined) {
                acoes.push(moverElementoAcimaAction);
            }
            else {
                verificaExistenciaEAdicionaMotivoOperacaoNaoPermitida(dispositivo, MotivosOperacaoNaoPermitida.PROXIMO_DIFERENTE_INCISO);
            }
            if (isDispositivoAlteracao(dispositivo) && !isDispositivoNovoNaNormaAlterada(dispositivo.pai)) {
                acoes.push(renumerarElementoAction);
            }
            if (isDispositivoAlteracao(dispositivo) && isUltimaAlteracao(dispositivo)) {
                acoes.push(iniciarBlocoAlteracao);
            }
            if (!isSuprimido(dispositivo)) {
                acoes.push(adicionarAlineaFilho);
            }
            if (hasIndicativoFinalSequencia(dispositivo) && isUltimoMesmoTipo(dispositivo)) {
                acoes.push(adicionarParagrafo);
            }
            if (isIncisoCaput(dispositivo) &&
                (!isPrimeiroMesmoTipo(dispositivo) || (getDispositivoAnterior(dispositivo) !== undefined && !isOmissis(getDispositivoAnterior(dispositivo))))) {
                acoes.push(transformarIncisoCaputEmAlinea);
            }
            if (isIncisoCaput(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo))) {
                acoes.push(transformarIncisoCaputEmParagrafo);
            }
            if (isIncisoCaput(dispositivo) && podeConverterEmOmissis(dispositivo)) {
                acoes.push(transformarEmOmissisIncisoCaput);
            }
            if (isIncisoParagrafo(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isPrimeiroMesmoTipo(dispositivo))) {
                acoes.push(transformarEmOmissisIncisoParagrafo);
            }
            if (isIncisoParagrafo(dispositivo) &&
                (!isPrimeiroMesmoTipo(dispositivo) || (getDispositivoAnterior(dispositivo) !== undefined && isOmissis(getDispositivoAnterior(dispositivo))))) {
                acoes.push(transformarIncisoParagrafoEmAlinea);
            }
            if (isIncisoParagrafo(dispositivo) && podeConverterEmOmissis(dispositivo)) {
                acoes.push(transformarEmOmissisIncisoParagrafo);
            }
            if (isIncisoParagrafo(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo))) {
                acoes.push(transformarIncisoParagrafoEmParagrafo);
            }
            if (isDispositivoAlteracao(dispositivo) && dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                dispositivo.situacao.existeNaNormaAlterada ? acoes.push(considerarElementoNovoNaNorma) : acoes.push(considerarElementoExistenteNaNorma);
            }
            if (podeEditarNotaAlteracao(dispositivo)) {
                acoes.push(atualizarNotaAlteracaoAction);
            }
            if (dispositivo.isDispositivoAlteracao && !isTextoOmitido(dispositivo) && !isSuprimido(dispositivo)) {
                acoes.push(adicionarTextoOmissisAction);
            }
            if (dispositivo.isDispositivoAlteracao && isTextoOmitido(dispositivo) && !isSuprimido(dispositivo)) {
                acoes.push(removerTextoOmissisAction);
            }
            return dispositivo.getAcoesPermitidas(dispositivo, acoes);
        }
        getAcaoPossivelTab(dispositivo) {
            var _a;
            if (!isInciso(dispositivo)) {
                return undefined;
            }
            if (isIncisoCaput(dispositivo) && (!isUnicoMesmoTipo(dispositivo) || !isPrimeiroMesmoTipo(dispositivo))) {
                return transformarIncisoCaputEmAlinea;
            }
            if (isIncisoParagrafo(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo))) {
                return transformarIncisoParagrafoEmAlinea;
            }
            return (_a = dispositivo.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.map(tipo => {
                const complemento = isInciso(dispositivo) ? dispositivo.pai.tipo : '';
                const destino = tipo.endsWith(TipoDispositivo.inciso.name)
                    ? isParagrafo(dispositivo) && (!isUnicoMesmoTipo(dispositivo) || !isPrimeiroMesmoTipo(dispositivo))
                        ? 'IncisoParagrafo'
                        : 'IncisoCaput'
                    : tipo;
                const acao = 'transformar' + dispositivo.tipo + complemento + 'Em' + destino;
                return dispositivo
                    .getAcoesPossiveis(dispositivo)
                    .filter(a => a instanceof TransformarElemento)
                    .filter(a => a instanceof TransformarElemento && a.nomeAcao && acao && a.nomeAcao === acao)[0];
            })[0];
        }
        getAcaoPossivelShiftTab(dispositivo) {
            var _a;
            if (!isInciso(dispositivo)) {
                return undefined;
            }
            if (isIncisoCaput(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo))) {
                return transformarIncisoCaputEmParagrafo;
            }
            if (isIncisoParagrafo(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo))) {
                return transformarIncisoParagrafoEmParagrafo;
            }
            return (_a = dispositivo.tiposPermitidosPai) === null || _a === void 0 ? void 0 : _a.map(tipo => {
                const acao = 'transformar' + dispositivo.tipo + 'Em' + tipo;
                return dispositivo
                    .getAcoesPossiveis(dispositivo)
                    .filter(a => a instanceof TransformarElemento)
                    .filter(a => a instanceof TransformarElemento && a.nomeAcao && acao && a.nomeAcao === acao)[0];
            })[0];
        }
    };
}

function RegrasItem(Base) {
    return class extends Base {
        getAcoesPossiveis(dispositivo) {
            const acoes = [];
            if (!isItem(dispositivo)) {
                return [];
            }
            acoes.push(removerElementoAction);
            if (!isDispositivoAlteracao(dispositivo) || dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO || dispositivo.numero !== '1') {
                acoes.push(adicionarItemAntes);
            }
            acoes.push(adicionarItemDepois);
            if (getDispositivoPosteriorMesmoTipoInclusiveOmissis(dispositivo) !== undefined) {
                acoes.push(moverElementoAbaixoAction);
            }
            if (getDispositivoAnteriorMesmoTipoInclusiveOmissis(dispositivo) !== undefined) {
                acoes.push(moverElementoAcimaAction);
            }
            if (isDispositivoAlteracao(dispositivo) && !isDispositivoNovoNaNormaAlterada(dispositivo.pai)) {
                acoes.push(renumerarElementoAction);
            }
            if (isDispositivoAlteracao(dispositivo) && isUltimaAlteracao(dispositivo)) {
                acoes.push(iniciarBlocoAlteracao);
            }
            if (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo)) {
                acoes.push(transformarItemEmAlinea);
            }
            if (podeConverterEmOmissis(dispositivo)) {
                acoes.push(transformarEmOmissisItem);
            }
            if (isDispositivoAlteracao(dispositivo) && dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                dispositivo.situacao.existeNaNormaAlterada ? acoes.push(considerarElementoNovoNaNorma) : acoes.push(considerarElementoExistenteNaNorma);
            }
            if (podeEditarNotaAlteracao(dispositivo)) {
                acoes.push(atualizarNotaAlteracaoAction);
            }
            if (dispositivo.isDispositivoAlteracao && !isTextoOmitido(dispositivo) && !isSuprimido(dispositivo)) {
                acoes.push(adicionarTextoOmissisAction);
            }
            if (dispositivo.isDispositivoAlteracao && isTextoOmitido(dispositivo) && !isSuprimido(dispositivo)) {
                acoes.push(removerTextoOmissisAction);
            }
            return dispositivo.getAcoesPermitidas(dispositivo, acoes);
        }
        getAcaoPossivelTab(dispositivo) {
            var _a;
            if (!isItem) {
                return undefined;
            }
            return (_a = dispositivo.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.map(tipo => {
                const acao = 'transformar' + dispositivo.tipo + 'Em' + tipo;
                return dispositivo
                    .getAcoesPossiveis(dispositivo)
                    .filter(a => a instanceof TransformarElemento)
                    .filter(a => a instanceof TransformarElemento && a.nomeAcao && acao && a.nomeAcao === acao)[0];
            })[0];
        }
        getAcaoPossivelShiftTab(dispositivo) {
            var _a;
            if (!dispositivo.tiposPermitidosFilhos) {
                return undefined;
            }
            return (_a = dispositivo.tiposPermitidosPai) === null || _a === void 0 ? void 0 : _a.map(tipo => {
                const acao = 'transformar' + dispositivo.tipo + 'Em' + tipo;
                return dispositivo
                    .getAcoesPossiveis(dispositivo)
                    .filter(a => a instanceof TransformarElemento)
                    .filter(a => a instanceof TransformarElemento && a.nomeAcao && acao && a.nomeAcao === acao)[0];
            })[0];
        }
    };
}

function RegrasOmissis(Base) {
    return class extends Base {
        getAcoesPossiveis(dispositivo) {
            const acoes = [];
            if (!isOmissis(dispositivo)) {
                return [];
            }
            acoes.push(removerElementoAction);
            if (getDispositivoPosteriorMesmoTipoInclusiveOmissis(dispositivo) !== undefined) {
                acoes.push(moverElementoAbaixoAction);
            }
            if (getDispositivoAnteriorMesmoTipoInclusiveOmissis(dispositivo) !== undefined) {
                acoes.push(moverElementoAcimaAction);
            }
            if (isDispositivoAlteracao(dispositivo) && isUltimaAlteracao(dispositivo)) {
                acoes.push(iniciarBlocoAlteracao);
            }
            if (isArticulacao(dispositivo.pai) && getDispositivoAnterior(dispositivo) !== undefined) {
                acoes.push(transformarOmissisEmArtigo);
            }
            if (isCaput(dispositivo.pai)) {
                acoes.push(transformarOmissisEmIncisoCaput);
            }
            if (isArtigo(dispositivo.pai)) {
                acoes.push(transformarOmissisEmParagrafo);
            }
            if (isParagrafo(dispositivo.pai)) {
                acoes.push(transformarOmissisEmIncisoParagrafo);
            }
            if (isInciso(dispositivo.pai)) {
                acoes.push(transformarOmissisEmAlinea);
            }
            if (isAlinea(dispositivo.pai)) {
                acoes.push(transformarOmissisEmItem);
            }
            if (podeEditarNotaAlteracao(dispositivo)) {
                acoes.push(atualizarNotaAlteracaoAction);
            }
            return dispositivo.getAcoesPermitidas(dispositivo, acoes);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getAcaoPossivelTab(dispositivo) {
            return undefined;
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getAcaoPossivelShiftTab(dispositivo) {
            return undefined;
        }
    };
}

function RegrasParagrafo(Base) {
    return class extends Base {
        getAcoesPossiveis(dispositivo) {
            const acoes = [];
            if (!isParagrafo(dispositivo)) {
                return [];
            }
            acoes.push(removerElementoAction);
            if (!isDispositivoAlteracao(dispositivo) || dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO || dispositivo.numero !== '1') {
                acoes.push(adicionarParagrafoAntes);
            }
            acoes.push(adicionarParagrafoDepois);
            if (getDispositivoPosteriorMesmoTipoInclusiveOmissis(dispositivo) !== undefined) {
                acoes.push(moverElementoAbaixoAction);
            }
            else {
                verificaExistenciaEAdicionaMotivoOperacaoNaoPermitida(dispositivo, MotivosOperacaoNaoPermitida.PROXIMO_DIFERENTE_PARAGRAFO);
            }
            if (getDispositivoAnteriorMesmoTipoInclusiveOmissis(dispositivo) !== undefined) {
                acoes.push(moverElementoAcimaAction);
            }
            else {
                verificaExistenciaEAdicionaMotivoOperacaoNaoPermitida(dispositivo, MotivosOperacaoNaoPermitida.PROXIMO_DIFERENTE_PARAGRAFO);
            }
            if (isDispositivoAlteracao(dispositivo) && !isDispositivoNovoNaNormaAlterada(dispositivo.pai)) {
                acoes.push(renumerarElementoAction);
            }
            if (!isSuprimido(dispositivo)) {
                acoes.push(adicionarIncisoFilho);
            }
            if ((isPrimeiroMesmoTipo(dispositivo) || isUnicoMesmoTipo(dispositivo)) && (!getDispositivoAnterior(dispositivo) || !isOmissis(getDispositivoAnterior(dispositivo)))) {
                acoes.push(transformarParagrafoEmIncisoCaput);
            }
            if (!isPrimeiroMesmoTipo(dispositivo) && isParagrafo(getDispositivoAnterior(dispositivo))) {
                acoes.push(transformarParagrafoEmIncisoParagrafo);
            }
            if (isUltimoMesmoTipo(dispositivo) || isUnicoMesmoTipo(dispositivo)) {
                acoes.push(transformarParagrafoEmArtigo);
            }
            if (podeConverterEmOmissis(dispositivo)) {
                acoes.push(transformarEmOmissisParagrafo);
            }
            if (isDispositivoAlteracao(dispositivo) && isUltimaAlteracao(dispositivo)) {
                acoes.push(iniciarBlocoAlteracao);
            }
            if (isDispositivoAlteracao(dispositivo) && dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                dispositivo.situacao.existeNaNormaAlterada ? acoes.push(considerarElementoNovoNaNorma) : acoes.push(considerarElementoExistenteNaNorma);
            }
            if (podeEditarNotaAlteracao(dispositivo)) {
                acoes.push(atualizarNotaAlteracaoAction);
            }
            if (dispositivo.isDispositivoAlteracao && !isTextoOmitido(dispositivo) && !isSuprimido(dispositivo)) {
                acoes.push(adicionarTextoOmissisAction);
            }
            if (dispositivo.isDispositivoAlteracao && isTextoOmitido(dispositivo) && !isSuprimido(dispositivo)) {
                acoes.push(removerTextoOmissisAction);
            }
            return dispositivo.getAcoesPermitidas(dispositivo, acoes);
        }
        getAcaoPossivelTab(dispositivo) {
            var _a;
            if (!isParagrafo(dispositivo)) {
                return undefined;
            }
            return (_a = dispositivo.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.map(tipo => {
                const destino = tipo.endsWith(TipoDispositivo.inciso.name)
                    ? isParagrafo(dispositivo) && !isUnicoMesmoTipo(dispositivo) && !isPrimeiroMesmoTipo(dispositivo) && isParagrafo(getDispositivoAnterior(dispositivo))
                        ? 'IncisoParagrafo'
                        : 'IncisoCaput'
                    : tipo;
                const acao = 'transformar' + dispositivo.tipo + 'Em' + destino;
                return dispositivo
                    .getAcoesPossiveis(dispositivo)
                    .filter(a => a instanceof TransformarElemento)
                    .filter(a => a instanceof TransformarElemento && a.nomeAcao && acao && a.nomeAcao === acao)[0];
            })[0];
        }
        getAcaoPossivelShiftTab(dispositivo) {
            var _a;
            if (!dispositivo.tiposPermitidosFilhos) {
                return undefined;
            }
            if (isIncisoCaput(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo))) {
                return transformarIncisoCaputEmParagrafo;
            }
            if (isIncisoParagrafo(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo))) {
                return transformarIncisoParagrafoEmParagrafo;
            }
            if (isAlinea(dispositivo) && (isUnicoMesmoTipo(dispositivo) || isUltimoMesmoTipo(dispositivo))) {
                return isParagrafo(dispositivo.pai.pai) ? transformarAlineaEmIncisoParagrafo : transformarAlineaEmIncisoCaput;
            }
            return (_a = dispositivo.tiposPermitidosPai) === null || _a === void 0 ? void 0 : _a.map(tipo => {
                const acao = 'transformar' + dispositivo.tipo + 'Em' + tipo;
                return dispositivo
                    .getAcoesPossiveis(dispositivo)
                    .filter(a => a instanceof TransformarElemento)
                    .filter(a => a instanceof TransformarElemento && a.nomeAcao && acao && a.nomeAcao === acao)[0];
            })[0];
        }
    };
}

class DispositivoNovo {
    constructor() {
        this.descricaoSituacao = DescricaoSituacao.DISPOSITIVO_NOVO;
    }
    getAcoesPermitidas(dispositivo, acoes) {
        const acoesSemDuplicidade = [...new Set(acoes)];
        return acoesSemDuplicidade
            .filter(a => a !== undefined)
            .filter((acao) => acao.descricao !== 'Adicionar' && acao.descricao !== 'Atualizar dispositivo')
            .sort((a, b) => a.descricao.localeCompare(b.descricao));
    }
}

class DispositivoAdicionado extends DispositivoNovo {
    constructor() {
        super(...arguments);
        this.descricaoSituacao = DescricaoSituacao.DISPOSITIVO_ADICIONADO;
        this.tipoEmenda = ClassificacaoDocumento.EMENDA;
    }
    getAcoesPermitidas(dispositivo, acoes) {
        const acoesSemDuplicidade = [...new Set(acoes)];
        return acoesSemDuplicidade
            .filter((a) => !(a instanceof AgruparElemento))
            .filter(a => a !== undefined)
            .filter((acao) => acao.descricao !== 'Adicionar' && acao.descricao !== 'Atualizar dispositivo')
            .sort((a, b) => a.descricao.localeCompare(b.descricao));
    }
}

function SituacaoDispositivo(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.situacao = new DispositivoNovo();
        }
        getAcoesPermitidas(dispositivo, acoes) {
            var _a;
            return (_a = this.situacao) === null || _a === void 0 ? void 0 : _a.getAcoesPermitidas(dispositivo, acoes);
        }
    };
}

class TipoLexml {
    constructor(tipo) {
        this.tipo = TipoDispositivo[tipo].tipo;
        this.tagId = TipoDispositivo[tipo].tagId;
        this.name = TipoDispositivo[tipo].name;
        this.descricao = TipoDispositivo[tipo].descricao;
        this.descricaoPlural = TipoDispositivo[tipo].descricaoPlural;
        this.tiposPermitidosPai = TipoDispositivo[tipo].tiposPermitidosPai;
        this.tiposPermitidosFilhos = TipoDispositivo[tipo].tiposPermitidosFilhos;
        this.tipoProvavelFilho = TipoDispositivo[tipo].tipoProvavelFilho;
        this.INDICADOR_SEQUENCIA = TipoDispositivo[tipo].INDICADOR_SEQUENCIA;
        this.INDICADOR_FIM_SEQUENCIA = TipoDispositivo[tipo].INDICADOR_FIM_SEQUENCIA;
        this.INDICADOR_DESDOBRAMENTO = TipoDispositivo[tipo].INDICADOR_DESDOBRAMENTO;
    }
}

class TipoArticulacao extends TipoLexml {
    constructor() {
        super('articulacao');
    }
    get artigos() {
        var _a;
        return (_a = this._artigos) !== null && _a !== void 0 ? _a : [];
    }
    addArtigo(artigo, referencia) {
        var _a;
        this._artigos = (_a = this._artigos) !== null && _a !== void 0 ? _a : [];
        referencia !== undefined ? this._artigos.splice(this._artigos.indexOf(referencia) + 1, 0, artigo) : this._artigos.push(artigo);
    }
    addArtigoOnPosition(filho, posicao) {
        var _a;
        this._artigos = (_a = this._artigos) !== null && _a !== void 0 ? _a : [];
        this._artigos.splice(posicao, 0, filho);
    }
    removeArtigo(artigo) {
        var _a;
        this._artigos = (_a = this._artigos) !== null && _a !== void 0 ? _a : [];
        this._artigos = this._artigos.filter(f => f.uuid !== artigo.uuid);
    }
    renumeraArtigos() {
        this.artigos
            .filter(f => f.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_NOVO || f.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO)
            .forEach(filho => {
            if (!isDispositivoAlteracao(filho)) {
                filho.numero = calculaNumeracao(filho);
            }
            filho.createRotulo(filho);
            filho.id = buildId(filho);
            const caput = filho.caput;
            if (caput) {
                caput.id = buildId(caput);
            }
        });
    }
    indexOfArtigo(artigo) {
        return this.artigos.indexOf(artigo);
    }
}

class TipoArtigo extends TipoLexml {
    constructor() {
        super('artigo');
    }
    get texto() {
        var _a, _b;
        return (_b = (_a = this.caput) === null || _a === void 0 ? void 0 : _a.texto) !== null && _b !== void 0 ? _b : '';
    }
    set texto(texto) {
        this.caput.texto = texto;
    }
}

const converteFilhos = (atual, destino) => {
    if (destino.tipoProvavelFilho === undefined) {
        return;
    }
    atual.filhos.forEach((filho, index) => {
        var _a;
        const novo = criaDispositivo(isArtigo(destino) && TipoDispositivo.inciso.name === destino.tipoProvavelFilho ? destino.caput : destino, destino.tipoProvavelFilho);
        novo.texto = (_a = filho.texto) !== null && _a !== void 0 ? _a : '';
        novo.situacao = filho.situacao;
        novo.mensagens = validaDispositivo(novo);
        novo.createRotulo(novo);
        filho.filhos ? converteFilhos(filho, novo) : undefined;
        index === atual.filhos.length - 1 ? destino.renumeraFilhos() : undefined;
    });
};
const converteDispositivo = (atual, action) => {
    var _a, _b;
    const paiAtual = atual.pai;
    let novo;
    let paiNovo;
    switch (action.subType) {
        case 'transformarAlineaEmItem':
        case 'transformarIncisoCaputEmAlinea':
        case 'transformarIncisoParagrafoEmAlinea':
        case 'transformarParagrafoEmIncisoParagrafo':
            paiNovo = getDispositivoAnterior(atual);
            novo = criaDispositivo(paiNovo, action.novo.tipo);
            break;
        case 'transformarDispositivoGenericoEmInciso':
        case 'transformarDispositivoGenericoEmAlinea':
        case 'transformarDispositivoGenericoEmItem':
        case 'transformarOmissisEmAlinea':
        case 'transformarOmissisEmArtigo':
        case 'transformarOmissisEmIncisoCaput':
        case 'transformarOmissisEmIncisoParagrafo':
        case 'transformarOmissisEmItem':
        case 'transformarOmissisEmParagrafo':
        case 'transformarAlineaEmOmissisAlinea':
        case 'transformarItemEmOmissisItem':
        case 'transformarParagrafoEmOmissisParagrafo':
        case 'transformarIncisoCaputEmOmissisIncisoCaput':
        case 'transformarIncisoParagrafoEmOmissisIncisoParagrafo':
            paiNovo = paiAtual;
            novo = criaDispositivo(paiAtual, action.novo.tipo, undefined, paiAtual === null || paiAtual === void 0 ? void 0 : paiAtual.indexOf(atual));
            break;
        case 'transformarParagrafoEmInciso':
            if (isParagrafo(atual) && (isPrimeiroMesmoTipo(atual) || isUnicoMesmoTipo(atual))) {
                paiNovo = paiAtual;
                novo = criaDispositivo(paiNovo.caput, action.novo.tipo);
                break;
            }
            paiNovo = getDispositivoAnterior(atual);
            novo = criaDispositivo(paiNovo, action.novo.tipo);
            break;
        case 'transformarParagrafoEmIncisoCaput':
            paiNovo = paiAtual;
            novo = criaDispositivo(paiNovo.caput, action.novo.tipo);
            break;
        case 'transformarArtigoEmParagrafo':
            paiNovo = getDispositivoAnterior(atual);
            novo = criaDispositivo(paiNovo, action.novo.tipo);
            break;
        default:
            paiNovo = atual.pai.pai;
            novo = criaDispositivo(paiNovo, action.novo.tipo, atual.pai);
            break;
    }
    novo.texto = (_b = (_a = action.atual.conteudo) === null || _a === void 0 ? void 0 : _a.texto) !== null && _b !== void 0 ? _b : atual.texto;
    novo.createRotulo(novo);
    novo.situacao = atual.situacao;
    if (isDispositivoCabecaAlteracao(novo)) {
        novo.notaAlteracao = 'NR';
    }
    novo.mensagens = validaDispositivo(novo);
    paiAtual === null || paiAtual === void 0 ? void 0 : paiAtual.removeFilho(atual);
    paiAtual === null || paiAtual === void 0 ? void 0 : paiAtual.renumeraFilhos();
    paiNovo === null || paiNovo === void 0 ? void 0 : paiNovo.renumeraFilhos();
    converteFilhos(atual, novo);
    return novo;
};
const copiaFilhos = (atual, destino) => {
    if (atual.tipo !== destino.tipo) {
        return;
    }
    atual.filhos.forEach(filho => {
        var _a;
        const novo = criaDispositivo(isArtigo(destino) && isCaput(filho.pai) ? destino.caput : destino, filho.tipo);
        filho.rotulo ? (novo.rotulo = filho.rotulo) : novo.createRotulo(novo);
        novo.texto = (_a = filho.texto) !== null && _a !== void 0 ? _a : '';
        novo.situacao = filho.situacao;
        atual.removeFilho(filho);
        novo.mensagens = validaDispositivo(filho);
        filho.filhos ? (atual.tipo === destino.tipo ? copiaFilhos(filho, novo) : converteFilhos(filho, novo)) : undefined;
        atual.filhos.length === 0 ? destino.renumeraFilhos() : undefined;
    });
};
const podeSerUltimaalteracao = (dispositivo, action) => {
    var _a, _b, _c;
    if (!isDispositivoAlteracao(dispositivo)) {
        return false;
    }
    const artigo = getArtigo(dispositivo);
    return isUltimoMesmoTipo(artigo) && hasIndicativoFimAlteracao(normalizaSeForOmissis((_c = (_b = (_a = action.atual) === null || _a === void 0 ? void 0 : _a.conteudo) === null || _b === void 0 ? void 0 : _b.texto) !== null && _c !== void 0 ? _c : '')) && isUltimaAlteracao(dispositivo);
};

const AlineaLexml = SituacaoDispositivo(RegrasAlinea(ValidacaoDispositivo(GeneroFeminino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoAlinea(HierarquiaDispositivo(TipoLexml))))))));
const ArtigoLexml = SituacaoDispositivo(RegrasArtigo(ValidacaoDispositivo(GeneroMasculino(BlocoAlteracaoPermitido(NumeracaoArtigo(HierarquiaArtigo(TipoArtigo)))))));
const CaputLexml = SituacaoDispositivo(RegrasCaput(ValidacaoDispositivo(GeneroMasculino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoCaput(HierarquiaDispositivo(TipoLexml))))))));
const DispositivoGenericoLexml = SituacaoDispositivo(RegrasDispositivoGenerico(ValidacaoDispositivo(GeneroIndefinido(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoGenerico(HierarquiaDispositivo(TipoLexml))))))));
const IncisoLexml = SituacaoDispositivo(RegrasInciso(ValidacaoDispositivo(GeneroMasculino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoInciso(HierarquiaDispositivo(TipoLexml))))))));
const ItemLexml = SituacaoDispositivo(RegrasItem(ValidacaoDispositivo(GeneroMasculino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoItem(HierarquiaDispositivo(TipoLexml))))))));
const ParagrafoLexml = SituacaoDispositivo(RegrasParagrafo(ValidacaoDispositivo(GeneroMasculino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoParagrafo(HierarquiaDispositivo(TipoLexml))))))));
const ArticulacaoLexml = SituacaoDispositivo(RegrasAgrupadores(ValidacaoDispositivo(GeneroIndefinido(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoAgrupador(HierarquiaAgrupador(TipoArticulacao))))))));
const CapituloLexml = SituacaoDispositivo(RegrasAgrupadores(ValidacaoDispositivo(GeneroMasculino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoAgrupador(HierarquiaAgrupador(TipoLexml))))))));
const DispositivoAgrupadorGenericoLexml = SituacaoDispositivo(RegrasAgrupadores(ValidacaoDispositivo(GeneroIndefinido(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoAgrupador(HierarquiaAgrupador(TipoLexml))))))));
const LivroLexml = SituacaoDispositivo(RegrasAgrupadores(ValidacaoDispositivo(GeneroMasculino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoAgrupador(HierarquiaAgrupador(TipoLexml))))))));
const ParteLexml = SituacaoDispositivo(RegrasAgrupadores(ValidacaoDispositivo(GeneroFeminino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoAgrupador(HierarquiaAgrupador(TipoLexml))))))));
const SubsecaoLexml = SituacaoDispositivo(RegrasAgrupadores(ValidacaoDispositivo(GeneroFeminino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoAgrupador(HierarquiaAgrupador(TipoLexml))))))));
const SecaoLexml = SituacaoDispositivo(RegrasAgrupadores(ValidacaoDispositivo(GeneroFeminino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoAgrupador(HierarquiaAgrupador(TipoLexml))))))));
const TituloLexml = SituacaoDispositivo(RegrasAgrupadores(ValidacaoDispositivo(GeneroMasculino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoAgrupador(HierarquiaAgrupador(TipoLexml))))))));
const OmissisLexml = SituacaoDispositivo(RegrasOmissis(GeneroFeminino(BlocoAlteracaoNaoPermitido(ConteudoOmissis(NumeracaoIndisponivel(HierarquiaDispositivo(TipoLexml)))))));
const EmentaLexml = SituacaoDispositivo(RegrasEmenta(GeneroFeminino(BlocoAlteracaoNaoPermitido(ConteudoDispositivo(NumeracaoIndisponivel(HierarquiaDispositivo(TipoLexml)))))));
const criaDispositivo = (parent, tipo, referencia, posicao) => {
    const dispositivo = create(tipo, parent);
    posicao !== undefined && posicao >= 0 ? parent.addFilhoOnPosition(dispositivo, posicao) : referencia ? parent.addFilho(dispositivo, referencia) : parent.addFilho(dispositivo);
    return dispositivo;
};
const create = (name, parent) => {
    let dispositivo;
    switch (name.toLowerCase()) {
        case 'alinea':
            dispositivo = new AlineaLexml(name.toLowerCase());
            break;
        case 'artigo':
            dispositivo = new ArtigoLexml();
            dispositivo.caput = create(TipoDispositivo.caput.tipo, dispositivo);
            break;
        case 'capitulo':
            dispositivo = new CapituloLexml(name.toLowerCase());
            break;
        case 'caput':
            dispositivo = new CaputLexml(name.toLowerCase());
            break;
        case 'inciso':
            dispositivo = new IncisoLexml(name.toLowerCase());
            break;
        case 'item':
            dispositivo = new ItemLexml(name.toLowerCase());
            break;
        case 'livro':
            dispositivo = new LivroLexml(name.toLowerCase());
            break;
        case 'omissis':
            dispositivo = new OmissisLexml(name.toLowerCase());
            break;
        case 'paragrafo':
            dispositivo = new ParagrafoLexml(name.toLowerCase());
            break;
        case 'parte':
            dispositivo = new ParteLexml(name.toLowerCase());
            break;
        case 'secao':
            dispositivo = new SecaoLexml(name.toLowerCase());
            break;
        case 'subsecao':
            dispositivo = new SubsecaoLexml(name.toLowerCase());
            break;
        case 'titulo':
            dispositivo = new TituloLexml(name.toLowerCase());
            break;
        case 'ementa':
            dispositivo = new EmentaLexml(name.toLowerCase());
            break;
        default: {
            dispositivo = parent && isAgrupador(parent) ? new DispositivoAgrupadorGenericoLexml('agrupadorGenerico') : new DispositivoGenericoLexml('generico');
            dispositivo.mensagens = [];
            dispositivo.mensagens.push({ tipo: TipoMensagem.WARNING, descricao: 'Não foi possível validar a natureza deste dispositivo com base na legislação vigente' });
        }
    }
    dispositivo.uuid = Counter.next();
    dispositivo.uuid2 = generateUUID();
    dispositivo.name = name;
    dispositivo.pai = isInciso(dispositivo) && isArtigo(parent) ? parent.caput : parent;
    dispositivo.isDispositivoAlteracao = isDispositivoAlteracao(dispositivo);
    desativaRotuloAutomaticoSeDispositivoAlteracao(dispositivo);
    return dispositivo;
};
const createArticulacao = () => {
    const articulacao = new ArticulacaoLexml();
    articulacao.uuid = Counter.next();
    articulacao.uuid2 = generateUUID();
    return articulacao;
};
const createAlteracao = (atual) => {
    atual.alteracoes = createArticulacao();
    atual.alteracoes.pai = atual;
};
const createByInferencia = (referencia, action) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
    let novo;
    if (isDispositivoAlteracao(referencia)) {
        if (action.subType === INICIAR_BLOCO) {
            novo = criaDispositivoCabecaAlteracao(TipoDispositivo.artigo.tipo, getArticulacao(referencia));
            novo.texto = ((_c = (_b = (_a = action.novo) === null || _a === void 0 ? void 0 : _a.conteudo) === null || _b === void 0 ? void 0 : _b.texto) === null || _c === void 0 ? void 0 : _c.length) > 0 ? (_e = (_d = action.novo) === null || _d === void 0 ? void 0 : _d.conteudo) === null || _e === void 0 ? void 0 : _e.texto : '';
        }
        else if (action.subType === FINALIZAR_BLOCO) {
            const ref = getArticulacao(referencia);
            novo = createFromReferencia(ref.pai);
            novo.texto = normalizaSeForOmissis((_h = (_g = (_f = action.novo) === null || _f === void 0 ? void 0 : _f.conteudo) === null || _g === void 0 ? void 0 : _g.texto) !== null && _h !== void 0 ? _h : '');
        }
        else if (podeSerUltimaalteracao(referencia, action)) {
            const ref = getArticulacao(referencia);
            novo = action.subType === INICIAR_BLOCO ? criaDispositivoCabecaAlteracao(TipoDispositivo.artigo.tipo, ref) : createFromReferencia(ref.pai);
            novo.texto = action.subType === INICIAR_BLOCO ? '' : normalizaSeForOmissis((_l = (_k = (_j = action.novo) === null || _j === void 0 ? void 0 : _j.conteudo) === null || _k === void 0 ? void 0 : _k.texto) !== null && _l !== void 0 ? _l : '');
        }
        else {
            novo = createFromReferencia(referencia);
            novo.createRotulo();
            novo.texto = ((_p = (_o = (_m = action.novo) === null || _m === void 0 ? void 0 : _m.conteudo) === null || _o === void 0 ? void 0 : _o.texto) === null || _p === void 0 ? void 0 : _p.length) > 0 ? normalizaSeForOmissis((_s = (_r = (_q = action.novo) === null || _q === void 0 ? void 0 : _q.conteudo) === null || _r === void 0 ? void 0 : _r.texto) !== null && _s !== void 0 ? _s : '') : '';
        }
    }
    else {
        if (referencia.alteracoes || hasIndicativoInicioAlteracao((_u = (_t = action.atual) === null || _t === void 0 ? void 0 : _t.conteudo) === null || _u === void 0 ? void 0 : _u.texto) || ((_v = action.novo) === null || _v === void 0 ? void 0 : _v.isDispositivoAlteracao)) {
            if (!referencia.hasAlteracao()) {
                createAlteracao(referencia);
            }
            novo = criaDispositivoCabecaAlteracao(referencia.tipo, referencia.alteracoes);
            novo.texto = ((_y = (_x = (_w = action.novo) === null || _w === void 0 ? void 0 : _w.conteudo) === null || _x === void 0 ? void 0 : _x.texto) === null || _y === void 0 ? void 0 : _y.length) > 0 ? (_0 = (_z = action.novo) === null || _z === void 0 ? void 0 : _z.conteudo) === null || _0 === void 0 ? void 0 : _0.texto : '';
        }
        else {
            novo = createFromReferencia(referencia);
            novo.texto = (_3 = (_2 = (_1 = action.novo) === null || _1 === void 0 ? void 0 : _1.conteudo) === null || _2 === void 0 ? void 0 : _2.texto) !== null && _3 !== void 0 ? _3 : '';
        }
    }
    return novo;
};
const createFromReferencia = (referencia) => {
    if (referencia.hasAlteracao()) {
        return createWhenReferenciaBlocoAlteracao(referencia);
    }
    if (isArtigo(referencia)) {
        if (!isDispositivoAlteracao(referencia)) {
            return createWhenReferenciaIsArtigo(referencia);
        }
        return criaDispositivo(referencia.caput, TipoDispositivo.inciso.tipo, undefined, 0);
    }
    if (isAgrupador(referencia)) {
        return createWhenReferenciaIsAgrupador(referencia);
    }
    if (isDispositivoAlteracao(referencia)) {
        if (isOmissis(referencia)) {
            return criaDispositivo(referencia.pai, isArtigo(referencia.pai) ? TipoDispositivo.paragrafo.tipo : referencia.pai.tipoProvavelFilho, referencia);
        }
        return hasFilhos(referencia) || hasIndicativoDesdobramento(referencia)
            ? criaDispositivo(referencia, referencia.tipoProvavelFilho, referencia)
            : criaDispositivo(referencia.pai, referencia.tipo, referencia);
    }
    if (isEmenta(referencia)) {
        return criaDispositivo(referencia.pai, TipoDispositivo.artigo.tipo, undefined, 0);
    }
    return createFromReferenciaDefault(referencia);
};
const createWhenReferenciaBlocoAlteracao = (referencia) => {
    var _a;
    if (referencia.pai.isLastFilho(referencia) && ((_a = referencia === null || referencia === void 0 ? void 0 : referencia.pai) === null || _a === void 0 ? void 0 : _a.pai)) {
        return criaDispositivo(referencia.pai.pai, referencia.pai.tipo, referencia.pai);
    }
    return criaDispositivo(referencia.pai, referencia.tipo, referencia);
};
const createFromReferenciaDefault = (referencia) => {
    if (hasIndicativoDesdobramento(referencia)) {
        const type = referencia.tipoProvavelFilho;
        return referencia.pai.filhos.length > 0 ? criaDispositivo(referencia, type, undefined, 0) : criaDispositivo(referencia, type);
    }
    if (referencia.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL && hasIndicativoFinalSequencia(referencia) && referencia.pai.isLastFilho(referencia)) {
        if (isIncisoCaput(referencia)) {
            const artigo = referencia.pai.pai;
            return artigo.filhos.filter(filho => isParagrafo(filho)).length > 0
                ? criaDispositivo(artigo, TipoDispositivo.paragrafo.tipo, undefined, 0)
                : criaDispositivo(artigo, TipoDispositivo.paragrafo.tipo);
        }
        else {
            return criaDispositivo(referencia.pai.pai, referencia.pai.tipo, referencia.pai);
        }
    }
    return criaDispositivo(referencia.pai, referencia.tipo, referencia);
};
const createWhenReferenciaIsArtigo = (referencia) => {
    if (hasIndicativoDesdobramento(referencia)) {
        const type = referencia.tipoProvavelFilho;
        if (type === TipoDispositivo.inciso.tipo) {
            const parent = referencia.caput;
            return parent.filhos.length > 0 ? criaDispositivo(parent, type, undefined, 0) : criaDispositivo(parent, type);
        }
        return referencia.pai.filhos.length > 0 ? criaDispositivo(referencia, type, undefined, 0) : criaDispositivo(referencia, type);
    }
    if (hasIndicativoContinuacaoSequencia(referencia) && referencia.filhos.length > 0 && isParagrafo(referencia.filhos[0])) {
        return criaDispositivo(referencia, TipoDispositivo.paragrafo.tipo, undefined, 0);
    }
    return criaDispositivo(referencia.pai, referencia.tipo, referencia);
};
const createWhenReferenciaIsAgrupador = (referencia) => {
    return criaDispositivo(referencia, TipoDispositivo.artigo.tipo, undefined, 0);
};
const criaDispositivoCabecaAlteracao = (tipo, alteracoes, referencia, posicao) => {
    const dispositivo = criaDispositivo(alteracoes, tipo, referencia, posicao);
    dispositivo.situacao = new DispositivoAdicionado();
    dispositivo.isDispositivoAlteracao = true;
    dispositivo.notaAlteracao = 'NR';
    dispositivo.createRotulo(dispositivo);
    return dispositivo;
};
const desativaRotuloAutomaticoSeDispositivoAlteracao = (dispositivo) => {
    if (isDispositivoAlteracao(dispositivo)) {
        // dispositivo.renumeraFilhos = (): void => undefined;
        // if (isArtigo(dispositivo)) {
        //   (dispositivo as Artigo).caput!.renumeraFilhos = (): void => undefined;
        // }
        getArticulacao(dispositivo).renumeraFilhos = () => undefined;
        getArticulacao(dispositivo).renumeraArtigos = () => undefined;
    }
};

const regex = new Map();
regex.set('Alinea', /(al[ií]nea|ali.?\s)\s*([uú]nica|[a-z]+[)]?(?:-[a-z])?).*/i);
regex.set('Artigo', /(art\.?|artigo)\s*([uú]nico\s*|\d+(?:-[a-z])?).*/i);
regex.set('Inciso', /(inciso|inc.?\s)\s*([uú]nico|[MDCLXVI]+[)]?(?:-[a-z])?).*/i);
regex.set('Item', /(item)\s*([uú]nico\s*|\d+(?:-[a-z])?).*/i);
regex.set('Paragrafo', /(§|par[aá]grafo|par.?\s)\s*([uú]nico\s*|\d+(?:-[a-z])?).*/i);
const processaFilhos = (dispositivo, referencias, modo) => {
    let parent = dispositivo;
    referencias === null || referencias === void 0 ? void 0 : referencias.forEach(referencia => {
        var _a, _b;
        if (!((_a = parent.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.includes((_b = referencia.tipo) === null || _b === void 0 ? void 0 : _b.tipo))) {
            if (referencia.numero && referencia.numero.match(/\d.*/)) {
                parent = criaDispositivo(parent, isArtigo(parent) ? TipoDispositivo.paragrafo.tipo : isAlinea(parent) ? TipoDispositivo.item.tipo : TipoDispositivo.generico.tipo);
                referencia.numero && parent.createNumeroFromRotulo(referencia.numero);
                parent.createRotulo(parent);
            }
            else {
                parent = criaDispositivo(parent, TipoDispositivo.generico.tipo);
                parent.rotulo = referencia.numero;
            }
        }
        else {
            parent = criaDispositivo(parent, referencia.tipo.tipo);
            referencia.numero && parent.createNumeroFromRotulo(referencia.numero);
            parent.createRotulo(parent);
        }
        if (modo) {
            parent.situacao.tipoEmenda = modo;
        }
        parent.isDispositivoAlteracao = true;
        parent.situacao = new DispositivoAdicionado();
        parent.situacao.existeNaNormaAlterada = true;
        parent.id = buildId(parent);
        if (isArtigo(parent)) {
            parent.caput.situacao = new DispositivoAdicionado();
            if (modo) {
                parent.caput.situacao.tipoEmenda = modo;
            }
        }
        parent.mensagens = validaDispositivo(parent);
    });
};
const buildCabecaAlteracao = (dispositivo, referencia, modo) => {
    if (!dispositivo.hasAlteracao()) {
        createAlteracao(dispositivo);
        dispositivo.alteracoes.situacao = new DispositivoAdicionado();
        dispositivo.alteracoes.situacao.tipoEmenda = modo;
    }
    const cabeca = criaDispositivoCabecaAlteracao(TipoDispositivo.artigo.tipo, dispositivo.alteracoes, undefined, 0);
    cabeca.isDispositivoAlteracao = true;
    cabeca.situacao = new DispositivoAdicionado();
    cabeca.situacao.tipoEmenda = modo;
    cabeca.situacao.existeNaNormaAlterada = true;
    referencia.numero && cabeca.createNumeroFromRotulo(referencia.numero);
    cabeca.createRotulo(cabeca);
    cabeca.id = buildId(cabeca);
    if (isArtigo(cabeca)) {
        cabeca.caput.situacao = new DispositivoAdicionado();
        cabeca.caput.situacao.tipoEmenda = modo;
    }
    return cabeca;
};
const buildDispositivosAssistente = (texto, dispositivo, modo = ClassificacaoDocumento.EMENDA) => {
    const referencias = identificaReferencias(texto);
    let artigoInformado = true;
    if (!referencias || referencias.length === 0) {
        throw new Error('Não foi possível informado o dispositivo');
    }
    if (referencias[0].tipo !== TipoDispositivo.artigo) {
        if (referencias.reverse()[0].tipo !== TipoDispositivo.artigo) {
            artigoInformado = false;
        }
    }
    const c = artigoInformado ? referencias.shift() : undefined;
    const cabeca = buildCabecaAlteracao(dispositivo, c !== null && c !== void 0 ? c : { tipo: TipoDispositivo.artigo }, modo);
    processaFilhos(cabeca, referencias, modo);
    return cabeca;
};
const validaDispositivoAssistente = (texto) => {
    return buildDispositivosAssistente(texto, criaDispositivo(createArticulacao(), TipoDispositivo.artigo.tipo));
};
const identificaTipo = (texto) => {
    if (texto.trim().match(/ali|al[ií]nea.*/i)) {
        return TipoDispositivo.alinea;
    }
    if (texto.trim().match(/art[igo]?.*/i)) {
        return TipoDispositivo.artigo;
    }
    if (texto.trim().match(/inc|inciso.*/i)) {
        return TipoDispositivo.inciso;
    }
    if (texto.trim().match(/item.*/i)) {
        return TipoDispositivo.item;
    }
    if (texto.trim().match(/§|par[ágrafo]?.*/i)) {
        return TipoDispositivo.paragrafo;
    }
    return;
};
// const normaliza = (p: string[]): string[] => {
//   for (let i = 0; i < p.length - 1; i += 2) {
//     const tipo = identificaTipo(p[i]);
//     if (tipo === TipoDispositivo.generico) {
//       if (isRomano(p[i][0].trim())) {
//         p.splice(i, 0, 'inciso');
//       } else if (isLetra(p[i][0].trim())) {
//         p.splice(i, 0, 'alinea');
//       } else {
//         p.splice(i, 0, 'generico');
//       }
//       continue;
//     }
//   }
//   return p;
// };
const identificaReferencias = (texto) => {
    const resultParser = new ReferenciaDispositivoParser(texto);
    if (resultParser.valido) {
        return resultParser.referencias;
    }
    return undefined;
    // let p = texto
    //   .replace(',', '')
    //   .replace('º', '')
    //   .replace(/\s+d[ao]+\s+/gi, ' ')
    //   .replace(/\s*caput\s*/, ' ')
    //   .split(' ')
    //   .filter(e => e.length !== 0);
    // p = normaliza(p);
    // const resultado: ReferenciaDispositivo[] = [];
    // for (let i = 0, j = 1; i < p.length - 1, j <= p.length - 1; i += 2, j += 2) {
    //   const tipo = identificaTipo(p[i]);
    //   if (!tipo) {
    //     throw new Error(`Não pude identificar o tipo no texto informado: ${p[i]}`);
    //   }
    //   const r = regex.get(tipo.tipo);
    //   if (!r) {
    //     resultado.push({ tipo, numero: p[j] });
    //     continue;
    //   }
    //   const matches = `${p[i]} ${p[j]}`.match(r);
    //   if (matches && matches.length === 3) {
    //     resultado.push({ tipo, numero: matches[2] });
    //   } else {
    //     resultado.push({ tipo, numero: undefined });
    //   }
    // }
    // return resultado;
};
class ReferenciaDispositivoParser {
    constructor(texto) {
        this.texto = texto;
        this.valido = false;
        this.referencias = [];
        this.regexEncaixe = '(?:-[a-z]+){0,3}';
        this.regexArtigo = `(art|artigo)\\s([uú]nico|\\d+${this.regexEncaixe})`;
        this.regexParagrafo = `(§|par[aá]grafo|par)\\s([uú]nico|\\d+${this.regexEncaixe})`;
        this.regexInciso = `(inciso|inc)\\s([uú]nico|X{0,3}(?:IX|IV|[XV]?I{0,3})${this.regexEncaixe})`;
        this.regexAlinea = `(al[ií]nea|al[ií])\\s([a-z]+${this.regexEncaixe})`;
        this.regexItem = `(item)\\s(\\d+${this.regexEncaixe})`;
        this.regex = `^(?:(?:(?:(?:${this.regexItem}\\s)?(?:${this.regexAlinea}\\s))?(?:${this.regexInciso}\\s))?(?:${this.regexParagrafo}\\s)?)?(?:${this.regexArtigo})$`;
        this.parse();
    }
    parse() {
        this.preparaTexto();
        const execArray = new RegExp(this.regex, 'gi').exec(this.texto);
        if (execArray) {
            this.valido = true;
            const p = execArray.slice(1).filter(s => s !== undefined);
            for (let i = 0, j = 1; i < p.length - 1, j <= p.length - 1; i += 2, j += 2) {
                const tipo = identificaTipo(p[i]);
                if (!tipo) {
                    throw new Error(`Não pude identificar o tipo no texto informado: ${p[i]}`);
                }
                this.referencias.push({ tipo, numero: p[j] });
            }
        }
    }
    preparaTexto() {
        this.texto = this.texto
            .toLowerCase()
            .replace(/[º°\\.]/g, '')
            .replace(/[,;]/g, ' ')
            .replace(/\sd[ao]\s/g, ' ')
            .replace(/\scaput\s/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
    }
}

const ATIVAR_DESATIVAR_REVISAO = 'ATIVAR_DESATIVAR_REVISAO';
class AtivarDesativarRevisao {
    constructor() {
        this.descricao = 'Ativar/Desativar revisão';
    }
    execute() {
        return {
            type: ATIVAR_DESATIVAR_REVISAO,
        };
    }
}
const ativarDesativarRevisaoAction = new AtivarDesativarRevisao();

var Modo;
(function (Modo) {
    Modo["JUSTIFICATIVA"] = "justificativa";
    Modo["TEXTO_LIVRE"] = "textoLivre";
})(Modo || (Modo = {}));

const getRevisoesElemento = (revisoes = []) => {
    return revisoes.filter(isRevisaoElemento).map(r => r);
};
const findRevisaoById = (revisoes = [], idRevisao) => {
    return revisoes === null || revisoes === void 0 ? void 0 : revisoes.find(r => r.id === idRevisao);
};
const findRevisaoByElementoUuid = (revisoes = [], uuid = 0) => {
    return getRevisoesElemento(revisoes)
        .filter(r => r.elementoAposRevisao.uuid === uuid)
        .slice(-1)[0];
};
const findRevisaoByElementoUuid2 = (revisoes = [], uuid2 = '') => {
    return getRevisoesElemento(revisoes)
        .filter(r => r.elementoAposRevisao.uuid2 === uuid2)
        .slice(-1)[0];
};
const findRevisoesByElementoUuid = (revisoes = [], uuid = 0) => {
    return getRevisoesElemento(revisoes).filter(r => r.elementoAposRevisao.uuid === uuid);
};
const findRevisoesByElementoUuid2 = (revisoes = [], uuid2 = '') => {
    return getRevisoesElemento(revisoes).filter(r => r.elementoAposRevisao.uuid2 === uuid2);
};
const findRevisoesByElementoLexmlId = (revisoes = [], lexmlId = '') => {
    return getRevisoesElemento(revisoes).filter(r => r.elementoAposRevisao.lexmlId === lexmlId);
};
const existeRevisaoParaElementos = (revisoes = [], elementos) => {
    const revisoesElemento = getRevisoesElemento(revisoes);
    return elementos.some(e => revisoesElemento.some(r => r.elementoAposRevisao.uuid === e.uuid));
};
const identificarRevisaoElementoPai = (state, revisoes) => {
    const result = [];
    revisoes === null || revisoes === void 0 ? void 0 : revisoes.forEach(r => {
        var _a, _b, _c, _d;
        if (isRevisaoElemento(r)) {
            const rAux = r;
            const uuidPai = rAux.stateType === StateType.ElementoIncluido ? getUuidPaiElementoRevisado(state, rAux) : (_c = (_b = (_a = rAux.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.hierarquia) === null || _b === void 0 ? void 0 : _b.pai) === null || _c === void 0 ? void 0 : _c.uuid;
            const rPai = uuidPai ? findRevisaoByElementoUuid(rAux.actionType === ADICIONAR_ELEMENTO ? state.revisoes : revisoes, uuidPai) : undefined;
            if (rPai && isRevisaoMesmaSituacao(rAux, rPai)) {
                rAux.idRevisaoElementoPai = rPai.id;
                rAux.idRevisaoElementoPrincipal = (_d = findRevisaoElementoPrincipal(state, revisoes, rPai)) === null || _d === void 0 ? void 0 : _d.id;
            }
        }
        result.push(r);
    });
    return result;
};
const findRevisaoElementoPrincipal = (state, revisoes, rPai) => {
    var _a, _b, _c;
    const uuid = rPai.stateType === StateType.ElementoIncluido ? getUuidPaiElementoRevisado(state, rPai) : (_c = (_b = (_a = rPai.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.hierarquia) === null || _b === void 0 ? void 0 : _b.pai) === null || _c === void 0 ? void 0 : _c.uuid;
    const rAux = rPai && findRevisaoByElementoUuid(revisoes, uuid);
    return rAux ? findRevisaoElementoPrincipal(state, revisoes, rAux) : rPai;
};
const buildDescricaoRevisao = (revisao) => {
    return isRevisaoElemento(revisao) ? buildDescricaoRevisaoElemento(revisao) : buildDescricaoRevisaoTexto(revisao);
};
const mapperActionTypeToDescricao = {
    [ADICIONAR_ELEMENTO]: () => 'Dispositivo adicionado',
    [REMOVER_ELEMENTO]: () => 'Dispositivo removido',
    [SUPRIMIR_ELEMENTO]: () => 'Dispositivo suprimido',
    [ATUALIZAR_TEXTO_ELEMENTO]: () => 'Texto do dispositivo foi alterado',
    [MOVER_ELEMENTO_ABAIXO]: (revisao) => buildDescricaoRevisaoFromMovimentacaoElemento(revisao),
    [MOVER_ELEMENTO_ACIMA]: () => 'Dispositivo movido',
    [RESTAURAR_ELEMENTO]: () => 'Dispositivo restaurado',
    [ADICIONAR_ELEMENTOS_FROM_CLIPBOARD]: (revisao) => buildDescricaoRevisaoFromStateType(revisao),
    [UNDO]: (revisao) => buildDescricaoRevisaoFromStateType(revisao),
    [REDO]: (revisao) => buildDescricaoRevisaoFromStateType(revisao),
};
const mapperStateTypeToDescricao = {
    [StateType.ElementoIncluido]: () => 'Dispositivo adicionado',
    [StateType.ElementoRemovido]: () => 'Dispositivo removido',
    [StateType.ElementoRestaurado]: () => 'Dispositivo restaurado',
    [StateType.ElementoModificado]: () => 'Texto do dispositivo foi alterado',
    [StateType.ElementoSuprimido]: () => 'Dispositivo suprimido',
    // [StateType.ElementoMovido]: (): string => 'Dispositivo movido',
};
const buildDescricaoRevisaoElemento = (revisao) => {
    const fn = mapperActionTypeToDescricao[revisao.actionType];
    return fn ? mapperActionTypeToDescricao[revisao.actionType](revisao) : buildDescricaoRevisaoFromStateType(revisao);
};
const buildDescricaoRevisaoTexto = (revisao) => {
    var _a;
    return (_a = revisao.descricao) !== null && _a !== void 0 ? _a : '';
};
const buildDescricaoRevisaoFromMovimentacaoElemento = (revisao) => {
    const { tipo, rotulo } = revisao.elementoAntesRevisao || { tipo: '', numero: 0 };
    return `Dispositivo movido${tipo ? ` (antes era "${tipo} ${rotulo}")` : ''}`;
};
const buildDescricaoRevisaoFromStateType = (revisao, elementoAposRevisao) => {
    const isUndoRedoDeMovimentacao = revisao.elementoAntesRevisao && elementoAposRevisao && revisao.elementoAntesRevisao.numero !== elementoAposRevisao.numero;
    return isUndoRedoDeMovimentacao ? buildDescricaoRevisaoFromMovimentacaoElemento(revisao) : mapperStateTypeToDescricao[revisao.stateType]();
};
const getUuidPaiElementoRevisado = (state, revisao) => {
    // return revisao.elementoAposRevisao.hierarquia?.pai?.uuid || 0;
    return getUuidPai(state, revisao.elementoAposRevisao) || 0;
};
const getUuidPai = (state, elemento) => {
    var _a, _b, _c, _d, _e, _f;
    const d = getDispositivoFromElemento(state.articulacao, elemento);
    if (!d) {
        return undefined;
    }
    else if (isDispositivoAlteracao(d)) {
        return isArticulacaoAlteracao(d.pai) || isCaput(d.pai) ? (_b = (_a = d.pai) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.uuid : (_c = d.pai) === null || _c === void 0 ? void 0 : _c.uuid;
    }
    else {
        return isCaput(d.pai) ? (_e = (_d = d.pai) === null || _d === void 0 ? void 0 : _d.pai) === null || _e === void 0 ? void 0 : _e.uuid : (_f = d.pai) === null || _f === void 0 ? void 0 : _f.uuid;
    }
};
const isRevisaoMesmaSituacao = (r, rPai) => {
    var _a, _b;
    // return r.stateType !== StateType.ElementoModificado && rPai.elementoAntesRevisao?.descricaoSituacao === r.elementoAntesRevisao?.descricaoSituacao;
    return (r.stateType !== StateType.ElementoModificado && ((_a = rPai.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.descricaoSituacao) === ((_b = r.elementoAntesRevisao) === null || _b === void 0 ? void 0 : _b.descricaoSituacao) && r.stateType === rPai.stateType);
};
const getRevisoesElementoAssociadas = (revisoes = [], revisao) => {
    return [revisao, ...getRevisoesElemento(revisoes).filter(r => r.idRevisaoElementoPrincipal === revisao.id)];
};
const getElementosFromRevisoes = (revisoes = [], state) => {
    return revisoes.filter(isRevisaoElemento).map(r => {
        const e = r.elementoAposRevisao;
        return state ? createElemento(getDispositivoFromElemento(state.articulacao, e)) : e;
    });
};
const getRevisoesFromElementos = (elementos = []) => elementos.map(e => e.revisao);
const isRevisaoElemento = (revisao) => 'elementoAposRevisao' in revisao;
const isRevisaoJustificativa = (revisao) => !isRevisaoElemento(revisao);
const existeFilhoExcluidoDuranteRevisao = (state, dispositivo) => {
    var _a;
    if (!((_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.length)) {
        return false;
    }
    const uuids = getDispositivoAndFilhosAsLista(dispositivo).map(d => d.uuid);
    return state.revisoes
        .filter(r => isRevisaoElemento(r) && isRevisaoDeExclusao(r))
        .map(r => r)
        .some(r => { var _a, _b, _c, _d; return uuids.includes((_a = r.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.uuid) || uuids.includes((_d = (_c = (_b = r.elementoAntesRevisao) === null || _b === void 0 ? void 0 : _b.hierarquia) === null || _c === void 0 ? void 0 : _c.pai) === null || _d === void 0 ? void 0 : _d.uuid); });
};
const existeFilhoExcluidoOuAlteradoDuranteRevisao = (state, dispositivo) => {
    var _a;
    if (!((_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.length)) {
        return false;
    }
    const uuids = getDispositivoAndFilhosAsLista(dispositivo).map(d => d.uuid);
    return state.revisoes
        .filter(isRevisaoElemento)
        .map(r => r)
        .some(r => { var _a, _b, _c, _d; return uuids.includes((_a = r.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.uuid) || uuids.includes((_d = (_c = (_b = r.elementoAntesRevisao) === null || _b === void 0 ? void 0 : _b.hierarquia) === null || _c === void 0 ? void 0 : _c.pai) === null || _d === void 0 ? void 0 : _d.uuid); });
};
const isRevisaoPrincipal = (revisao) => isRevisaoElemento(revisao) && !revisao.idRevisaoElementoPrincipal;
const existeRevisaoCriadaPorExclusao = (revisoes = []) => revisoes.some(r => isRevisaoDeExclusao(r));
var RevisaoJustificativaEnum;
(function (RevisaoJustificativaEnum) {
    RevisaoJustificativaEnum["JustificativaAlterada"] = "Justifica\u00E7\u00E3o Alterada";
})(RevisaoJustificativaEnum || (RevisaoJustificativaEnum = {}));
var RevisaoTextoLivreEnum;
(function (RevisaoTextoLivreEnum) {
    RevisaoTextoLivreEnum["TextoLivreAlterado"] = "Texto Livre Alterado";
})(RevisaoTextoLivreEnum || (RevisaoTextoLivreEnum = {}));
const ordernarRevisoes = (revisoes = []) => {
    const result = revisoes.filter(r => isRevisaoElemento(r) && !isRevisaoDeExclusao(r));
    result.push(...getRevisoesDeExclusaoOrdenadasPorUuid(revisoes));
    result.push(...revisoes.filter(isRevisaoJustificativa));
    return result;
};
const getRevisoesDeExclusaoOrdenadasPorUuid = (revisoes = []) => {
    return revisoes
        .filter(r => isRevisaoElemento(r) && isRevisaoDeExclusao(r))
        .sort((r1, r2) => r1.elementoAposRevisao.uuid - r2.elementoAposRevisao.uuid);
};
const isRevisaoDeExclusao = (revisao) => revisao.stateType === StateType.ElementoRemovido;
const removeAtributosDoElemento = (elemento) => {
    if (!elemento) {
        return;
    }
    delete elemento.acoesPossiveis;
    delete elemento.tiposAgrupadoresQuePodemSerInseridosAntes;
    delete elemento.tiposAgrupadoresQuePodemSerInseridosDepois;
    if (elemento.revisao) {
        elemento.revisao;
    }
    removeAtributosDoElementoAnteriorNaSequenciaDeLeitura(elemento.elementoAnteriorNaSequenciaDeLeitura);
};
const atributosPermitidos = ['tipo', 'uuid', 'uuid2', 'lexmlId', 'conteudo', 'descricaoSituacao', 'uuidAlteracao', 'uuid2Alteracao', 'existeNaNormaAlterada'];
const removeAtributosDoElementoAnteriorNaSequenciaDeLeitura = (elemento) => {
    if (!elemento) {
        return;
    }
    for (const key in elemento) {
        if (!atributosPermitidos.includes(key)) {
            delete elemento[key];
        }
    }
};
const getQuantidadeRevisoes = (revisoes = []) => {
    return revisoes.filter(isRevisaoPrincipal).length;
};
const getQuantidadeRevisoesJustificativa = (revisoes = []) => {
    return revisoes.filter(e => e.descricao === RevisaoJustificativaEnum.JustificativaAlterada).length;
};
const mostrarDialogDisclaimerRevisao = () => {
    if (localStorage.getItem('naoMostrarNovamenteDisclaimerMarcaAlteracao') !== 'true') {
        const dialog = document.createElement('sl-dialog');
        dialog.label = 'Marcas de revisão';
        const botoesHtml = ` <sl-button slot="footer" variant="primary" id="closeButton">Fechar</sl-button>`;
        dialog.innerHTML = `
      Todas as alterações realizadas no texto serão registradas e ficarão disponíveis para consulta.
      Esta é uma versão inicial da funcionalidade de controle de alterações/marcas de revisão.
      <br><br>
      <sl-switch id="chk-nao-mostrar-modal-novamente">Não mostrar mais essa mensagem</sl-switch>
    `.concat(botoesHtml);
        document.body.appendChild(dialog);
        dialog.show();
        dialog.addEventListener('sl-request-close', (event) => {
            if (event.detail.source === 'overlay') {
                event.preventDefault();
            }
        });
        const chkNaoMostrarNovamente = dialog.querySelector('#chk-nao-mostrar-modal-novamente');
        chkNaoMostrarNovamente === null || chkNaoMostrarNovamente === void 0 ? void 0 : chkNaoMostrarNovamente.addEventListener('sl-change', () => {
            salvaNoNavegadorOpcaoNaoMostrarNovamente();
        });
        const closeButton = dialog.querySelector('#closeButton[slot="footer"]');
        closeButton === null || closeButton === void 0 ? void 0 : closeButton.addEventListener('click', () => {
            dialog.hide();
            dialog.remove();
        });
    }
};
const getQuantidadeRevisoesTextoLivre = (revisoes = []) => {
    return revisoes.filter(e => e.descricao === RevisaoTextoLivreEnum.TextoLivreAlterado).length;
};
const salvaNoNavegadorOpcaoNaoMostrarNovamente = () => {
    const checkbox = document.getElementById('chk-nao-mostrar-modal-novamente');
    if (checkbox) {
        localStorage.setItem('naoMostrarNovamenteDisclaimerMarcaAlteracao', checkbox.checked ? 'true' : 'false');
    }
};
const ativarDesativarMarcaDeRevisao = (rootStore) => {
    rootStore.dispatch(ativarDesativarRevisaoAction.execute());
};
const atualizaQuantidadeRevisao = (revisoes = [], element, modo) => {
    const quantidade = modo === Modo.JUSTIFICATIVA
        ? getQuantidadeRevisoesJustificativa(revisoes)
        : modo === 'textoLivre'
            ? getQuantidadeRevisoesTextoLivre(revisoes)
            : getQuantidadeRevisoes(revisoes);
    if (element) {
        element.innerHTML = quantidade;
    }
};
const setCheckedElement = (element, checked) => {
    if (element) {
        if (checked) {
            element.setAttribute('checked', '');
        }
        else {
            element.removeAttribute('checked');
        }
    }
};
const atualizaReferenciaElementoAnteriorSeNecessario = (articulacao, revisoes = [], elemento, tipoProcessamento) => {
    // Procura o elemento anterior ao excluído/incluído nos elementos anteriores das outras revisões.
    const rAux = findRevisaoDeExclusaoComElementoAnteriorApontandoPara(revisoes, elemento.elementoAnteriorNaSequenciaDeLeitura);
    if (rAux) {
        if (tipoProcessamento === 'exclusao') {
            // Pega a última revisão do grupo da revisão principal (rAux) e utiliza o "elementoAposRevisao" como elemento anterior do atual elemento removido
            elemento.elementoAnteriorNaSequenciaDeLeitura = JSON.parse(JSON.stringify(findUltimaRevisaoDoGrupo(revisoes, rAux).elementoAposRevisao));
            removeAtributosDoElementoAnteriorNaSequenciaDeLeitura(elemento.elementoAnteriorNaSequenciaDeLeitura);
        }
        else {
            // Pega o último filho do elemento incluído e utiliza como elemento anterior da revisão principal (rAux)
            const dPrimeiroElementoIncluido = getDispositivoFromElemento(articulacao, elemento);
            const ultimoFilho = createElemento(getUltimoFilho(dPrimeiroElementoIncluido));
            removeAtributosDoElementoAnteriorNaSequenciaDeLeitura(ultimoFilho);
            rAux.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura = ultimoFilho;
            rAux.elementoAntesRevisao.elementoAnteriorNaSequenciaDeLeitura = ultimoFilho;
            const ePrimeiroElementoIncluido = createElemento(dPrimeiroElementoIncluido);
            if (isAtualizarPosicaoDeElementoExcluido(ePrimeiroElementoIncluido, rAux.elementoAposRevisao)) {
                rAux.elementoAposRevisao.hierarquia.posicao = ePrimeiroElementoIncluido.hierarquia.posicao + 1;
                rAux.elementoAntesRevisao.hierarquia.posicao = ePrimeiroElementoIncluido.hierarquia.posicao + 1;
            }
        }
    }
};
const findRevisaoDeExclusaoComElementoAnteriorApontandoPara = (revisoes = [], elementoAnteriorNaSequenciaDeLeitura) => {
    return revisoes
        .filter(isRevisaoElemento)
        .map(r => r)
        .filter(isRevisaoDeExclusao)
        .find(r => r.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura.uuid === elementoAnteriorNaSequenciaDeLeitura.uuid);
};
const findUltimaRevisaoDoGrupo = (revisoes = [], revisao) => {
    return (revisoes
        .map(r => r)
        .filter(r => r.idRevisaoElementoPrincipal === revisao.id)
        .slice(-1)[0] || revisao);
};
const isRevisaoDeMovimentacao = (revisao) => {
    const r = revisao;
    return !!(isRevisaoElemento(revisao) &&
        r.stateType === StateType.ElementoIncluido &&
        r.elementoAntesRevisao &&
        r.elementoAposRevisao &&
        r.elementoAntesRevisao.tipo === r.elementoAposRevisao.tipo);
};
const isRevisaoDeTransformacao = (revisao) => {
    const r = revisao;
    return !!(isRevisaoElemento(revisao) && r.elementoAntesRevisao && r.elementoAposRevisao && r.elementoAntesRevisao.tipo !== r.elementoAposRevisao.tipo);
};
const isRevisaoDeModificacao = (revisao) => {
    return isRevisaoElemento(revisao) && revisao.stateType === StateType.ElementoModificado;
};
const isRevisaoDeRestauracao = (revisao) => {
    return isRevisaoElemento(revisao) && revisao.stateType === StateType.ElementoRestaurado;
};
const isAtualizarPosicaoDeElementoExcluido = (elementoIncluido, elementoExcluido) => {
    var _a, _b, _c, _d;
    return ((_b = (_a = elementoIncluido.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.lexmlId) === ((_d = (_c = elementoExcluido.hierarquia) === null || _c === void 0 ? void 0 : _c.pai) === null || _d === void 0 ? void 0 : _d.lexmlId) && elementoIncluido.uuid < elementoExcluido.uuid;
};
const findRevisaoDeRestauracaoByUuid = (revisoes = [], uuid) => {
    return revisoes.map(r => r).find(r => isRevisaoElemento(r) && r.stateType === StateType.ElementoRestaurado && r.elementoAposRevisao.uuid === uuid);
};
const associarRevisoesAosElementosDosEventos = (state) => {
    var _a;
    (_a = state.ui) === null || _a === void 0 ? void 0 : _a.events.filter(se => se.stateType !== StateType.RevisaoRejeitada).filter(se => se.stateType !== StateType.RevisaoAdicionalRejeitada).forEach(se => associarRevisoesAosElementos(state.revisoes, se.elementos));
};
const associarRevisoesAosElementos = (revisoes = [], elementos = []) => {
    elementos.filter(Boolean).forEach(e => {
        const r = findRevisaoByElementoUuid(revisoes, e.uuid);
        e.revisao = r ? JSON.parse(JSON.stringify(r)) : undefined;
    });
};
const mergeEventosStatesAposAceitarOuRejeitarMultiplasRevisoes = (state, tempStates, revisoes, operacao) => {
    var _a, _b;
    const eventosParaUnificar = {
        aceitar: [StateType.ElementoValidado],
        rejeitar: [
            StateType.ElementoIncluido,
            StateType.ElementoRemovido,
            StateType.ElementoSuprimido,
            StateType.ElementoRenumerado,
            StateType.ElementoValidado,
            StateType.ElementoSelecionado,
            StateType.ElementoMarcado,
            StateType.SituacaoElementoModificada,
        ],
    };
    let eventosPast = [];
    let eventos = [];
    tempStates.forEach(tempState => {
        eventosPast.push(...tempState.past[0]);
        eventos.push(...tempState.ui.events);
    });
    const tempState = { ...state };
    eventosParaUnificar[operacao].forEach(stateType => {
        eventosPast = unificarEvento(tempState, eventosPast, stateType);
        eventos = unificarEvento(tempState, eventos, stateType);
    });
    const idsRevisoes = revisoes.map(r => r.id);
    tempState.past = buildPast(tempState, eventosPast);
    tempState.present = eventos;
    tempState.future = [];
    tempState.ui = {
        events: eventos,
        alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
    };
    tempState.revisoes = (_b = state.revisoes) === null || _b === void 0 ? void 0 : _b.filter((r) => !idsRevisoes.includes(r.id));
    return tempState;
};

class DispositivoOriginal {
    constructor() {
        this.descricaoSituacao = DescricaoSituacao.DISPOSITIVO_ORIGINAL;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAcoesPermitidas(dispositivo, acoes) {
        const acoesFiltradas = acoes
            .filter((a) => !(a instanceof AgruparElemento))
            .filter((a) => !(a instanceof RemoverElemento))
            .filter((a) => { var _a; return !((_a = a.descricao) === null || _a === void 0 ? void 0 : _a.startsWith('Mover')); })
            .filter((a) => !(a instanceof TransformarElemento))
            .filter((a) => !(a instanceof RenumerarElemento))
            .filter((a) => !(a instanceof InformarNorma));
        if (!isEmenta(dispositivo) &&
            (!isAgrupador(dispositivo) || !isDispositivoAlteracao(dispositivo)) &&
            getDispositivoAndFilhosAsLista(dispositivo).filter(f => isSituacaoExclusivaDispositivoEmenda(f)).length === 0) {
            acoesFiltradas.push(suprimirElementoAction);
        }
        if (isAgrupador(dispositivo) && isDispositivoAlteracao(dispositivo)) {
            acoesFiltradas.push(suprimirAgrupadorAction);
        }
        return acoesFiltradas;
    }
}

const textoFoiModificado = (atual, action, state) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (state && ((_a = state.ui) === null || _a === void 0 ? void 0 : _a.events)) {
        const ev = getEvento(state.ui.events, StateType.ElementoModificado);
        if (ev && ev.elementos && ((_c = (_b = ev.elementos[0]) === null || _b === void 0 ? void 0 : _b.conteudo) === null || _c === void 0 ? void 0 : _c.texto) === atual.texto) {
            return true;
        }
    }
    return (atual.texto !== '' && ((_e = (_d = action.atual) === null || _d === void 0 ? void 0 : _d.conteudo) === null || _e === void 0 ? void 0 : _e.texto) === '') || (((_g = (_f = action.atual) === null || _f === void 0 ? void 0 : _f.conteudo) === null || _g === void 0 ? void 0 : _g.texto) && atual.texto.localeCompare((_j = (_h = action.atual) === null || _h === void 0 ? void 0 : _h.conteudo) === null || _j === void 0 ? void 0 : _j.texto) !== 0);
};
const resetUuidTodaArvore = (dispositivo) => {
    var _a;
    dispositivo.uuid = Counter.next();
    (_a = dispositivo.filhos) === null || _a === void 0 ? void 0 : _a.forEach(f => resetUuidTodaArvore(f));
};
const copiaDispositivosParaOutroPai = (pai, dispositivos) => {
    return dispositivos.map(d => {
        const posicaoAtualArtigo = isArtigo(d) ? getArticulacao(d).indexOfArtigo(d) : -1;
        const paiAtual = d.pai;
        const anterior = isArtigo(d) ? getDispositivoAnteriorMesmoTipo(d) : undefined;
        paiAtual === null || paiAtual === void 0 ? void 0 : paiAtual.removeFilho(d);
        d.pai = pai;
        pai.addFilho(d, anterior);
        if (isArtigo(d) && !anterior) {
            const articulacao = getArticulacao(d);
            articulacao.removeArtigo(d);
            articulacao.addArtigoOnPosition(d, posicaoAtualArtigo);
        }
        return d;
    });
};
const isPrimeiroArtigo = (dispositivo) => {
    return isArtigo(dispositivo) && getArticulacao(dispositivo).indexOfArtigo(dispositivo) === 0;
};
const isDesdobramentoAgrupadorAtual = (dispositivo, tipo) => {
    return dispositivo.pai.tipo === tipo;
};
const ajustaReferencia = (referencia, dispositivo) => {
    if (isArticulacao(referencia) && !isArticulacaoAlteracao(referencia) && hasEmenta(referencia)) {
        return referencia.projetoNorma.ementa;
    }
    return isArticulacao(referencia) || (isPrimeiroArtigo(dispositivo) && !isDispositivoAlteracao(dispositivo)) || dispositivo.pai.indexOf(dispositivo) === 0
        ? referencia
        : isPrimeiroParagrafo(dispositivo)
            ? getUltimoFilho(dispositivo.pai.caput)
            : getUltimoFilho(referencia);
};
function isPrimeiroParagrafo(dispositivo) {
    return isArtigo(dispositivo.pai) && getParagrafosEOmissis(dispositivo.pai).indexOf(dispositivo) === 0;
}
const naoPodeCriarFilho = (pDispositivo, action) => {
    var _a, _b, _c;
    const dispositivo = isCaput(pDispositivo) ? pDispositivo.pai : pDispositivo;
    return (isDispositivoGenerico(dispositivo) ||
        (hasIndicativoDesdobramento(dispositivo) && !isAcaoPermitida(dispositivo, AdicionarElemento)) ||
        (((_a = dispositivo.situacao) === null || _a === void 0 ? void 0 : _a.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_ORIGINAL && isNovoDispositivoDesmembrandoAtual((_c = (_b = action.novo) === null || _b === void 0 ? void 0 : _b.conteudo) === null || _c === void 0 ? void 0 : _c.texto)));
};
const isNovoDispositivoDesmembrandoAtual = (texto) => {
    return texto !== undefined && texto !== '';
};
const getElementosDoDispositivo = (dispositivo, valida = false) => {
    const lista = [];
    getDispositivoAndFilhosAsLista(dispositivo).forEach(d => {
        if (valida) {
            const mensagens = validaDispositivo(d);
            if (mensagens) {
                d.mensagens = mensagens;
                lista.push(createElemento(d, true, true));
            }
        }
        else {
            lista.push(createElemento(d, true, true));
        }
    });
    return lista;
};
const getElementosAlteracaoASeremAtualizados = (articulacao, elementos) => {
    const result = [];
    getDispositivosCabecaAlteracaoFromElementos(articulacao, elementos).forEach(d => result.push(...getElementos(d, true)));
    return result;
};
const getDispositivosCabecaAlteracaoFromElementos = (articulacao, elementos) => {
    const map = new Map();
    elementos.forEach(elemento => {
        var _a;
        const d = getDispositivoFromElemento(articulacao, elemento) || (((_a = elemento.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) && getDispositivoFromElemento(articulacao, elemento.hierarquia.pai));
        if (d && isDispositivoAlteracao(d)) {
            const ca = getDispositivoCabecaAlteracao(d);
            map.set(ca.id, ca);
        }
    });
    return Array.from(map.values());
};

const buildEventoAdicionarElemento = (atual, novo) => {
    const eventos = new Eventos();
    eventos.setReferencia(createElemento(ajustaReferencia(atual, novo)));
    eventos.add(StateType.ElementoIncluido, getElementosDoDispositivo(novo));
    eventos.add(StateType.ElementoRenumerado, buildListaElementosRenumerados(novo));
    eventos.add(StateType.ElementoValidado, criaListaElementosAfinsValidados(novo, false));
    if (isDispositivoAlteracao(atual)) {
        eventos.add(StateType.SituacaoElementoModificada, [createElemento(atual)]);
    }
    return eventos;
};
const buildEventoAtualizacaoElemento = (dispositivo) => {
    const eventos = new Eventos();
    const elemento = createElemento(dispositivo);
    elemento.mensagens = validaDispositivo(dispositivo);
    eventos.add(StateType.ElementoModificado, [elemento]);
    eventos.add(StateType.ElementoValidado, criaListaElementosAfinsValidados(dispositivo));
    return eventos;
};
const buildUpdateEvent = (dispositivo, original) => {
    dispositivo.mensagens = validaDispositivo(dispositivo);
    const elemento = createElemento(dispositivo);
    const elementos = original ? [original] : [];
    elementos.push(elemento);
    return [
        {
            stateType: StateType.ElementoModificado,
            elementos: elementos,
        },
        {
            stateType: StateType.ElementoValidado,
            elementos: criaListaElementosAfinsValidados(dispositivo, true),
        },
    ];
};
const buildEventoExclusaoElemento = (elementosRemovidos, dispositivosRenumerados, elementosValidados) => {
    const eventos = new Eventos();
    eventos.add(StateType.ElementoRemovido, elementosRemovidos);
    eventos.add(StateType.ElementoRenumerado, dispositivosRenumerados.map(d => createElemento(d)));
    eventos.add(StateType.ElementoValidado, elementosValidados);
    return eventos;
};
const buildEventoTransformacaooElemento = (atual, novo, elementosRemovidos, elementosRenumerados, elementosValidados) => {
    const eventos = new Eventos();
    eventos.setReferencia(createElemento(ajustaReferencia(atual, novo)));
    eventos.add(StateType.ElementoIncluido, getElementos(novo));
    eventos.add(StateType.ElementoRemovido, elementosRemovidos);
    eventos.add(StateType.ElementoRenumerado, elementosRenumerados);
    eventos.add(StateType.ElementoValidado, elementosValidados);
    return eventos;
};
const removeAndBuildEvents = (state, dispositivo) => {
    const articulacao = state.articulacao;
    const removidos = getElementos(dispositivo, false, true);
    const dispositivosRenumerados = listaDispositivosRenumerados(dispositivo);
    const dispositivoAnterior = getDispositivoAnterior(dispositivo);
    const ehDispositivoAlteracao = isDispositivoAlteracao(dispositivo);
    const pai = dispositivo.pai;
    pai.removeFilho(dispositivo);
    pai.renumeraFilhos();
    if (isArticulacaoAlteracao(pai) && pai.filhos.length === 0) {
        pai.pai.alteracoes = undefined;
    }
    const dispositivoValidado = dispositivoAnterior && (isArtigoUnico(dispositivoAnterior) || isParagrafoUnico(dispositivoAnterior)) ? dispositivoAnterior : isCaput(pai) ? pai.pai : pai;
    if (articulacao.artigos.length === 1) {
        dispositivosRenumerados.push(articulacao.artigos[0]);
    }
    const eventos = buildEventoExclusaoElemento(removidos, dispositivosRenumerados, criaListaElementosAfinsValidados(dispositivoValidado, false));
    if (ehDispositivoAlteracao) {
        eventos.add(StateType.ElementoValidado, criaListaElementosAfinsValidados(pai, true));
        if (dispositivoAnterior || pai) {
            try {
                const dispositivoParaAtualizar = dispositivoAnterior || (pai.tipo === 'Caput' ? pai.pai : pai);
                eventos.add(StateType.SituacaoElementoModificada, getElementos(dispositivoParaAtualizar));
            }
            catch (error) {
                eventos.add(StateType.SituacaoElementoModificada, []);
            }
        }
    }
    return eventos.build();
};
const removeAgrupadorAndBuildEvents = (articulacao, atual) => {
    let pos = atual.pai.indexOf(atual);
    const agrupadoresAnteriorMesmoTipo = atual.pai.filhos.filter((d, i) => i < pos && isAgrupador(d));
    const paiOriginal = atual.pai;
    const removido = createElemento(atual, false, true);
    const irmaoAnterior = getDispositivoAnteriorMesmoTipo(atual);
    const agrupadorAntes = getAgrupadorAntes(atual);
    const pai = (agrupadoresAnteriorMesmoTipo === null || agrupadoresAnteriorMesmoTipo === void 0 ? void 0 : agrupadoresAnteriorMesmoTipo.length) > 0 ? agrupadoresAnteriorMesmoTipo.reverse()[0] : atual.pai;
    const dispositivoAnterior = (agrupadoresAnteriorMesmoTipo === null || agrupadoresAnteriorMesmoTipo === void 0 ? void 0 : agrupadoresAnteriorMesmoTipo.length) > 0 ? agrupadoresAnteriorMesmoTipo.reverse()[0] : pos > 0 ? getUltimoFilho(pai.filhos[pos - 1]) : pai;
    const referencia = isArticulacao(dispositivoAnterior) || (hasFilhos(pai) && pai.filhos[0].id === atual.id) ? pai : getUltimoFilho(dispositivoAnterior);
    const transferidosParaOutroPai = [];
    let posNoPaiNovo = pai.filhos.length;
    atual.filhos.forEach(d => {
        var _a, _b;
        let novoPai;
        if (isArtigo(d)) {
            novoPai = agrupadorAntes !== null && agrupadorAntes !== void 0 ? agrupadorAntes : articulacao;
        }
        else if ((_a = pai.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.includes(d.tipo)) {
            novoPai = pai;
        }
        else if ((_b = dispositivoAnterior.tiposPermitidosFilhos) === null || _b === void 0 ? void 0 : _b.includes(d.tipo)) {
            novoPai = dispositivoAnterior;
        }
        else {
            novoPai = getPaiQuePodeReceberFilhoDoTipo(atual.pai, d.tipo, []);
        }
        d.pai = novoPai;
        atual.removeFilho(d);
        if ((agrupadoresAnteriorMesmoTipo === null || agrupadoresAnteriorMesmoTipo === void 0 ? void 0 : agrupadoresAnteriorMesmoTipo.length) > 0) {
            // TODO: revisar valor de "posNoPaiNovo" e "pos" (novoPai pode variar, como fica a posição???)
            novoPai.addFilhoOnPosition(d, posNoPaiNovo++);
        }
        else {
            novoPai.addFilhoOnPosition(d, pos++);
        }
        transferidosParaOutroPai.push(createElemento(d));
        return d;
    });
    atual.pai.removeFilho(atual);
    pai === null || pai === void 0 ? void 0 : pai.renumeraFilhos();
    paiOriginal.renumeraFilhos();
    const renumerados = pai.filhos
        .filter((f, index) => index >= pos && (isAgrupador(f) || isDispositivoCabecaAlteracao(f)))
        .map(d => createElemento(d))
        .flat();
    const renumeradosPaiOriginal = (paiOriginal === null || paiOriginal === void 0 ? void 0 : paiOriginal.filhos.filter(f => f.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO || f.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_NOVO).map(d => createElemento(d))) || [];
    if (irmaoAnterior && irmaosMesmoTipo(irmaoAnterior).length === 1) {
        renumerados.unshift(createElemento(irmaoAnterior));
    }
    const eventos = new Eventos();
    eventos.setReferencia(isArticulacao(referencia) && isArticulacaoAlteracao(referencia) ? createElemento(referencia.pai) : createElemento(referencia));
    eventos.add(StateType.ElementoRemovido, [removido]);
    eventos.add(StateType.SituacaoElementoModificada, transferidosParaOutroPai);
    eventos.add(StateType.ElementoRenumerado, [...renumerados, ...renumeradosPaiOriginal]);
    return eventos.build();
};
const getPaiQuePodeReceberFilhoDoTipo = (dispositivo, tipoFilho, dispositivosPermitidos) => {
    var _a;
    return ((_a = dispositivo.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.includes(tipoFilho))
        ? dispositivosPermitidos.length === 0 || dispositivosPermitidos.includes(dispositivo)
            ? dispositivo
            : undefined
        : getPaiQuePodeReceberFilhoDoTipo(dispositivo.pai, tipoFilho, dispositivosPermitidos);
};
const restaura = (d) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    d.numero = (_b = (_a = d.situacao.dispositivoOriginal) === null || _a === void 0 ? void 0 : _a.numero) !== null && _b !== void 0 ? _b : '';
    d.rotulo = (_d = (_c = d.situacao.dispositivoOriginal) === null || _c === void 0 ? void 0 : _c.rotulo) !== null && _d !== void 0 ? _d : '';
    d.id = (_f = (_e = d.situacao.dispositivoOriginal) === null || _e === void 0 ? void 0 : _e.lexmlId) !== null && _f !== void 0 ? _f : '';
    d.texto = d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO ? (_j = (_h = (_g = d.situacao.dispositivoOriginal) === null || _g === void 0 ? void 0 : _g.conteudo) === null || _h === void 0 ? void 0 : _h.texto) !== null && _j !== void 0 ? _j : '' : d.texto;
    d.situacao = new DispositivoOriginal();
    if (isArtigo(d)) {
        d.caput.situacao = new DispositivoOriginal();
    }
};
const restauraAndBuildEvents = (dispositivo) => {
    const result = [];
    const addRestauracao = (d) => {
        const elementoAntesRestauracao = createElemento(d);
        restaura(d);
        result.push({ stateType: StateType.ElementoRestaurado, elementos: [elementoAntesRestauracao, createElemento(d)] });
    };
    if (dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
        const aRestaurar = getDispositivoAndFilhosAsLista(dispositivo).filter(f => f.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO);
        aRestaurar.forEach(addRestauracao);
        const elementoPai = getElementoPaiDeEnumerodos(dispositivo);
        if (elementoPai) {
            result.push({ stateType: StateType.ElementoValidado, elementos: [elementoPai] });
        }
    }
    else {
        addRestauracao(dispositivo);
    }
    result.push({ stateType: StateType.ElementoSelecionado, elementos: [createElemento(dispositivo, true)] });
    return result;
};
const suprimeAndBuildEvents = (articulacao, dispositivo) => {
    getDispositivoAndFilhosAsLista(dispositivo).forEach(d => (d.situacao = new DispositivoSuprimido(createElemento(d))));
    if (dispositivo.alteracoes && dispositivo.alteracoes.filhos.length > 0) {
        dispositivo.alteracoes.filhos.forEach(f => getDispositivoAndFilhosAsLista(f).forEach(d => (d.situacao = new DispositivoSuprimido(createElemento(d)))));
    }
    const eventos = new Eventos();
    eventos.add(StateType.ElementoSuprimido, getElementos(dispositivo));
    const elementoPai = getElementoPaiDeEnumerodos(dispositivo);
    if (elementoPai) {
        eventos.add(StateType.ElementoValidado, [elementoPai]);
    }
    eventos.add(StateType.ElementoSelecionado, [createElemento(dispositivo, true)]);
    return eventos.build();
};
const getElementoPaiDeEnumerodos = (dispositivo) => {
    const dipositivoPai = dispositivo.pai && !isAgrupador(dispositivo.pai) ? (isCaput(dispositivo.pai) ? dispositivo.pai.pai : dispositivo.pai) : null;
    if (dipositivoPai) {
        dipositivoPai.mensagens = validaDispositivo(dipositivoPai);
        return createElemento(dipositivoPai, true);
    }
    return null;
};
const getEvento = (eventos, stateType) => {
    return eventos === null || eventos === void 0 ? void 0 : eventos.filter(ev => ev.stateType === stateType)[0];
};
const eventoContem = (stateEvents, elemento) => {
    return ((stateEvents === null || stateEvents === void 0 ? void 0 : stateEvents.elementos.map(ev => { var _a, _b; return ev.uuid === elemento.uuid && ev.rotulo === elemento.rotulo && ((_a = ev.conteudo) === null || _a === void 0 ? void 0 : _a.texto) === ((_b = elemento.conteudo) === null || _b === void 0 ? void 0 : _b.texto); }).filter(value => value).length) > 0);
};
const createEventos = () => {
    return [
        {
            stateType: StateType.ElementoIncluido,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.ElementoRemovido,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.ElementoModificado,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.ElementoRenumerado,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.ElementoRestaurado,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.ElementoSuprimido,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.ElementoValidado,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.ElementoSelecionado,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.ElementoMarcado,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.SituacaoElementoModificada,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.ElementoReferenciado,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.RevisaoAceita,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
        {
            stateType: StateType.RevisaoRejeitada,
            referencia: undefined,
            pai: undefined,
            elementos: [],
        },
    ];
};
const getElementosRemovidosEIncluidos = (eventos) => {
    const map = new Map();
    eventos.filter(ev => [StateType.ElementoRemovido, StateType.ElementoIncluido].includes(ev.stateType)).forEach(ev => { var _a; return (_a = ev.elementos) === null || _a === void 0 ? void 0 : _a.forEach(el => map.set(el.uuid, el)); });
    return Array.from(map.values());
};
const unificarEvento = (state, eventos, stateType) => {
    const result = eventos.filter(ev => ev.stateType !== stateType);
    if (stateType === StateType.ElementoRemovido) {
        const elementos = eventos
            .filter(ev => ev.stateType === StateType.ElementoRemovido)
            .map(ev => ev.elementos || [])
            .flat();
        elementos.length && result.push({ stateType: stateType, elementos });
    }
    else {
        const elementos = [];
        const mapDispositivos = new Map();
        eventos
            .filter(ev => ev.stateType === stateType)
            .forEach(ev => {
            var _a;
            (_a = ev.elementos) === null || _a === void 0 ? void 0 : _a.forEach(e => {
                const r = [StateType.ElementoIncluido, StateType.ElementoMarcado, StateType.SituacaoElementoModificada, StateType.ElementoRenumerado].includes(stateType)
                    ? findRevisaoByElementoUuid(state.revisoes, e.uuid)
                    : undefined;
                if (r && isRevisaoDeExclusao(r)) {
                    elementos.push(e);
                }
                else if (!mapDispositivos.has(e.uuid)) {
                    const dispositivo = getDispositivoFromElemento(state.articulacao, e);
                    if (dispositivo) {
                        mapDispositivos.set(e.uuid, dispositivo);
                        elementos.push(createElementoValidado(dispositivo, stateType === StateType.ElementoIncluido));
                    }
                }
            });
        });
        elementos.length && result.push({ stateType: stateType, elementos });
    }
    return result;
};

class Eventos {
    constructor() {
        this.eventos = [];
        this.eventos = createEventos();
    }
    add(stateType, elementos) {
        const evento = this.get(stateType);
        elementos.forEach(el => { var _a; return (!eventoContem(evento, el) ? (_a = evento.elementos) === null || _a === void 0 ? void 0 : _a.push(el) : undefined); });
    }
    build() {
        return this.eventos.filter(ev => ev.elementos && ev.elementos.length > 0);
    }
    get(stateType) {
        return this.eventos.filter(ev => ev.stateType === stateType)[0];
    }
    setReferencia(referencia) {
        this.get(StateType.ElementoIncluido).referencia = referencia;
    }
}

const adicionaAlteracaoComAssistente = (state, action) => {
    var _a, _b, _c;
    const atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (atual === undefined || !isArtigo(atual)) {
        state.ui.events = [];
        return state;
    }
    const novo = criaDispositivo(atual.pai, atual.tipo, atual);
    novo.situacao = new DispositivoAdicionado();
    novo.situacao.tipoEmenda = state.modo;
    novo.isDispositivoAlteracao = false;
    novo.situacao.existeNaNormaAlterada = undefined;
    (_a = novo.pai) === null || _a === void 0 ? void 0 : _a.renumeraFilhos();
    novo.id = buildId(novo);
    novo.caput.situacao = novo.situacao = new DispositivoAdicionado();
    novo.caput.situacao.tipoEmenda = state.modo;
    createAlteracao(novo);
    novo.alteracoes.situacao = new DispositivoAdicionado();
    novo.alteracoes.situacao.tipoEmenda = state.modo;
    if (action.dispositivos) {
        try {
            buildDispositivosAssistente(action.dispositivos, novo, state.modo);
        }
        catch (e) {
            return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.ERROR, descricao: e.message });
        }
    }
    if (action.norma) {
        novo.alteracoes.base = action.norma;
        const genero = (_b = getTipo$1(action.norma)) === null || _b === void 0 ? void 0 : _b.genero;
        if (action.norma && validaUrn(action.norma)) {
            const textoUrn = `${getTipo$1(action.norma).descricao} nº ${formataNumero(getNumero(action.norma))}, de ${getDataPorExtenso(action.norma)}`;
            novo.texto = `${genero && genero === 'M' ? 'O' : 'A'} <a href="${action.norma}">${textoUrn}</a>, passa a vigorar com as seguintes alterações:`;
        }
    }
    const novosDispositivos = buildListaDispositivos(novo, []);
    novosDispositivos.forEach((d, i) => {
        if (i > 0 && i < novosDispositivos.length - 1) {
            d.texto = TEXTO_OMISSIS;
        }
        if (i > 1) {
            adicionarOmissisObrigatorios(d);
        }
    });
    const eventos = new Eventos();
    eventos.setReferencia(createElemento(ajustaReferencia(atual, novo)));
    eventos.add(StateType.ElementoIncluido, getElementosDoDispositivo(novo, true));
    eventos.add(StateType.ElementoValidado, criaListaElementosAfinsValidados(novo, false));
    eventos.add(StateType.ElementoMarcado, [createElemento(getUltimoFilho(novo)), createElemento(atual)]);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, eventos.build()),
        present: eventos.build(),
        future: [],
        ui: {
            events: eventos.build(),
            alertas: (_c = state.ui) === null || _c === void 0 ? void 0 : _c.alertas,
        },
    };
};
const adicionarOmissisObrigatorios = (atual) => {
    var _a;
    if (parseInt(atual.numero) > 1) {
        const anterior = getDispositivoAnterior(atual);
        const novo = criaDispositivo(atual.pai, TipoDispositivo.omissis.tipo, anterior, anterior ? undefined : 0);
        novo.situacao = new DispositivoAdicionado();
        (_a = atual.pai) === null || _a === void 0 ? void 0 : _a.addFilhoOnPosition(novo, 0);
    }
};

const calculaPosicao = (atual, posicao) => {
    const posicaoAtual = atual.pai.indexOf(atual);
    if (posicao === 'antes') {
        return posicaoAtual;
    }
    return posicaoAtual === atual.pai.filhos.length - 1 ? undefined : posicaoAtual + 1;
};
const adicionaElemento$1 = (state, action) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    let textoModificado = false;
    const refAtual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    const atualCaputPosicaoFilho = refAtual && isArtigo(refAtual) && action.novo.tipo === TipoDispositivo.inciso.tipo ? refAtual.caput : undefined;
    const atual = action.posicao === 'filho' && atualCaputPosicaoFilho ? atualCaputPosicaoFilho : refAtual;
    const refUltimoFilho = atual && action.posicao === 'filho' ? (hasFilhos(atual) ? atual.filhos[atual.filhos.length - 1] : undefined) : undefined;
    if (atual === undefined || (atual.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO && hasIndicativoDesdobramento(atual))) {
        state.ui.events = [];
        return state;
    }
    if (atual.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_NOVO &&
        atual.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO &&
        hasIndicativoDesdobramento(atual) &&
        !isNovoDispositivoDesmembrandoAtual((_b = (_a = action.novo) === null || _a === void 0 ? void 0 : _a.conteudo) === null || _b === void 0 ? void 0 : _b.texto)) {
        if (atual.hasAlteracao() &&
            ((_c = atual.alteracoes) === null || _c === void 0 ? void 0 : _c.filhos) &&
            isOriginal(atual.alteracoes.filhos[0]) &&
            !isOmissis(atual.alteracoes.filhos[0]) &&
            atual.alteracoes.filhos[0].numero === '1' &&
            action.posicao !== 'antes' &&
            atual.tipo !== action.novo.tipo) {
            state.ui.events = [];
            return state;
        }
        if (action.posicao === undefined &&
            isDispositivoAlteracao(atual) &&
            hasFilhos(atual) &&
            isOriginal(atual.filhos[0]) &&
            !isOmissis(atual.filhos[0]) &&
            !isParagrafo(atual.filhos[0]) &&
            atual.filhos[0].numero === '1') {
            state.ui.events = [];
            return state;
        }
    }
    let ref = atual.pai.indexOf(atual) === 0
        ? !action.posicao && atual.hasAlteracao()
            ? atual
            : isIncisoCaput(atual) || isDispositivoCabecaAlteracao(atual)
                ? atual.pai.pai
                : atual.pai
        : atual.pai.filhos[atual.pai.indexOf(atual) - 1];
    if (((_d = atual.situacao) === null || _d === void 0 ? void 0 : _d.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_ORIGINAL && isNovoDispositivoDesmembrandoAtual((_f = (_e = action.novo) === null || _e === void 0 ? void 0 : _e.conteudo) === null || _f === void 0 ? void 0 : _f.texto)) {
        action.atual.conteudo.texto = atual.texto;
        action.novo.conteudo.texto = undefined;
    }
    const originalmenteUnico = isArtigoUnico(atual) || isParagrafoUnico(atual);
    const elementoAtualOriginal = createElementoValidado(atual);
    const elementosRemovidos = [];
    createElementos(elementosRemovidos, atual);
    if (textoFoiModificado(atual, action, state)) {
        atual.texto = !isDispositivoAlteracao(atual) ? (_g = action.atual.conteudo) === null || _g === void 0 ? void 0 : _g.texto : normalizaSeForOmissis((_j = (_h = action.atual.conteudo) === null || _h === void 0 ? void 0 : _h.texto) !== null && _j !== void 0 ? _j : '');
        textoModificado = true;
    }
    if (naoPodeCriarFilho(atual, action)) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.INFO, descricao: 'Não é possível criar dispositivos nessa situação' });
    }
    let novo;
    if (action.posicao && action.posicao !== 'filho' && !isEmenta(atual)) {
        if (atual.tipo === action.novo.tipo) {
            novo =
                action.posicao === 'antes'
                    ? criaDispositivo(atual.pai, action.novo.tipo, undefined, calculaPosicao(atual, action.posicao))
                    : criaDispositivo(atual.pai, action.novo.tipo, atual); // depois
        }
        else if (isAgrupador(atual) && action.novo.tipo === TipoDispositivo.artigo.tipo) {
            if (action.posicao === 'antes') {
                const anterior = getDispositivoAnteriorNaSequenciaDeLeitura(atual);
                ref = anterior;
                const paiDoNovo = !anterior ? atual.pai : isAgrupador(anterior) ? anterior : isArtigo(anterior) ? anterior.pai : getArtigo(anterior).pai;
                const posicao = anterior && isAgrupador(anterior) ? 0 : undefined;
                const referencia = !anterior || isAgrupador(anterior) ? undefined : isArtigo(anterior) ? anterior : getArtigo(anterior);
                novo = criaDispositivo(paiDoNovo, action.novo.tipo, referencia, posicao);
            }
            else {
                novo = criaDispositivo(atual, action.novo.tipo, undefined, 0);
            }
        }
    }
    else if (atual.hasAlteracao()) {
        novo = criaDispositivoCabecaAlteracao(TipoDispositivo.artigo.tipo, atual.alteracoes, undefined, 0);
    }
    else if (isEmenta(atual) && action.novo.tipo) {
        novo = criaDispositivo(state.articulacao, action.novo.tipo, undefined, 0);
    }
    else if (action.novo.tipo && atual.tipo !== action.novo.tipo) {
        novo = criaDispositivo(atual, action.novo.tipo, refUltimoFilho);
    }
    else {
        novo = createByInferencia(atual, action);
    }
    if (isDispositivoCabecaAlteracao(novo)) {
        // novo.cabecaAlteracao = isDispositivoCabecaAlteracao(novo);
        novo.notaAlteracao = 'NR';
    }
    if (isDispositivoCabecaAlteracao(novo)) {
        novo.notaAlteracao = 'NR';
    }
    if (((_k = atual.situacao) === null || _k === void 0 ? void 0 : _k.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_ORIGINAL ||
        ((_l = atual.situacao) === null || _l === void 0 ? void 0 : _l.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_MODIFICADO ||
        ((_m = atual.situacao) === null || _m === void 0 ? void 0 : _m.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO ||
        atual.situacao instanceof DispositivoAdicionado) {
        novo.situacao = new DispositivoAdicionado();
        if (isArtigo(novo)) {
            novo.caput.situacao = new DispositivoAdicionado();
        }
        novo.situacao.tipoEmenda = state.modo;
        const pai = novo.pai;
        if (isArticulacaoAlteracao(pai) && pai.filhos.length === 1) {
            pai.situacao = new DispositivoAdicionado();
        }
    }
    if (isNovoDispositivoDesmembrandoAtual((_p = (_o = action.novo) === null || _o === void 0 ? void 0 : _o.conteudo) === null || _p === void 0 ? void 0 : _p.texto) && atual.tipo === novo.tipo && hasFilhos(atual)) {
        copiaFilhos(atual, novo);
    }
    if (isDispositivoAlteracao(novo)) {
        novo.createRotulo(novo);
        novo.id = buildId(novo);
        (_q = novo.mensagens) === null || _q === void 0 ? void 0 : _q.push({ tipo: TipoMensagem.WARNING, descricao: `É necessário informar o rótulo do dispositivo` });
    }
    if (isDispositivoAlteracao(novo) && novo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
        novo.situacao.existeNaNormaAlterada = isDispositivoCabecaAlteracao(novo) || !podeRenumerarFilhosAutomaticamente(novo.pai);
    }
    novo.pai.renumeraFilhos();
    if (((_r = novo.situacao) === null || _r === void 0 ? void 0 : _r.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
        novo.id = buildId(novo);
    }
    const eventos = action.posicao && action.posicao === 'antes'
        ? buildEventoAdicionarElemento(ref, novo)
        : action.posicao === 'filho' && refUltimoFilho
            ? buildEventoAdicionarElemento(refUltimoFilho, novo)
            : action.posicao === 'filho' && !refUltimoFilho && isCaput(atual)
                ? buildEventoAdicionarElemento(atual.pai, novo)
                : buildEventoAdicionarElemento(atual, novo);
    const elementoAtualAtualizado = createElementoValidado(atual);
    if (isNovoDispositivoDesmembrandoAtual((_t = (_s = action.novo) === null || _s === void 0 ? void 0 : _s.conteudo) === null || _t === void 0 ? void 0 : _t.texto) && atual.tipo === novo.tipo && elementosRemovidos && elementosRemovidos.length > 0) {
        eventos.add(StateType.ElementoRemovido, elementosRemovidos);
    }
    if (isAgrupador(novo) && irmaosMesmoTipo(novo).length === 2) {
        const irmao = irmaosMesmoTipo(novo).filter(a => a !== novo);
        eventos.add(StateType.ElementoModificado, [createElemento(irmao[0])]);
    }
    if (textoModificado || isNovoDispositivoDesmembrandoAtual((_v = (_u = action.novo) === null || _u === void 0 ? void 0 : _u.conteudo) === null || _v === void 0 ? void 0 : _v.texto)) {
        eventos.add(StateType.ElementoModificado, [elementoAtualOriginal, elementoAtualAtualizado]);
    }
    if (textoModificado || isNovoDispositivoDesmembrandoAtual((_x = (_w = action.novo) === null || _w === void 0 ? void 0 : _w.conteudo) === null || _x === void 0 ? void 0 : _x.texto) || isOmissis(atual)) {
        eventos.add(StateType.ElementoValidado, [elementoAtualAtualizado]);
    }
    if (isArtigoUnico(atual) || originalmenteUnico) {
        eventos.add(StateType.ElementoValidado, [elementoAtualAtualizado]);
        eventos.add(StateType.ElementoRenumerado, [elementoAtualAtualizado]);
    }
    if (action.posicao && action.posicao === 'antes') {
        eventos.add(StateType.ElementoRenumerado, listaDispositivosRenumerados(novo).map(d => createElemento(d)));
    }
    eventos.add(StateType.ElementoMarcado, [createElemento(novo), createElemento(atual)]);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, eventos.build()),
        present: eventos.build(),
        future: [],
        ui: {
            events: eventos.build(),
            alertas: (_y = state.ui) === null || _y === void 0 ? void 0 : _y.alertas,
        },
    };
};

const adicionarAlerta = (state, action) => {
    var _a, _b, _c, _d;
    let alertas = ((_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas) || [];
    if (((_c = (_b = state.ui) === null || _b === void 0 ? void 0 : _b.alertas) === null || _c === void 0 ? void 0 : _c.filter(({ id }) => id === action.alerta.id).length) > 0) {
        alertas = [...alertas];
    }
    else {
        alertas = [...alertas, action.alerta];
    }
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: state.present,
        future: state.future,
        ui: {
            events: [{ stateType: StateType.AtualizacaoAlertas }],
            message: (_d = state.ui) === null || _d === void 0 ? void 0 : _d.mensagem,
            alertas: alertas,
        },
    };
};

const agrupaElemento = (state, action) => {
    var _a, _b, _c, _d, _e;
    let atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (atual === undefined) {
        return state;
    }
    if (!isArtigo(atual) && !isAgrupador(atual) && !isEmenta(atual)) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.ERROR, descricao: 'Não é permitido adicionar agrupador de artigo a partir da seleção atual' });
    }
    if ((isArticulacao(atual) || isEmenta(atual)) && action.novo.posicao === 'antes') {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.ERROR, descricao: 'Não é permitido adicionar agrupador de artigo antes da ementa' });
    }
    // if (isArtigo(atual) && action.novo.posicao !== 'antes') {
    //   return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.ERROR, descricao: 'Operação não permitida.' });
    // }
    const descricaoTipo = TipoDispositivo[action.novo.tipo.toLowerCase()].descricao;
    if (!action.isAbrindoEmenda && action.novo.posicao === 'antes' && !getTiposAgrupadoresQuePodemSerInseridosAntes(atual).includes(action.novo.tipo)) {
        return retornaEstadoAtualComMensagem(state, {
            tipo: TipoMensagem.ERROR,
            descricao: `Não é permitido adicionar agrupador "${descricaoTipo}" antes do dispositivo selecionado [${atual.rotulo}]`,
        });
    }
    if (!action.isAbrindoEmenda && action.novo.posicao === 'depois' && !getTiposAgrupadoresQuePodemSerInseridosDepois(atual).includes(action.novo.tipo)) {
        return retornaEstadoAtualComMensagem(state, {
            tipo: TipoMensagem.ERROR,
            descricao: `Não é permitido adicionar agrupador "${descricaoTipo}" após o dispositivo selecionado [${atual.rotulo}]`,
        });
    }
    if (isEmenta(atual)) {
        atual = state.articulacao;
    }
    const posicaoDoNovoAgrupador = action.novo.posicao;
    const manterNovoNoMesmoGrupoDeAspas = action.novo.manterNoMesmoGrupoDeAspas;
    const cabecaAlteracao = isDispositivoAlteracao(atual) ? getDispositivoCabecaAlteracao(atual) : undefined;
    const dispositivosAlteracao = cabecaAlteracao ? getDispositivoAndFilhosAsLista(cabecaAlteracao) : [];
    const dispositivosArticulacao = getDispositivoAndFilhosAsLista(state.articulacao);
    if (isDispositivoAlteracao(atual)) {
        if (isDispositivoCabecaAlteracao(atual) && manterNovoNoMesmoGrupoDeAspas && posicaoDoNovoAgrupador === 'antes' && !((_a = atual.tiposPermitidosPai) === null || _a === void 0 ? void 0 : _a.includes(action.novo.tipo))) {
            return retornaEstadoAtualComMensagem(state, {
                tipo: TipoMensagem.ERROR,
                descricao: `Não é permitido adicionar agrupador "${descricaoTipo}", no mesmo grupo de aspas, antes do dispositivo selecionado [${atual.rotulo}]`,
            });
        }
        if (!isDispositivoCabecaAlteracao(atual) && manterNovoNoMesmoGrupoDeAspas && !dispositivosAlteracao.some(d => { var _a; return (_a = d.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.includes(action.novo.tipo); })) {
            return retornaEstadoAtualComMensagem(state, {
                tipo: TipoMensagem.ERROR,
                descricao: `Não é permitido adicionar agrupador "${descricaoTipo}", no mesmo grupo de aspas, após o dispositivo selecionado [${atual.rotulo}]`,
            });
        }
        if (isArtigo(atual) && !isDispositivoCabecaAlteracao(atual) && !manterNovoNoMesmoGrupoDeAspas) {
            return retornaEstadoAtualComMensagem(state, {
                tipo: TipoMensagem.ERROR,
                descricao: `Não é permitido adicionar agrupador "${descricaoTipo}", na alteração de norma, a partir do atual dispositivo selecionado [${atual.rotulo}]`,
            });
        }
        if (!manterNovoNoMesmoGrupoDeAspas) {
            return criarNovaCabecaDeAlteracao(state, atual, posicaoDoNovoAgrupador, action.novo.tipo, false, { rotulo: action.novo.rotulo, uuid: action.novo.uuid });
        }
        if (isDispositivoCabecaAlteracao(atual) && posicaoDoNovoAgrupador === 'antes') {
            return criarNovaCabecaDeAlteracao(state, atual, posicaoDoNovoAgrupador, action.novo.tipo, true, { rotulo: action.novo.rotulo, uuid: action.novo.uuid });
        }
    }
    let novo;
    // const ref = dispositivosArticulacao[dispositivosArticulacao.indexOf(atual) - (posicaoDoNovoAgrupador === 'antes' ? 1 : 0)];
    const ref = getReferencia(atual, posicaoDoNovoAgrupador, dispositivosArticulacao);
    if (!isArticulacao(atual) && isDesdobramentoAgrupadorAtual(atual, action.novo.tipo)) {
        novo = criaDispositivo(atual.pai.pai, action.novo.tipo, undefined, atual.pai.pai.indexOf(atual.pai) + 1);
    }
    else {
        const paiQuePodeReceberNovoAgrupador = getPaiQuePodeReceberFilhoDoTipo(ref, action.novo.tipo, dispositivosAlteracao);
        if (!paiQuePodeReceberNovoAgrupador) {
            return retornaEstadoAtualComMensagem(state, {
                tipo: TipoMensagem.ERROR,
                descricao: `Não é permitido adicionar agrupador "${descricaoTipo}" a partir do atual dispositivo selecionado [${atual.rotulo}]`,
            });
        }
        const posNovoAgrupador = atual.pai === paiQuePodeReceberNovoAgrupador
            ? atual.pai.indexOf(atual) + (posicaoDoNovoAgrupador === 'antes' ? 0 : 1)
            : calculaPosNovoAgrupador(atual, paiQuePodeReceberNovoAgrupador, dispositivosArticulacao, dispositivosAlteracao);
        novo = criaDispositivo(paiQuePodeReceberNovoAgrupador, action.novo.tipo, undefined, posNovoAgrupador);
    }
    // Reutiliza "uuid" quando o agrupador é criado por ação de undo ou redo
    novo.uuid = (_b = action.novo.uuid) !== null && _b !== void 0 ? _b : novo.uuid;
    novo.situacao = new DispositivoAdicionado();
    novo.situacao.tipoEmenda = state.modo;
    novo.texto = (_c = action.novo.texto) !== null && _c !== void 0 ? _c : '';
    novo.createRotulo(novo);
    novo.rotulo = (_d = action.novo.rotulo) !== null && _d !== void 0 ? _d : novo.rotulo;
    novo.id = buildId(novo);
    if (isDispositivoAlteracao(novo) && novo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
        novo.situacao.existeNaNormaAlterada = isDispositivoCabecaAlteracao(novo) || !podeRenumerarFilhosAutomaticamente(novo.pai);
    }
    const dispositivos = getDispositivosASeremCopiadosParaOutroPai(atual, novo, posicaoDoNovoAgrupador, dispositivosAlteracao);
    copiaDispositivosParaOutroPai(novo, dispositivos);
    novo.pai.renumeraFilhos();
    novo.pai.filhos.forEach(f => f.renumeraFilhos());
    // novo.renumeraFilhos();
    const dispositivosAux = getDispositivoAndFilhosAsLista(novo.pai);
    dispositivosAux.filter(d => isAgrupador(d) && !(d.tipo === 'Articulacao' && d.pai === undefined)).forEach(d => (d.id = buildId(d)));
    const renumerados = dispositivosAux.filter(fnFilterAgrupadorAdicionado).map((d) => createElemento(d));
    const irmaoAnterior = getDispositivoAnteriorMesmoTipo(novo);
    if (irmaoAnterior && irmaosMesmoTipo(novo).length === 2) {
        renumerados.unshift(createElemento(irmaoAnterior));
    }
    const eventos = new Eventos();
    if (isArticulacao(ref) && hasEmenta(ref)) {
        eventos.setReferencia(createElemento(state.articulacao.projetoNorma.ementa));
    }
    else if (isArtigo(atual) && posicaoDoNovoAgrupador === 'depois') {
        eventos.setReferencia(createElemento(getUltimoFilho(ref)));
    }
    else if (isArtigo(ref) && posicaoDoNovoAgrupador === 'antes') {
        eventos.setReferencia(createElemento(getUltimoFilho(ref)));
    }
    else {
        eventos.setReferencia(createElemento(ref));
    }
    const transferidosParaOutroPai = novo.filhos.map((d) => createElemento(d));
    // eventos.add(StateType.ElementoIncluido, [createElemento(novo)]);
    const elementoIncluido = createElemento(novo);
    elementoIncluido.manterNoMesmoGrupoDeAspas = manterNovoNoMesmoGrupoDeAspas;
    eventos.add(StateType.ElementoIncluido, [elementoIncluido]);
    eventos.add(StateType.SituacaoElementoModificada, [createElemento(atual), ...transferidosParaOutroPai]);
    eventos.add(StateType.ElementoRenumerado, renumerados);
    eventos.add(StateType.ElementoMarcado, [createElemento(novo)]);
    const dArticulacao = getDispositivoAndFilhosAsLista(state.articulacao);
    const dReferenciado = dArticulacao[dArticulacao.indexOf(novo) + 1];
    eventos.add(StateType.ElementoReferenciado, dReferenciado ? [createElemento(dReferenciado)] : []);
    if (novo === getPrimeiroAgrupadorNaArticulacao(novo) && hasEmenta(novo)) {
        eventos.get(StateType.SituacaoElementoModificada).elementos.push(createElemento(state.articulacao.projetoNorma.ementa));
    }
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, eventos.build()),
        present: eventos.build(),
        future: [],
        ui: {
            events: eventos.build(),
            alertas: (_e = state.ui) === null || _e === void 0 ? void 0 : _e.alertas,
        },
    };
};
const calculaPosNovoAgrupador = (dispositivo, paiQuePodeReceberFilho, dispositivosArticulacao, dispositivosAlteracao) => {
    const ds = dispositivosArticulacao.filter(d => isDispositivoValidoNoConjunto(d, dispositivosAlteracao) && (d === dispositivo || paiQuePodeReceberFilho.filhos.includes(d)));
    return ds.indexOf(dispositivo);
};
// const isUltimoArtigoOuAgrupadorDaAlteracao = (dispositivo: Dispositivo): boolean => {
//   return isUltimaAlteracao(dispositivo) || isUltimaAlteracao(getUltimoFilho(dispositivo));
// };
const fnFilterAgrupadorAdicionado = (d) => !isArtigo(d) && d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO;
const criarNovaCabecaDeAlteracao = (state, atual, posicao, tipo, manterNovoNoMesmoGrupoDeAspas = false, dadosComplementares = {}) => {
    var _a, _b, _c, _d, _e;
    const cabecaAlteracao = getDispositivoCabecaAlteracao(atual);
    const pos = cabecaAlteracao.pai.indexOf(cabecaAlteracao) + (posicao === 'antes' ? 0 : 1);
    const novo = criaDispositivoCabecaAlteracao(tipo, cabecaAlteracao.pai, undefined, pos);
    novo.rotulo = (_a = dadosComplementares.rotulo) !== null && _a !== void 0 ? _a : novo.rotulo;
    novo.uuid = (_b = dadosComplementares.uuid) !== null && _b !== void 0 ? _b : novo.uuid;
    novo.texto = (_d = (_c = dadosComplementares.texto) !== null && _c !== void 0 ? _c : novo.texto) !== null && _d !== void 0 ? _d : '';
    novo.id = buildId(novo);
    if (isDispositivoAlteracao(novo) && novo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
        novo.situacao.existeNaNormaAlterada = isDispositivoCabecaAlteracao(novo) || !podeRenumerarFilhosAutomaticamente(novo.pai);
    }
    const ref = pos === 0 ? novo.pai.pai : getUltimoFilho(novo.pai.filhos[pos - 1]);
    const eventos = new Eventos();
    if (manterNovoNoMesmoGrupoDeAspas) {
        atual.cabecaAlteracao = false;
        copiaDispositivosParaOutroPai(novo, [atual]);
        novo.pai.renumeraFilhos();
        novo.renumeraFilhos();
        const renumerados = [
            ...novo.pai.filhos.filter(fnFilterAgrupadorAdicionado).map(d => createElemento(d)),
            ...novo.filhos.filter(fnFilterAgrupadorAdicionado).map(d => createElemento(d)),
        ];
        eventos.add(StateType.ElementoRenumerado, renumerados);
    }
    eventos.setReferencia(createElemento(ref));
    // eventos.add(StateType.ElementoIncluido, [createElemento(novo)]);
    const elementoIncluido = createElemento(novo);
    elementoIncluido.manterNoMesmoGrupoDeAspas = manterNovoNoMesmoGrupoDeAspas;
    eventos.add(StateType.ElementoIncluido, [elementoIncluido]);
    eventos.add(StateType.SituacaoElementoModificada, getElementos(novo));
    eventos.add(StateType.ElementoMarcado, [createElemento(novo)]);
    const dArticulacao = getDispositivoAndFilhosAsLista(state.articulacao);
    const dReferenciado = dArticulacao[dArticulacao.indexOf(novo) + 1];
    eventos.add(StateType.ElementoReferenciado, dReferenciado ? [createElemento(dReferenciado)] : []);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, eventos.build()),
        present: eventos.build(),
        future: [],
        ui: {
            events: eventos.build(),
            alertas: (_e = state.ui) === null || _e === void 0 ? void 0 : _e.alertas,
        },
    };
};
const isDispositivoValidoNoConjunto = (d, dispositivosAlteracao) => dispositivosAlteracao.length === 0 || dispositivosAlteracao.includes(d);
const getDispositivosASeremCopiadosParaOutroPai = (atual, novo, posicaoDoNovoAgrupador, dispositivosAlteracao) => {
    const dArticulacao = getDispositivoAndFilhosAsLista(getArticulacao(atual));
    const pais = getPais(atual, novo.tipo);
    if (isAgrupador(atual) && posicaoDoNovoAgrupador === 'depois') {
        pais.push(atual);
    }
    const indexAtual = dArticulacao.indexOf(atual) + (posicaoDoNovoAgrupador === 'antes' ? 0 : 1);
    const podeCopiar = (d, index) => { var _a; return index >= indexAtual && d !== novo && !!((_a = novo.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.includes(d.tipo)) && pais.includes(d.pai) && isDispositivoValidoNoConjunto(d, dispositivosAlteracao); };
    return dArticulacao.filter(podeCopiar);
};
const getPais = (dispositivo, tipo, result = []) => {
    const tiposAgrupadorArtigo = ['Parte', 'Livro', 'Titulo', 'Capitulo', 'Secao', 'Subsecao', 'Artigo'];
    if (dispositivo && tiposAgrupadorArtigo.indexOf(dispositivo.tipo) >= tiposAgrupadorArtigo.indexOf(tipo)) {
        result.push(dispositivo.pai);
        return getPais(dispositivo.pai, tipo, result);
    }
    return result;
};
const getReferencia = (atual, posicaoDoNovoAgrupador, dispositivosArticulacao) => {
    const atuaEhDispositivoDeAlteracao = isDispositivoAlteracao(atual);
    const dispositivos = dispositivosArticulacao.filter(d => isDispositivoAlteracao(d) === atuaEhDispositivoDeAlteracao);
    return dispositivos[dispositivos.indexOf(atual) - (posicaoDoNovoAgrupador === 'antes' ? 1 : 0)];
};

class DispositivoModificado {
    constructor(dispositivoOriginal) {
        this.descricaoSituacao = DescricaoSituacao.DISPOSITIVO_MODIFICADO;
        this.dispositivoOriginal = dispositivoOriginal;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAcoesPermitidas(dispositivo, acoes) {
        const acoesFiltradas = acoes
            .filter((a) => !(a instanceof AgruparElemento))
            .filter((a) => !(a instanceof RemoverElemento))
            .filter((a) => !(a instanceof RenumerarElemento))
            .filter((a) => { var _a; return !((_a = a.descricao) === null || _a === void 0 ? void 0 : _a.startsWith('Mover')); })
            .filter((acao) => acao.descricao !== 'Adicionar' && acao.descricao !== 'Atualizar dispositivo')
            .filter((a) => !(a instanceof TransformarElemento));
        acoesFiltradas.push(restaurarElementoAction);
        return acoesFiltradas.filter(a => a !== undefined).sort((a, b) => a.descricao.localeCompare(b.descricao));
    }
}

const aplicaAlteracoesEmenda = (state, action) => {
    var _a;
    const retorno = {
        articulacao: state.articulacao,
        modo: state.modo,
        past: [],
        present: [],
        future: [],
        ui: {
            events: [],
            alertas: [],
        },
        revisoes: [],
        emRevisao: state.emRevisao,
        numEventosPassadosAntesDaRevisao: 0,
    };
    const eventos = new Eventos();
    if (action.alteracoesEmenda.dispositivosSuprimidos) {
        eventos.add(StateType.ElementoSuprimido, []);
        action.alteracoesEmenda.dispositivosSuprimidos.forEach(dispositivo => {
            const d = buscaDispositivoById(state.articulacao, dispositivo.id);
            if (d) {
                percorreHierarquiaDispositivos(d, d => {
                    var _a;
                    d.situacao = new DispositivoSuprimido(createElemento(d));
                    (_a = eventos.get(StateType.ElementoSuprimido).elementos) === null || _a === void 0 ? void 0 : _a.push(createElemento(d));
                });
            }
        });
    }
    if (action.alteracoesEmenda.dispositivosModificados) {
        eventos.add(StateType.ElementoModificado, []);
        action.alteracoesEmenda.dispositivosModificados.forEach(dispositivo => {
            var _a;
            const d = buscaDispositivoById(state.articulacao, dispositivo.tipo === 'Caput' ? idSemCpt(dispositivo.id) : dispositivo.id);
            if (d) {
                d.situacao = new DispositivoModificado(createElemento(d));
                d.texto = dispositivo.texto;
                (_a = eventos.get(StateType.ElementoModificado).elementos) === null || _a === void 0 ? void 0 : _a.push(createElemento(d));
            }
        });
    }
    if (action.alteracoesEmenda.dispositivosAdicionados) {
        eventos.eventos.push(...processaDispositivosAdicionados(state, action.alteracoesEmenda));
    }
    if ((_a = action.revisoes) === null || _a === void 0 ? void 0 : _a.length) {
        eventos.eventos.push(...processaRevisoes$1(retorno, action.revisoes));
        retorno.emRevisao = true;
    }
    retorno.ui.events = eventos.build();
    const elementosInseridos = [];
    retorno.ui.events.filter(stateEvent => stateEvent.stateType === StateType.ElementoIncluido).forEach(se => elementosInseridos.push(...se.elementos));
    retorno.ui.events.push({
        stateType: StateType.SituacaoElementoModificada,
        elementos: getElementosAlteracaoASeremAtualizados(state.articulacao, elementosInseridos),
    });
    if (retorno.emRevisao) {
        retorno.ui.events.push({ stateType: StateType.RevisaoAtivada });
    }
    return retorno;
};
const processaDispositivosAdicionados = (state, alteracoesEmenda) => {
    const tiposAgrupadorArtigo = getTiposAgrupadorArtigoOrdenados();
    const eventos = [];
    for (const da of alteracoesEmenda.dispositivosAdicionados) {
        if (tiposAgrupadorArtigo.includes(da.tipo)) {
            eventos.push(...criaEventosParaDispositivoAgrupador(state, da));
        }
        else {
            eventos.push(criaEventoElementosIncluidos(state, da));
        }
    }
    return eventos;
};
const isPrimeiroDispositivoEmAlteracaoDeNorma = (ref, dea) => {
    return !isDispositivoAlteracao(ref) && isEmendaEmAlteracaoDeNorma(dea);
};
const isEmendaEmAlteracaoDeNorma = (dea) => {
    return dea.id.split('_').some(p => p.startsWith('alt'));
};
const criaEventosParaDispositivoAgrupador = (state, dea) => {
    const articulacao = state.articulacao;
    let ref = buscaDispositivoById(state.articulacao, dea.idPosicaoAgrupador);
    let posicao = 'depois';
    // Solução de contorno para emendas com adição de artigo que altera norma vigente e com agrupadores adicionados na alteração.
    if (buscaDispositivoById(state.articulacao, dea.id)) {
        return [];
    }
    // ---------------------------------------------------------------------------
    if (ref) {
        if (isArticulacao(ref) && !isArticulacaoAlteracao(ref) && hasEmenta(ref)) {
            ref = ref.projetoNorma.ementa;
        }
        else if (isPrimeiroDispositivoEmAlteracaoDeNorma(ref, dea)) {
            ref = ref.alteracoes.filhos[0];
            posicao = 'antes';
        }
        const atual = createElemento(ref);
        const manterNoMesmoGrupoDeAspas = !dea.abreAspas || !dea.fechaAspas;
        const tempState = agrupaElemento(state, { atual, novo: { tipo: dea.tipo, posicao, manterNoMesmoGrupoDeAspas, rotulo: dea.rotulo }, isAbrindoEmenda: true });
        const events = tempState.ui.events.filter(ev => ev.stateType !== StateType.ElementoMarcado);
        const elementosIncluidos = events.find(e => e.stateType === StateType.ElementoIncluido).elementos;
        const novoAgrupador = elementosIncluidos[0];
        const novo = getDispositivoFromElemento(articulacao, novoAgrupador);
        ajustaAtributosDispositivoAdicionado(novo, dea, ClassificacaoDocumento.EMENDA);
        elementosIncluidos.length = 0;
        elementosIncluidos.push(createElemento(novo));
        return events;
    }
    return [];
};
const criaEventoElementosIncluidos = (state, dispositivo) => {
    const evento = {
        stateType: StateType.ElementoIncluido,
        referencia: undefined,
        pai: undefined,
        elementos: [],
    };
    const novo = criaArvoreDispositivos(state.articulacao, dispositivo, state.modo);
    if (novo) {
        if (novo.rotulo) {
            novo.createNumeroFromRotulo(novo.rotulo);
        }
        if (!evento.referencia) {
            const dispositivoAnterior = getIrmaoAnteriorIndependenteDeTipo(novo);
            let pai = isCaput(novo.pai) ? novo.pai.pai : novo.pai;
            pai = isArticulacaoAlteracao(pai) ? buscaDispositivoById(state.articulacao, pai.pai.id) : pai;
            if (dispositivo.idPai && isAgrupador(pai)) {
                evento.referencia = createElemento(pai);
            }
            else {
                evento.referencia = createElemento(referenciaAjustada(dispositivoAnterior || pai, novo));
            }
        }
        percorreHierarquiaDispositivos(novo, d => {
            var _a;
            if (!isCaput(d) && !isArticulacaoAlteracao(d)) {
                const novoEl = createElemento(d);
                novoEl.lexmlId = buildId(d);
                (_a = evento.elementos) === null || _a === void 0 ? void 0 : _a.push(novoEl);
            }
        });
    }
    return evento;
};
const referenciaAjustada = (referencia, dispositivo) => {
    const ref = ajustaReferencia(referencia, dispositivo);
    return ref.id !== dispositivo.id ? ref : dispositivo.pai.filhos[dispositivo.pai.filhos.length - 2];
};
const criaArvoreDispositivos = (articulacao, da, modo) => {
    var _a, _b;
    let novo;
    const ehCaput = da.tipo === 'Caput';
    if (da.idIrmaoAnterior) {
        const d = buscaDispositivoById(articulacao, idSemCpt(da.idIrmaoAnterior));
        if (d) {
            if (d.id === da.idIrmaoAnterior) {
                novo = criaDispositivo(d.pai, da.tipo, d);
            }
            else {
                // Entra aqui quando dispositivo é do tipo "Paragrafo" e irmão anterior procurado é o "Caput" do artigo
                // Nesse caso, "d" já é o "Artigo" que será "pai" do novo dispositivo
                // Em outras palavras: quando o idIrmaoAnterior é de "caput" a função "buscaDispositivoById" traz o artigo
                novo = criaDispositivo(d, da.tipo, undefined, 0);
            }
        }
    }
    else if (da.idPai) {
        const d = buscaDispositivoById(articulacao, idSemCpt(da.idPai));
        if (d) {
            if ((da.tipo === 'Inciso' || da.tipo === 'Omissis') && d.tipo === 'Artigo') {
                novo = criaDispositivo(d.caput, da.tipo, undefined, 0);
            }
            else if (ehCaput) {
                d.texto = (_a = da.texto) !== null && _a !== void 0 ? _a : '';
                novo = d.caput;
            }
            else if (da.tipo === 'Alteracao') {
                createAlteracao(d);
                novo = d.alteracoes;
                d.alteracoes.id = da.id;
                d.alteracoes.base = da.urnNormaAlterada;
            }
            else {
                novo = criaDispositivo(d, da.tipo, undefined, 0);
                novo.texto = (_b = da.texto) !== null && _b !== void 0 ? _b : '';
            }
        }
    }
    else {
        novo = criaDispositivo(articulacao, da.tipo, undefined, 0);
    }
    if (novo) {
        ajustaAtributosDispositivoAdicionado(novo, da, modo);
    }
    if (novo && da.filhos) {
        da.filhos.forEach((f, i) => {
            if (i === 0) {
                f.idPai = da.id;
                f.id = corrigeIdDispositivoSeNecessario(f.id, da.id);
            }
            else {
                f.idIrmaoAnterior = da.filhos[i - 1].id;
            }
            criaArvoreDispositivos(articulacao, f, modo);
        });
    }
    return novo;
};
// O código abaixo é necessário para permitir abertura de emendas que foram salvas com o id incorreto (no caput de artigos em alteração de norma).
// Novas emendas não terão esse problema.
const corrigeIdDispositivoSeNecessario = (id, idPai) => {
    return id.startsWith(idPai) ? id : idPai.split('_').slice(0, -1).join('_') + '_' + id;
};
const ajustaAtributosDispositivoAdicionado = (dispositivo, da, modo) => {
    var _a, _b;
    dispositivo.texto = (_a = da.texto) !== null && _a !== void 0 ? _a : '';
    dispositivo.id = da.id;
    const situacao = new DispositivoAdicionado();
    situacao.tipoEmenda = modo;
    dispositivo.situacao = situacao;
    if (dispositivo.isDispositivoAlteracao) {
        situacao.existeNaNormaAlterada = !!da.existeNaNormaAlterada;
    }
    if (!isCaput(dispositivo) && !isOmissis(dispositivo) && !isArticulacao(dispositivo)) {
        dispositivo.createNumeroFromRotulo(da.rotulo);
        dispositivo.rotulo = da.rotulo;
        if (da.abreAspas) {
            dispositivo.cabecaAlteracao = true;
        }
    }
    if (!isArticulacao(dispositivo)) {
        dispositivo.texto = (_b = da.texto) !== null && _b !== void 0 ? _b : '';
        if (da.fechaAspas) {
            const cabecaAlteracao = getDispositivoCabecaAlteracao(dispositivo);
            cabecaAlteracao.notaAlteracao = da.notaAlteracao;
        }
    }
};
const idSemCpt = (id) => id.replace(/(_cpt)$/, '');
const processaRevisoes$1 = (state, revisoes) => {
    const elementosExcluidosEmModoDeRevisao = [];
    let elementoAnterior;
    revisoes.forEach(r => {
        var _a;
        try {
            if (isRevisaoElemento(r)) {
                const rAux = r;
                processarElementoDaRevisao(state, rAux, elementoAnterior, elementosExcluidosEmModoDeRevisao);
                if (isRevisaoDeExclusao(rAux)) {
                    elementoAnterior = rAux.elementoAposRevisao;
                }
            }
            (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.push(r);
        }
        catch (error) {
            // TODO: tratar erro
        }
    });
    state.revisoes = identificarRevisaoElementoPai(state, state.revisoes);
    return [...buildEventoRevisaoDispositivoRestaurado(state, revisoes), { stateType: StateType.ElementoIncluido, elementos: elementosExcluidosEmModoDeRevisao }];
};
const buildEventoRevisaoDispositivoRestaurado = (state, revisoes) => {
    const result = [];
    const revisoesRestauracao = revisoes.map(r => r).filter(r => r.actionType === RESTAURAR_ELEMENTO) || [];
    if (revisoesRestauracao.length) {
        const elementos = revisoesRestauracao.map(r => buscaDispositivoById(state.articulacao, r.elementoAposRevisao.lexmlId)).map(d => createElemento(d));
        result.push({ stateType: StateType.ElementoRestaurado, elementos });
    }
    return result;
};
const processarElementoDaRevisao = (state, revisao, elementoAnterior, elementosExcluidosEmModoDeRevisao) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    if (isRevisaoDeExclusao(revisao)) {
        let e;
        if (isRevisaoPrincipal(revisao)) {
            let d = findDispositivoByUuid2(state.articulacao, revisao.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura.uuid2);
            d = d || buscaDispositivoById(state.articulacao, idSemCpt(revisao.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura.lexmlId)) || null;
            e = d ? createElemento(d) : elementoAnterior;
        }
        else {
            e = elementoAnterior;
        }
        revisao.elementoAposRevisao.uuid = Counter.next();
        revisao.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura = JSON.parse(JSON.stringify(e));
        revisao.elementoAntesRevisao.uuid = revisao.elementoAposRevisao.uuid;
        revisao.elementoAntesRevisao.elementoAnteriorNaSequenciaDeLeitura = JSON.parse(JSON.stringify(e));
        atualizarUuidDoPaiDoElementoRemovido(state, revisao);
        elementosExcluidosEmModoDeRevisao.push(revisao.elementoAposRevisao);
        elementoAnterior = revisao.elementoAposRevisao;
    }
    else {
        const e = createElemento(buscaDispositivoById(state.articulacao, revisao.elementoAposRevisao.lexmlId));
        revisao.elementoAposRevisao.uuid = e.uuid;
        revisao.elementoAposRevisao.uuid2 = e.uuid2;
        revisao.elementoAposRevisao.hierarquia.pai.uuid = (_b = (_a = e.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.uuid;
        revisao.elementoAposRevisao.hierarquia.pai.uuid2 = (_d = (_c = e.hierarquia) === null || _c === void 0 ? void 0 : _c.pai) === null || _d === void 0 ? void 0 : _d.uuid2;
        if (isRevisaoDeMovimentacao(revisao) || isRevisaoDeTransformacao(revisao)) {
            revisao.elementoAntesRevisao.uuid = Counter.next();
            revisao.elementoAntesRevisao.hierarquia.pai.uuid = (_f = (_e = e.hierarquia) === null || _e === void 0 ? void 0 : _e.pai) === null || _f === void 0 ? void 0 : _f.uuid;
            revisao.elementoAntesRevisao.hierarquia.pai.uuid2 = (_h = (_g = e.hierarquia) === null || _g === void 0 ? void 0 : _g.pai) === null || _h === void 0 ? void 0 : _h.uuid2;
        }
        else if (revisao.stateType !== StateType.ElementoIncluido) {
            revisao.elementoAntesRevisao.uuid = e.uuid;
            revisao.elementoAntesRevisao.uuid2 = e.uuid2;
            revisao.elementoAntesRevisao.hierarquia.pai.uuid = (_k = (_j = e.hierarquia) === null || _j === void 0 ? void 0 : _j.pai) === null || _k === void 0 ? void 0 : _k.uuid;
            revisao.elementoAntesRevisao.hierarquia.pai.uuid2 = (_m = (_l = e.hierarquia) === null || _l === void 0 ? void 0 : _l.pai) === null || _m === void 0 ? void 0 : _m.uuid2;
        }
        if (e.dispositivoAlteracao) {
            revisao.elementoAposRevisao.hierarquia.pai.uuidAlteracao = (_p = (_o = e.hierarquia) === null || _o === void 0 ? void 0 : _o.pai) === null || _p === void 0 ? void 0 : _p.uuidAlteracao;
            revisao.elementoAposRevisao.hierarquia.pai.uuid2Alteracao = (_r = (_q = e.hierarquia) === null || _q === void 0 ? void 0 : _q.pai) === null || _r === void 0 ? void 0 : _r.uuid2Alteracao;
        }
    }
};
const atualizarUuidDoPaiDoElementoRemovido = (state, revisao) => {
    let uuid = 0;
    let uuid2 = '';
    let uuidAlteracao = undefined;
    let uuid2Alteracao = undefined;
    if (isRevisaoPrincipal(revisao)) {
        const pai = buscaDispositivoById(state.articulacao, revisao.elementoAposRevisao.hierarquia.pai.lexmlId);
        uuid = pai === null || pai === void 0 ? void 0 : pai.uuid;
        uuid2 = pai === null || pai === void 0 ? void 0 : pai.uuid2;
        if (pai && isDispositivoAlteracao(pai)) {
            const articulacaoAlteracao = getArticulacao(pai);
            uuidAlteracao = articulacaoAlteracao === null || articulacaoAlteracao === void 0 ? void 0 : articulacaoAlteracao.uuid;
            uuid2Alteracao = articulacaoAlteracao === null || articulacaoAlteracao === void 0 ? void 0 : articulacaoAlteracao.uuid2;
        }
    }
    else {
        const revisaoPai = findRevisaoById(state.revisoes, revisao.idRevisaoElementoPai);
        uuid = revisaoPai.elementoAposRevisao.uuid;
        uuid2 = revisaoPai.elementoAposRevisao.uuid2;
    }
    revisao.elementoAposRevisao.hierarquia.pai.uuid = uuid;
    revisao.elementoAposRevisao.hierarquia.pai.uuid2 = uuid2;
    revisao.elementoAntesRevisao.hierarquia.pai.uuid = uuid;
    revisao.elementoAntesRevisao.hierarquia.pai.uuid2 = uuid2;
    revisao.elementoAposRevisao.hierarquia.pai.uuidAlteracao = uuidAlteracao;
    revisao.elementoAposRevisao.hierarquia.pai.uuid2Alteracao = uuid2Alteracao;
    revisao.elementoAntesRevisao.hierarquia.pai.uuidAlteracao = uuidAlteracao;
    revisao.elementoAntesRevisao.hierarquia.pai.uuid2Alteracao = uuid2Alteracao;
};

const atualizaElemento = (state, action) => {
    var _a, _b, _c, _d, _e;
    const dispositivo = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (dispositivo === undefined || dispositivo.texto === action.atual.conteudo.texto) {
        state.ui.events = [];
        return state;
    }
    const original = createElemento(dispositivo);
    dispositivo.texto = !isDispositivoAlteracao(dispositivo) ? (_a = action.atual.conteudo) === null || _a === void 0 ? void 0 : _a.texto : normalizaSeForOmissis((_c = (_b = action.atual.conteudo) === null || _b === void 0 ? void 0 : _b.texto) !== null && _c !== void 0 ? _c : '');
    if (((_d = dispositivo.situacao) === null || _d === void 0 ? void 0 : _d.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
        dispositivo.situacao = new DispositivoModificado(original);
    }
    const eventos = buildEventoAtualizacaoElemento(dispositivo);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, buildUpdateEvent(dispositivo, original)),
        present: eventos.build(),
        future: state.future,
        ui: {
            events: eventos.build(),
            alertas: (_e = state.ui) === null || _e === void 0 ? void 0 : _e.alertas,
        },
    };
};

const atualizaNotaAlteracao = (state, action) => {
    var _a;
    const dispositivo = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (dispositivo === undefined) {
        state.ui.events = [];
        return state;
    }
    if (!isAcaoPermitida(dispositivo, AtualizarNotaAlteracao)) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.INFO, descricao: 'Nessa situação, não é possível alterar esse dado do dispositivo' });
    }
    const cabecaAlteracao = getDispositivoCabecaAlteracao(dispositivo);
    if (cabecaAlteracao === undefined) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.INFO, descricao: 'Nessa situação, não é possível alterar esse dado do dispositivo' });
    }
    if (cabecaAlteracao.notaAlteracao === action.notaAlteracao) {
        state.ui.events = [];
        return state;
    }
    const original = createElemento(dispositivo);
    cabecaAlteracao.notaAlteracao = action.notaAlteracao || undefined;
    const alterado = createElemento(dispositivo);
    const eventos = [];
    eventos.push({
        stateType: StateType.ElementoModificado,
        elementos: [original, alterado],
    });
    eventos.push({
        stateType: StateType.ElementoValidado,
        elementos: [alterado],
    });
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, eventos),
        present: eventos,
        future: [],
        ui: {
            events: eventos,
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
    };
};

const atualizaReferenciaElemento = (state, action) => {
    var _a, _b, _c, _d;
    const dispositivo = getDispositivoFromElemento(state.articulacao, action.atual, true);
    const urnNova = action.atual.norma;
    const urnAnterior = (dispositivo === null || dispositivo === void 0 ? void 0 : dispositivo.alteracoes.base) || '';
    const regex = new RegExp(`<a.+href=.${urnAnterior}.*?>.*?</a>`, 'ig');
    const normaExtenso = getNomeExtensoComDataExtenso(urnNova);
    if (dispositivo === undefined || !dispositivo.alteracoes || (urnAnterior === urnNova && dispositivo.texto.match(regex))) {
        state.ui.events = [];
        return state;
    }
    const normaLink = buildHtmlLink(urnNova);
    const textoDispositivo = dispositivo.texto;
    if (dispositivo.texto.match(regex)) {
        dispositivo.texto = textoDispositivo.replace(regex, normaLink);
    }
    else if (dispositivo.texto.includes(normaExtenso)) {
        dispositivo.texto = textoDispositivo.replace(normaExtenso, normaLink);
    }
    else if (urnNova && validaUrn(urnNova) && (dispositivo.texto === undefined || ((_a = dispositivo.texto) === null || _a === void 0 ? void 0 : _a.trim()) === '')) {
        const genero = (_b = getTipo$1(urnNova)) === null || _b === void 0 ? void 0 : _b.genero;
        const textoUrn = `${getTipo$1(urnNova).descricao} nº ${formataNumero(getNumero(urnNova))}, de ${getDataPorExtenso(urnNova)}`;
        dispositivo.texto = `${genero && genero === 'M' ? 'O' : 'A'} <a href="${urnNova}">${textoUrn}</a>, passa a vigorar com as seguintes alterações:`;
    }
    else {
        const index = parseInt(localStorage.indexCursor);
        dispositivo.texto = [textoDispositivo.slice(0, index), normaLink, textoDispositivo.slice(index)].join(' ');
        localStorage.removeItem('indexCursor');
    }
    const original = createElemento(dispositivo);
    dispositivo.alteracoes.base = urnNova;
    if (((_c = dispositivo.situacao) === null || _c === void 0 ? void 0 : _c.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
        dispositivo.situacao = new DispositivoModificado(original);
    }
    const eventosUi = new Eventos();
    const elemento = createElemento(dispositivo, true);
    elemento.mensagens = validaDispositivo(dispositivo);
    eventosUi.add(StateType.ElementoValidado, [elemento]);
    eventosUi.add(StateType.ElementoModificado, [elemento]);
    eventosUi.add(StateType.SituacaoElementoModificada, [elemento]);
    const eventos = buildEventoAtualizacaoElemento(dispositivo);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, buildUpdateEvent(dispositivo, original)),
        present: eventos.build(),
        future: state.future,
        ui: {
            events: eventosUi.build(),
            alertas: (_d = state.ui) === null || _d === void 0 ? void 0 : _d.alertas,
        },
    };
};

// const houveAlteracaoNoTextoAposAcao = (dispositivo: Dispositivo, action: any): boolean => {
//   const textoAtual = action.atual?.conteudo?.texto;
//   const textoOriginal = dispositivo.situacao.dispositivoOriginal?.conteudo?.texto;
//   return textoAtual !== dispositivo.texto && textoAtual !== textoOriginal;
// };
const atualizaTextoElemento = (state, action) => {
    var _a, _b, _c, _d, _e, _f;
    const dispositivo = getDispositivoFromElemento(state.articulacao, action.atual, true);
    const textoOriginal = (_b = (_a = dispositivo === null || dispositivo === void 0 ? void 0 : dispositivo.situacao.dispositivoOriginal) === null || _a === void 0 ? void 0 : _a.conteudo) === null || _b === void 0 ? void 0 : _b.texto;
    const textoAtual = (_d = (_c = action.atual) === null || _c === void 0 ? void 0 : _c.conteudo) === null || _d === void 0 ? void 0 : _d.texto;
    const dispositivoOriginalNovamente = dispositivo && textoOriginal === textoAtual;
    if (dispositivo === undefined || dispositivo.texto === textoAtual) {
        state.ui.events = [];
        return state;
    }
    const original = createElemento(dispositivo);
    dispositivo.texto = !isDispositivoAlteracao(dispositivo) ? textoAtual : normalizaSeForOmissis(textoAtual !== null && textoAtual !== void 0 ? textoAtual : '');
    if (dispositivoOriginalNovamente) {
        dispositivo.situacao = new DispositivoOriginal();
    }
    else if (((_e = dispositivo.situacao) === null || _e === void 0 ? void 0 : _e.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
        dispositivo.situacao = new DispositivoModificado(original);
    }
    const eventosUi = new Eventos();
    const elemento = createElemento(dispositivo, true);
    elemento.mensagens = validaDispositivo(dispositivo);
    // if (houveAlteracaoNoTextoAposAcao(dispositivo, action)) {
    //   eventosUi.add(StateType.ElementoModificado, [elemento]);
    // }
    if (isTextoMaiusculo(dispositivo)) {
        dispositivo.texto = dispositivo.texto.toUpperCase();
    }
    eventosUi.add(StateType.ElementoModificado, [elemento]);
    eventosUi.add(StateType.ElementoValidado, criaListaElementosAfinsValidados(dispositivo));
    if (textoAtual === '') {
        eventosUi.add(StateType.ElementoMarcado, [elemento]);
    }
    eventosUi.eventos.push({ stateType: StateType.ElementoSelecionado, elementos: [elemento] });
    const eventos = buildEventoAtualizacaoElemento(dispositivo);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, buildUpdateEvent(dispositivo, original)),
        present: eventos.build(),
        future: [],
        ui: {
            events: eventosUi.build(),
            alertas: (_f = state.ui) === null || _f === void 0 ? void 0 : _f.alertas,
        },
    };
};

const solicitaNorma = (state, action) => {
    var _a;
    const atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (atual === undefined) {
        state.ui.events = [];
        return state;
    }
    atual.mensagens = validaDispositivo(atual);
    const elemento = createElemento(atual, true);
    const events = [
        {
            stateType: StateType.InformarNorma,
            elementos: [elemento],
        },
    ];
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: state.present,
        future: [],
        ui: {
            events,
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
    };
};

const hasFix = (dispositivo) => {
    var _a, _b;
    return ((_b = (_a = dispositivo.mensagens) === null || _a === void 0 ? void 0 : _a.filter(m => m.fix)) !== null && _b !== void 0 ? _b : []).length > 0;
};
const autoFixElemento = (state, action) => {
    var _a, _b;
    const atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (atual === undefined || !hasFix(atual)) {
        state.ui.events = [];
        return state;
    }
    const eventos = new Eventos();
    switch ((_a = action.mensagem) === null || _a === void 0 ? void 0 : _a.descricao) {
        case AutoFix.INFORMAR_NORMA: {
            return solicitaNorma(state, action);
        }
        case AutoFix.OMISSIS_ANTES: {
            const anterior = getDispositivoAnterior(atual);
            const novo = criaDispositivo(atual.pai, TipoDispositivo.omissis.tipo, anterior, anterior ? undefined : 0);
            novo.situacao = new DispositivoAdicionado();
            novo.mensagens = validaDispositivo(novo);
            const elementoNovo = createElemento(novo, true);
            atual.mensagens = validaDispositivo(atual);
            const elementoAtual = createElemento(atual);
            eventos.add(StateType.ElementoIncluido, [elementoNovo]);
            eventos.add(StateType.ElementoValidado, [elementoAtual]);
            eventos.setReferencia(createElemento(anterior !== null && anterior !== void 0 ? anterior : (isIncisoCaput(atual) ? atual.pai.pai : atual.pai)));
            break;
        }
        case AutoFix.OMISSIS_SEQUENCIAIS: {
            const removido = createElemento(atual);
            let proximo = getDispositivoPosterior(atual);
            if (!proximo || !isOmissis(proximo)) {
                proximo = buscaProximoOmissis(atual.pai);
            }
            const pai = atual.pai;
            pai.removeFilho(atual);
            pai.renumeraFilhos();
            eventos.add(StateType.ElementoRemovido, [removido]);
            proximo && eventos.add(StateType.ElementoValidado, [createElemento(proximo)]);
            break;
        }
        default:
            state.ui = [];
            return state;
    }
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, eventos.build()),
        present: eventos.build(),
        future: [],
        ui: {
            events: eventos.build(),
            alertas: (_b = state.ui) === null || _b === void 0 ? void 0 : _b.alertas,
        },
    };
};

const informaExistenciaDoElementoNaNorma = (state, action) => {
    var _a;
    const dispositivo = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (dispositivo === undefined) {
        state.ui.events = [];
        return state;
    }
    if (!isAcaoPermitida(dispositivo, InformarExistenciaDoElementoNaNorma)) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.INFO, descricao: 'Nessa situação, não é possível alterar esse dado do dispositivo' });
    }
    const currentValueExisteNaNormaAlterada = !isDispositivoNovoNaNormaAlterada(dispositivo);
    const newValueExisteNaNormaAlterada = action.existeNaNormaAlterada;
    if (currentValueExisteNaNormaAlterada === newValueExisteNaNormaAlterada) {
        state.ui.events = [];
        return state;
    }
    const mensagemValidacao = validaAlteracaoExistenciaDispositivo(dispositivo, newValueExisteNaNormaAlterada);
    if (mensagemValidacao) {
        return retornaEstadoAtualComMensagem(state, mensagemValidacao);
    }
    const mudouIndicacaoDeExistenteParaNovo = currentValueExisteNaNormaAlterada && !action.existeNaNormaAlterada;
    const eventos = [];
    if (mudouIndicacaoDeExistenteParaNovo) {
        const dispositivos = getDispositivoAndFilhosAsLista(dispositivo).filter(d => !isAgrupador(dispositivo) || isAgrupador(d));
        dispositivos.forEach(d => {
            const original = createElemento(d);
            d.situacao.existeNaNormaAlterada = action.existeNaNormaAlterada;
            const alterado = createElemento(d);
            eventos.push({
                stateType: StateType.ElementoModificado,
                elementos: [original, alterado],
            });
        });
    }
    else {
        const original = createElemento(dispositivo);
        dispositivo.situacao.existeNaNormaAlterada = action.existeNaNormaAlterada;
        const alterado = createElemento(dispositivo);
        eventos.push({
            stateType: StateType.ElementoModificado,
            elementos: [original, alterado],
        });
        eventos.push({
            stateType: StateType.SituacaoElementoModificada,
            elementos: getElementos(dispositivo),
        });
    }
    eventos.push({
        stateType: StateType.ElementoSelecionado,
        elementos: [createElemento(dispositivo)],
    });
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, eventos),
        present: eventos,
        future: [],
        ui: {
            events: eventos,
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
    };
};
const validaAlteracaoExistenciaDispositivo = (dispositivo, newValueExisteNaNormaAlterada) => {
    const currentValueExisteNaNormaAlterada = !isDispositivoNovoNaNormaAlterada(dispositivo);
    if (currentValueExisteNaNormaAlterada === newValueExisteNaNormaAlterada) {
        return;
    }
    const mudouIndicacaoDeExistenteParaNovo = currentValueExisteNaNormaAlterada && !newValueExisteNaNormaAlterada;
    return mudouIndicacaoDeExistenteParaNovo ? validaAlteracaoExistenteParaNovo(dispositivo) : validaAlteracaoNovoParaExistente(dispositivo);
};
const validaAlteracaoNovoParaExistente = (dispositivo) => {
    if (isDispositivoPossuiPaiNovoNaNormaAlterada(dispositivo)) {
        return {
            tipo: TipoMensagem.INFO,
            descricao: 'Não é permitido mudar a indicação de dispositivo "Novo" para "Existente" quando dispositivo hierarquicamente superior é novo na norma alteradao.',
        };
    }
};
const validaAlteracaoExistenteParaNovo = (dispositivo) => {
    const dispositivos = getDispositivoAndFilhosAsLista(dispositivo).filter(d => !isAgrupador(dispositivo) || !isArtigo(d));
    if (existeDispositivoSemNumeroNaoOmissis(dispositivos.slice(1))) {
        return {
            tipo: TipoMensagem.INFO,
            descricao: 'Não é permitido mudar a indicação de dispositivo "Existente" para "Novo" quando existe dispositivo subordinado sem numeração.',
        };
    }
    if (existeOmissis(dispositivo)) {
        return {
            tipo: TipoMensagem.INFO,
            descricao: 'Não é permitido mudar a indicação de dispositivo "Existente" para "Novo" quando existe texto omitido na estrutura do dispositivo.',
        };
    }
    if (existeNecessidadeDeOmissis(dispositivos.slice(1))) {
        return {
            tipo: TipoMensagem.INFO,
            descricao: 'Não é permitido mudar a indicação de dispositivo "Existente" para "Novo" quando existe numeração não sequencial nos dispositivos subordinados.',
        };
    }
};
const isDispositivoPossuiPaiNovoNaNormaAlterada = (dispositivo) => {
    var _a;
    const existe = ((_a = dispositivo.pai) === null || _a === void 0 ? void 0 : _a.situacao).existeNaNormaAlterada;
    return !isArtigo(dispositivo) && !isDispositivoCabecaAlteracao(dispositivo) && !(existe !== null && existe !== void 0 ? existe : true);
};
const existeDispositivoSemNumeroNaoOmissis = (dispositivos) => {
    return dispositivos.some(d => { var _a; return (((_a = d.mensagens) === null || _a === void 0 ? void 0 : _a.some(m => { var _a; return (_a = m.descricao) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes('numere o dispositivo'); })) || d.numero === undefined) && !isOmissis(d); });
};
const existeOmissis = (dispositivo) => {
    const dispositivos = getDispositivoAndFilhosAsLista(dispositivo);
    return dispositivos.some(d => { var _a; return d.tipo === 'Omissis' || ((_a = d.texto) === null || _a === void 0 ? void 0 : _a.includes(TEXTO_OMISSIS)); });
};
const existeNecessidadeDeOmissis = (dispositivos) => {
    return dispositivos.some(d => { var _a; return (_a = d.mensagens) === null || _a === void 0 ? void 0 : _a.some(m => { var _a; return (_a = m.descricao) === null || _a === void 0 ? void 0 : _a.includes('omissis antes'); }); });
};

const limparAlertas = (state) => {
    var _a;
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: state.present,
        future: state.future,
        ui: {
            events: [{ stateType: StateType.AtualizacaoAlertas }],
            message: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.mensagem,
            alertas: [],
        },
    };
};

const transformaTipoElemento = (state, action) => {
    var _a;
    const atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    const cabecaAlteracao = atual && isDispositivoAlteracao(atual) && getDispositivoCabecaAlteracao(atual);
    if (atual === undefined) {
        state.ui.events = [];
        return state;
    }
    if (!isAcaoTransformacaoPermitida(atual, action)) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.INFO, descricao: 'Nessa situação, não é possível transformar o dispositivo' });
    }
    const dispositivoAnteriorAtual = getDispositivoAnterior(atual);
    if (dispositivoAnteriorAtual && isDispositivoNovoNaNormaAlterada(dispositivoAnteriorAtual) && !isDispositivoNovoNaNormaAlterada(atual)) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.INFO, descricao: 'Dispositivo existente não pode ser transformado em filho de dispositivo novo' });
    }
    const ultimoFilhoDispositivoAnteriorAtual = cabecaAlteracao && dispositivoAnteriorAtual && getUltimoFilho(dispositivoAnteriorAtual);
    action.subType = normalizaNomeAcaoTransformacao(atual, action.subType);
    const removidos = [...getElementos(atual, false, true)];
    const atualRenumerados = listaDispositivosRenumerados(atual);
    const novo = converteDispositivo(atual, action);
    const novoRenumerados = listaDispositivosRenumerados(novo);
    const renumerados = novoRenumerados.concat(atualRenumerados);
    const validados = getElementosDoDispositivo(novo, true);
    const paiNovo = isCaput(novo.pai) ? novo.pai.pai : novo.pai;
    if (dispositivoAnteriorAtual && isParagrafoUnico(dispositivoAnteriorAtual)) {
        dispositivoAnteriorAtual.pai.renumeraFilhos();
        renumerados.unshift(dispositivoAnteriorAtual);
    }
    const dispositivoAnterior = getDispositivoAnterior(novo);
    if (dispositivoAnterior) {
        const mensagens = validaDispositivo(dispositivoAnterior);
        if (dispositivoAnterior.mensagens !== mensagens) {
            validados.unshift(createElemento(dispositivoAnterior));
        }
    }
    const parent = validados.filter(v => v.uuid === paiNovo.uuid).length > 0 ? atual.pai : paiNovo;
    if (parent) {
        getDispositivoAndFilhosAsLista(parent).forEach(d => {
            d.mensagens = validaDispositivo(d);
            validados.unshift(createElemento(d));
        });
    }
    const referencia = dispositivoAnterior !== null && dispositivoAnterior !== void 0 ? dispositivoAnterior : novo.pai;
    const eventos = buildEventoTransformacaooElemento(isCaput(referencia) ? referencia.pai : referencia, novo, removidos, renumerados.map(d => {
        d.mensagens = validaDispositivo(d);
        const el = createElemento(d);
        return el;
    }), validados);
    if (novo.tipo === 'Artigo' && cabecaAlteracao) {
        eventos.add(StateType.SituacaoElementoModificada, [createElemento(getUltimoFilho(cabecaAlteracao))]);
    }
    else if (novo.tipo === 'Paragrafo' && ultimoFilhoDispositivoAnteriorAtual) {
        eventos.add(StateType.SituacaoElementoModificada, [createElemento(ultimoFilhoDispositivoAnteriorAtual)]);
    }
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, eventos.build()),
        present: eventos.build(),
        future: [],
        ui: {
            events: eventos.build(),
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
    };
};

const modificaTipoElementoWithTab = (state, action) => {
    const atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (atual === undefined) {
        state.ui.events = [];
        return state;
    }
    const acao = action.type === TAB ? atual.getAcaoPossivelTab(atual) : atual.getAcaoPossivelShiftTab(atual);
    if (!acao) {
        state.ui.events = [];
        return state;
    }
    const newAction = {
        type: TRANSFORMAR_TIPO_ELEMENTO,
        subType: acao.nomeAcao,
        atual: action.atual,
        novo: {
            tipo: acao.tipo,
        },
    };
    return transformaTipoElemento(state, newAction);
};

const moveElementoAbaixo = (state, action) => {
    var _a;
    const atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (atual === undefined) {
        state.ui.events = [];
        return state;
    }
    if (!isAcaoPermitida(atual, MoverElementoAbaixo)) {
        return montaEMostraMensagensErro(atual, state);
    }
    if (state.emRevisao && existeFilhoExcluidoDuranteRevisao(state, atual) && !action.isRejeitandoRevisao) {
        return retornaEstadoAtualComMensagem(state, {
            tipo: TipoMensagem.ERROR,
            descricao: 'Não é possível mover dispositivo que possua dispositivo subordinado já removido ou alterado em modo de revisão.',
        });
    }
    // Dispositivo cuja posição será trocada com o atual
    let proximo = getIrmaoPosteriorIndependenteDeTipo(atual);
    if (!proximo && isArtigo(atual)) {
        proximo = getProximoAgrupadorAposArtigo(atual);
    }
    if (!proximo) {
        return state;
    }
    const movendoArtigoParaAgrupador = isAgrupadorNaoArticulacao(proximo);
    const removidos = [...getElementos(atual, false, true)];
    const renumerados = listaDispositivosRenumerados(atual);
    const paiAntigo = atual.pai;
    const novoPai = movendoArtigoParaAgrupador ? proximo : proximo.pai;
    const pos = movendoArtigoParaAgrupador ? 0 : novoPai.indexOf(atual) + 1;
    resetUuidTodaArvore(atual);
    atual.pai.removeFilho(atual);
    novoPai.addFilhoOnPosition(atual, pos);
    novoPai.renumeraFilhos();
    if (paiAntigo !== novoPai) {
        paiAntigo.renumeraFilhos();
    }
    getDispositivoAndFilhosAsLista(atual).forEach(d => (d.id = buildId(d)));
    const dAnterior = atual.pai.filhos[atual.pai.indexOf(atual) - 1];
    dAnterior && getDispositivoAndFilhosAsLista(dAnterior).forEach(d => (d.id = buildId(d)));
    const referencia = movendoArtigoParaAgrupador ? proximo : getUltimoFilho(proximo);
    const eventos = new Eventos();
    eventos.setReferencia(createElemento(ajustaReferencia(referencia, atual)));
    eventos.add(StateType.ElementoIncluido, buildListaDispositivos(atual, []).map(v => {
        v.mensagens = validaDispositivo(v);
        return createElemento(v);
    }));
    eventos.add(StateType.ElementoRemovido, removidos);
    eventos.add(StateType.ElementoRenumerado, renumerados.map(r => createElemento(r)));
    // Elementos em StateType.ElementoMarcado:
    // Primeiro elemento será usado para marcar o elemento no editor
    // Segundo elemento será usado para marcar o elemento em caso de "undo"
    eventos.add(StateType.ElementoMarcado, [createElemento(atual), action.atual]);
    eventos.add(StateType.ElementoSelecionado, [createElemento(atual)]);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, eventos.build()),
        present: eventos.build(),
        future: [],
        ui: {
            events: eventos.build(),
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
    };
};

const moveElementoAcima = (state, action) => {
    var _a;
    const atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (atual === undefined) {
        state.ui.events = [];
        return state;
    }
    if (!isAcaoPermitida(atual, MoverElementoAcima)) {
        return montaEMostraMensagensErro(atual, state);
    }
    if (state.emRevisao && existeFilhoExcluidoDuranteRevisao(state, atual) && !action.isRejeitandoRevisao) {
        return retornaEstadoAtualComMensagem(state, {
            tipo: TipoMensagem.ERROR,
            descricao: 'Não é possível mover dispositivo que possua dispositivo subordinado já removido ou alterado em modo de revisão.',
        });
    }
    // Dispositivo cuja posição será trocada com o atual
    const emAlteracao = isDispositivoAlteracao(atual);
    const anterior = isArtigo(atual)
        ? getDispositivoAnteriorNaSequenciaDeLeitura(atual, d => (isArtigo(d) || isAgrupador(d)) && isDispositivoAlteracao(d) === emAlteracao)
        : getIrmaoAnteriorIndependenteDeTipo(atual);
    if (anterior === undefined || isDispositivoRaiz(anterior) || isEmenta(anterior)) {
        return state;
    }
    const removidos = getElementos(atual, false, true);
    const renumerados = irmaosMesmoTipo(atual).filter(d => d !== atual && d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL);
    resetUuidTodaArvore(atual);
    // Partindo do caso feliz (movendo entre irmãos)
    const paiAntigo = atual.pai;
    let novoPai = anterior.pai;
    let pos = novoPai.indexOf(anterior);
    /*
      Verifica casos de artigo pulando agrupador.
  
      Agrupador
        Agrupador
      Agrupador
        Art <movendo este para cima>
      ---
      Agrupador
        Art
      Agrupador
        Art <movendo este para cima>
    */
    // Artigo pulando agrupador
    if (isAgrupador(anterior)) {
        const anteriorAoAgrupador = getDispositivoAnteriorNaSequenciaDeLeitura(anterior, d => (isArtigo(d) || isAgrupador(d)) && isDispositivoAlteracao(d) === emAlteracao);
        if (isAgrupador(anteriorAoAgrupador)) {
            novoPai = anteriorAoAgrupador;
            pos = 0;
        }
        else {
            // Artigo
            novoPai = anteriorAoAgrupador.pai;
            pos = novoPai.indexOf(anteriorAoAgrupador) + 1;
        }
    }
    atual.pai.removeFilho(atual);
    novoPai.addFilhoOnPosition(atual, pos);
    novoPai.renumeraFilhos();
    if (paiAntigo !== novoPai) {
        paiAntigo.renumeraFilhos();
    }
    getDispositivoAndFilhosAsLista(atual).forEach(d => (d.id = buildId(d)));
    const dPosterior = atual.pai.filhos[atual.pai.indexOf(atual) + 1];
    dPosterior && getDispositivoAndFilhosAsLista(dPosterior).forEach(d => (d.id = buildId(d)));
    const referencia = getDispositivoAnteriorNaSequenciaDeLeitura(atual, d => !isCaput(d) && !isArticulacaoAlteracao(d));
    const eventos = new Eventos();
    eventos.add(StateType.ElementoRemovido, removidos);
    eventos.setReferencia(createElemento(ajustaReferencia(referencia, atual)));
    eventos.add(StateType.ElementoIncluido, buildListaDispositivos(atual, []).map(v => {
        v.mensagens = validaDispositivo(v);
        return createElemento(v);
    }));
    eventos.add(StateType.ElementoRenumerado, renumerados.map(r => createElemento(r)));
    // Elementos em StateType.ElementoMarcado:
    // Primeiro elemento será usado para marcar o elemento no editor
    // Segundo elemento será usado para marcar o elemento em caso de "undo"
    eventos.add(StateType.ElementoMarcado, [createElemento(atual), action.atual]);
    eventos.add(StateType.ElementoSelecionado, [createElemento(atual)]);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, eventos.build()),
        present: eventos.build(),
        future: [],
        ui: {
            events: eventos.build(),
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
    };
};

const removeElemento = (state, action) => {
    var _a;
    const dispositivo = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (dispositivo === undefined) {
        state.ui.events = [];
        return state;
    }
    if (isAgrupador(dispositivo) && !isDispositivoAlteracao(dispositivo)) {
        // Só deixa remover agrupador se articulação permenecer consistente
        if (isArticulacao(dispositivo.pai)) {
            const tipos = getTiposAgrupadorArtigoPermitidosNaArticulacao();
            if (!dispositivo.filhos.every(f => isArtigo(f) || tipos.includes(f.tipo))) {
                return retornaEstadoAtualComMensagem(state, {
                    tipo: TipoMensagem.ERROR,
                    descricao: `Operação não permitida (se houver seções abaixo do "${dispositivo.rotulo}", elas devem ser removidas antes)`,
                });
            }
        }
        else if (dispositivo.filhos.filter(f => !isArtigo(f)).length) {
            const dispositivos = getDispositivoAndFilhosAsLista(dispositivo.pai).filter(isAgrupador);
            const agrupadorAntes = dispositivos[dispositivos.indexOf(dispositivo) - 1] || {};
            const agrupadorDepois = dispositivos[dispositivos.indexOf(dispositivo) + 1] || {};
            return retornaEstadoAtualComMensagem(state, {
                tipo: TipoMensagem.ERROR,
                descricao: `Operação não permitida (o agrupador "${agrupadorDepois.rotulo}" não poder estar diretamente subordinado ao agrupador "${agrupadorAntes.rotulo}")`,
            });
        }
    }
    if (!isAcaoPermitida(dispositivo, RemoverElemento)) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.ERROR, descricao: 'Não é possível excluir um dispositivo original mas apenas suprimi-lo.' });
    }
    if (!isDispositivoAlteracao(dispositivo) &&
        (isArtigoUnico(dispositivo) || (state.articulacao.filhos.length === 1 && state.articulacao.filhos[0] === dispositivo && !hasFilhos(dispositivo)))) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.ERROR, descricao: 'Não é possível excluir o único dispositivo disponível.' });
    }
    if (state.emRevisao && existeFilhoExcluidoOuAlteradoDuranteRevisao(state, dispositivo) && !action.isRejeitandoRevisao) {
        return retornaEstadoAtualComMensagem(state, {
            tipo: TipoMensagem.ERROR,
            descricao: 'Não é possível remover dispositivo que possua dispositivo subordinado já removido ou alterado em modo de revisão.',
        });
    }
    const revisao = findRevisaoByElementoUuid2(state.revisoes, dispositivo.uuid2);
    if (state.emRevisao && revisao && isRevisaoPrincipal(revisao) && isRevisaoDeMovimentacao(revisao) && !action.isRejeitandoRevisao) {
        return retornaEstadoAtualComMensagem(state, {
            tipo: TipoMensagem.ERROR,
            descricao: 'Não é possível remover dispositivo movido em modo de revisão.',
        });
    }
    const primeiroFilhoDoAgrupador = isAgrupador(dispositivo) ? dispositivo.filhos[0] || getDispositivoPosterior(dispositivo) || getDispositivoAnterior(dispositivo) : undefined;
    const elPrimeiroFilhoDoAgrupador = primeiroFilhoDoAgrupador ? createElemento(primeiroFilhoDoAgrupador) : undefined;
    const isAtualizarElementoEmenta = hasEmenta(dispositivo) && dispositivo === getPrimeiroAgrupadorNaArticulacao(dispositivo);
    const events = isAgrupador(dispositivo) ? removeAgrupadorAndBuildEvents(state.articulacao, dispositivo) : removeAndBuildEvents(state, dispositivo);
    if (elPrimeiroFilhoDoAgrupador) {
        events.push({ stateType: StateType.ElementoMarcado, elementos: [elPrimeiroFilhoDoAgrupador] });
        events.push({ stateType: StateType.ElementoReferenciado, elementos: [elPrimeiroFilhoDoAgrupador] });
    }
    if (isAtualizarElementoEmenta) {
        events.push({ stateType: StateType.SituacaoElementoModificada, elementos: [createElemento(state.articulacao.projetoNorma.ementa)] });
    }
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, events),
        present: events,
        future: [],
        ui: {
            events,
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
    };
};

const getTipoSituacaoByDescricao = (descricao) => {
    switch (descricao) {
        case DescricaoSituacao.DISPOSITIVO_ADICIONADO:
            return new DispositivoAdicionado();
        case DescricaoSituacao.DISPOSITIVO_NOVO:
            return new DispositivoNovo();
        default:
            return new DispositivoOriginal();
    }
};
const getDispositivoPaiFromElemento = (articulacao, elemento) => {
    if (isElementoDispositivoAlteracao(elemento)) {
        const artigo = isArticulacaoAlteracao(articulacao)
            ? articulacao.pai
            : findDispositivoByUuid(articulacao, elemento.hierarquia.pai.uuidAlteracao) || buscaDispositivoById(articulacao, elemento.hierarquia.pai.lexmlId);
        if (artigo) {
            if (!artigo.alteracoes) {
                artigo.alteracoes = createArticulacao();
                artigo.alteracoes.pai = artigo;
            }
            if (elemento.hierarquia.pai.tipo === TipoDispositivo.articulacao.tipo) {
                return artigo.alteracoes;
            }
            return findDispositivoByUuid(artigo.alteracoes, elemento.hierarquia.pai.uuid) || buscaDispositivoById(artigo.alteracoes, elemento.hierarquia.pai.lexmlId) || null;
        }
    }
    return findDispositivoByUuid(articulacao, elemento.hierarquia.pai.uuid) || buscaDispositivoById(articulacao, elemento.hierarquia.pai.lexmlId) || null;
};
const isOmissisCaput = (elemento) => {
    return elemento.tipo === TipoDispositivo.omissis.tipo && elemento.tipoOmissis === 'inciso-caput';
};
const redodDispositivoExcluido = (elemento, pai, modo) => {
    var _a, _b, _c;
    const novo = criaDispositivo(isArtigo(pai) && (elemento.tipo === TipoDispositivo.inciso.name || isOmissisCaput(elemento)) ? pai.caput : pai, elemento.tipo, undefined, elemento.hierarquia.posicao);
    novo.uuid = elemento.uuid;
    novo.uuid2 = elemento.uuid2;
    novo.id = elemento.lexmlId;
    novo.texto = (_b = (_a = elemento === null || elemento === void 0 ? void 0 : elemento.conteudo) === null || _a === void 0 ? void 0 : _a.texto) !== null && _b !== void 0 ? _b : '';
    novo.numero = (_c = elemento === null || elemento === void 0 ? void 0 : elemento.hierarquia) === null || _c === void 0 ? void 0 : _c.numero;
    novo.rotulo = elemento === null || elemento === void 0 ? void 0 : elemento.rotulo;
    novo.mensagens = elemento === null || elemento === void 0 ? void 0 : elemento.mensagens;
    novo.situacao = getTipoSituacaoByDescricao(elemento.descricaoSituacao);
    if (elemento.descricaoSituacao === 'Dispositivo Adicionado') {
        novo.situacao.existeNaNormaAlterada = elemento.existeNaNormaAlterada;
        if (modo) {
            novo.situacao.tipoEmenda = modo;
        }
    }
    if (isArtigo(novo)) {
        novo.caput.situacao = getTipoSituacaoByDescricao(elemento.descricaoSituacao);
        if (elemento.norma) {
            createAlteracao(novo);
            novo.alteracoes.base = elemento.norma;
            novo.alteracoes.situacao = new DispositivoAdicionado();
            novo.alteracoes.situacao.tipoEmenda = modo;
        }
    }
    return novo;
};
const redoDispositivosExcluidos = (articulacao, elementos, modo) => {
    const primeiroElemento = elementos.shift();
    const pai = getDispositivoPaiFromElemento(articulacao, primeiroElemento) || buscaDispositivoById(articulacao, primeiroElemento.hierarquia.pai.lexmlId);
    const primeiro = redodDispositivoExcluido(primeiroElemento, pai, modo);
    const idPrimeiroDispositivo = primeiro.id;
    const novos = [primeiro];
    elementos === null || elementos === void 0 ? void 0 : elementos.forEach(filho => {
        var _a, _b;
        const parent = ((_a = filho.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) === ((_b = primeiroElemento === null || primeiroElemento === void 0 ? void 0 : primeiroElemento.hierarquia) === null || _b === void 0 ? void 0 : _b.pai)
            ? primeiro.pai
            : getDispositivoPaiFromElemento(articulacao, filho) || buscaDispositivoById(articulacao, idPrimeiroDispositivo);
        const novo = redodDispositivoExcluido(filho, parent, modo);
        novos.push(novo);
    });
    return novos;
};
const incluir = (state, evento, novosEvento) => {
    if (evento !== undefined && evento.elementos !== undefined && evento.elementos[0] !== undefined) {
        const elemento = evento.elementos[0];
        const procurarElementoAnterior = evento.elementos.some(e => e.elementoAnteriorNaSequenciaDeLeitura);
        const pai = getDispositivoPaiFromElemento(state.articulacao, elemento);
        const novos = redoDispositivosExcluidos(state.articulacao, evento.elementos, state.modo);
        pai === null || pai === void 0 ? void 0 : pai.renumeraFilhos();
        if (novosEvento) {
            const posicao = elemento.hierarquia.posicao;
            let referencia = posicao === 0 ? (isArticulacao(pai) && isArticulacaoAlteracao(pai) ? pai.pai : pai) : getUltimoFilho(getDispositivoAnterior(novos[0]));
            if (referencia) {
                referencia = isArticulacao(referencia) && hasEmenta(referencia) ? referencia.projetoNorma.ementa : referencia;
                const dispositivo = getDispositivoFromElemento(state.articulacao, referencia);
                dispositivo ? (novosEvento.referencia = createElemento(dispositivo)) : retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.ERROR, descricao: 'Erro inesperado' });
            }
        }
        if (evento.stateType === StateType.ElementoIncluido) {
            novosEvento.referencia = evento.referencia;
        }
        return novos.map(n => createElemento(n, true, procurarElementoAnterior));
    }
    return [];
};
const remover = (state, evento) => {
    if (evento !== undefined && evento.elementos !== undefined && evento.elementos[0] !== undefined) {
        evento.elementos.forEach(el => {
            const dispositivo = getDispositivoFromElemento(state.articulacao, el, true);
            if (dispositivo) {
                const pai = dispositivo.pai;
                pai.removeFilho(dispositivo);
                pai.renumeraFilhos();
            }
        });
        return evento.elementos;
    }
    return [];
};
const restaurarSituacao = (state, evento, eventoRestaurados, Situacao) => {
    if (evento !== undefined && evento.elementos !== undefined && evento.elementos[0] !== undefined) {
        evento.elementos.forEach(el => {
            var _a, _b, _c, _d, _e, _f, _g;
            const d = getDispositivoFromElemento(state.articulacao, el, true);
            if (Situacao instanceof DispositivoOriginal) {
                d.numero = (_b = (_a = d.situacao.dispositivoOriginal) === null || _a === void 0 ? void 0 : _a.numero) !== null && _b !== void 0 ? _b : '';
                d.rotulo = (_d = (_c = d.situacao.dispositivoOriginal) === null || _c === void 0 ? void 0 : _c.rotulo) !== null && _d !== void 0 ? _d : '';
                d.texto = (_g = (_f = (_e = d.situacao.dispositivoOriginal) === null || _e === void 0 ? void 0 : _e.conteudo) === null || _f === void 0 ? void 0 : _f.texto) !== null && _g !== void 0 ? _g : '';
                d.situacao = new DispositivoOriginal();
            }
            else {
                d.situacao = new Situacao(createElemento(d));
            }
            eventoRestaurados.elementos.push(createElemento(d));
        });
        return eventoRestaurados.elementos;
    }
    return [];
};
const processarModificados = (state, evento, operacao, revisoes = []) => {
    if (evento !== undefined && evento.elementos !== undefined && evento.elementos[0] !== undefined) {
        const novosElementos = [];
        let anterior = 0;
        evento.elementos.forEach(e => {
            var _a, _b, _c, _d, _e, _f, _g;
            const dispositivo = getDispositivoFromElemento(state.articulacao, e, true);
            if (dispositivo) {
                const permiteAtualizar = anterior !== dispositivo.uuid || (operacao === 'REDO' && anterior === dispositivo.uuid);
                if (permiteAtualizar) {
                    if (dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO) {
                        if (findRevisaoDeRestauracaoByUuid(revisoes, dispositivo.uuid) || dispositivo.situacao.dispositivoOriginal.conteudo.texto === ((_a = e.conteudo) === null || _a === void 0 ? void 0 : _a.texto)) {
                            dispositivo.texto = (_c = (_b = dispositivo.situacao.dispositivoOriginal.conteudo) === null || _b === void 0 ? void 0 : _b.texto) !== null && _c !== void 0 ? _c : '';
                            dispositivo.situacao = new DispositivoOriginal();
                        }
                        else {
                            dispositivo.texto = (_e = (_d = e.conteudo) === null || _d === void 0 ? void 0 : _d.texto) !== null && _e !== void 0 ? _e : '';
                        }
                    }
                    else {
                        if (e.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO) {
                            dispositivo.situacao = new DispositivoModificado(createElemento(dispositivo));
                        }
                        dispositivo.texto = (_g = (_f = e.conteudo) === null || _f === void 0 ? void 0 : _f.texto) !== null && _g !== void 0 ? _g : '';
                    }
                    if (dispositivo.alteracoes) {
                        dispositivo.alteracoes.base = e.norma;
                    }
                    if (dispositivo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                        dispositivo.situacao.existeNaNormaAlterada = e.existeNaNormaAlterada;
                        if (isDispositivoAlteracao(dispositivo) && isUltimaAlteracao(dispositivo)) {
                            const cabecaAlteracao = getDispositivoCabecaAlteracao(dispositivo);
                            cabecaAlteracao.notaAlteracao = e.notaAlteracao;
                        }
                    }
                    dispositivo.mensagens = validaDispositivo(dispositivo);
                    novosElementos.push(createElemento(dispositivo));
                    anterior = dispositivo.uuid;
                }
            }
        });
        return novosElementos;
    }
    return [];
};
const processaRenumerados = (state, evento) => {
    if (evento !== undefined && evento.elementos !== undefined && evento.elementos[0] !== undefined) {
        const novosElementos = [];
        evento.elementos.forEach(e => {
            const dispositivo = getDispositivoFromElemento(state.articulacao, e, true);
            if (dispositivo) {
                novosElementos.push(createElemento(dispositivo));
            }
        });
        return novosElementos;
    }
    return [];
};
const processaValidados = (state, eventos) => {
    const evento = getEvento(eventos, StateType.ElementoValidado);
    if (evento !== undefined && evento.elementos !== undefined && evento.elementos[0] !== undefined) {
        const validados = [];
        evento.elementos.forEach(e => {
            const dispositivo = getDispositivoFromElemento(state.articulacao, e, true);
            if (dispositivo) {
                dispositivo.mensagens = validaDispositivo(dispositivo);
                validados.push(createElemento(dispositivo));
            }
        });
        return validados;
    }
    return [];
};
const processaSituacoesAlteradas = (state, eventos) => {
    const elementos = [];
    eventos
        .filter(ev => ev.stateType === StateType.SituacaoElementoModificada)
        .forEach(ev => {
        var _a;
        (_a = ev.elementos) === null || _a === void 0 ? void 0 : _a.forEach((el) => {
            const dispositivo = getDispositivoFromElemento(state.articulacao, el, true);
            if (dispositivo) {
                elementos.push(createElemento(dispositivo));
            }
        });
    });
    return elementos;
};
const isUndoRedoInclusaoExclusaoAgrupador = (eventos) => {
    const tiposAgrupadorArtigo = getTiposAgrupadorArtigoOrdenados();
    const eventosFiltrados = eventos.filter(ev => ![StateType.RevisaoAceita, StateType.RevisaoRejeitada, StateType.RevisaoAdicionalRejeitada].includes(ev.stateType));
    return (eventosFiltrados.length > 0 &&
        [StateType.ElementoIncluido, StateType.ElementoRemovido].includes(eventosFiltrados[0].stateType) &&
        eventosFiltrados[0].elementos.length > 0 &&
        tiposAgrupadorArtigo.includes(eventosFiltrados[0].elementos[0].tipo));
};
const ajustarAtributosAgrupadorIncluidoPorUndoRedo = (articulacao, eventosFonte, eventosResultantes) => {
    var _a;
    const refFonteAgrupadorIncluido = eventosFonte[0].elementos[0];
    const agrupadorIncluido = eventosResultantes[0].elementos[0];
    const dispositivo = getDispositivoFromElemento(articulacao, agrupadorIncluido);
    dispositivo.texto = (_a = refFonteAgrupadorIncluido.conteudo.texto) !== null && _a !== void 0 ? _a : '';
    dispositivo.numero = refFonteAgrupadorIncluido.numero;
    dispositivo.id = refFonteAgrupadorIncluido.lexmlId;
    dispositivo.rotulo = refFonteAgrupadorIncluido.rotulo;
    eventosResultantes[0].elementos.length = 0;
    eventosResultantes[0].elementos.push(createElemento(dispositivo));
};
const processarRestaurados = (state, evento, acao) => {
    var _a, _b, _c, _d;
    const elementoDeReferencia = evento.elementos[acao === 'UNDO' ? 0 : 1];
    const d = getDispositivoFromElemento(state.articulacao, elementoDeReferencia, true);
    const elementoAntesDeRestaurarSituacao = createElemento(d);
    let stateType;
    if (elementoDeReferencia.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO) {
        d.situacao = new DispositivoModificado(createElemento(d));
        stateType = StateType.ElementoRestaurado;
    }
    else if (elementoDeReferencia.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
        d.situacao = new DispositivoSuprimido(createElemento(d));
        stateType = StateType.ElementoRestaurado;
    }
    else {
        d.situacao = new DispositivoOriginal();
        stateType = StateType.ElementoRestaurado;
    }
    d.numero = (_a = elementoDeReferencia.numero) !== null && _a !== void 0 ? _a : '';
    d.rotulo = (_b = elementoDeReferencia.rotulo) !== null && _b !== void 0 ? _b : '';
    d.texto = (_d = (_c = elementoDeReferencia.conteudo) === null || _c === void 0 ? void 0 : _c.texto) !== null && _d !== void 0 ? _d : '';
    const elementos = isSuprimido(d) ? [createElemento(d)] : [elementoAntesDeRestaurarSituacao, createElemento(d)];
    return { stateType, elementos };
};
const processarSuprimidos = (state, evento) => {
    var _a;
    const result = [];
    (_a = evento.elementos) === null || _a === void 0 ? void 0 : _a.forEach(e => {
        const d = getDispositivoFromElemento(state.articulacao, e, true);
        const elementoAntesRestauracao = createElemento(d);
        d.situacao = new DispositivoOriginal();
        result.push({ stateType: StateType.ElementoRestaurado, elementos: [elementoAntesRestauracao, createElemento(d)] });
    });
    return result;
};
const processarRevisoesAceitasOuRejeitadas = (state, eventos, stateType) => {
    const atualizaReferenciaElementoAnteriorSeNecessario = (revisoesRetornadasParaState) => {
        revisoesRetornadasParaState.filter(isRevisaoPrincipal).forEach(r => {
            const e = r.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura;
            const revisaoASerAtualizada = findRevisaoDeExclusaoComElementoAnteriorApontandoPara(state.revisoes, e);
            if (revisaoASerAtualizada && revisaoASerAtualizada.id !== r.id) {
                const revisaoRetornada = findRevisaoDeExclusaoComElementoAnteriorApontandoPara(revisoesRetornadasParaState, e);
                const ultimaRevisaoDoGrupo = findUltimaRevisaoDoGrupo(revisoesRetornadasParaState, revisaoRetornada);
                const elementoAnterior = JSON.parse(JSON.stringify(ultimaRevisaoDoGrupo.elementoAposRevisao));
                removeAtributosDoElementoAnteriorNaSequenciaDeLeitura(elementoAnterior);
                revisaoASerAtualizada.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura = elementoAnterior;
                revisaoASerAtualizada.elementoAntesRevisao.elementoAnteriorNaSequenciaDeLeitura = elementoAnterior;
            }
        });
    };
    const result = [];
    const eventosFiltrados = eventos.filter((se) => se.stateType === stateType);
    if (eventosFiltrados.length) {
        eventosFiltrados.forEach((ev) => {
            const revisoesRetornadasParaState = ev.elementos.map(e => e.revisao);
            state.revisoes.push(...revisoesRetornadasParaState);
            result.push({ stateType: ev.stateType, elementos: ev.elementos });
            if (existeRevisaoCriadaPorExclusao(revisoesRetornadasParaState)) {
                const elementos = revisoesRetornadasParaState.map(r => r.elementoAntesRevisao);
                if (stateType === StateType.RevisaoAdicionalRejeitada) {
                    elementos.forEach(e => removeElemento({ ...state, emRevisao: false }, { atual: e }));
                }
                // Reapresenta, no editor, os dispositivos removidos em modo de revisão
                if (stateType === StateType.RevisaoAceita) {
                    result.push({ stateType: StateType.ElementoIncluido, elementos: elementos });
                    result.push({ stateType: StateType.ElementoMarcado, elementos: [elementos[0]] });
                }
                atualizaReferenciaElementoAnteriorSeNecessario(revisoesRetornadasParaState);
            }
            else {
                const elementos = getElementosFromRevisoes(revisoesRetornadasParaState, state).map(e => JSON.parse(JSON.stringify(e)));
                associarRevisoesAosElementos(state.revisoes, elementos);
                result.push({ stateType: StateType.SituacaoElementoModificada, elementos: elementos });
                if (stateType === StateType.RevisaoAceita) {
                    result.push({ stateType: StateType.ElementoMarcado, elementos: [elementos[0]] });
                }
            }
        });
    }
    return result;
};

const redo = (state) => {
    var _a, _b, _c, _d;
    if (state.future === undefined || state.future.length === 0) {
        state.ui.events = [];
        return state;
    }
    const eventos = state.future.pop();
    const past = buildPast(state, eventos);
    const retorno = {
        articulacao: state.articulacao,
        modo: state.modo,
        past,
        present: [],
        future: state.future,
        ui: {
            events: [],
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
        emRevisao: state.emRevisao,
        usuario: state.usuario,
        revisoes: state.revisoes,
        numEventosPassadosAntesDaRevisao: state.numEventosPassadosAntesDaRevisao,
    };
    if (isUndoRedoInclusaoExclusaoAgrupador(eventos)) {
        let tempState;
        tempState = { ...retorno };
        tempState.past = [];
        tempState.present = [];
        tempState.future = [];
        if (eventos[0].stateType === StateType.ElementoIncluido) {
            const ref = eventos.find((ev) => ev.stateType === StateType.ElementoReferenciado).elementos[0];
            const elementoASerIncluido = eventos[0].elementos[0];
            tempState = agrupaElemento(tempState, {
                atual: ref,
                novo: { tipo: elementoASerIncluido.tipo, uuid: elementoASerIncluido.uuid, posicao: 'antes', manterNoMesmoGrupoDeAspas: elementoASerIncluido.manterNoMesmoGrupoDeAspas },
            });
            ajustarAtributosAgrupadorIncluidoPorUndoRedo(state.articulacao, eventos, tempState.ui.events);
        }
        else {
            tempState = removeElemento(tempState, { atual: eventos[0].elementos[0] });
        }
        const eventosRevisao = getEventosDeRevisao(eventos);
        if (eventosRevisao.length) {
            const idsRevisoesAssociadas = eventosRevisao
                .map((se) => se.elementos || [])
                .flat()
                .map((e) => findRevisoesByElementoUuid(retorno.revisoes, e.uuid))
                .flat()
                .map(r => r.id)
                .filter(Boolean);
            retorno.revisoes = (_b = state.revisoes) === null || _b === void 0 ? void 0 : _b.filter((r) => !idsRevisoesAssociadas.includes(r.id));
        }
        retorno.ui.events = [...eventosRevisao, ...tempState.ui.events];
        retorno.present = [...eventosRevisao, ...tempState.ui.events];
        return retorno;
    }
    const events = new Eventos();
    events.add(StateType.ElementoRemovido, remover(state, getEvento(eventos, StateType.ElementoRemovido)));
    events.add(StateType.ElementoIncluido, incluir(state, getEvento(eventos, StateType.ElementoIncluido), getEvento(events.eventos, StateType.ElementoIncluido)));
    eventos
        .filter((ev) => ev.stateType === StateType.ElementoModificado)
        .forEach((ev) => events.eventos.push({ stateType: StateType.ElementoModificado, elementos: processarModificados(state, ev, 'REDO') }));
    events.add(StateType.ElementoSuprimido, restaurarSituacao(state, getEvento(eventos, StateType.ElementoSuprimido), getEvento(events.eventos, StateType.ElementoSuprimido), DispositivoSuprimido));
    eventos.filter((ev) => ev.stateType === StateType.ElementoRestaurado).forEach((ev) => events.eventos.push(processarRestaurados(state, ev, 'REDO')));
    events.add(StateType.ElementoRenumerado, processaRenumerados(state, getEvento(eventos, StateType.ElementoRenumerado)));
    events.add(StateType.ElementoValidado, processaValidados(state, eventos));
    const elementosParaMarcar = (_c = getEvento(eventos, StateType.ElementoMarcado)) === null || _c === void 0 ? void 0 : _c.elementos;
    if (elementosParaMarcar) {
        events.add(StateType.ElementoMarcado, elementosParaMarcar);
        events.add(StateType.ElementoSelecionado, [elementosParaMarcar[0]]);
    }
    events.add(StateType.SituacaoElementoModificada, getElementosAlteracaoASeremAtualizados(state.articulacao, getElementosRemovidosEIncluidos(events.eventos)));
    events.eventos.push({ stateType: StateType.SituacaoElementoModificada, elementos: processaSituacoesAlteradas(state, eventos) });
    const eventosRevisao = getEventosDeRevisao(eventos);
    if (eventosRevisao.length) {
        const idsRevisoesAssociadas = eventosRevisao
            .map((se) => se.elementos || [])
            .flat()
            .map((e) => findRevisoesByElementoUuid(retorno.revisoes, e.uuid))
            .flat()
            .map(r => r.id)
            .filter(Boolean);
        retorno.revisoes = (_d = state.revisoes) === null || _d === void 0 ? void 0 : _d.filter((r) => !idsRevisoesAssociadas.includes(r.id));
    }
    retorno.ui.events = [...eventosRevisao, ...events.build()];
    retorno.present = [...eventosRevisao, ...events.build()];
    return retorno;
};
const getEventosDeRevisao = (eventos) => {
    return eventos.filter((se) => [StateType.RevisaoAceita, StateType.RevisaoRejeitada, StateType.RevisaoAdicionalRejeitada].includes(se.stateType));
};

const removeAlerta = (state, action) => {
    var _a, _b, _c;
    const alertas = (_b = (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas) === null || _b === void 0 ? void 0 : _b.filter(({ id }) => id !== action.id);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: state.present,
        future: state.future,
        ui: {
            events: [{ stateType: StateType.AtualizacaoAlertas }],
            message: (_c = state.ui) === null || _c === void 0 ? void 0 : _c.mensagem,
            alertas: alertas,
        },
    };
};

const removeElementoSemTexto = (state, action) => {
    var _a;
    const dispositivo = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (dispositivo === undefined || !podeRemoverDispositivo(state, dispositivo)) {
        state.ui.events = [];
        return state;
    }
    const dispositivoAnterior = getDispositivoAnterior(dispositivo);
    const retorno = removeElemento(state, action);
    if (action.key === 'Backspace' && dispositivoAnterior) {
        (_a = retorno.ui) === null || _a === void 0 ? void 0 : _a.events.push(getEventoMarcacaoElemento(dispositivoAnterior));
    }
    return retorno;
};
const getEventoMarcacaoElemento = (dispositivo) => {
    return {
        stateType: StateType.ElementoMarcado,
        elementos: [createElemento(dispositivo)],
        moverParaFimLinha: true,
    };
};
const podeRemoverDispositivo = (state, dispositivo) => {
    if (state.modo.startsWith('emenda') && dispositivo.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
        return false;
    }
    return !hasFilhos(dispositivo);
};

const ajustarNumero = (dispositivo, numero) => {
    if (!numero) {
        return '';
    }
    if (dispositivo.tipo !== 'Alinea') {
        return numero.toUpperCase();
    }
    const partes = numero.split('-');
    return partes.map((parte, index) => (index > 0 ? parte.toUpperCase() : parte)).join('-');
};
const renumeraElemento = (state, action) => {
    var _a, _b, _c, _d;
    const dispositivo = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (dispositivo === undefined) {
        state.ui.events = [];
        return state;
    }
    if (!isAcaoPermitida(dispositivo, RenumerarElemento)) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.INFO, descricao: 'Nessa situação, não é possível renumerar o dispositivo' });
    }
    if (isDispositivoAlteracao(dispositivo) && ((_b = ajustarNumero(dispositivo, (_a = action.novo) === null || _a === void 0 ? void 0 : _a.numero)) === null || _b === void 0 ? void 0 : _b.startsWith('0'))) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.INFO, descricao: 'Não pode haver um dispositivo com esse rótulo em alteração de norma' });
    }
    const past = buildPast(state, buildUpdateEvent(dispositivo));
    try {
        const numero = ajustarNumero(dispositivo, (_c = action.novo) === null || _c === void 0 ? void 0 : _c.numero);
        dispositivo.createNumeroFromRotulo(numero);
        dispositivo.id = buildId(dispositivo);
        if (dispositivo.tipo === 'Artigo') {
            dispositivo.caput.id = buildId(dispositivo.caput);
        }
    }
    catch (error) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.ERROR, descricao: 'O rótulo informado é inválido', detalhe: error });
    }
    dispositivo.createRotulo(dispositivo);
    const eventos = buildEventoAtualizacaoElemento(dispositivo);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past,
        present: eventos.build(),
        future: state.future,
        ui: {
            events: eventos.build(),
            alertas: (_d = state.ui) === null || _d === void 0 ? void 0 : _d.alertas,
        },
    };
};

const restauraElemento = (state, action) => {
    var _a, _b, _c;
    const dispositivo = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (dispositivo === undefined) {
        state.ui.events = [];
        return state;
    }
    const possuiFilhosModificados = getDispositivoAndFilhosAsLista(dispositivo).filter(f => isSituacaoExclusivaDispositivoEmenda(f)).length > 0;
    if (!possuiFilhosModificados &&
        ((_a = dispositivo.situacao) === null || _a === void 0 ? void 0 : _a.descricaoSituacao) !== DescricaoSituacao.DISPOSITIVO_MODIFICADO &&
        ((_b = dispositivo.situacao) === null || _b === void 0 ? void 0 : _b.descricaoSituacao) !== DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
        return state;
    }
    const events = restauraAndBuildEvents(dispositivo);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, events),
        present: events,
        future: [],
        ui: {
            events,
            alertas: (_c = state.ui) === null || _c === void 0 ? void 0 : _c.alertas,
        },
    };
};

const selecionaElemento = (state, action) => {
    var _a;
    const atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (atual === undefined) {
        const revisao = findRevisaoByElementoUuid(state.revisoes, action.atual.uuid);
        if (!revisao) {
            state.ui.events = [];
        }
        else {
            const e = { ...revisao.elementoAntesRevisao, acoesPossiveis: [] };
            state.ui.events = [{ stateType: StateType.ElementoSelecionado, elementos: [e] }];
        }
        return state;
    }
    atual.mensagens = validaDispositivo(atual);
    const elemento = createElemento(atual, true);
    const events = [
        {
            stateType: StateType.ElementoSelecionado,
            elementos: [elemento],
        },
    ];
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: state.present,
        future: state.future,
        ui: {
            events,
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
    };
};

const solicitaDadosAssistente = (state, action) => {
    var _a;
    const atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (atual === undefined) {
        state.ui.events = [];
        return state;
    }
    atual.mensagens = validaDispositivo(atual);
    const elemento = createElemento(atual, true);
    const events = [
        {
            stateType: StateType.InformarDadosAssistente,
            elementos: [elemento],
        },
    ];
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: state.present,
        future: [],
        ui: {
            events,
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
    };
};

const suprimeAgrupador = (state, action) => {
    var _a, _b;
    const dispositivo = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (dispositivo === undefined || ((_a = dispositivo.situacao) === null || _a === void 0 ? void 0 : _a.descricaoSituacao) !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
        state.ui.events = [];
        return state;
    }
    dispositivo.situacao = new DispositivoSuprimido(createElemento(dispositivo));
    const eventos = new Eventos();
    eventos.add(StateType.ElementoSuprimido, [createElemento(dispositivo)]);
    const events = eventos.build();
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, events),
        present: events,
        future: [],
        ui: {
            events,
            alertas: (_b = state.ui) === null || _b === void 0 ? void 0 : _b.alertas,
        },
    };
};

const getSituacoesFilhos = (dispositivos, situacoes) => {
    if (dispositivos.length === 0) {
        return;
    }
    dispositivos === null || dispositivos === void 0 ? void 0 : dispositivos.forEach(d => {
        situacoes.add(d.situacao.descricaoSituacao);
        getSituacoesFilhos(d.filhos, situacoes);
    });
};
const podeSuprimir = (dispositivo) => {
    var _a;
    const situacoes = new Set();
    situacoes.add(dispositivo.situacao.descricaoSituacao);
    getSituacoesFilhos(dispositivo.filhos, situacoes);
    if (dispositivo.alteracoes) {
        getSituacoesFilhos((_a = dispositivo.alteracoes) === null || _a === void 0 ? void 0 : _a.filhos, situacoes);
    }
    return situacoes.size === 1 && [...situacoes][0] === DescricaoSituacao.DISPOSITIVO_ORIGINAL;
};
const suprimeElemento = (state, action) => {
    var _a, _b;
    const dispositivo = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (dispositivo === undefined || ((_a = dispositivo.situacao) === null || _a === void 0 ? void 0 : _a.descricaoSituacao) !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
        state.ui.events = [];
        return state;
    }
    if (!podeSuprimir(dispositivo)) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.ERROR, descricao: 'Só é possível suprimir dispositivos que não tenham sofrido modificação.' });
    }
    const events = suprimeAndBuildEvents(state.articulacao, dispositivo);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, events),
        present: events,
        future: [],
        ui: {
            events,
            alertas: (_b = state.ui) === null || _b === void 0 ? void 0 : _b.alertas,
        },
    };
};

const undo = (state) => {
    var _a, _b, _c;
    if (state.past === undefined || state.past.length === 0) {
        state.ui.events = [];
        return state;
    }
    const eventos = state.past.pop();
    const future = buildFuture(state, eventos);
    const retorno = {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: [],
        future,
        ui: {
            events: [],
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
        emRevisao: state.emRevisao,
        usuario: state.usuario,
        revisoes: state.revisoes,
        numEventosPassadosAntesDaRevisao: state.numEventosPassadosAntesDaRevisao,
    };
    if (isUndoRedoInclusaoExclusaoAgrupador(eventos)) {
        let tempState;
        tempState = { ...retorno };
        tempState.past = [];
        tempState.present = [];
        tempState.future = [];
        const eventosFiltrados = eventos.filter((ev) => ![StateType.RevisaoAceita, StateType.RevisaoRejeitada, StateType.RevisaoAdicionalRejeitada].includes(ev.stateType));
        if (eventosFiltrados[0].stateType === StateType.ElementoIncluido) {
            tempState = removeElemento(tempState, { atual: eventosFiltrados[0].elementos[0] });
        }
        else {
            const ref = eventosFiltrados.find((ev) => ev.stateType === StateType.ElementoReferenciado).elementos[0];
            const elementoASerIncluido = eventosFiltrados[0].elementos[0];
            tempState = agrupaElemento(tempState, {
                atual: ref,
                novo: { tipo: elementoASerIncluido.tipo, uuid: elementoASerIncluido.uuid, posicao: 'antes', manterNoMesmoGrupoDeAspas: elementoASerIncluido.manterNoMesmoGrupoDeAspas },
            });
            ajustarAtributosAgrupadorIncluidoPorUndoRedo(state.articulacao, eventosFiltrados, tempState.ui.events);
        }
        const eventosRevisao = [
            ...processarRevisoesAceitasOuRejeitadas(retorno, eventos, StateType.RevisaoAceita),
            ...processarRevisoesAceitasOuRejeitadas(retorno, eventos, StateType.RevisaoRejeitada),
            ...processarRevisoesAceitasOuRejeitadas(retorno, eventos, StateType.RevisaoAdicionalRejeitada),
        ].filter(ev => { var _a; return (_a = ev.elementos) === null || _a === void 0 ? void 0 : _a.length; });
        retorno.ui.events = [...eventosRevisao, ...tempState.ui.events];
        retorno.present = [...eventosRevisao, ...tempState.ui.events];
        return retorno;
    }
    const events = new Eventos();
    events.add(StateType.ElementoRemovido, remover(state, getEvento(eventos, StateType.ElementoIncluido)));
    events.add(StateType.ElementoIncluido, incluir(state, getEvento(eventos, StateType.ElementoRemovido), getEvento(events.eventos, StateType.ElementoIncluido)));
    eventos.filter((ev) => ev.stateType === StateType.ElementoSuprimido).forEach((ev) => events.eventos.push(...processarSuprimidos(state, ev)));
    eventos.filter((ev) => ev.stateType === StateType.ElementoRestaurado).forEach((ev) => events.eventos.push(processarRestaurados(state, ev, 'UNDO')));
    const revisoesDeRejeicaoDeRestauracaoASeremRetornadas = getRevisoesFromElementos(eventos
        .filter((ev) => ev.stateType === StateType.RevisaoRejeitada)
        .map((ev) => ev.elementos || [])
        .flat());
    eventos
        .filter((ev) => ev.stateType === StateType.ElementoModificado)
        .forEach((ev) => events.eventos.push({ stateType: StateType.ElementoModificado, elementos: processarModificados(state, ev, 'UNDO', revisoesDeRejeicaoDeRestauracaoASeremRetornadas) }));
    events.add(StateType.ElementoRenumerado, processaRenumerados(state, getEvento(eventos, StateType.ElementoRenumerado)));
    events.add(StateType.ElementoValidado, processaValidados(state, eventos));
    const incluidos = events.get(StateType.ElementoIncluido);
    const primeiroElementoIncluidoEhAgrupador = !incluidos.elementos || !incluidos.elementos.length ? false : incluidos.elementos[0].agrupador;
    if (primeiroElementoIncluidoEhAgrupador) {
        events.add(StateType.ElementoMarcado, [incluidos.elementos[0]]);
        events.add(StateType.ElementoSelecionado, [incluidos.elementos[0]]);
    }
    else {
        const elementosParaMarcar = (_c = (_b = getEvento(eventos, StateType.ElementoMarcado)) === null || _b === void 0 ? void 0 : _b.elementos) === null || _c === void 0 ? void 0 : _c.filter(e => getDispositivoFromElemento(state.articulacao, e, true));
        if (elementosParaMarcar) {
            events.add(StateType.ElementoMarcado, [elementosParaMarcar[1], elementosParaMarcar[0]].filter(Boolean));
            events.add(StateType.ElementoSelecionado, [elementosParaMarcar[1]].filter(Boolean));
        }
    }
    events.add(StateType.SituacaoElementoModificada, events.get(StateType.ElementoIncluido).elementos || []);
    events.add(StateType.SituacaoElementoModificada, getElementosAlteracaoASeremAtualizados(state.articulacao, getElementosRemovidosEIncluidos(events.eventos)));
    events.add(StateType.SituacaoElementoModificada, processaSituacoesAlteradas(state, eventos));
    let eventosRevisao = [
        ...processarRevisoesAceitasOuRejeitadas(retorno, eventos, StateType.RevisaoAceita),
        ...processarRevisoesAceitasOuRejeitadas(retorno, eventos, StateType.RevisaoRejeitada),
        ...processarRevisoesAceitasOuRejeitadas(retorno, eventos, StateType.RevisaoAdicionalRejeitada),
    ].filter(ev => { var _a; return (_a = ev.elementos) === null || _a === void 0 ? void 0 : _a.length; });
    eventosRevisao = unificarEvento(retorno, eventosRevisao, StateType.ElementoIncluido);
    eventosRevisao = unificarEvento(retorno, eventosRevisao, StateType.SituacaoElementoModificada);
    eventosRevisao = unificarEvento(retorno, eventosRevisao, StateType.ElementoMarcado);
    retorno.ui.events = [...eventosRevisao, ...events.build()];
    retorno.present = [...eventosRevisao, ...events.build()];
    return retorno;
};

const validaArticulacao = (state) => {
    var _a;
    const elementos = [];
    buildListaDispositivos(state.articulacao, []).forEach(d => {
        const mensagens = validaDispositivo(d);
        if ((mensagens === null || mensagens === void 0 ? void 0 : mensagens.length) > 0) {
            d.mensagens = mensagens;
            elementos.push(createElemento(d));
        }
    });
    const events = [
        {
            stateType: StateType.ElementoValidado,
            elementos: elementos,
        },
    ];
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: state.present,
        future: state.future,
        ui: {
            events,
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
    };
};

const validaElemento = (state, action) => {
    var _a;
    const atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (atual === undefined) {
        state.ui.events = [];
        return state;
    }
    atual.mensagens = validaDispositivo(atual);
    const elemento = createElemento(atual, true);
    const events = [
        {
            stateType: StateType.ElementoValidado,
            elementos: [elemento],
        },
    ];
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: state.present,
        future: state.future,
        ui: {
            events,
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
    };
};

let isEmendamento = false;
let ultimoDispositivoCriado;
// Workaround para o problema de textos que possuam tags <b> ou <i> contendo <a> no meio
// O Quill faz um tratamento para que as tags <b> e <i> fiquem dentro da tag <a>
// Nesse caso, é necessário fazer esse ajuste antecipadamente para que o editor não trate a transformação como uma alteração
const ajustarTextosParaQuill = (projetoNorma) => {
    if (window.process.env.testMode)
        return;
    const fnAjustaFormatoQuill = (texto, container, quill) => {
        const regexMatchTagsBoldOuItalicContendoTagAnchorDentro = /<(b|i)>(?:(?!(<\/\1>)).)*<a[^>]*>.*<\/a>.*<\/\1>/gi;
        if (texto === null || texto === void 0 ? void 0 : texto.match(regexMatchTagsBoldOuItalicContendoTagAnchorDentro)) {
            quill.setContents(quill.clipboard.convert(texto));
            return container.querySelector('.ql-editor p').innerHTML;
        }
        return texto;
    };
    const tempContainer = document.createElement('div');
    const tempQuill = new Quill(tempContainer, {});
    if (projetoNorma.ementa) {
        projetoNorma.ementa.texto = fnAjustaFormatoQuill(projetoNorma.ementa.texto, tempContainer, tempQuill);
    }
    if (projetoNorma.articulacao) {
        getDispositivoAndFilhosAsLista(projetoNorma.articulacao).forEach(d => {
            d.texto = fnAjustaFormatoQuill(d.texto, tempContainer, tempQuill);
        });
    }
};
const buildProjetoNormaFromJsonix = (documentoLexml, emendamento = false) => {
    var _a, _b;
    isEmendamento = emendamento;
    if (!((_a = documentoLexml === null || documentoLexml === void 0 ? void 0 : documentoLexml.value) === null || _a === void 0 ? void 0 : _a.projetoNorma)) {
        throw new Error('Não se trata de um documento lexml válido');
    }
    const projetoNorma = {
        classificacao: ((_b = documentoLexml.value) === null || _b === void 0 ? void 0 : _b.projetoNorma.norma) ? ClassificacaoDocumento.NORMA : ClassificacaoDocumento.PROJETO,
        tipo: getTipo$1(getUrn(documentoLexml)),
        ...getMetadado(documentoLexml),
        ...getParteInicial(documentoLexml),
        ...getTextoArticulado(documentoLexml.value.projetoNorma.norma || documentoLexml.value.projetoNorma.projeto),
    };
    if (projetoNorma.articulacao) {
        projetoNorma.articulacao.projetoNorma = projetoNorma;
        if (projetoNorma.ementa) {
            projetoNorma.ementa.pai = projetoNorma.articulacao;
        }
    }
    ajustarTextosParaQuill(projetoNorma);
    return projetoNorma;
};
const retiraCaracteresDesnecessarios = (texto) => {
    return texto === null || texto === void 0 ? void 0 : texto.replace(/[\n]/g, '').trim();
};
const getUrn = (documento) => {
    var _a, _b, _c;
    return (_c = (_b = (_a = documento === null || documento === void 0 ? void 0 : documento.value) === null || _a === void 0 ? void 0 : _a.metadado) === null || _b === void 0 ? void 0 : _b.identificacao) === null || _c === void 0 ? void 0 : _c.urn;
};
const getMetadado = (documento) => {
    return {
        urn: getUrn(documento),
    };
};
const getParteInicial = (documento) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    const epigrafe = (_f = (_e = (_d = (_c = (_b = (_a = documento === null || documento === void 0 ? void 0 : documento.value) === null || _a === void 0 ? void 0 : _a.projetoNorma) === null || _b === void 0 ? void 0 : _b.norma) === null || _c === void 0 ? void 0 : _c.parteInicial) === null || _d === void 0 ? void 0 : _d.epigrafe) === null || _e === void 0 ? void 0 : _e.content[0]) !== null && _f !== void 0 ? _f : '';
    const ementa = buildContent$1((_k = (_j = (_h = (_g = documento === null || documento === void 0 ? void 0 : documento.value) === null || _g === void 0 ? void 0 : _g.projetoNorma) === null || _h === void 0 ? void 0 : _h.norma) === null || _j === void 0 ? void 0 : _j.parteInicial) === null || _k === void 0 ? void 0 : _k.ementa.content);
    const preambulo = (_r = (_q = (_p = (_o = (_m = (_l = documento === null || documento === void 0 ? void 0 : documento.value) === null || _l === void 0 ? void 0 : _l.projetoNorma) === null || _m === void 0 ? void 0 : _m.norma) === null || _o === void 0 ? void 0 : _o.parteInicial) === null || _p === void 0 ? void 0 : _p.preambulo) === null || _q === void 0 ? void 0 : _q.p[0].content[0]) !== null && _r !== void 0 ? _r : '';
    return {
        epigrafe: retiraCaracteresDesnecessarios(epigrafe),
        ementa: buildDispositivoEmenta(retiraCaracteresDesnecessarios(ementa)),
        preambulo: retiraCaracteresDesnecessarios(preambulo),
    };
};
const getTextoArticulado = (norma) => {
    return {
        articulacao: buildArticulacao(norma.articulacao),
    };
};
const buildDispositivoEmenta = (texto) => {
    if (!texto) {
        return;
    }
    const dispositivo = criaDispositivo(createArticulacao(), 'Ementa');
    dispositivo.pai = undefined;
    dispositivo.texto = substituiAspasRetasPorCurvas(texto);
    dispositivo.rotulo = '';
    dispositivo.id = 'ementa';
    if (isEmendamento) {
        dispositivo.situacao = new DispositivoOriginal();
    }
    return dispositivo;
};
const buildArticulacao = (tree) => {
    const articulacao = createArticulacao();
    buildTree$1(articulacao, tree.lXhier, []);
    return articulacao;
};
const buildTree$1 = (pai, filhos, cabecasAlteracao) => {
    if (!pai || !filhos) {
        return;
    }
    filhos === null || filhos === void 0 ? void 0 : filhos.forEach((el) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        let dispositivo;
        const notaAlteracao = (_a = el.value) === null || _a === void 0 ? void 0 : _a.notaAlteracao;
        if ((_b = el.value) === null || _b === void 0 ? void 0 : _b.fechaAspas) {
            const cabecaAlteracao = cabecasAlteracao.pop();
            if (cabecaAlteracao) {
                cabecaAlteracao.notaAlteracao = (_c = el.value) === null || _c === void 0 ? void 0 : _c.notaAlteracao;
            }
        }
        if (((_d = el.name) === null || _d === void 0 ? void 0 : _d.localPart) === 'Caput') {
            if (((_e = el.value) === null || _e === void 0 ? void 0 : _e.abreAspas) === 's') {
                cabecasAlteracao.push(dispositivo);
                dispositivo.rotulo = (_f = el.value) === null || _f === void 0 ? void 0 : _f.rotulo;
                dispositivo.cabecaAlteracao = true;
                dispositivo.notaAlteracao = notaAlteracao;
            }
            else if ((_g = el.value) === null || _g === void 0 ? void 0 : _g.rotulo) {
                dispositivo.rotulo = el.value.rotulo;
                dispositivo.createNumeroFromRotulo(dispositivo.rotulo);
            }
            pai.texto = ((_h = el.value) === null || _h === void 0 ? void 0 : _h.textoOmitido) ? TEXTO_OMISSIS : retiraCaracteresDesnecessarios(buildContentDispositivo(el));
            pai.caput.href = (_j = el.value) === null || _j === void 0 ? void 0 : _j.href;
            pai.caput.id = (_k = el.value) === null || _k === void 0 ? void 0 : _k.id;
            buildAlteracao(pai, (_l = el.value) === null || _l === void 0 ? void 0 : _l.alteracao, cabecasAlteracao);
            buildTree$1(pai.caput, (_m = el.value) === null || _m === void 0 ? void 0 : _m.lXcontainersOmissis, cabecasAlteracao);
        }
        else if (((_o = el.name) === null || _o === void 0 ? void 0 : _o.localPart) === 'alteracao') {
            buildAlteracao(pai, el, cabecasAlteracao);
            buildTree$1(pai.caput, (_p = el.value) === null || _p === void 0 ? void 0 : _p.lXcontainersOmissis, cabecasAlteracao);
        }
        else {
            if (((_q = el.name) === null || _q === void 0 ? void 0 : _q.localPart) === 'p') {
                adicionaTextoAoUltimoDispositivoCriado(el);
            }
            else {
                // Impede que sejam criados filhos em artigos que já possuam alterações
                if (!pai.alteracoes) {
                    dispositivo = buildDispositivo$1(pai, el, cabecasAlteracao);
                    buildTree$1(dispositivo, (_s = (_r = el.value) === null || _r === void 0 ? void 0 : _r.lXhier) !== null && _s !== void 0 ? _s : (_t = el.value) === null || _t === void 0 ? void 0 : _t.lXcontainersOmissis, cabecasAlteracao);
                }
            }
        }
    });
};
const buildAlteracao = (pai, el, cabecasAlteracao) => {
    var _a;
    if (el) {
        createAlteracao(pai);
        pai.alteracoes.id = el.id;
        pai.alteracoes.base = el.base;
        if (isEmendamento) {
            pai.alteracoes.situacao = new DispositivoOriginal();
        }
        (_a = el.content) === null || _a === void 0 ? void 0 : _a.forEach((c) => {
            var _a, _b, _c, _d, _e;
            if (((_a = c.name) === null || _a === void 0 ? void 0 : _a.localPart) === 'p') {
                adicionaTextoAoUltimoDispositivoCriado(c);
            }
            else {
                const d = buildDispositivo$1(pai.alteracoes, c, cabecasAlteracao);
                d.isDispositivoAlteracao = true;
                d.rotulo = (_b = c.value) === null || _b === void 0 ? void 0 : _b.rotulo;
                buildTree$1(d, (_d = (_c = c.value) === null || _c === void 0 ? void 0 : _c.lXhier) !== null && _d !== void 0 ? _d : (_e = c.value) === null || _e === void 0 ? void 0 : _e.lXcontainersOmissis, cabecasAlteracao);
            }
        });
    }
};
const adicionaTextoAoUltimoDispositivoCriado = (el) => {
    var _a;
    ultimoDispositivoCriado.texto = (ultimoDispositivoCriado.texto + ' ' + retiraCaracteresDesnecessarios(buildContent$1((_a = el.value) === null || _a === void 0 ? void 0 : _a.content))).replace(/\s+/g, ' ');
};
const buildDispositivo$1 = (pai, el, cabecasAlteracao) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const dispositivo = criaDispositivo(pai, (_a = el.name) === null || _a === void 0 ? void 0 : _a.localPart);
    const notaAlteracao = (_b = el.value) === null || _b === void 0 ? void 0 : _b.notaAlteracao;
    if ((_c = el.value) === null || _c === void 0 ? void 0 : _c.fechaAspas) {
        const cabecaAlteracao = cabecasAlteracao.pop();
        if (cabecaAlteracao) {
            cabecaAlteracao.notaAlteracao = (_d = el.value) === null || _d === void 0 ? void 0 : _d.notaAlteracao;
        }
    }
    if (!isOmissis(dispositivo)) {
        if (((_e = el.value) === null || _e === void 0 ? void 0 : _e.abreAspas) === 's') {
            cabecasAlteracao.push(dispositivo);
            dispositivo.rotulo = (_f = el.value) === null || _f === void 0 ? void 0 : _f.rotulo;
            dispositivo.cabecaAlteracao = true;
            dispositivo.notaAlteracao = notaAlteracao;
        }
        else {
            dispositivo.rotulo = (_g = el.value) === null || _g === void 0 ? void 0 : _g.rotulo;
        }
        dispositivo.createNumeroFromRotulo(dispositivo.rotulo);
    }
    dispositivo.href = (_h = el.value) === null || _h === void 0 ? void 0 : _h.href;
    dispositivo.id = (_j = el.value) === null || _j === void 0 ? void 0 : _j.id;
    if (isEmendamento) {
        dispositivo.situacao = new DispositivoOriginal();
        if (isArtigo(dispositivo)) {
            dispositivo.caput.situacao = new DispositivoOriginal();
        }
    }
    dispositivo.texto = ((_k = el.value) === null || _k === void 0 ? void 0 : _k.textoOmitido) ? TEXTO_OMISSIS : retiraCaracteresDesnecessarios(buildContentDispositivo(el));
    ultimoDispositivoCriado = dispositivo;
    return dispositivo;
};
// const montaReferencia = (value: any): string => {
//   return `<a href="${value.href}"> ${value.content[0]} </a>`;
// };
const buildContentDispositivo = (el) => {
    var _a, _b, _c, _d, _e;
    let texto = '';
    if ((_a = el.value) === null || _a === void 0 ? void 0 : _a.nomeAgrupador) {
        return (_b = el.value.nomeAgrupador.content[0]) !== null && _b !== void 0 ? _b : '';
    }
    else {
        (_e = (_d = (_c = el.value) === null || _c === void 0 ? void 0 : _c.p) === null || _d === void 0 ? void 0 : _d.map((p) => p)) === null || _e === void 0 ? void 0 : _e.map((a) => a.content).forEach((content) => (texto += buildContent$1(content)));
    }
    return substituiAspasRetasPorCurvas(texto);
};
const substituiAspasRetasPorCurvas = (html) => {
    const div = document.createElement('div');
    div.innerHTML = html;
    const elements = div.getElementsByTagName('*');
    for (let i = 0; i < elements.length; i++) {
        const innerHTML = elements[i].innerHTML;
        if (innerHTML.indexOf('"') !== -1) {
            const newInnerHTML = innerHTML.replace(/"(?=\w|$)/g, '&#8220;').replace(/(?=[\w,.?!\-")]|^)"/g, '&#8221;');
            elements[i].innerHTML = newInnerHTML;
        }
    }
    return div.innerHTML.replace(/&nbsp;/g, ' ');
};
const buildContent$1 = (content) => {
    let texto = '';
    content === null || content === void 0 ? void 0 : content.forEach((element) => {
        if (element.value) {
            texto += montaTag(element.name, element.value);
        }
        else {
            let elementTexto = element;
            elementTexto = elementTexto.replace(/"(?=\w|$)/g, '&#8220;');
            elementTexto = elementTexto.replace(/(?=[\w,.?!\-")]|^)"/g, '&#8221;');
            texto += elementTexto;
        }
    });
    return texto;
};
const montaTag = (name, value) => {
    const localPart = name.localPart;
    if (localPart === 'span' && value.href) {
        return `<a href="${value.href}">${buildContent$1(value.content)}</a>`;
    }
    if (localPart === 'b' || localPart === 'i' || localPart === 'sub' || localPart === 'sup') {
        return `<${localPart}>${buildContent$1(value.content)}</${localPart}>`;
    }
    return '';
};

const buildDispositivoFromJsonix = (documentoLexml) => {
    var _a;
    if (!((_a = documentoLexml === null || documentoLexml === void 0 ? void 0 : documentoLexml.value) === null || _a === void 0 ? void 0 : _a.projetoNorma)) {
        throw new Error('Não se trata de um documento lexml válido');
    }
    return {
        ...getTextoArticulado(documentoLexml.value.projetoNorma.norma ? documentoLexml.value.projetoNorma.norma : documentoLexml.value.projetoNorma.projeto),
    };
};

var TipoRestricaoEnum;
(function (TipoRestricaoEnum) {
    TipoRestricaoEnum[TipoRestricaoEnum["ARTICULACAO_SEM_FILHOS"] = 0] = "ARTICULACAO_SEM_FILHOS";
    TipoRestricaoEnum[TipoRestricaoEnum["AGRUPADOR_GENERICO_NA_ARTICULACAO"] = 1] = "AGRUPADOR_GENERICO_NA_ARTICULACAO";
    TipoRestricaoEnum[TipoRestricaoEnum["AGRUPADORES_DE_ARTIGO"] = 2] = "AGRUPADORES_DE_ARTIGO";
    TipoRestricaoEnum[TipoRestricaoEnum["DISPOSITIVOS_DE_TIPOS_DIFERENTES"] = 3] = "DISPOSITIVOS_DE_TIPOS_DIFERENTES";
    TipoRestricaoEnum[TipoRestricaoEnum["DISPOSITIVOS_COM_ROTULO_DUPLICADO"] = 4] = "DISPOSITIVOS_COM_ROTULO_DUPLICADO";
    TipoRestricaoEnum[TipoRestricaoEnum["ARTIGOS_SEM_NUMERACAO_DENTRO_DE_ALTERACAO"] = 5] = "ARTIGOS_SEM_NUMERACAO_DENTRO_DE_ALTERACAO";
    TipoRestricaoEnum[TipoRestricaoEnum["ALTERACAO_DENTRO_DE_ALTERACAO"] = 6] = "ALTERACAO_DENTRO_DE_ALTERACAO";
    TipoRestricaoEnum[TipoRestricaoEnum["FILHOS_EM_DISPOSITIVO_SUPRIMIDO"] = 7] = "FILHOS_EM_DISPOSITIVO_SUPRIMIDO";
    TipoRestricaoEnum[TipoRestricaoEnum["DISPOSITIVO_JA_MODIFICADO"] = 8] = "DISPOSITIVO_JA_MODIFICADO";
    TipoRestricaoEnum[TipoRestricaoEnum["DISPOSITIVO_EM_POSICAO_INVALIDA"] = 9] = "DISPOSITIVO_EM_POSICAO_INVALIDA";
    TipoRestricaoEnum[TipoRestricaoEnum["DISPOSITIVO_ANTES_DO_ATUAL"] = 10] = "DISPOSITIVO_ANTES_DO_ATUAL";
    TipoRestricaoEnum[TipoRestricaoEnum["ARTIGO_COM_FILHOS_SOBRE_ARTIGO_COM_ALTERACOES"] = 11] = "ARTIGO_COM_FILHOS_SOBRE_ARTIGO_COM_ALTERACOES";
    TipoRestricaoEnum[TipoRestricaoEnum["ARTIGO_COM_ALTERACOES_SOBRE_ARTIGO_COM_FILHOS"] = 12] = "ARTIGO_COM_ALTERACOES_SOBRE_ARTIGO_COM_FILHOS";
    TipoRestricaoEnum[TipoRestricaoEnum["ARTIGO_COM_MUDANCA_IDENTIFICACAO_NORMA_ALTERADA"] = 13] = "ARTIGO_COM_MUDANCA_IDENTIFICACAO_NORMA_ALTERADA";
    TipoRestricaoEnum[TipoRestricaoEnum["ARTICULACAO_INCONSISTENTE"] = 14] = "ARTICULACAO_INCONSISTENTE";
})(TipoRestricaoEnum || (TipoRestricaoEnum = {}));
class InfoTextoColado {
    constructor(articulacaoProposicao, textoColadoOriginal, textoColadoAjustado, textoColadoAjustadoParaParser, jsonix, articulacaoColada, atual, isColarSubstituindo = true, posicao = 'depois') {
        var _a;
        this.isColarSubstituindo = true;
        this.montarRestricoes = () => {
            return [...validarArticulacaoColadaAnaliseInicial(this.articulacaoColada), ...validarArticulacaoColadaAnaliseContextualizada(this, this.infoDispositivos)];
        };
        this.textoColadoOriginal = textoColadoOriginal;
        this.textoColadoAjustado = textoColadoAjustado;
        this.textoColadoAjustadoParaParser = textoColadoAjustadoParaParser;
        this.isColandoArtigoSemNumeracao = hasArtigoOndeCouber(textoColadoAjustado);
        this.jsonix = jsonix;
        this.articulacaoProposicao = articulacaoProposicao;
        this.articulacaoColada = articulacaoColada;
        this.isColarSubstituindo = isColarSubstituindo;
        this.posicao = posicao;
        this.infoDispositivos = {
            tiposColados: montarListaTiposDispositivosColados(this.articulacaoColada),
            atual: getDispositivoFromElemento(this.articulacaoProposicao, atual),
            existentes: [],
            novos: [],
        };
        this.tipoColado = getTipoColadoFromArticulacao(this.articulacaoColada);
        this.infoDispositivos.referencia = getDispositivoReferencia(articulacaoColada.filhos[0].tipo, this.infoDispositivos.atual);
        this.infoDispositivos.existentes = montarListaDispositivosExistentes(this.articulacaoProposicao, this.articulacaoColada, this.infoDispositivos.referencia);
        this.infoDispositivos.novos = montarListaDispositivosNovos(this.articulacaoProposicao, this.articulacaoColada, this.infoDispositivos.referencia);
        this.infoElementos = {
            tiposColados: this.infoDispositivos.tiposColados,
            atual: createElemento(this.infoDispositivos.atual),
            existentes: this.infoDispositivos.existentes.map(d => createElemento(d)),
            novos: this.getElementos(this.infoDispositivos.novos),
            referencia: this.infoDispositivos.referencia ? createElemento(this.infoDispositivos.referencia) : undefined,
        };
        this.podeColarAntes = ((_a = this.infoDispositivos.referencia) === null || _a === void 0 ? void 0 : _a.tipo) === this.infoDispositivos.tiposColados[0];
        this.restricoes = this.montarRestricoes();
    }
    getElementos(dispositivos) {
        try {
            return dispositivos.map(d => createElemento(d));
        }
        catch (error) {
            return [];
        }
    }
    static async newInstanceFromTexto(textoColadoOriginal, textoColadoAjustado, articulacaoProposicao, atual) {
        let textoColadoAjustadoParaParser = removeAspasENRSeNecessario(hasArtigoOndeCouber(textoColadoAjustado) ? numerarArtigosOndeCouber(textoColadoAjustado) : textoColadoAjustado);
        let jsonix = await getJsonixFromTexto(textoColadoAjustadoParaParser);
        let projetoNorma = buildDispositivoFromJsonix(jsonix);
        const dispositivos = getDispositivoAndFilhosAsLista(projetoNorma.articulacao);
        if (existeItemSemPaiAlinea(dispositivos)) {
            textoColadoAjustadoParaParser = ajustaFalsosItensParaParser(textoColadoAjustadoParaParser, dispositivos);
            jsonix = await getJsonixFromTexto(textoColadoAjustadoParaParser);
            projetoNorma = buildDispositivoFromJsonix(jsonix);
        }
        return new InfoTextoColado(articulacaoProposicao, textoColadoOriginal, textoColadoAjustado, textoColadoAjustadoParaParser, jsonix, projetoNorma.articulacao, atual);
    }
    static newInstanceFromJsonix(jsonix, articulacaoProposicao, atual, isColarSubstituindo = true, posicao = 'depois') {
        const projetoNorma = buildDispositivoFromJsonix(jsonix);
        return new InfoTextoColado(articulacaoProposicao, '', '', '', jsonix, projetoNorma.articulacao, atual, isColarSubstituindo, posicao);
    }
    static newInstanceFromTextoEJsonix(textoColadoOriginal, textoColadoAjustado, jsonix, articulacaoProposicao, atual) {
        const projetoNorma = buildDispositivoFromJsonix(jsonix);
        return new InfoTextoColado(articulacaoProposicao, textoColadoOriginal, textoColadoAjustado, textoColadoAjustado, jsonix, projetoNorma.articulacao, atual);
    }
    static newInstanceFromArticulacao(articulacaoColada, articulacaoProposicao, atual) {
        return new InfoTextoColado(articulacaoProposicao, '', '', '', undefined, articulacaoColada, atual);
    }
    atualizarAtributosEAnaliseContextualizada(isColarSubstituindo, posicao) {
        const tiposRestricoesAnaliseInicial = [
            TipoRestricaoEnum.ARTICULACAO_SEM_FILHOS,
            TipoRestricaoEnum.AGRUPADORES_DE_ARTIGO,
            TipoRestricaoEnum.DISPOSITIVOS_DE_TIPOS_DIFERENTES,
            TipoRestricaoEnum.DISPOSITIVOS_COM_ROTULO_DUPLICADO,
        ];
        this.posicao = posicao;
        this.isColarSubstituindo = isColarSubstituindo;
        this.restricoes = this.restricoes.filter(r => tiposRestricoesAnaliseInicial.includes(r.tipo));
        this.restricoes.push(...validarArticulacaoColadaAnaliseContextualizada(this, this.infoDispositivos));
    }
}
// Retira a quebra de linha anterior ao texto que foi identificado como item (sem que houvesse um alínea antes)
const ajustaFalsosItensParaParser = (texto, dispositivos) => {
    let textoAux = texto;
    const lista = dispositivos.filter(d => isItem(d) && !isAlinea(d.pai));
    lista.forEach(d => {
        const textoItemAjustadoParaPesquisa = escapeRegex(d.texto).split(' ').join('[\\s\\n]?');
        const regex = new RegExp(`(\\n)(.*${d.numero}.*${textoItemAjustadoParaPesquisa})`, 'i');
        textoAux = textoAux.replace(regex, ' $2');
    });
    return textoAux;
};
const existeItemSemPaiAlinea = (dispositivos) => {
    return dispositivos.some(d => isItem(d) && !isAlinea(d.pai) && !isArticulacao(d.pai));
};
const removeAspasENRSeNecessario = (texto) => {
    const textoAux = texto
        .replace(/\r/g, '')
        .replace(/\n\s*\(NR\)/gi, ' (NR)')
        .replace(/(\(NR\))\./gi, '$1');
    if (!comecaComAspas(textoAux)) {
        return textoAux;
    }
    const regexMatchTextoArtigoEntreAspasOuNao = /(?<=\n|^)["“‘']?art(?:\.|\s|\d)(?:.|\n)+?(?:(?=\n["“‘']?art(?:\.|\s|\d))|$)/gi;
    if (!textoAux.match(regexMatchTextoArtigoEntreAspasOuNao)) {
        return textoAux;
    }
    // Grupo 1 do regex abaixo corresponde ao texto do artigo sem aspas iniciais e finais e sem o (NR)
    const regexMatchTextoArtigoEntreAspasOuNaoComCapturaDeGrupo = /(?<=\n|^)\s*["“‘']?(art(?:\.|\s|\d)(?:.|\n)+?)(["”’]\s*(?:\(NR\))?[\s]*)?(?:(?=\n\s*["“‘']?art(?:\.|\s|\d))|$)/gi;
    return textoAux.replace(regexMatchTextoArtigoEntreAspasOuNaoComCapturaDeGrupo, '\n$1').trim();
};
const comecaComAspas = (texto) => !!texto.match(/^["“‘']/);
const getJsonixFromTexto = async (texto) => {
    const options = {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain' },
        body: texto,
    };
    try {
        const response = await fetch('https://www6ghml.senado.leg.br/editor-emendas/api/parser/jsonix', options);
        return await response.json();
    }
    catch (err) {
        return console.error(err);
    }
};
const montarListaTiposDispositivosColados = (articulacao) => {
    return [...new Set(articulacao.filhos.filter(f => f.tipo !== 'Omissis').map(f => f.tipo))];
};
const getTipoColadoFromArticulacao = (articulacao) => getTipoColadoFromDispositipo(articulacao.filhos[0]);
const getTipoColadoFromDispositipo = (dispositivo) => getTipo(dispositivo.tipo);
const getTipo = (nomeTipo) => TipoDispositivo[nomeTipo === null || nomeTipo === void 0 ? void 0 : nomeTipo.toLowerCase()];
const montarListaDispositivosExistentes = (articulacao, articulacaoColada, referencia) => {
    if (referencia && (!isArtigo(articulacaoColada.filhos[0]) || isDispositivoAlteracao(referencia))) {
        ajustaIdsNaArticulacaoColada(articulacaoColada.filhos, referencia);
    }
    const idsColados = getDispositivoAndFilhosAsLista(articulacaoColada)
        .filter(d => d.tipo !== 'Articulacao')
        .map(d => d.id)
        .reduce((acc, cur) => {
        if (cur) {
            acc.push(cur);
            if (cur.endsWith('_par1')) {
                acc.push(cur.replace('_par1', '_par1u'));
            }
        }
        return acc;
    }, []);
    return getDispositivoAndFilhosAsLista(articulacao).filter(d => isOriginal(d) && idsColados.includes(d.id));
};
const montarListaDispositivosNovos = (articulacao, articulacaoColada, referencia) => {
    const idsExistentes = montarListaDispositivosExistentes(articulacao, articulacaoColada, referencia).map(d => d.id);
    return getDispositivoAndFilhosAsLista(articulacaoColada).filter(d => !isArticulacao(d) && !idsExistentes.includes(d.id));
};
const validarArticulacaoColadaAnaliseInicial = (articulacaoColada) => {
    const result = [];
    if (!articulacaoColada || !articulacaoColada.filhos.length) {
        result.push({
            tipo: TipoRestricaoEnum.ARTICULACAO_SEM_FILHOS,
            mensagens: ['Não foi possível identificar dispositivos no texto informado'],
        });
        return result;
    }
    if (getDispositivoAndFilhosAsLista(articulacaoColada).some(isAgrupadorGenerico)) {
        result.push({
            tipo: TipoRestricaoEnum.AGRUPADOR_GENERICO_NA_ARTICULACAO,
            mensagens: ['Não foi possível identificar, corretamente, os dispositivos no texto a ser colado.'],
        });
    }
    if (hasAgrupador(articulacaoColada)) {
        result.push({
            tipo: TipoRestricaoEnum.AGRUPADORES_DE_ARTIGO,
            mensagens: ['Não é permitido colar texto com agrupadores de artigo.', 'Por favor, adicione-os manualmente no editor e depois cole os artigos, se houverem.'],
        });
    }
    if (articulacaoColada.filhos.filter(f => !isOmissis(f)).length !== irmaosMesmoTipo(articulacaoColada.filhos.filter(f => !isOmissis(f))[0]).length) {
        const tipos = [...new Set(articulacaoColada.filhos.map(f => { var _a; return (_a = TipoDispositivo[f.tipo.toLowerCase()].descricaoPlural) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase(); }))];
        result.push({
            tipo: TipoRestricaoEnum.DISPOSITIVOS_DE_TIPOS_DIFERENTES,
            mensagens: [`Não é permitido colar texto com dispositivos de tipos diferentes: ${tipos.join(', ')}.`, 'Por favor, cole-os separadamente.'],
        });
    }
    if (existeDispositivoComRotuloDuplicado(articulacaoColada)) {
        result.push({
            tipo: TipoRestricaoEnum.DISPOSITIVOS_COM_ROTULO_DUPLICADO,
            mensagens: ['Não é permitido colar dispositivos com rótulos duplicados.'],
        });
    }
    if (isArticulacaoInconsistente(articulacaoColada)) {
        const mensagens = [
            'Não foi possível identificar, corretamente, os dispositivos no texto a ser colado.',
            getTextoInconsistencia(getDispositivoAndFilhosAsLista(articulacaoColada)),
            'Por favor, verifique se o texto está correto e tente novamente.',
        ].filter(Boolean);
        result.push({
            tipo: TipoRestricaoEnum.ARTICULACAO_INCONSISTENTE,
            mensagens,
        });
    }
    return result;
};
const hasAgrupador = (dispositivo) => {
    return dispositivo.filhos.filter(a => isAgrupador(a) && a.tipo !== 'DispositivoAgrupadorGenerico').length > 0;
};
const isArticulacaoInconsistente = (articulacao) => {
    const dispositivos = getDispositivoAndFilhosAsLista(articulacao).slice(1);
    return dispositivos.some(d => isDispositivoInconsistente(d));
};
const isDispositivoInconsistente = (dispositivo) => {
    var _a, _b;
    return !((_b = (_a = dispositivo.pai) === null || _a === void 0 ? void 0 : _a.tiposPermitidosFilhos) === null || _b === void 0 ? void 0 : _b.includes(dispositivo.tipo)) && !isOmissis(dispositivo) && !!dispositivo.pai && !isArticulacao(dispositivo.pai);
};
const getTextoInconsistencia = (dispositivos) => {
    var _a, _b;
    const dispositivo = dispositivos.find(d => isDispositivoInconsistente(d));
    if (dispositivo && dispositivo.pai) {
        const pai = isCaput(dispositivo.pai) ? dispositivo.pai.pai : dispositivo.pai;
        const tiposPermitidos = (_a = pai === null || pai === void 0 ? void 0 : pai.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.map(t => { var _a; return (_a = TipoDispositivo[t.toLowerCase()].descricao) === null || _a === void 0 ? void 0 : _a.toLowerCase(); });
        return `O dispositivo "${dispositivo.rotulo}" não pode ser colado como filho de "${pai === null || pai === void 0 ? void 0 : pai.rotulo}" pois o tipo do dispositivo é ${(_b = TipoDispositivo[dispositivo.tipo.toLowerCase()].descricao) === null || _b === void 0 ? void 0 : _b.toLowerCase()} e o tipo permitido é ${tiposPermitidos === null || tiposPermitidos === void 0 ? void 0 : tiposPermitidos.join(' ou ')}.`;
    }
    return '';
};
const existeDispositivoComRotuloDuplicado = (articulacaoColada) => {
    const rotulos = articulacaoColada.filhos.map(f => f.rotulo);
    return rotulos.length > new Set(rotulos).size;
};
const validarArticulacaoColadaAnaliseContextualizada = (infoTextoColado, infoDispositivos) => {
    const result = [];
    const { textoColadoAjustado, articulacaoColada, articulacaoProposicao, tipoColado, isColarSubstituindo, posicao } = infoTextoColado;
    const { atual, referencia, existentes: dispositivosExistentes } = infoDispositivos;
    if (infoTextoColado.infoElementos.tiposColados.includes('DispositivoAgrupadorGenerico')) {
        return result;
    }
    if (!articulacaoColada.filhos.length) {
        return result;
    }
    const pluralTipoColado = tipoColado.descricaoPlural;
    if (isDispositivoAlteracao(atual) && hasArtigoOndeCouber(textoColadoAjustado)) {
        result.push({
            tipo: TipoRestricaoEnum.ARTIGOS_SEM_NUMERACAO_DENTRO_DE_ALTERACAO,
            mensagens: [`Não é permitido colar artigo sem numeração dentro de alteração de norma.`],
        });
    }
    if (isDispositivoAlteracao(atual) && articulacaoColada.filhos.some(f => { var _a; return isArtigo(f) && ((_a = f.alteracoes) === null || _a === void 0 ? void 0 : _a.filhos.length); })) {
        result.push({
            tipo: TipoRestricaoEnum.ALTERACAO_DENTRO_DE_ALTERACAO,
            mensagens: ['Não é permitido colar alteração de norma dentro de alteração de norma'],
        });
    }
    const dispositivosExistentesAux = dispositivosExistentes || montarListaDispositivosExistentes(getArticulacao(atual), articulacaoColada, referencia);
    if (atual.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO && articulacaoColada.filhos && isColandoFilhos(articulacaoColada.filhos, atual)) {
        result.push({
            tipo: TipoRestricaoEnum.FILHOS_EM_DISPOSITIVO_SUPRIMIDO,
            mensagens: ['Não é permitido colar filhos em dispositivo suprimido'],
        });
    }
    if (isColarSubstituindo && dispositivosExistentesAux.some(isModificadoOuSuprimido)) {
        const ids = dispositivosExistentesAux.filter(isModificadoOuSuprimido).map(d => d.id);
        const dispositivos = getDispositivoAndFilhosAsLista(articulacaoProposicao)
            .filter(d => tipoColado.name === d.tipo && ids.includes(d.id))
            .map(d => { var _a; return (_a = d.rotulo) === null || _a === void 0 ? void 0 : _a.replace(/ [-–)]/, ''); })
            .join(', ');
        result.push({
            tipo: TipoRestricaoEnum.DISPOSITIVO_JA_MODIFICADO,
            titulo: 'Atenção, dispositivo já modificado encontrado',
            mensagens: [`Não é permitido colar dispositivos que já foram alterados na emenda${dispositivos ? ` (veja ${pluralTipoColado}: ${dispositivos})` : ''}.`],
            isPermitidoColarAdicionando: true,
        });
    }
    const referenciaAux = referencia || getDispositivoReferencia(articulacaoColada.filhos[0].tipo, atual);
    if (!referenciaAux) {
        const pluralTipoAtual = getTipo(atual.tipo).descricaoPlural;
        result.push({
            tipo: TipoRestricaoEnum.DISPOSITIVO_EM_POSICAO_INVALIDA,
            mensagens: [`Não é permitido colar ${pluralTipoColado === null || pluralTipoColado === void 0 ? void 0 : pluralTipoColado.toLowerCase()} sobre ${pluralTipoAtual === null || pluralTipoAtual === void 0 ? void 0 : pluralTipoAtual.toLowerCase()}`],
        });
        return result;
    }
    if (posicao === 'antes' && referenciaAux.tipo !== articulacaoColada.filhos[0].tipo) {
        result.push({
            tipo: TipoRestricaoEnum.DISPOSITIVO_ANTES_DO_ATUAL,
            mensagens: [`Não é permitido colar ${pluralTipoColado} antes do atual dispositivo selecionado`],
        });
    }
    if (isColandoArtigosComFilhosSobreArtigosComAlteracoes(infoTextoColado, infoDispositivos)) {
        result.push({
            tipo: TipoRestricaoEnum.ARTIGO_COM_FILHOS_SOBRE_ARTIGO_COM_ALTERACOES,
            mensagens: ['Não é permitido adicionar incisos ou parágrafos a artigo que já possua alterações de norma'],
            isPermitidoColarAdicionando: true,
        });
    }
    if (isColandoArtigosComAlteracoesSobreArtigosComFilhos(infoTextoColado, infoDispositivos)) {
        result.push({
            tipo: TipoRestricaoEnum.ARTIGO_COM_ALTERACOES_SOBRE_ARTIGO_COM_FILHOS,
            mensagens: ['Não é permitido adicionar alterações de norma a artigo que já possua incisos ou parágrafos'],
            isPermitidoColarAdicionando: true,
        });
    }
    if (isColandoArtigoExistenteComMudancaDaNormaAlterada(infoTextoColado)) {
        result.push({
            tipo: TipoRestricaoEnum.ARTIGO_COM_MUDANCA_IDENTIFICACAO_NORMA_ALTERADA,
            mensagens: ['Não é permitido colar artigo com mudança na identificação da norma alterada'],
            isPermitidoColarAdicionando: true,
        });
    }
    return result;
};
const isColandoArtigosComFilhosSobreArtigosComAlteracoes = (infoTextoColado, infoDispositivos) => {
    return infoTextoColado.isColarSubstituindo && hasArtigosComAlteracoes(infoDispositivos.existentes) && hasArtigosComFilhos(infoTextoColado.articulacaoColada.filhos);
};
const isColandoArtigosComAlteracoesSobreArtigosComFilhos = (infoTextoColado, infoDispositivos) => {
    return infoTextoColado.isColarSubstituindo && hasArtigosComFilhos(infoDispositivos.existentes) && hasArtigosComAlteracoes(infoTextoColado.articulacaoColada.filhos);
};
const isColandoArtigoExistenteComMudancaDaNormaAlterada = (infoTextoColado) => {
    // TODO: Implementar quando parser estiver rodando o linker
    return !infoTextoColado;
};
const hasArtigosComAlteracoes = (dispositivos) => dispositivos.some(d => { var _a; return isArtigo(d) && !isDispositivoAlteracao(d) && ((_a = d.alteracoes) === null || _a === void 0 ? void 0 : _a.filhos.length); });
const hasArtigosComFilhos = (dispositivos) => dispositivos.some(d => { var _a; return isArtigo(d) && !isDispositivoAlteracao(d) && ((_a = d.filhos) === null || _a === void 0 ? void 0 : _a.length); });
const getDispositivoReferencia = (tipoASerColado, ref) => {
    if (!ref) {
        return;
    }
    else if (ref.tipo === tipoASerColado || (ref.tiposPermitidosFilhos || []).includes(tipoASerColado)) {
        return ref;
    }
    else {
        return getDispositivoReferencia(tipoASerColado, ref.pai);
    }
};
const isColandoFilhos = (filhos, atual) => {
    var _a;
    return filhos[0].tipo !== atual.tipo && !!((_a = atual.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.includes(filhos[0].tipo));
};
const ajustaIdsNaArticulacaoColada = (filhos, referencia) => {
    let prefixo;
    if (referencia.tipo === filhos[0].tipo) {
        prefixo = referencia.pai.id;
    }
    else {
        prefixo = referencia.id;
    }
    if (isArtigo(referencia) && isInciso(filhos[0])) {
        prefixo += '_cpt';
    }
    filhos.forEach(f => getDispositivoAndFilhosAsLista(f).forEach(f2 => ajustaIdSeNecessario(f2, prefixo)));
};
const ajustaIdSeNecessario = (dispositivo, prefixo) => {
    var _a;
    !((_a = dispositivo.id) === null || _a === void 0 ? void 0 : _a.startsWith(prefixo)) && ajustarId(dispositivo, prefixo);
};
const ajustarId = (dispositivo, prefixo) => {
    dispositivo.id = prefixo + '_' + dispositivo.id;
    if (isArtigo(dispositivo) && dispositivo.caput) {
        dispositivo.caput.id = prefixo + '_' + dispositivo.caput.id;
    }
};
const getRegexRotuloArtigoOndeCouber = () => /^(["“‘'])?(art\.\s+(?!\d+)[x. ]*[º0]?)/gim;
const hasArtigoOndeCouber = (texto) => {
    var _a;
    const t = (_a = removeAllHtmlTags(texto)) === null || _a === void 0 ? void 0 : _a.replace(/&nbsp;/g, ' ').replace(/["“']/g, '').trim();
    return getRegexRotuloArtigoOndeCouber().test(t);
};
const numerarArtigosOndeCouber = (texto) => {
    if (hasArtigoOndeCouber(texto)) {
        let contador = 5000;
        let novoTexto = texto.replaceAll(getRegexRotuloArtigoOndeCouber(), '$1ArtigoANumerar');
        //numera artigos
        while (novoTexto.indexOf('ArtigoANumerar') !== -1) {
            novoTexto = novoTexto.replace('ArtigoANumerar', 'Art. ' + contador++ + '. ');
        }
        return novoTexto;
    }
    return texto;
};
const ajustaHtmlParaColagem = (htmlInicial) => {
    let html = htmlInicial
        .replace(/\xA0/g, ' ') // &nbsp; (non breaking space to space) (\xA0 = 160)
        .replace(/<![^>]*>/g, '')
        .replace(/<p/g, '\n<p')
        .replace(/<br\b[^>]*>/gi, '\n')
        .replace(/&nbsp;/g, ' ')
        .replace(/(<br\s*\/?>)/gi, ' ')
        .replace(/<([a-z]+) .*?=".*?( *\/?>)/gi, '<$1$2')
        .replace(/;[/s]?[e][/s]?$/, '; ')
        .replace(';', '; ')
        .replace(/^["“']/g, '')
        .replace(/<\/?body[^>]*>/gi, '')
        .replace(/\r/g, '')
        .replace(/\n+/g, '\n')
        .replace(/&ldquo; |&ldquo;/g, '“')
        .replace(/&rdquo;/g, '”');
    const allowedTags = ['B', 'STRONG', 'I', 'EM', 'SUP', 'SUB', 'P'];
    allowedTags.map(tag => tag.toLowerCase()).forEach(tag => (html = html.replace(new RegExp(`<${tag}[^>]*>`, 'gi'), `<${tag}>`)));
    // Substitui tags "strong" por "b" e "em" por "i"
    html = html.replace(/<(\/?)strong>/gi, '<$1b>').replace(/<(\/?)em(>)/gi, '<$1i>');
    // Remove quebras de linha dentro de parágrafos
    html = html.replace(/<p[^>]*>(?:.|\n)*?<\/p>/gi, s => s.replace(/\n/g, ' ')).replace(/[\t ]+/g, ' ');
    html = html.replace(/&gt;/g, '>').replace(/&lt;/g, '<');
    html = removeAllHtmlTagsExcept(html, allowedTags)
        .replace(/<p[^>]*>/gi, '\n<p>') // Garante que cada parágrafo comece em uma nova linha
        .replace(/(?<=<\/p>).*/gi, '') // Remove tudo que vem depois do fim do parágrafo, na mesma linha (remove o que não estiver dentro de um parágrafo)
        .replace(/<\/?p[^>]*>/g, '\n')
        .replace(/\n+/g, '\n')
        .replace(/ +/g, ' ')
        .replace(/\n\s+/g, '\n')
        .replace(/\n *<i>(Parágrafo único\. *)<\/i>/gi, '\n$1') // Remove itálico de rótulo de parágrafo único
        .trim();
    return html;
};

const REGEX_OMISSIS = /^\.{2,}/;
const adicionaElementosNaProposicaoFromClipboard = (state, action) => {
    var _a, _b, _c, _d;
    const atual = getDispositivoFromElemento(state.articulacao, action.atual, true);
    if (atual === undefined) {
        state.ui.events = [];
        return state;
    }
    const infoTextoColado = (_a = action.infoTextoColado) !== null && _a !== void 0 ? _a : InfoTextoColado.newInstanceFromJsonix((_c = (_b = action.novo) === null || _b === void 0 ? void 0 : _b.conteudo) === null || _c === void 0 ? void 0 : _c.texto, state.articulacao, action.atual, action.isColarSubstituindo, action.posicao);
    if (infoTextoColado.restricoes.length) {
        return retornaEstadoAtualComMensagem(state, { tipo: TipoMensagem.ERROR, descricao: infoTextoColado.restricoes[0].mensagens[0] });
    }
    const articulacaoColada = infoTextoColado.articulacaoColada;
    const ref = getDispositivoFromElemento(state.articulacao, infoTextoColado.infoElementos.referencia);
    if (!isArtigo(articulacaoColada.filhos[0]) || isDispositivoAlteracao(atual)) {
        ajustaIdsNaArticulacaoColada(articulacaoColada.filhos, ref);
    }
    const eventos = colarDispositivos(state.articulacao, articulacaoColada, atual, ref, action.posicao, action.isColarSubstituindo, action.isUsarDispositivoDeMesmoRotuloComoReferenciaDuranteAdicao, state.modo, infoTextoColado.infoElementos.tiposColados[0]);
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: buildPast(state, eventos),
        present: eventos,
        future: [],
        ui: {
            events: eventos,
            alertas: (_d = state.ui) === null || _d === void 0 ? void 0 : _d.alertas,
        },
    };
};
const colarDispositivos = (articulacao, articulacaoColada, atual, referencia, posicao, isColarSubstituindo, isUsarDispositivoDeMesmoRotuloComoReferenciaDuranteAdicao, modo, tipoColado) => {
    const isColandoEmAlteracaoDeNorma = isDispositivoAlteracao(atual);
    let refAux = referencia;
    const adicionados = [];
    const modificados = [];
    articulacaoColada.filhos.forEach(f => {
        if (isColandoEmAlteracaoDeNorma || !isOmissis(f)) {
            const d = buscarDispositivoByIdTratandoParagrafoUnico(articulacao, f.id);
            if (d && isColarSubstituindo) {
                const d2 = colarDispositivoSubstituindo(d, f, modo, isColandoEmAlteracaoDeNorma);
                modificados.push(...getDispositivoAndFilhosAsLista(d2).filter(isModificado));
                adicionados.push(...getDispositivoAndFilhosAsLista(d2).filter(isAdicionado));
                refAux = d2;
            }
            else {
                refAux = d && isUsarDispositivoDeMesmoRotuloComoReferenciaDuranteAdicao ? d : refAux;
                const d2 = colarDispositivoAdicionando(refAux, f, isColandoEmAlteracaoDeNorma, false, modo, posicao === 'antes' && refAux === referencia ? posicao : undefined);
                adicionados.push(...getDispositivoAndFilhosAsLista(d2));
                refAux = d2;
            }
        }
    });
    const eventos = [];
    let eventoElementoRemovido;
    if (isAdicionarNaPosicaoAtual(articulacaoColada, atual, referencia)) {
        eventoElementoRemovido = buildEventoElementoRemovido(referencia);
        referencia.pai.removeFilho(referencia);
        referencia.pai.renumeraFilhos();
        adicionados.forEach(d => (d.id = buildId(d)));
    }
    eventos.push(buildEventoElementoIncluido(adicionados, referencia));
    eventoElementoRemovido && eventos.push(eventoElementoRemovido);
    eventos.push(...buildEventosElementoModificado(modificados));
    eventos.push(buildEventoElementosRenumerados(adicionados, referencia, tipoColado));
    processaEventosSuprimidos(eventos, modificados);
    eventos.push(buildEventoSituacaoElementoModificada(adicionados, isColandoEmAlteracaoDeNorma));
    adicionados[0] && eventos.push(buildEventoElementoMarcado([adicionados[0], atual]));
    return eventos.filter(ev => { var _a; return (_a = ev.elementos) === null || _a === void 0 ? void 0 : _a.length; });
};
const buildEventoElementosRenumerados = (adicionados, referencia, tipoColado) => {
    const refAux = referencia.tipo === tipoColado ? referencia.pai : referencia;
    const filhosASeremRenumerados = refAux.filhos.filter(f => isAdicionado(f) && !adicionados.includes(f));
    return {
        stateType: StateType.ElementoRenumerado,
        elementos: filhosASeremRenumerados.map(f => createElemento(f)),
    };
};
const isAdicionarNaPosicaoAtual = (articulacaoColada, atual, referencia) => {
    const primeiroDispositivoColado = getDispositivoAndFilhosAsLista(articulacaoColada).filter(d => !['Articulacao', 'Omissis'].includes(d.tipo))[0];
    return atual === referencia && primeiroDispositivoColado.tipo === referencia.tipo && !referencia.texto && isAdicionado(referencia);
};
const buildEventoElementoRemovido = (dispositivo) => {
    return {
        stateType: StateType.ElementoRemovido,
        elementos: [createElementoValidado(dispositivo)],
    };
};
const buildEventoElementoIncluido = (adicionados, referencia) => {
    const elementoAdicionados = [];
    const paiRef = referencia.pai;
    let referenciaUI;
    if (adicionados.length) {
        let dispositivos = getDispositivoAndFilhosAsLista(paiRef);
        let index = dispositivos.indexOf(adicionados[0]);
        if (index === -1) {
            dispositivos = getDispositivoAndFilhosAsLista(getArticulacao(paiRef));
            index = dispositivos.indexOf(adicionados[0]);
        }
        adicionados.forEach(d => {
            const elemento = createElemento(d, true, true);
            elemento.mensagens = validaDispositivo(d);
            elementoAdicionados.push(elemento);
        });
        referenciaUI = createElemento(dispositivos[index - 1]);
    }
    return {
        stateType: StateType.ElementoIncluido,
        elementos: elementoAdicionados,
        referencia: referenciaUI,
    };
};
const buildEventosElementoModificado = (modificados) => {
    const eventos = [];
    modificados.forEach(d => {
        eventos.push({
            stateType: StateType.ElementoModificado,
            elementos: [d.situacao.dispositivoOriginal, createElementoValidado(d)],
        });
    });
    return eventos;
};
const processaEventosSuprimidos = (eventos, modificados) => {
    if (modificados.length > 0) {
        const suprimidos = [];
        modificados.forEach(d => {
            getDispositivosToElementoSuprimido(d).forEach(d => {
                if (suprimidos.filter(s => s.id === d.id).length === 0) {
                    suprimidos.push(d);
                }
            });
        });
        eventos.push({ stateType: StateType.ElementoSuprimido, elementos: suprimidos.map(d => createElementoValidado(d)) });
    }
};
const getDispositivosToElementoSuprimido = (referencia) => {
    const suprimidos = getDispositivoAndFilhosAsLista(referencia.pai)
        .filter(isSuprimido)
        .map(d => getDispositivoAndFilhosAsLista(d))
        .flat();
    return suprimidos;
};
const buildEventoSituacaoElementoModificada = (dispositivos, isColandoEmAlteracaoDeNorma) => {
    const elementosComSituacaoModificada = []; // elementos a serem atualizados na UI
    if (isColandoEmAlteracaoDeNorma) {
        elementosComSituacaoModificada.push(...getDispositivosEmAlteracaoDeNormaASeremAtualizados(dispositivos).map(d => createElementoValidado(d)));
    }
    elementosComSituacaoModificada.push(...getParagrafosDeNumero1(dispositivos).map(d => createElementoValidado(d)));
    elementosComSituacaoModificada.push(...getArtigosComAlteracaoDeNorma(dispositivos).map(d => createElementoValidado(d)));
    return {
        stateType: StateType.SituacaoElementoModificada,
        elementos: elementosComSituacaoModificada,
    };
};
const buildEventoElementoMarcado = (dispositivos) => {
    return {
        stateType: StateType.ElementoMarcado,
        elementos: dispositivos.map(d => createElementoValidado(d)),
    };
};
const getParagrafosDeNumero1 = (dispositivos) => {
    return [...new Set(dispositivos.filter(isParagrafo).map(d => d.pai))].map(art => art.filhos.filter(f => isParagrafo(f) && f.numero === '1')).flat();
};
const getArtigosComAlteracaoDeNorma = (dispositivos) => {
    return dispositivos.filter(d => { var _a; return isArtigo(d) && !isArticulacaoAlteracao(d) && ((_a = d.alteracoes) === null || _a === void 0 ? void 0 : _a.filhos.length); });
};
const colarDispositivoSubstituindo = (dOriginal, dColado, modo, isColandoEmAlteracaoDeNorma, colecaoInfoOmissis = []) => {
    var _a;
    let refAux = dOriginal;
    if (removeAllHtmlTags(dOriginal.texto) !== removeAllHtmlTags(dColado.texto) && !dColado.texto.match(REGEX_OMISSIS) && dColado.texto.trim()) {
        dOriginal.situacao = new DispositivoModificado(createElementoValidado(dOriginal));
        // dOriginal.isDispositivoAlteracao = false;
        dOriginal.texto = dColado.texto;
    }
    let omissisImediatamenteAnterior;
    const filhosColados = ((_a = dColado.alteracoes) === null || _a === void 0 ? void 0 : _a.filhos) || dColado.filhos;
    filhosColados.forEach(fColado => {
        if (isOmissis(fColado)) {
            colecaoInfoOmissis.push(montarInfoOmissis(dOriginal, fColado));
        }
        if (!isOmissis(fColado) || isColandoEmAlteracaoDeNorma) {
            const fOriginal = buscarDispositivoByIdTratandoParagrafoUnico(getArticulacao(dOriginal), fColado.id);
            if (fOriginal) {
                refAux = fOriginal;
                colarDispositivoSubstituindo(fOriginal, fColado, modo, isColandoEmAlteracaoDeNorma || isDispositivoAlteracao(fColado), colecaoInfoOmissis);
            }
            else {
                refAux = (omissisImediatamenteAnterior && getUltimoDispositivoDoIntervaloOmitido(omissisImediatamenteAnterior, colecaoInfoOmissis, fColado)) || refAux;
                colarDispositivoAdicionando(refAux, fColado, isColandoEmAlteracaoDeNorma || isDispositivoAlteracao(fColado), !!omissisImediatamenteAnterior, modo, 'depois');
                refAux = fColado;
            }
        }
        omissisImediatamenteAnterior = isOmissis(fColado) ? fColado : undefined;
    });
    if (!isColandoEmAlteracaoDeNorma) {
        suprimirDispositivosForaDosIntervalosOmitidos(dOriginal, dColado, colecaoInfoOmissis);
    }
    return dOriginal;
};
const getUltimoDispositivoDoIntervaloOmitido = (omissis, colecaoInfoOmissis, dColado) => {
    var _a;
    return (_a = colecaoInfoOmissis
        .find(i => i.omissis === omissis)) === null || _a === void 0 ? void 0 : _a.omitidos.filter(o => o.tipo === dColado.tipo).slice(-1)[0];
};
const suprimirDispositivosForaDosIntervalosOmitidos = (dOriginal, dColado, colecaoInfoOmissis) => {
    const articulacaoColada = getArticulacao(dColado);
    const dispositivosOriginaisOmitidosNaArticulacaoColada = colecaoInfoOmissis.map(i => i.omitidos).flat();
    dOriginal.filhos.forEach(fOriginal => {
        const fColado = buscarDispositivoByIdTratandoParagrafoUnico(articulacaoColada, fOriginal.id) || buscaDispositivoById(articulacaoColada, fOriginal.id.replace('par1u', 'par1'));
        if (!fColado && !dispositivosOriginaisOmitidosNaArticulacaoColada.find(d => d.id === fOriginal.id)) {
            getDispositivoAndFilhosAsLista(fOriginal).forEach(d => (d.situacao = new DispositivoSuprimido(createElementoValidado(d))));
        }
    });
};
const buscarDispositivoByIdTratandoParagrafoUnico = (articulacao, id) => {
    const d = buscaDispositivoById(articulacao, id);
    if (d) {
        return d;
    }
    else {
        const idSemConsiderarAlteracaoEmNorma = id.split('alt')[0];
        if (idSemConsiderarAlteracaoEmNorma.split('_').includes('par1')) {
            return buscaDispositivoById(articulacao, id.replace('_par1_', '_par1u_').replace(/par1$/, 'par1u'));
        }
        else {
            return;
        }
    }
};
const colarDispositivoAdicionando = (referencia, dColado, isColandoEmAlteracaoDeNorma, isPrecedidoPorOmissis, modo, posicao) => {
    var _a, _b, _c, _d;
    if (!isOmissis(referencia) && ((_a = referencia.tiposPermitidosFilhos) === null || _a === void 0 ? void 0 : _a.includes(dColado.tipo))) {
        if (isArtigo(referencia) && isInciso(dColado)) {
            dColado.pai = referencia.caput;
            if (isPrecedidoPorOmissis) {
                referencia.caput.addFilho(dColado);
            }
            else {
                referencia.caput.addFilhoOnPosition(dColado, 0);
            }
        }
        else {
            dColado.pai = referencia;
            if (isPrecedidoPorOmissis) {
                referencia.addFilho(dColado);
            }
            else {
                referencia.addFilhoOnPosition(dColado, 0);
            }
        }
    }
    else if (!isDispositivoAlteracao(referencia) && isDispositivoAlteracao(dColado)) {
        dColado.pai = referencia.alteracoes;
        referencia.alteracoes.addFilhoOnPosition(dColado, 0);
    }
    else {
        dColado.pai = referencia.pai;
        (_b = referencia.pai) === null || _b === void 0 ? void 0 : _b.addFilhoOnPosition(dColado, referencia.pai.indexOf(referencia) + (posicao === 'antes' ? 0 : 1));
    }
    if (dColado.texto.match(REGEX_OMISSIS) && !isColandoEmAlteracaoDeNorma) {
        dColado.texto = '';
    }
    ajustaSituacaoDispositivoAdicionado(dColado, modo);
    if (isColandoEmAlteracaoDeNorma) {
        dColado.notaAlteracao = isDispositivoCabecaAlteracao(dColado) ? 'NR' : undefined;
    }
    else {
        removeOmissis(dColado);
    }
    if (!((_d = (_c = dColado.pai) === null || _c === void 0 ? void 0 : _c.tiposPermitidosFilhos) === null || _d === void 0 ? void 0 : _d.includes(dColado.tipo)) && !isOmissis(dColado)) {
        throw new Error('Erro ao colar dispositivo adicionado');
    }
    renumerarEAjustarIds(dColado);
    return dColado;
};
const renumerarEAjustarIds = (dispositivo) => {
    var _a;
    (_a = dispositivo.pai) === null || _a === void 0 ? void 0 : _a.renumeraFilhos();
    getDispositivoAndFilhosAsLista(dispositivo).forEach(d => {
        d.id = buildId(d);
        if (isArtigo(d)) {
            d.caput.id = buildId(d.caput);
        }
    });
};
const criaAtributosComunsAdicionado = (filho, modo) => {
    filho.situacao = new DispositivoAdicionado();
    filho.isDispositivoAlteracao = isDispositivoAlteracao(filho);
    filho.situacao.tipoEmenda = modo;
    if (filho.isDispositivoAlteracao && !isOmissis(filho)) {
        filho.situacao.existeNaNormaAlterada = true;
    }
};
const removeOmissis = (atual) => {
    const omissis = atual.filhos.filter(isOmissis);
    omissis.forEach(o => o.pai.removeFilho(o));
    atual.filhos.forEach(removeOmissis);
    atual.id = buildId(atual);
    atual.renumeraFilhos();
};
const ajustaSituacaoDispositivoAdicionado = (atual, modo) => {
    criaAtributosComunsAdicionado(atual, modo);
    atual.filhos.forEach(filho => {
        criaAtributosComunsAdicionado(filho, modo);
        filho.filhos && ajustaSituacaoDispositivoAdicionado(filho, modo);
    });
    if (atual.alteracoes) {
        criaAtributosComunsAdicionado(atual.alteracoes, modo);
        atual.alteracoes.filhos.forEach(filho => {
            criaAtributosComunsAdicionado(filho, modo);
            filho.filhos && ajustaSituacaoDispositivoAdicionado(filho, modo);
        });
    }
};
const montarInfoOmissis = (dOriginal, omissisColado) => {
    const dispositivosDaArvoreDoOmisses = getDispositivoAndFilhosAsLista(isCaput(omissisColado.pai) ? omissisColado.pai.pai : omissisColado.pai);
    const dispositivosDaArvoreDoOriginal = getDispositivoAndFilhosAsLista(isArtigo(dOriginal) ? dOriginal : dOriginal.pai);
    const indexOmissis = dispositivosDaArvoreDoOmisses.indexOf(omissisColado);
    const anteriorOmissis = dispositivosDaArvoreDoOmisses[indexOmissis - 1];
    const posteriorOmissis = dispositivosDaArvoreDoOmisses[indexOmissis + 1];
    const anteriorOmissisNaArvoreDoOriginal = dispositivosDaArvoreDoOriginal.find(d => d.id === anteriorOmissis.id);
    const posteriorOmissisNaArvoreDoOriginal = posteriorOmissis && dispositivosDaArvoreDoOriginal.find(d => d.id === posteriorOmissis.id);
    const omitidos = getDispositivosOriginais(dispositivosDaArvoreDoOriginal, anteriorOmissisNaArvoreDoOriginal, posteriorOmissisNaArvoreDoOriginal, posteriorOmissis);
    const prefixos = [...new Set(omitidos.map(d => d.id.split('_')[0]))];
    if (prefixos.length > 1) {
        throw new Error('Erro ao montar lista de dispositivos omitidos');
    }
    return {
        omissis: omissisColado,
        anterior: anteriorOmissis,
        posterior: posteriorOmissis,
        omitidos,
    };
};
const getDispositivosOriginais = (dispositivosDaArvoreDoOriginal, anteriorOmissisNaArvoreDoOriginal, posteriorOmissisNaArvoreDoOriginal, posteriorOmissisNaArvoreDoOmissis) => {
    const result = [];
    if (posteriorOmissisNaArvoreDoOriginal) {
        const indexAnteriorNaListaOriginal = dispositivosDaArvoreDoOriginal.findIndex(d => d.id === anteriorOmissisNaArvoreDoOriginal.id);
        const indexPosteriorNaListaOriginal = dispositivosDaArvoreDoOriginal.findIndex(d => d.id === posteriorOmissisNaArvoreDoOriginal.id);
        result.push(...dispositivosDaArvoreDoOriginal.filter((_, index) => index > indexAnteriorNaListaOriginal && index < indexPosteriorNaListaOriginal));
    }
    else {
        const indexAnteriorNaListaOriginal = dispositivosDaArvoreDoOriginal.findIndex(d => d.id === anteriorOmissisNaArvoreDoOriginal.id);
        result.push(...dispositivosDaArvoreDoOriginal.filter((d, index) => index > indexAnteriorNaListaOriginal && (!posteriorOmissisNaArvoreDoOmissis || d.id.startsWith(posteriorOmissisNaArvoreDoOmissis.pai.id))));
    }
    return result;
};
const getDispositivosEmAlteracaoDeNormaASeremAtualizados = (dispositivos) => {
    const mapa = new Map();
    dispositivos.forEach(d => {
        const cabeca = getDispositivoCabecaAlteracao(d);
        mapa.set(cabeca.id, cabeca);
    });
    const cabecas = [...mapa.values()];
    return cabecas
        .map(d => {
        const ultimoFilho = getUltimoFilho(d);
        const irmaoAnterior = getDispositivoAnteriorNaSequenciaDeLeitura(ultimoFilho, d1 => !!(d1.pai && d1.pai === ultimoFilho.pai));
        return irmaoAnterior ? [irmaoAnterior, ultimoFilho] : [ultimoFilho];
    })
        .flat()
        .filter(d => d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO);
};

const ativaDesativaRevisao = (state) => {
    var _a, _b;
    const isActive = !state.emRevisao;
    if (!isActive && ((_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.length)) {
        return {
            ...retornaEstadoAtualComMensagem(state, {
                tipo: TipoMensagem.INFO,
                descricao: 'É necessário resolver todas as marcas de revisão' + getMensagemTipoRevisoes(state) + 'para desativar o modo de controle de alterações',
            }),
            emRevisao: true,
        };
    }
    return {
        ...state,
        emRevisao: isActive,
        ui: {
            events: [{ stateType: isActive ? StateType.RevisaoAtivada : StateType.RevisaoDesativada }],
            alertas: (_b = state.ui) === null || _b === void 0 ? void 0 : _b.alertas,
        },
    };
};
const getMensagemTipoRevisoes = (state) => {
    const contemRevisoesDispositivos = state.revisoes.filter(e => e.descricao !== RevisaoJustificativaEnum.JustificativaAlterada).length > 0;
    const contemRevisoesJustificativa = state.revisoes.filter(e => e.descricao === RevisaoJustificativaEnum.JustificativaAlterada).length > 0;
    return contemRevisoesDispositivos && contemRevisoesJustificativa
        ? ' das abas texto e justificação '
        : contemRevisoesDispositivos
            ? ' da aba texto '
            : contemRevisoesJustificativa
                ? ' da aba justificação '
                : ' ';
};

class Revisao {
    constructor(usuario, dataHora, descricao) {
        this.id = generateUUID();
        this.usuario = usuario;
        this.dataHora = dataHora;
        this.descricao = descricao;
    }
}
class RevisaoJustificativa extends Revisao {
    constructor(usuario, dataHora, descricao) {
        super(usuario, dataHora, descricao);
        this.type = 'RevisaoJustificativa';
    }
}
class RevisaoTextoLivre extends Revisao {
    constructor(usuario, dataHora, descricao) {
        super(usuario, dataHora, descricao);
        this.type = 'RevisaoTextoLivre';
    }
}
class RevisaoElemento extends Revisao {
    constructor(actionType, stateType, descricao, usuario, dataHora, elementoAntesRevisao, elementoAposRevisao) {
        super(usuario, dataHora, descricao);
        this.type = 'RevisaoElemento';
        this.actionType = actionType;
        this.stateType = stateType;
        this.elementoAntesRevisao = elementoAntesRevisao;
        this.elementoAposRevisao = elementoAposRevisao;
        this.descricao = descricao || buildDescricaoRevisao(this);
        removeAtributosDoElemento(this.elementoAntesRevisao);
        removeAtributosDoElemento(this.elementoAposRevisao);
    }
}

const padTo2Digits = (num) => {
    return num.toString().padStart(2, '0');
};
const formatDDMMYYYY = (date) => {
    return [padTo2Digits(date.getDate()), padTo2Digits(date.getMonth() + 1), date.getFullYear()].join('/');
};
const formatDateTime = (date) => {
    const data = [date.getFullYear(), padTo2Digits(date.getMonth() + 1), padTo2Digits(date.getDate())].join('-');
    const hora = [padTo2Digits(date.getHours()), padTo2Digits(date.getMinutes()), padTo2Digits(date.getSeconds())].join(':');
    return `${data} ${hora}`;
};

const ATUALIZAR_USUARIO = 'ATUALIZAR_USUARIO';
class AtualizarUsuario {
    constructor() {
        this.descricao = 'Atualizar o usuário da revisão.';
    }
    execute(usuario) {
        return {
            type: ATUALIZAR_USUARIO,
            usuario: usuario,
        };
    }
}
const atualizarUsuarioAction = new AtualizarUsuario();

const atualizaRevisao = (state, actionType) => {
    var _a, _b, _c, _d, _e;
    const numElementos = (_a = state.ui) === null || _a === void 0 ? void 0 : _a.events.map(se => se.elementos).flat().length;
    if ([ABRIR_ARTICULACAO, ATUALIZAR_USUARIO, VALIDAR_ARTICULACAO].includes(actionType) || !state.emRevisao || !actionType || !numElementos) {
        return state;
    }
    else if (actionType === APLICAR_ALTERACOES_EMENDA) {
        associarRevisoesAosElementosDosEventos(state);
        return state;
    }
    if (UNDO === actionType && (((_b = state.past) === null || _b === void 0 ? void 0 : _b.length) || 0) < state.numEventosPassadosAntesDaRevisao) {
        associarRevisoesAosElementosDosEventos(state);
        return state;
    }
    if (REDO === actionType && (((_c = state.past) === null || _c === void 0 ? void 0 : _c.length) || 0) <= state.numEventosPassadosAntesDaRevisao) {
        associarRevisoesAosElementosDosEventos(state);
        return state;
    }
    if (((_e = (_d = state.ui) === null || _d === void 0 ? void 0 : _d.message) === null || _e === void 0 ? void 0 : _e.tipo) === TipoMensagem.ERROR) {
        return state;
    }
    let revisoes = [];
    if ((UNDO !== actionType || !isUndoDeRevisaoAceitaOuRejeitada(state)) && !isAcaoDeRevisaoRejeitada(state)) {
        revisoes.push(...processaEventosDeSupressao(state, actionType));
        revisoes.push(...processaEventosDeModificacao(state, actionType));
        revisoes.push(...processaEventosDeRestauracao(state, actionType));
        // revisoes.push(...processaEventosDeRenumeracao(state, actionType, elementoAntesAcao));
        if (isAcaoMoverOuTransformar(state)) {
            revisoes.push(...processaEventosDeMoverOuTransformar(state, actionType));
        }
        else {
            revisoes.push(...processaEventosDeInclusao(state, actionType));
            revisoes.push(...processaEventosDeRemocao(state, actionType));
        }
    }
    revisoes = identificarRevisaoElementoPai(state, revisoes);
    if (existeEventoDeInclusaoOuExclusao(state)) {
        atualizarLexmlIdEmElementosDeRevisoes(state);
        atualizarPosicaoDeElementosEmRevisoes(state);
    }
    state.revisoes.push(...revisoes);
    associarRevisoesAosElementosDosEventos(state);
    adicionarOpcoesAoMenu(state);
    return state;
};
const isUndoDeRevisaoAceitaOuRejeitada = (state) => {
    var _a;
    return !!((_a = state.future) === null || _a === void 0 ? void 0 : _a.length) && [StateType.RevisaoAceita, StateType.RevisaoRejeitada].includes(state.future[state.future.length - 1][0].stateType);
};
const isAcaoDeRevisaoRejeitada = (state) => { var _a; return !!((_a = state.ui) === null || _a === void 0 ? void 0 : _a.events.some(ev => ev.stateType === StateType.RevisaoRejeitada)); };
const processaEventosDeSupressao = (state, actionType) => {
    var _a;
    const eventos = getEventos(state, StateType.ElementoSuprimido);
    const result = [];
    const revisoesParaRemover = [];
    getElementosFromEventos(eventos).forEach(e => {
        var _a;
        const revisao = findRevisaoByElementoUuid(state.revisoes, e.uuid);
        if (revisao && ((_a = revisao.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
            revisoesParaRemover.push(revisao);
        }
        else {
            const d = getDispositivoFromElemento(state.articulacao, e);
            const eAux = (revisao === null || revisao === void 0 ? void 0 : revisao.elementoAntesRevisao) || JSON.parse(JSON.stringify(d.situacao.dispositivoOriginal));
            result.push(new RevisaoElemento(actionType, StateType.ElementoSuprimido, '', state.usuario, formatDateTime(new Date()), eAux, JSON.parse(JSON.stringify(e))));
            if (revisao) {
                revisoesParaRemover.push(revisao);
            }
        }
    });
    state.revisoes = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => !revisoesParaRemover.includes(r));
    return result;
};
const processaEventosDeModificacao = (state, actionType) => {
    var _a;
    const eventos = getEventos(state, StateType.ElementoModificado);
    const result = [];
    const revisoesParaRemover = [];
    getElementosFromEventos(eventos).forEach(e => {
        const revisao = findRevisaoByElementoUuid(state.revisoes, e.uuid);
        if (revisao) {
            if ((isRevisaoDeModificacao(revisao) || isRevisaoDeRestauracao(revisao)) && revisaoDeElementoComMesmoUuid2RotuloEConteudo(revisao, e)) {
                revisoesParaRemover.push(revisao);
            }
            revisao.elementoAposRevisao = JSON.parse(JSON.stringify(e));
            state.usuario && (revisao.usuario = state.usuario);
            revisao.dataHora = formatDateTime(new Date());
        }
        else {
            const eAux = getElementoAntesModificacao(state, e);
            // result.push(new RevisaoElemento(actionType, StateType.ElementoModificado, '', state.usuario!, formatDateTime(new Date()), eAux, JSON.parse(JSON.stringify(e))));
            if (!isAjusteTextoOmitido(eAux, e)) {
                result.push(new RevisaoElemento(actionType, StateType.ElementoModificado, '', state.usuario, formatDateTime(new Date()), eAux, JSON.parse(JSON.stringify(e))));
            }
        }
    });
    state.revisoes = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => !revisoesParaRemover.includes(r));
    return result;
};
const isAjusteTextoOmitido = (eAntesRevisao, eAposRevisao) => {
    var _a, _b, _c, _d, _e, _f, _g;
    // O texto omitido do dispositivo original pode possuir um span com a classe texto__omissis, que não deve ser considerado para fins de comparação de modificação.
    return !!(eAposRevisao.tipo === (eAntesRevisao === null || eAntesRevisao === void 0 ? void 0 : eAntesRevisao.tipo) &&
        ((_b = (_a = eAposRevisao.conteudo) === null || _a === void 0 ? void 0 : _a.texto) === null || _b === void 0 ? void 0 : _b.includes(TEXTO_OMISSIS)) &&
        ((_d = (_c = eAntesRevisao === null || eAntesRevisao === void 0 ? void 0 : eAntesRevisao.conteudo) === null || _c === void 0 ? void 0 : _c.texto) === null || _d === void 0 ? void 0 : _d.includes(TEXTO_OMISSIS)) &&
        ((_f = (_e = eAposRevisao.conteudo) === null || _e === void 0 ? void 0 : _e.texto) === null || _f === void 0 ? void 0 : _f.replace('<span class="texto__omissis">', '').replace('</span>', '')) === ((_g = eAntesRevisao === null || eAntesRevisao === void 0 ? void 0 : eAntesRevisao.conteudo) === null || _g === void 0 ? void 0 : _g.texto));
};
const processaEventosDeMoverOuTransformar = (state, actionType) => {
    var _a;
    const incluidos = getElementosFromEventos(getEventos(state, StateType.ElementoIncluido));
    const removidos = getElementosFromEventos(getEventos(state, StateType.ElementoRemovido));
    const result = [];
    const revisoesParaRemover = [];
    const montarNovaRevisao = (eAntesRevisao, eAposRevisao) => {
        const revInclusao = new RevisaoElemento(actionType, StateType.ElementoIncluido, '', state.usuario, formatDateTime(new Date()), eAntesRevisao ? JSON.parse(JSON.stringify(eAntesRevisao)) : undefined, JSON.parse(JSON.stringify(eAposRevisao)));
        revInclusao.descricao = buildDescricaoRevisaoFromStateType(revInclusao, eAposRevisao);
        // revExclusao.idRevisaoAssociada = revInclusao.id;
        // revInclusao.idRevisaoAssociada = revExclusao.id;
        // result.push(revExclusao);
        return revInclusao;
    };
    if (existeRevisaoParaElementos(state.revisoes, removidos)) {
        removidos.forEach((e, index) => {
            var _a;
            const revisao = findRevisaoByElementoUuid(state.revisoes, e.uuid);
            // A revisão pode não existir se houver dispositivo removido após a movimentação em modo de revisão
            // Exemplo: moveu inciso com alíneas, removeu alínea e depois moveu novamente o inciso
            if (!revisao) {
                result.push(montarNovaRevisao(e, incluidos[index]));
            }
            else if (isRevisaoDeTransformacao(revisao) && revisaoDeElementoComMesmoLexmlIdRotuloEConteudo(revisao, incluidos[index])) {
                revisoesParaRemover.push(...findRevisoesByElementoLexmlId(state.revisoes, e.lexmlId));
            }
            else if (revisaoDeElementoComMesmoUuid2RotuloEConteudo(revisao, incluidos[index]) && revisao.elementoAntesRevisao.uuid !== e.uuid) {
                revisoesParaRemover.push(...findRevisoesByElementoUuid2(state.revisoes, incluidos[index].uuid2));
            }
            else {
                state.revisoes = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => r.id !== revisao.id);
                // result.push(montarNovaRevisao(revisao.elementoAntesRevisao! as Elemento, incluidos[index]));
                revisao.stateType = StateType.ElementoIncluido;
                revisao.actionType = actionType;
                revisao.dataHora = formatDateTime(new Date());
                revisao.elementoAposRevisao = JSON.parse(JSON.stringify(incluidos[index]));
                removeAtributosDoElemento(revisao.elementoAposRevisao);
                revisao.usuario = state.usuario;
                revisao.descricao = buildDescricaoRevisaoFromStateType(revisao, incluidos[index]);
                revisao.idRevisaoElementoPai = revisoesParaRemover.find(r => r.id === revisao.idRevisaoElementoPai) ? undefined : revisao.idRevisaoElementoPai;
                revisao.idRevisaoElementoPrincipal = revisoesParaRemover.find(r => r.id === revisao.idRevisaoElementoPrincipal) ? undefined : revisao.idRevisaoElementoPrincipal;
                result.push(revisao);
            }
        });
    }
    else {
        removidos.forEach((e, index) => result.push(montarNovaRevisao(e, incluidos[index])));
    }
    state.revisoes = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => !revisoesParaRemover.includes(r));
    return result;
};
const processaEventosDeInclusao = (state, actionType) => {
    var _a;
    const eventos = getEventos(state, StateType.ElementoIncluido);
    const result = [];
    const revisoesParaRemover = [];
    const elementosIncluidos = getElementosFromEventos(eventos);
    const uuidsElementosIncluidos = elementosIncluidos.map(e => e.uuid);
    getElementosFromEventos(eventos).forEach(e => {
        var _a, _b;
        const revisao = findRevisaoByElementoUuid(state.revisoes, e.uuid);
        if (revisao) {
            revisoesParaRemover.push(revisao);
        }
        else {
            if (!uuidsElementosIncluidos.includes((_b = (_a = e.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.uuid)) {
                atualizaReferenciaElementoAnteriorSeNecessario(state.articulacao, state.revisoes, e, 'inclusao');
            }
            result.push(new RevisaoElemento(actionType, StateType.ElementoIncluido, '', state.usuario, formatDateTime(new Date()), undefined, JSON.parse(JSON.stringify(e))));
        }
    });
    state.revisoes = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => !revisoesParaRemover.includes(r));
    return result;
};
const processaEventosDeRemocao = (state, actionType) => {
    var _a;
    const eventos = getEventos(state, StateType.ElementoRemovido);
    const result = [];
    const revisoesParaRemover = [];
    const elementosRemovidos = getElementosFromEventos(eventos);
    const uuidsElementosRemovidos = elementosRemovidos.map(e => e.uuid);
    elementosRemovidos.forEach(e => {
        var _a, _b;
        const revisao = findRevisaoByElementoUuid(state.revisoes, e.uuid);
        if (revisao && (isRevisaoPrincipal(revisao) || !isRevisaoDeMovimentacao(revisao))) {
            revisoesParaRemover.push(revisao);
        }
        else {
            if (!uuidsElementosRemovidos.includes((_b = (_a = e.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.uuid)) {
                atualizaReferenciaElementoAnteriorSeNecessario(state.articulacao, state.revisoes, e, 'exclusao');
            }
            const eAux = JSON.parse(JSON.stringify(e));
            result.push(new RevisaoElemento(actionType, StateType.ElementoRemovido, '', state.usuario, formatDateTime(new Date()), eAux, { ...eAux, acoesPossiveis: [] }));
        }
    });
    state.revisoes = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => !revisoesParaRemover.includes(r));
    return result;
};
const processaEventosDeRestauracao = (state, actionType) => {
    var _a;
    const eventos = getEventos(state, StateType.ElementoRestaurado);
    const result = [];
    const revisoesParaRemover = [];
    eventos.forEach(se => {
        var _a;
        const elementoAtual = se.elementos[1];
        const elementoAnterior = se.elementos[0];
        const eAux = elementoAtual || elementoAnterior;
        const revisao = findRevisaoByElementoUuid(state.revisoes, elementoAnterior.uuid);
        if (revisao && ((_a = revisao.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.descricaoSituacao) === eAux.descricaoSituacao && revisaoDeElementoComMesmoUuid2RotuloEConteudo(revisao, eAux)) {
            revisoesParaRemover.push(revisao);
        }
        else {
            const d = getDispositivoFromElemento(state.articulacao, elementoAnterior);
            const eAntesRevisao = !elementoAtual ? d.situacao.dispositivoOriginal : elementoAnterior;
            const eAposRevisao = createElemento(d);
            result.push(new RevisaoElemento(actionType, StateType.ElementoRestaurado, '', state.usuario, formatDateTime(new Date()), JSON.parse(JSON.stringify(eAntesRevisao)), JSON.parse(JSON.stringify(eAposRevisao))));
            if (revisao) {
                revisoesParaRemover.push(revisao);
            }
        }
    });
    state.revisoes = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => !revisoesParaRemover.includes(r));
    return result;
};
const getEventos = (state, stateType) => {
    var _a;
    return ((_a = state.ui) === null || _a === void 0 ? void 0 : _a.events.filter(se => se.stateType === stateType)) || [];
};
const getElementosFromEventos = (eventos) => {
    return removeDuplicidades(eventos.map(se => se.elementos || []).flat());
};
const removeDuplicidades = (elementos) => {
    const map = new Map();
    const result = [];
    elementos.reverse().forEach(e => {
        if (!map.has(e.uuid)) {
            map.set(e.uuid, e);
            result.unshift(e);
        }
    });
    return result;
};
const revisaoDeElementoComMesmoLexmlIdRotuloEConteudo = (r, e) => {
    var _a, _b, _c, _d, _e;
    return ((_a = r.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.lexmlId) === e.lexmlId && ((_b = r.elementoAntesRevisao) === null || _b === void 0 ? void 0 : _b.rotulo) === e.rotulo && ((_d = (_c = r.elementoAntesRevisao) === null || _c === void 0 ? void 0 : _c.conteudo) === null || _d === void 0 ? void 0 : _d.texto) === ((_e = e.conteudo) === null || _e === void 0 ? void 0 : _e.texto);
};
const revisaoDeElementoComMesmoUuid2RotuloEConteudo = (r, e) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return (((_a = r.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.uuid2) === e.uuid2 &&
        ((_b = r.elementoAntesRevisao) === null || _b === void 0 ? void 0 : _b.rotulo) === e.rotulo &&
        ((_d = (_c = r.elementoAntesRevisao) === null || _c === void 0 ? void 0 : _c.conteudo) === null || _d === void 0 ? void 0 : _d.texto) === ((_e = e.conteudo) === null || _e === void 0 ? void 0 : _e.texto) &&
        ((_h = (_g = (_f = r.elementoAntesRevisao) === null || _f === void 0 ? void 0 : _f.hierarquia) === null || _g === void 0 ? void 0 : _g.pai) === null || _h === void 0 ? void 0 : _h.lexmlId) === ((_k = (_j = e.hierarquia) === null || _j === void 0 ? void 0 : _j.pai) === null || _k === void 0 ? void 0 : _k.lexmlId) // Checa se elementos estão na mesma hierarquia
    );
};
const isAcaoMoverOuTransformar = (state) => {
    const incluidos = getEventos(state, StateType.ElementoIncluido);
    const removidos = getEventos(state, StateType.ElementoRemovido);
    return !!incluidos.length && incluidos.length === removidos.length;
};
const getElementoAntesModificacao = (state, elemento) => {
    const eventos = [...state.past].pop();
    const modificacoes = eventos.filter(se => { var _a; return se.stateType === StateType.ElementoModificado && ((_a = se.elementos) === null || _a === void 0 ? void 0 : _a.some(e => e.uuid === elemento.uuid)); });
    const modificacao = modificacoes.pop();
    return modificacao ? JSON.parse(JSON.stringify(modificacao.elementos[0])) : undefined;
};
const adicionarOpcoesAoMenu = (state) => {
    var _a;
    (_a = state.ui) === null || _a === void 0 ? void 0 : _a.events.forEach(se => {
        var _a;
        return (_a = se.elementos) === null || _a === void 0 ? void 0 : _a.filter(Boolean).forEach(e => {
            if (e.revisao && !e.revisao.idRevisaoElementoPrincipal) {
                e.acoesPossiveis = se.stateType === StateType.ElementoRemovido ? [] : [...(e.acoesPossiveis || [])];
                !e.acoesPossiveis.includes(aceitarRevisaoAction) && e.acoesPossiveis.push(aceitarRevisaoAction);
                !e.acoesPossiveis.includes(rejeitarRevisaoAction) && e.acoesPossiveis.push(rejeitarRevisaoAction);
            }
        });
    });
};
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const existeEventoDeInclusaoOuExclusao = (state) => {
    var _a;
    const eventos = ((_a = state.ui) === null || _a === void 0 ? void 0 : _a.events) || [];
    return eventos.some(se => se.stateType === StateType.ElementoIncluido || se.stateType === StateType.ElementoRemovido);
};
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const atualizarLexmlIdEmElementosDeRevisoes = (state) => {
    let revisoes = getRevisoesElemento(state.revisoes || [])
        .filter(r => r.elementoAposRevisao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO)
        .filter(r => !isRevisaoDeExclusao(r));
    revisoes.forEach(r => {
        const d = getDispositivoFromElemento(state.articulacao, r.elementoAposRevisao);
        if (d) {
            const e = createElemento(d, false, true);
            r.elementoAposRevisao.lexmlId = d.id;
            r.elementoAposRevisao.hierarquia.pai.lexmlId = d.pai.id;
            r.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura = JSON.parse(JSON.stringify(e.elementoAnteriorNaSequenciaDeLeitura));
            if (r.elementoAntesRevisao) {
                r.elementoAntesRevisao.lexmlId = d.id;
                r.elementoAntesRevisao.hierarquia.pai.lexmlId = d.pai.id;
                r.elementoAntesRevisao.elementoAnteriorNaSequenciaDeLeitura = JSON.parse(JSON.stringify(e.elementoAnteriorNaSequenciaDeLeitura));
            }
        }
    });
    revisoes = getRevisoesElemento(state.revisoes || []).filter(r => isRevisaoPrincipal(r) && isRevisaoDeExclusao(r));
    revisoes.forEach(r => {
        const d = getDispositivoFromElemento(state.articulacao, r.elementoAposRevisao.hierarquia.pai);
        r.elementoAposRevisao.hierarquia.pai.lexmlId = d.id;
    });
};
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const atualizarPosicaoDeElementosEmRevisoes = (state) => {
    const revisoes = getRevisoesElemento(state.revisoes || []).filter(r => isRevisaoPrincipal(r) && isRevisaoDeExclusao(r));
    atualizarPosicaoDeElementosEmRevisoesByEvento(revisoes, getEvento(state.ui.events, StateType.ElementoIncluido));
    atualizarPosicaoDeElementosEmRevisoesByEvento(revisoes, getEvento(state.ui.events, StateType.ElementoRemovido));
};
const atualizarPosicaoDeElementosEmRevisoesByEvento = (revisoes = [], evento) => {
    if (!evento) {
        return;
    }
    const fator = evento.stateType === StateType.ElementoIncluido ? 1 : -1;
    const fnCondicaoInclusao = (e, posicaoAtual) => e.hierarquia.posicao <= posicaoAtual;
    const fnCondicaoExclusao = (e, posicaoAtual) => e.hierarquia.posicao < posicaoAtual;
    const fnCondicao2 = evento.stateType === StateType.ElementoIncluido ? fnCondicaoInclusao : fnCondicaoExclusao;
    revisoes.forEach(r => {
        const lexmlIdPai = r.elementoAposRevisao.hierarquia.pai.lexmlId;
        const posicaoAtual = r.elementoAposRevisao.hierarquia.posicao;
        const deslocamento = evento.elementos.filter(e => { var _a, _b; return ((_b = (_a = e.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.lexmlId) === lexmlIdPai && fnCondicao2(e, posicaoAtual); }).length * fator;
        r.elementoAposRevisao.hierarquia.posicao += deslocamento;
    });
};

const atualizaUsuario = (state, action) => {
    var _a, _b;
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: state.present,
        future: state.future,
        ui: {
            events: [{ stateType: StateType.AtualizaUsuario }],
            message: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.mensagem,
            alertas: (_b = state.ui) === null || _b === void 0 ? void 0 : _b.alertas,
        },
        usuario: action.usuario,
    };
};

const aceitaRevisao = (state, action) => {
    if (action.revisao || action.elemento) {
        return aceitarRevisao(state, action);
    }
    else {
        return aceitarRevisaoEmLote(state, state.revisoes);
    }
};
const aceitarRevisaoEmLote = (state, revisoes = []) => {
    var _a;
    const tempStates = [];
    revisoes.filter(isRevisaoPrincipal).forEach((revisao) => {
        const tempState = { ...state, past: [], present: [], future: [], ui: { ...state.ui, events: [] } };
        tempStates.push(aceitarRevisao(tempState, { revisao }));
    });
    const tempState = mergeEventosStatesAposAceitarOuRejeitarMultiplasRevisoes(state, tempStates, revisoes, 'aceitar');
    tempState.revisoes = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => !isRevisaoPrincipal(r));
    return tempState;
};
const aceitarRevisao = (state, action) => {
    var _a, _b;
    const revisao = (action.revisao || findRevisaoByElementoUuid(state.revisoes, action.elemento.uuid));
    const revisoesAssociadas = getRevisoesElementoAssociadas(state.revisoes, revisao);
    const idsRevisoesAssociadas = revisoesAssociadas.map(r => r.id);
    const elementos = revisoesAssociadas.map(r => {
        const e = isRevisaoDeExclusao(r) ? r.elementoAposRevisao : createElementoValidado(getDispositivoFromElemento(state.articulacao, r.elementoAposRevisao));
        e.revisao = JSON.parse(JSON.stringify(r));
        return e;
    });
    const elementosValidados = elementos
        .map(e => getDispositivoFromElemento(state.articulacao, e))
        .filter(Boolean)
        .map(d => createElementoValidado(d));
    const events = [{ stateType: StateType.RevisaoAceita, elementos }];
    if (elementosValidados.length) {
        events.push({ stateType: StateType.ElementoValidado, elementos: elementosValidados });
    }
    const revisoes = state.revisoes.filter((r) => !idsRevisoesAssociadas.includes(r.id));
    if (isRevisaoDeExclusao(revisao)) {
        // Se está aceitando uma revisão de exclusão, é preciso atualizar os elementos de outras revisões de exclusão que referenciam o elemento REALMENTE excluído durante a aceitação
        atualizaReferenciaElementoAnteriorEmRevisoesExclusaoAposAceitacao(revisoes, revisoesAssociadas);
    }
    return {
        ...state,
        past: buildPast(state, events),
        present: events,
        future: [],
        ui: {
            events,
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
        revisoes: (_b = state.revisoes) === null || _b === void 0 ? void 0 : _b.filter((r) => !idsRevisoesAssociadas.includes(r.id)),
    };
};
const atualizaReferenciaElementoAnteriorEmRevisoesExclusaoAposAceitacao = (revisoes, revisoesAssociadas) => {
    const revisaoPrincipal = revisoesAssociadas[0];
    const ultimaRevisao = revisoesAssociadas[revisoesAssociadas.length - 1];
    const revisao = revisoes.find(r => { var _a, _b; return ((_b = (_a = r.elementoAposRevisao) === null || _a === void 0 ? void 0 : _a.elementoAnteriorNaSequenciaDeLeitura) === null || _b === void 0 ? void 0 : _b.uuid) === ultimaRevisao.elementoAposRevisao.uuid; });
    if (revisao) {
        revisao.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura = revisaoPrincipal.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura;
        revisao.elementoAntesRevisao.elementoAnteriorNaSequenciaDeLeitura = revisaoPrincipal.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura;
    }
};

const rejeitaRevisao = (state, action) => {
    if (action.revisao || action.elemento) {
        return rejeitarRevisao(state, action);
    }
    else {
        return rejeitarRevisaoEmLote(state, state.revisoes);
    }
};
const rejeitarRevisaoEmLote = (state, revisoes = []) => {
    var _a;
    const tempStates = [];
    revisoes.filter(isRevisaoPrincipal).forEach((revisao) => {
        const tempState = { ...state, past: [], present: [], future: [], ui: { ...state.ui, events: [] } };
        tempStates.push(rejeitarRevisao(tempState, { revisao }));
    });
    const tempState = mergeEventosStatesAposAceitarOuRejeitarMultiplasRevisoes(state, tempStates, revisoes, 'rejeitar');
    tempState.revisoes = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => !isRevisaoPrincipal(r));
    return tempState;
};
const rejeitarRevisao = (state, action) => {
    var _a, _b;
    const revisao = (action.revisao || findRevisaoByElementoUuid(state.revisoes, action.elemento.uuid));
    const revisoesAssociadas = getRevisoesElementoAssociadas(state.revisoes, revisao);
    const idsRevisoesAssociadas = revisoesAssociadas.map(r => r.id);
    const elementos = revisoesAssociadas.map(r => {
        r.elementoAposRevisao.revisao = JSON.parse(JSON.stringify(r));
        return r.elementoAposRevisao;
    });
    const eventos = [{ stateType: StateType.RevisaoRejeitada, elementos }];
    if (isRevisaoDeMovimentacao(revisao)) {
        // Elementos com revisão de movimentação também podem ter revisão de exclusão (desde que não seja o elemento principal)
        // Nesse caso, a revisão de exclusão deve ser removida do state (não precisa ser rejeitada)
        const uuid2Elementos = elementos.map(e => e.uuid2);
        const outrasRevisoes = state.revisoes
            .filter((r) => !idsRevisoesAssociadas.includes(r.id))
            .filter((r) => uuid2Elementos.includes(r.elementoAposRevisao.uuid2));
        idsRevisoesAssociadas.push(...outrasRevisoes.map(r => r.id));
        // Desfaz as ações feitas após a movimentação do dispositivo e que geraram revisões adicionais
        processaRevisoes(state, outrasRevisoes.filter(isRevisaoPrincipal));
        const elementosDeOutrasRevisoes = outrasRevisoes.map(r => {
            r.elementoAposRevisao.revisao = JSON.parse(JSON.stringify(r));
            return r.elementoAposRevisao;
        });
        eventos.push({ stateType: StateType.RevisaoAdicionalRejeitada, elementos: elementosDeOutrasRevisoes });
    }
    const tempState = { ...state, past: [] };
    eventos.push(...processaRevisoes(tempState, revisoesAssociadas.filter(isRevisaoPrincipal)));
    const eventosPast = isRevisaoDeModificacao(revisao) ? montarEventosDeModificacaoParaHistorico(eventos, revisao, state) : eventos;
    return {
        ...state,
        past: buildPast(state, eventosPast),
        present: eventos,
        future: [],
        ui: {
            events: eventos,
            alertas: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.alertas,
        },
        revisoes: (_b = state.revisoes) === null || _b === void 0 ? void 0 : _b.filter((r) => !idsRevisoesAssociadas.includes(r.id)),
    };
};
const montarEventosDeModificacaoParaHistorico = (eventos, revisao, state) => {
    // O PASSADO de evento de modificação (StateType.ElementoModificado) deve possuir 2 itens no array elemento:
    // Item 0: valor a ser retornado para a articulação em caso de UNDO
    // Item 1: valor a ser retornado para a articulação em caso de REDO
    const eventosPast = eventos.filter(ev => ev.stateType !== StateType.ElementoModificado);
    const dispositivo = getDispositivoFromElemento(state.articulacao, revisao.elementoAposRevisao);
    eventosPast.push({ stateType: StateType.ElementoModificado, elementos: [revisao.elementoAposRevisao, revisao.elementoAntesRevisao] });
    eventosPast.push({ stateType: StateType.ElementoValidado, elementos: criaListaElementosAfinsValidados(dispositivo, true) });
    return eventosPast;
};
const processaRevisoes = (state, revisoes) => {
    const eventos = [];
    revisoes.forEach(r => {
        r.stateType === StateType.ElementoSuprimido && eventos.push(...rejeitaSupressao(state, r));
        r.stateType === StateType.ElementoModificado && eventos.push(...rejeitaModificacao(state, r));
        r.stateType === StateType.ElementoRestaurado && eventos.push(...rejeitaRestauracao(state, r));
        r.stateType === StateType.ElementoIncluido && eventos.push(...rejeitaInclusao(state, r));
        r.stateType === StateType.ElementoRemovido && eventos.push(...rejeitaExclusao(state, r));
    });
    return unificarEvento(state, eventos, StateType.ElementoRenumerado);
};
const rejeitaSupressao = (state, revisao) => {
    var _a;
    return ((_a = restauraElemento(state, { atual: revisao.elementoAntesRevisao }).ui) === null || _a === void 0 ? void 0 : _a.events) || [];
};
const rejeitaModificacao = (state, revisao) => {
    var _a;
    return ((_a = atualizaTextoElemento(state, { atual: revisao.elementoAntesRevisao }).ui) === null || _a === void 0 ? void 0 : _a.events) || [];
};
const rejeitaRestauracao = (state, revisao) => {
    var _a, _b, _c, _d;
    if (((_a = revisao.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
        return ((_b = suprimeElemento(state, { atual: revisao.elementoAntesRevisao }).ui) === null || _b === void 0 ? void 0 : _b.events) || [];
    }
    else if (((_c = revisao.elementoAntesRevisao) === null || _c === void 0 ? void 0 : _c.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_MODIFICADO) {
        return ((_d = atualizaTextoElemento(state, { atual: revisao.elementoAntesRevisao }).ui) === null || _d === void 0 ? void 0 : _d.events) || [];
    }
    return [];
};
const rejeitaInclusao = (state, revisao) => {
    var _a;
    const dispositivoASerRemovido = getDispositivoFromElemento(state.articulacao, revisao.elementoAposRevisao);
    const dispositivoAnterior = getDispositivoAnteriorNaSequenciaDeLeitura(dispositivoASerRemovido, d => !isCaput(d));
    const result = ((_a = removeElemento(state, { atual: revisao.elementoAposRevisao, isRejeitandoRevisao: true }).ui) === null || _a === void 0 ? void 0 : _a.events) || [];
    // Se existe elemento antes da revisão, então reinclui elemento (havia sido excluído por se tratar de uma movimentação)
    if (revisao.elementoAntesRevisao) {
        result.push(...rejeitaExclusao(state, revisao));
    }
    const ultimaRevisaoDoGrupo = findUltimaRevisaoDoGrupo(state.revisoes, revisao);
    const rAux2 = findRevisaoDeExclusaoComElementoAnteriorApontandoPara(state.revisoes, ultimaRevisaoDoGrupo.elementoAposRevisao);
    if (rAux2) {
        const e = dispositivoAnterior ? createElemento(dispositivoAnterior) : undefined;
        rAux2.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura = e ? JSON.parse(JSON.stringify(e)) : undefined;
        rAux2.elementoAntesRevisao.elementoAnteriorNaSequenciaDeLeitura = e ? JSON.parse(JSON.stringify(e)) : undefined;
    }
    return result;
};
const rejeitaExclusao = (state, revisao) => {
    const revisoesAssociadas = getRevisoesElementoAssociadas(state.revisoes, revisao);
    const evento = { stateType: StateType.ElementoRemovido, elementos: revisoesAssociadas.map(r => r.elementoAntesRevisao) };
    const eventoAux = { stateType: StateType.ElementoIncluido, elementos: [] };
    const result = [];
    const elementoASerIncluido = revisao.elementoAposRevisao;
    if (elementoASerIncluido.agrupador) {
        let tempState = { ...state, past: [], present: [], future: [], ui: { events: [] } };
        tempState = agrupaElemento(tempState, {
            atual: elementoASerIncluido.elementoAnteriorNaSequenciaDeLeitura,
            novo: {
                tipo: elementoASerIncluido.tipo,
                uuid: elementoASerIncluido.uuid,
                posicao: 'depois',
                manterNoMesmoGrupoDeAspas: elementoASerIncluido.manterNoMesmoGrupoDeAspas,
            },
        });
        result.push(...tempState.ui.events);
    }
    else {
        result.push({ stateType: StateType.ElementoIncluido, elementos: incluir(state, evento, eventoAux) });
    }
    atualizaReferenciaElementoAnteriorEmRevisoesDeExclusaoAposRejeicao(state, revisao, result[0].elementos[0]);
    const dispositivosRenumerados = listaDispositivosRenumerados(getDispositivoFromElemento(state.articulacao, result[0].elementos[0])).filter(isAdicionado);
    result.push({ stateType: StateType.ElementoRenumerado, elementos: dispositivosRenumerados.map(d => createElemento(d)) });
    result.push({ stateType: StateType.SituacaoElementoModificada, elementos: getElementosAlteracaoASeremAtualizados(state.articulacao, getElementosRemovidosEIncluidos(result)) });
    result.push({ stateType: StateType.ElementoValidado, elementos: montarListaElementosValidados(state, result) });
    return result.filter(ev => { var _a; return (_a = ev.elementos) === null || _a === void 0 ? void 0 : _a.length; });
};
const atualizaReferenciaElementoAnteriorEmRevisoesDeExclusaoAposRejeicao = (state, revisao, primeiroElementoReincluido) => {
    var _a;
    // Atualizar referência
    const dUltimoFilho = getUltimoFilho(getDispositivoFromElemento(state.articulacao, primeiroElementoReincluido));
    const eUltimoFilho = createElemento(dUltimoFilho, false, true);
    const revisaoASerAtualizada = findRevisaoDeExclusaoComElementoAnteriorApontandoPara((_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => r.id !== revisao.id), eUltimoFilho);
    if (revisaoASerAtualizada && revisaoASerAtualizada.id !== revisao.id) {
        // Atualiza referência
        revisaoASerAtualizada.elementoAposRevisao.elementoAnteriorNaSequenciaDeLeitura = JSON.parse(JSON.stringify(eUltimoFilho));
        revisaoASerAtualizada.elementoAntesRevisao.elementoAnteriorNaSequenciaDeLeitura = JSON.parse(JSON.stringify(eUltimoFilho));
        // // Atualiza posição
        // if (isAtualizarPosicaoDeElementoExcluido(primeiroElementoReincluido, revisaoASerAtualizada.elementoAposRevisao)) {
        //   revisaoASerAtualizada.elementoAposRevisao.hierarquia!.posicao = primeiroElementoReincluido.hierarquia!.posicao! + 1;
        //   revisaoASerAtualizada.elementoAntesRevisao!.hierarquia!.posicao = primeiroElementoReincluido.hierarquia!.posicao! + 1;
        // }
    }
};
const montarListaElementosValidados = (state, result) => {
    return result
        .filter(ev => ev.stateType === StateType.ElementoIncluido)
        .map(ev => ev.elementos || [])
        .flat()
        .map(e => getDispositivoFromElemento(state.articulacao, e))
        .map(d => createElementoValidado(d));
};

const adicionaDiffMenuOpcoes = (state) => {
    var _a;
    (_a = state.ui) === null || _a === void 0 ? void 0 : _a.events.forEach(se => {
        var _a;
        return (_a = se.elementos) === null || _a === void 0 ? void 0 : _a.filter(Boolean).forEach(e => {
            var _a, _b, _c;
            if (e.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO ||
                (e.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO && e.revisao && e.revisao.descricao === 'Texto do dispositivo foi alterado') ||
                (e.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ORIGINAL && e.revisao && ((_b = (_a = e.revisao.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.conteudo) === null || _b === void 0 ? void 0 : _b.texto) !== ((_c = e.conteudo) === null || _c === void 0 ? void 0 : _c.texto))) {
                !e.acoesPossiveis.includes(exibirDiferencaAction) && e.acoesPossiveis.push(exibirDiferencaAction);
            }
        });
    });
    return state;
};

const LIMPAR_REVISAO = 'LIMPAR_REVISAO';
class LimparRevisao {
    execute() {
        const revisoes = [];
        return {
            type: LIMPAR_REVISAO,
            revisoes,
        };
    }
}
const limparRevisaoAction = new LimparRevisao();

const limpaRevisao = (state) => {
    var _a;
    return {
        articulacao: state.articulacao,
        modo: state.modo,
        past: state.past,
        present: state.present,
        future: state.future,
        ui: {
            events: [{ stateType: StateType.AtualizacaoAlertas }],
            message: (_a = state.ui) === null || _a === void 0 ? void 0 : _a.mensagem,
            alertas: state.alertas,
        },
        revisoes: [],
        emRevisao: false,
        usuario: state.usuario,
    };
};

const elementoReducer = (state = {}, action) => {
    var _a, _b;
    let tempState;
    let usuario = state.usuario;
    let actionType = action.type;
    let emRevisao = state.emRevisao;
    let revisoes = state.revisoes || [];
    let numEventosPassadosAntesDaRevisao = state.numEventosPassadosAntesDaRevisao || 0;
    switch (action.type) {
        case ADICIONAR_AGRUPADOR_ARTIGO:
            tempState = agrupaElemento(state, action);
            break;
        case INFORMAR_EXISTENCIA_NA_NORMA:
            tempState = informaExistenciaDoElementoNaNorma(state, action);
            break;
        case ATUALIZAR_NOTA_ALTERACAO:
            tempState = atualizaNotaAlteracao(state, action);
            break;
        case APLICAR_ALTERACOES_EMENDA:
            tempState = aplicaAlteracoesEmenda(state, action);
            emRevisao = tempState.emRevisao;
            break;
        case ASSISTENTE_ALTERACAO:
            tempState = adicionaAlteracaoComAssistente(state, action);
            break;
        case ATUALIZAR_ELEMENTO:
            tempState = atualizaElemento(state, action);
            break;
        case ATUALIZAR_REFERENCIA_ELEMENTO:
            tempState = atualizaReferenciaElemento(state, action);
            break;
        case ATUALIZAR_TEXTO_ELEMENTO:
            tempState = atualizaTextoElemento(state, action);
            break;
        case AUTO_FIX:
            tempState = autoFixElemento(state, action);
            break;
        case ADICIONAR_ELEMENTO:
            tempState = adicionaElemento$1(state, action);
            break;
        case ADICIONAR_ELEMENTOS_FROM_CLIPBOARD:
            tempState = adicionaElementosNaProposicaoFromClipboard(state, action);
            break;
        case AGRUPAR_ELEMENTO:
            tempState = agrupaElemento(state, action);
            break;
        case TRANSFORMAR_TIPO_ELEMENTO:
            tempState = transformaTipoElemento(state, action);
            break;
        case ELEMENTO_SELECIONADO:
            tempState = selecionaElemento(state, action);
            break;
        case INFORMAR_DADOS_ASSISTENTE:
            tempState = solicitaDadosAssistente(state, action);
            break;
        case INFORMAR_NORMA:
            tempState = solicitaNorma(state, action);
            break;
        case MOVER_ELEMENTO_ABAIXO:
            tempState = moveElementoAbaixo(state, action);
            break;
        case MOVER_ELEMENTO_ACIMA:
            tempState = moveElementoAcima(state, action);
            break;
        case RENUMERAR_ELEMENTO:
            tempState = renumeraElemento(state, action);
            break;
        case RESTAURAR_ELEMENTO:
            tempState = restauraElemento(state, action);
            break;
        case SUPRIMIR_AGRUPADOR:
            tempState = suprimeAgrupador(state, action);
            break;
        case SUPRIMIR_ELEMENTO:
            tempState = suprimeElemento(state, action);
            break;
        case ABRIR_ARTICULACAO:
            tempState = abreArticulacao(state, action);
            break;
        case REDO:
            tempState = redo(state);
            break;
        case REMOVER_ELEMENTO:
            tempState = removeElemento(state, action);
            break;
        case REMOVER_ELEMENTO_SEM_TEXTO:
            tempState = removeElementoSemTexto(state, action);
            break;
        case SHIFT_TAB:
        case TAB:
            tempState = modificaTipoElementoWithTab(state, action);
            break;
        case UNDO:
            tempState = undo(state);
            break;
        case VALIDAR_ELEMENTO:
            tempState = validaElemento(state, action);
            break;
        case VALIDAR_ARTICULACAO:
            tempState = validaArticulacao(state);
            break;
        case ADICIONAR_ALERTA:
            tempState = adicionarAlerta(state, action);
            break;
        case REMOVER_ALERTA:
            tempState = removeAlerta(state, action);
            break;
        case LIMPAR_ALERTAS:
            tempState = limparAlertas(state);
            break;
        case ATIVAR_DESATIVAR_REVISAO:
            tempState = ativaDesativaRevisao(state);
            emRevisao = tempState.emRevisao;
            numEventosPassadosAntesDaRevisao = ((_a = tempState.past) === null || _a === void 0 ? void 0 : _a.length) || 0;
            break;
        case ATUALIZAR_USUARIO:
            tempState = atualizaUsuario(state, action);
            usuario = tempState.usuario;
            break;
        case ACEITAR_REVISAO:
            tempState = aceitaRevisao(state, action);
            break;
        case REJEITAR_REVISAO:
            tempState = rejeitaRevisao(state, action);
            break;
        case LIMPAR_REVISAO:
            tempState = limpaRevisao(state);
            break;
        default:
            actionType = undefined;
            tempState = state;
            break;
    }
    if ([LIMPAR_REVISAO].includes(actionType)) {
        //tempState.revisoes = [];
        revisoes = [];
    }
    if (![ABRIR_ARTICULACAO, APLICAR_ALTERACOES_EMENDA, ACEITAR_REVISAO, REJEITAR_REVISAO].includes(actionType) &&
        !isRedoDeRevisaoAceita(actionType, tempState) &&
        !isRedoDeRevisaoRejeitada(actionType, tempState)) {
        tempState.revisoes = revisoes;
        tempState.numEventosPassadosAntesDaRevisao = emRevisao ? numEventosPassadosAntesDaRevisao : ((_b = tempState.past) === null || _b === void 0 ? void 0 : _b.length) || 0;
    }
    tempState.emRevisao = emRevisao;
    tempState.usuario = usuario;
    tempState = atualizaRevisao(tempState, actionType);
    return adicionaDiffMenuOpcoes(tempState);
};
const isRedoDeRevisaoAceita = (actionType, state) => {
    var _a;
    return actionType === REDO && !!((_a = state.ui) === null || _a === void 0 ? void 0 : _a.events.some(event => event.stateType === StateType.RevisaoAceita));
};
const isRedoDeRevisaoRejeitada = (actionType, state) => {
    var _a;
    return actionType === REDO && !!((_a = state.ui) === null || _a === void 0 ? void 0 : _a.events.some(event => event.stateType === StateType.RevisaoRejeitada));
};

const combinedReducer = combineReducers({
    appReducer: appReducer,
    elementoReducer: elementoReducer,
});
const rootStore = createStore(combinedReducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

let ArticulacaoComponent = class ArticulacaoComponent extends connect(rootStore)(s) {
    constructor() {
        super();
        this.elementos = [];
        this.lexmlEtaConfig = new LexmlEmendaConfig();
        this.tabIndex = -1;
    }
    createRenderRoot() {
        return this;
    }
    render() {
        return $ `
      <style>
        lexml-eta-editor {
          display: block;
          height: 100%;
        }

        lexml-eta-editor:focus {
          outline: 0;
          border: 0px solid #f1f1f1;
          -webkit-box-shadow: 0px;
          box-shadow: none;
        }
      </style>
      <lexml-eta-editor .lexmlEtaConfig=${this.lexmlEtaConfig}></lexml-eta-editor>
    `;
    }
};
__decorate([
    e$3({ type: Array })
], ArticulacaoComponent.prototype, "elementos", void 0);
__decorate([
    e$3({ type: Object })
], ArticulacaoComponent.prototype, "lexmlEtaConfig", void 0);
ArticulacaoComponent = __decorate([
    n$1('lexml-eta-articulacao')
], ArticulacaoComponent);

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e$1=t=>(...e)=>({_$litDirective$:t,values:e});class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */class e extends i{constructor(i){if(super(i),this.it=w,i.type!==t.CHILD)throw Error(this.constructor.directiveName+"() can only be used in child bindings")}render(r){if(r===w||null==r)return this.ft=void 0,this.it=r;if(r===b)return r;if("string"!=typeof r)throw Error(this.constructor.directiveName+"() called with a non-string value");if(r===this.it)return this.ft;this.it=r;const s=[r];return s.raw=s,this.ft={_$litType$:this.constructor.resultType,strings:s,values:[]}}}e.directiveName="unsafeHTML",e.resultType=1;const o=e$1(e);

let ComandoEmendaComponent = class ComandoEmendaComponent extends connect(rootStore)(s) {
    constructor() {
        super(...arguments);
        this.alertas = [];
    }
    update(changedProperties) {
        super.update(changedProperties);
    }
    stateChanged(state) {
        var _a;
        this.alertas = ((_a = state.elementoReducer.ui) === null || _a === void 0 ? void 0 : _a.alertas) || [];
    }
    buildTemplateComando(comandos) {
        const res = comandos === null || comandos === void 0 ? void 0 : comandos.reduce((acumulador, comando) => acumulador + `<p> ${comando.cabecalho} </p>`, '');
        return $ `${res}`;
    }
    buildTemplateCitacao(citacao) {
        // eslint-disable-next-line prettier/prettier
        const corpo = citacao
            .replaceAll('<Rotulo>', '<b>')
            .replaceAll('</Rotulo>', '</b> ')
            .replaceAll('<Alteracao>', '<div class="alteracao">')
            .replaceAll('</Alteracao>', '</div> ')
            .replaceAll('<Omissis/>', '<span class="texto__omissis">...............................................</span>');
        return corpo;
    }
    render() {
        var _a, _b;
        const cabecalhoComum = (_a = this.emenda) === null || _a === void 0 ? void 0 : _a.cabecalhoComum;
        const comandos = (_b = this.emenda) === null || _b === void 0 ? void 0 : _b.comandos;
        return $ `
      <style>
        :host {
          --lexml-emenda-comando-height: 100%;
          --lexml-emenda-comando-overflow: hidden;
          --lexml-emenda-comando-border: 1px solid #ccc;
        }
        .lexml-emenda-comando {
          display: block;
          height: var(--lexml-emenda-comando-height);
          overflow: var(--lexml-emenda-comando-overflow);
          overflow-y: auto;
          padding: 0px 10px;
          font-size: 18px;
          font-family: 'Times New Roman', Times, serif;
          text-align: justify;
        }
        .lexml-emenda-comando:focus {
          outline: 0;
          border: 0px solid #f1f1f1;
          -webkit-box-shadow: 0px;
          box-shadow: none;
        }

        .lexml-emenda-cabecalhoComando {
          display: block;
          margin-top: 1em;
          text-indent: 3em;
        }

        .lexml-emenda-citacaoComando {
          display: block;
          margin-top: 1em;
        }

        .lexml-emenda-complementoComando {
          margin-top: 1em;
        }

        .lexml-emenda-citacaoComando p {
          /* text-align: justify; */
          text-indent: 3em;
          margin: 0;
        }

        .lexml-emenda-citacaoComando p.ementa {
          text-indent: 0;
          margin-left: 30%;
        }

        .lexml-emenda-citacaoComando p.agrupador {
          text-indent: 0;
          text-align: center;
        }

        .lexml-emenda-citacaoComando p.secao,
        .lexml-emenda-citacaoComando p.subsecao {
          font-weight: bold;
        }

        .lexml-emenda-citacaoComando div.alteracao {
          margin-left: 4em;
        }

        .lexml-emenda-citacaoComando div.alteracao p {
          text-indent: 2em;
        }
        .mensagem {
          font-size: 0.8em;
          font-weight: normal;
          text-align: left;
          border: 1px solid;
          padding: 4px 10px;
          margin: 10px 0;
          display: inline-block;
          border-radius: 2px;
          font-family: var(--sl-font-sans);
        }
        .mensagem--warning {
          color: #856404;
          background-color: #fff3cd;
          border-color: #ffeeba;
        }
        .mensagem--danger {
          color: #721c24;
          background-color: #f8d7da;
          border-color: #f5c6cb;
        }
      </style>

      <div class="lexml-emenda-comando">
        ${(this.alertas || [])
            .filter(alerta => alerta.exibirComandoEmenda)
            .map(alerta => $ `<div class="lexml-emenda-complementoComando mensagem mensagem--danger">${alerta.mensagem}</div>`)}
        ${cabecalhoComum ? o(`<p class="lexml-emenda-cabecalhoComando">${cabecalhoComum}</p>`) : ''}
        ${comandos === null || comandos === void 0 ? void 0 : comandos.map(comando => {
            return o('<div class="lexml-emenda-cabecalhoComando">' +
                (comando.rotulo ? `<strong>${comando.rotulo}</strong> ` : '') +
                comando.cabecalho +
                '</div>' +
                '<div class="lexml-emenda-citacaoComando">' +
                this.buildTemplateCitacao(comando.citacao) +
                '</div>' +
                (comando.complemento ? '<div class="lexml-emenda-complementoComando mensagem mensagem--warning">' + comando.complemento + '</div>' : ''));
        })}
      </div>
    `;
    }
};
__decorate([
    e$3({ type: Object })
], ComandoEmendaComponent.prototype, "emenda", void 0);
__decorate([
    e$3({ type: Array })
], ComandoEmendaComponent.prototype, "alertas", void 0);
ComandoEmendaComponent = __decorate([
    n$1('lexml-emenda-comando')
], ComandoEmendaComponent);

class Subscription {
    constructor(callback, canceled) {
        this.callback = callback;
        this.canceled = canceled;
    }
    isCanceled() {
        var _a;
        return (_a = this.canceled) !== null && _a !== void 0 ? _a : false;
    }
    cancel() {
        this.canceled = true;
    }
}
class Observable {
    constructor() {
        this.subscriptions = [];
    }
    subscribe(callback) {
        const inscricao = new Subscription(callback);
        this.subscriptions.push(inscricao);
        return inscricao;
    }
    notify(data) {
        this.subscriptions.forEach((subscription) => {
            if (!subscription.isCanceled()) {
                setTimeout(() => {
                    subscription.callback(data);
                }, 1);
            }
        });
    }
    clean() {
        this.subscriptions = [];
    }
}

const ID_DIALOGO_TIPO_COLAGEM = 'slDialogoTipoColagem';
const ID_DIALOGO_MODIFICAR_EXISTENTE_ADICIONAR_NOVO = 'slDialogoModificarExistenteAdicionarNovo';
const ID_DIALOGO_MODIFICAR_DISPOSITIVOS_EXISTENTES = 'slDialogoModificarDispositivosExistentes';
const ID_DIALOGO_ADICIONAR_APOS_ATUAL = 'slDialogoAdicionarAposAtual';
const ID_DIALOGO_AVISO = 'slDialogoAviso';
const RODAPE_CONFIRMAR = 'RODAPE_CONFIRMAR';
const RODAPE_FECHAR = 'RODAPE_FECHAR';
const ANTES_DE_PROSSEGUIR = 'Antes de prosseguir';
const OPERACAO_NAO_PERMITIDA = 'Operação não permitida';
const DISPOSITIVO_JA_EXISTE = 'Atenção, dispositivo já existe no texto';
const IMPORTANTE = 'Importante!';
const DANGER = 'danger';
const INFO = 'primary';
const SVG_DANGER = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 0C9.62663 0 7.30655 0.703788 5.33316 2.02236C3.35977 3.34094 1.8217 5.21508 0.913451 7.4078C0.00519941
9.60051 -0.232441 12.0133 0.230582 14.3411C0.693605 16.6689 1.83649 18.807 3.51472 20.4853C5.19295 22.1635 7.33115
23.3064 9.65892 23.7694C11.9867 24.2324 14.3995 23.9948 16.5922 23.0865C18.7849 22.1783 20.6591 20.6402 21.9776
18.6668C23.2962 16.6934 24 14.3734 24 12C24 10.4241 23.6896 8.8637 23.0866 7.4078C22.4835 5.95189 21.5996 4.62902
20.4853 3.51472C19.371 2.40041 18.0481 1.5165 16.5922 0.913445C15.1363 0.310389 13.5759 0 12 0ZM12 18C11.7627 18
11.5307 17.9296 11.3333 17.7978C11.136 17.6659 10.9822 17.4785 10.8913 17.2592C10.8005 17.0399 10.7768 16.7987
10.8231 16.5659C10.8694 16.3331 10.9837 16.1193 11.1515 15.9515C11.3193 15.7836 11.5331 15.6694 11.7659 15.6231C11.9987
15.5768 12.24 15.6005 12.4592 15.6913C12.6785 15.7822 12.8659 15.936 12.9978 16.1333C13.1296 16.3307 13.2 16.5627 13.2
16.8C13.2 17.1183 13.0736 17.4235 12.8485 17.6485C12.6235 17.8736 12.3183 18 12 18ZM13.2 13.2C13.2 13.5183 13.0736 13.8235
12.8485 14.0485C12.6235 14.2736 12.3183 14.4 12 14.4C11.6817 14.4 11.3765 14.2736 11.1515 14.0485C10.9264 13.8235 10.8
13.5183 10.8 13.2V7.2C10.8 6.88174 10.9264 6.57651 11.1515 6.35147C11.3765 6.12643 11.6817 6 12 6C12.3183 6 12.6235
6.12643 12.8485 6.35147C13.0736 6.57651 13.2 6.88174 13.2 7.2V13.2Z" fill="#CA3A31"/>
</svg>`;
const SVG_INFO = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none">
<path d="M12 0C9.62663 0 7.30655 0.703788 5.33316 2.02236C3.35977 3.34094 1.8217 5.21508 0.913451 7.4078C0.00519941
9.60051 -0.232441 12.0133 0.230582 14.3411C0.693605 16.6689 1.83649 18.807 3.51472 20.4853C5.19295 22.1635 7.33115
23.3064 9.65892 23.7694C11.9867 24.2324 14.3995 23.9948 16.5922 23.0865C18.7849 22.1783 20.6591 20.6402 21.9776
18.6668C23.2962 16.6934 24 14.3734 24 12C24 10.4241 23.6896 8.8637 23.0866 7.4078C22.4835 5.95189 21.5996 4.62902
20.4853 3.51472C19.371 2.40042 18.0481 1.5165 16.5922 0.913445C15.1363 0.310389 13.5759 0 12 0V0ZM12 18C11.7627 18
11.5307 17.9296 11.3333 17.7978C11.136 17.6659 10.9822 17.4785 10.8913 17.2592C10.8005 17.0399 10.7768 16.7987 10.8231
16.5659C10.8694 16.3331 10.9837 16.1193 11.1515 15.9515C11.3193 15.7836 11.5331 15.6694 11.7659 15.6231C11.9987
15.5768 12.24 15.6005 12.4592 15.6913C12.6785 15.7822 12.8659 15.936 12.9978 16.1333C13.1296 16.3307 13.2 16.5627
13.2 16.8C13.2 17.1183 13.0736 17.4235 12.8485 17.6485C12.6235 17.8736 12.3183 18 12 18ZM13.2 13.2C13.2 13.5183 13.0736
13.8235 12.8485 14.0485C12.6235 14.2736 12.3183 14.4 12 14.4C11.6817 14.4 11.3765 14.2736 11.1515 14.0485C10.9264 13.8235
10.8 13.5183 10.8 13.2V7.2C10.8 6.88174 10.9264 6.57651 11.1515 6.35147C11.3765 6.12643 11.6817 6 12 6C12.3183 6
12.6235 6.12643 12.8485 6.35147C13.0736 6.57651 13.2 6.88174 13.2 7.2V13.2Z" fill="#3982C1"/>
</svg>`;
const onChangeColarDialog = new Observable();
class DialogColagem {
    constructor() {
        this.mensagens = [];
        this.nomeDispositivoSingular = '';
        this.nomeDispositivoPlural = '';
        this.isPrimeiroDialogoTipoColagem = true;
        this.exibeDialogAviso = true;
    }
}
const montaDialogoTipoColagem = (dialogColagem) => {
    const mensagens = ['Selecione abaixo o formato com o qual gostaria de colar seu texto.'];
    dialogColagem.mensagens = mensagens;
    dialogColagem.idDialog = ID_DIALOGO_TIPO_COLAGEM;
    dialogColagem.labelDialog = ANTES_DE_PROSSEGUIR;
    dialogColagem.tipoRodape = RODAPE_CONFIRMAR;
    dialogColagem.variante = INFO;
    montaDialogo(dialogColagem);
};
const montaDialagoNaoPermitidoPadrao = (dialogColagem) => {
    dialogColagem.mensagens = dialogColagem.infoTextoColado.restricoes[0].mensagens;
    dialogColagem.idDialog = 'slDialogoNaoPermitido';
    dialogColagem.labelDialog = OPERACAO_NAO_PERMITIDA;
    dialogColagem.tipoRodape = RODAPE_FECHAR;
    dialogColagem.variante = DANGER;
    dialogColagem.exibeDialogAviso = false;
    montaDialogo(dialogColagem);
};
const montaDialogoAdicionarAposAtual = (dialogColagem) => {
    const mensagens = [
        ...dialogColagem.infoTextoColado.restricoes[0].mensagens,
        'Você deseja adicionar ' +
            getConcordanciaTodosTodas(dialogColagem.nomeDispositivoSingular) +
            getConcordanciaAsOs(dialogColagem.nomeDispositivoSingular) +
            dialogColagem.nomeDispositivoPlural +
            ' após a posição atual?',
    ];
    dialogColagem.mensagens = mensagens;
    dialogColagem.idDialog = ID_DIALOGO_ADICIONAR_APOS_ATUAL;
    dialogColagem.tipoRodape = RODAPE_CONFIRMAR;
    dialogColagem.variante = INFO;
    montaDialogo(dialogColagem);
};
const montaDialogoModificarExistenteAdicionarNovo = (dialogColagem) => {
    dialogColagem.idDialog = ID_DIALOGO_MODIFICAR_EXISTENTE_ADICIONAR_NOVO;
    dialogColagem.labelDialog = DISPOSITIVO_JA_EXISTE;
    dialogColagem.tipoRodape = RODAPE_CONFIRMAR;
    dialogColagem.variante = INFO;
    const mensagens = [
        'Você gostaria de modificar ' +
            getConcordanciaAsOs(dialogColagem.nomeDispositivoSingular) +
            dialogColagem.nomeDispositivoPlural +
            ' existentes ou adicionar novos após o atual?',
    ];
    dialogColagem.mensagens = mensagens;
    montaDialogo(dialogColagem);
};
const montaDialogoAviso = (dialogColagem) => {
    if (dialogColagem.exibeDialogAviso) {
        dialogColagem.idDialog = ID_DIALOGO_AVISO;
        dialogColagem.labelDialog = IMPORTANTE;
        dialogColagem.tipoRodape = RODAPE_FECHAR;
        dialogColagem.variante = INFO;
        const mensagens = ['Por favor, verifique se o texto e a estrutura de dispositivos colados está de acordo com o esperado. ', 'Podem ser necessários ajustes.'];
        dialogColagem.mensagens = mensagens;
        montaDialogo(dialogColagem);
    }
};
/**
 * Inicializa caixas de diálogo
 */
const colarTextoArticuladoDialog = (quill, rootStore, infoTextoColado, range, isPrimeiroDialogoTipoColagem = true) => {
    const dialogColagem = new DialogColagem();
    dialogColagem.quill = quill;
    dialogColagem.rootStore = rootStore;
    dialogColagem.infoTextoColado = infoTextoColado;
    dialogColagem.range = range;
    dialogColagem.nomeDispositivoSingular = getNomeDispositivo(TipoSubstantivoEnum.SINGULAR, dialogColagem.infoTextoColado);
    dialogColagem.nomeDispositivoPlural = getNomeDispositivo(TipoSubstantivoEnum.PLURAL, dialogColagem.infoTextoColado);
    dialogColagem.isPrimeiroDialogoTipoColagem = isPrimeiroDialogoTipoColagem;
    if (infoTextoColado.infoElementos.novos.length > 1 || infoTextoColado.infoElementos.existentes.length > 1) {
        executarValidacaoRestricao(dialogColagem);
        dialogColagem.isPrimeiroDialogoTipoColagem = false;
        montaDialogoAviso(dialogColagem);
    }
    else {
        montaDialogoTipoColagem(dialogColagem);
        dialogColagem.isPrimeiroDialogoTipoColagem = false;
    }
};
/**
 * Método utilizado para criar caixas de diálogo conforme restrições encontradas
 *
 * @param dialogColagem
 */
const executarValidacaoRestricao = (dialogColagem) => {
    if (dialogColagem.infoTextoColado.restricoes.length) {
        const restricao = dialogColagem.infoTextoColado.restricoes[0];
        dialogColagem.labelDialog = restricao.titulo || OPERACAO_NAO_PERMITIDA;
        restricao.isPermitidoColarAdicionando ? montaDialogoAdicionarAposAtual(dialogColagem) : montaDialagoNaoPermitidoPadrao(dialogColagem);
        dialogColagem.exibeDialogAviso = false;
    }
    else if (dialogColagem.infoTextoColado.restricoes.length === 0 && dialogColagem.infoTextoColado.infoElementos.existentes.length === 0) {
        adicionaElemento(dialogColagem, false);
    }
    else {
        dialogColagem.exibeDialogAviso = false;
        montaDialogoModificarExistenteAdicionarNovo(dialogColagem);
    }
};
/**
 * Constrói dinamicamente html e ações de cada caixa de diálogo
 */
const montaDialogo = (dialogColagem) => {
    Array.from(document.querySelectorAll('.dialogo-colagem')).forEach(el => document.body.removeChild(el));
    const dialogElem = document.createElement('sl-dialog');
    dialogElem.classList.add('dialogo-colagem');
    dialogElem.id = dialogColagem.idDialog;
    document.body.appendChild(dialogElem);
    dialogElem.label = dialogColagem.labelDialog;
    const content = document.createRange().createContextualFragment(`
    <style>
      .rodape-confirmar {
        float: right;
      }
      .tiposColagem {
        font-weight: normal;
      }
      sl-dialog::part(title) {
        display: flex;
        align-items: center;
        gap: 1rem;
      }
    </style>
      <div class="tiposColagem">
        ${buildMessages(dialogColagem.mensagens)}
        <br><br>
        ${getRadioGroup(dialogColagem)}
        <div class="rodape-confirmar">
        ${getTipoRodape(dialogColagem)}
        <div/>
      </div>
  `);
    buildButtons(content, dialogElem, dialogColagem);
    buildRadioClick(content);
    dialogColagem.quill.blur();
    dialogElem.appendChild(content);
    dialogElem.show();
    setTimeout(() => addIconBeforeTitle(dialogColagem), 0);
    if (dialogColagem.idDialog === ID_DIALOGO_TIPO_COLAGEM) {
        setTimeout(() => setFocusButtonConfirmar(), 0);
    }
};
const setFocusButtonConfirmar = () => {
    document.getElementById('btnConfirmar').focus();
};
const addIconBeforeTitle = (dialogColagem) => {
    const elDialogTitle = document.querySelector('#' + dialogColagem.idDialog).shadowRoot.querySelector('#title');
    elDialogTitle === null || elDialogTitle === void 0 ? void 0 : elDialogTitle.insertAdjacentHTML('afterbegin', getIcon(dialogColagem));
};
const getIcon = (dialogColagem) => {
    if (dialogColagem.variante === DANGER) {
        return SVG_DANGER;
    }
    return SVG_INFO;
};
/**
 * Define os botões da caixa de diálogo
 */
const buildButtons = (content, dialogElem, dialogColagem) => {
    const botoes = content.querySelectorAll('sl-button');
    if (botoes.length === 1) {
        const fechar = botoes[0];
        fechar.onclick = () => {
            fecharDialog(dialogElem, dialogColagem);
        };
    }
    else if (botoes.length > 1) {
        const confirma = botoes[0];
        const fechar = botoes[1];
        fechar.onclick = () => {
            fecharDialog(dialogElem, dialogColagem);
        };
        confirma.onclick = () => {
            executeByIdDialog(dialogColagem, dialogElem);
        };
    }
};
const buildRadioClick = (content) => {
    const radio = content.querySelectorAll('sl-radio');
    if (radio.length > 0) {
        const opt1 = radio[0];
        const opt2 = radio[1];
        opt1.onclick = () => {
            habilitaBotaoConfirmar();
        };
        opt2.onclick = () => {
            habilitaBotaoConfirmar();
        };
    }
};
const getValueFromRadioGroup = (idRadioGroup) => {
    return document.getElementById(idRadioGroup).querySelector('sl-radio[checked]').value;
};
/**
 * Realiza validação e constrói ação de cada situação de cada caixa de diálogo de acordo com o texto colado
 */
const executeByIdDialog = (dialogColagem, dialogElem) => {
    const { idDialog } = dialogColagem;
    let valor = '';
    let colarSubstituindo = false;
    if (idDialog === ID_DIALOGO_ADICIONAR_APOS_ATUAL) {
        valor = getValueFromRadioGroup('rdgSimNao') === '1' ? '1' : '';
    }
    else if (idDialog === ID_DIALOGO_TIPO_COLAGEM) {
        valor = getValueFromRadioGroup('rdgTipoColagem');
        if (valor === '1') {
            colarComoTextoSimples(dialogColagem);
            valor = ''; // para não executar adicionarElementoFromClipboardAction
        }
        else if (valor === '2' && dialogColagem.isPrimeiroDialogoTipoColagem) {
            dialogColagem.isPrimeiroDialogoTipoColagem = false;
            valor = '';
            colarTextoArticuladoDialog(dialogColagem.quill, dialogColagem.rootStore, dialogColagem.infoTextoColado, dialogColagem.range, false);
        }
        else if (valor === '2' && !dialogColagem.isPrimeiroDialogoTipoColagem) {
            executarValidacaoRestricao(dialogColagem);
            valor = '';
        }
    }
    else if (idDialog === ID_DIALOGO_MODIFICAR_EXISTENTE_ADICIONAR_NOVO) {
        valor = getValueFromRadioGroup('rdgModificarExistenteAdicionarNovo');
        colarSubstituindo = valor === '1';
    }
    if (valor) {
        adicionaElemento(dialogColagem, colarSubstituindo);
    }
    fecharDialog(dialogElem, dialogColagem);
    montaDialogoAviso(dialogColagem);
};
const adicionaElemento = (dialogColagem, colarSubstituindo) => {
    const { infoTextoColado, rootStore } = dialogColagem;
    rootStore.dispatch(adicionarElementoFromClipboardAction.execute(infoTextoColado.infoElementos.atual, infoTextoColado.jsonix, undefined, infoTextoColado.infoElementos.atual.dispositivoAlteracao, colarSubstituindo, 'depois'));
};
const colarComoTextoSimples = (dialogColagem) => {
    const { quill, range, infoTextoColado } = dialogColagem;
    quill.clipboard.dangerouslyPasteHTML(range.index, infoTextoColado.textoColadoOriginal);
    onChangeColarDialog.notify('clipboard');
};
const fecharDialog = (dialogElem, dialogColagem) => {
    dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
    if (document.body.contains(dialogElem)) {
        document.body.removeChild(dialogElem);
    }
    setTimeout(() => dialogColagem.quill.focus(), 0);
};
const buildMessages = (mensagens) => mensagens.join('<br><br>');
const getRadioGroup = (dialogColagem) => {
    if (dialogColagem.idDialog === ID_DIALOGO_TIPO_COLAGEM) {
        return getRadioGroupTipoColagem();
    }
    else if (dialogColagem.idDialog === ID_DIALOGO_MODIFICAR_EXISTENTE_ADICIONAR_NOVO) {
        return getRadioGroupModificarExistenteAdicionarNovo(dialogColagem);
    }
    else if (dialogColagem.idDialog === ID_DIALOGO_MODIFICAR_DISPOSITIVOS_EXISTENTES || dialogColagem.idDialog === ID_DIALOGO_ADICIONAR_APOS_ATUAL) {
        return getRadioGroupSimNao();
    }
    return '';
};
const getRadioGroupTipoColagem = () => {
    return `
  <sl-radio-group id="rdgTipoColagem">
    <sl-radio class="tipo-colagem" id="colarSimples" value="1">Colar como texto simples</sl-radio>
    <sl-radio class="tipo-colagem" id="colarEstruturado" value="2" checked>Colar como dispositivo</sl-radio>
  </sl-radio-group>
  `;
};
const getRadioGroupModificarExistenteAdicionarNovo = (dialogColagem) => {
    return (`
  <sl-radio-group id="rdgModificarExistenteAdicionarNovo">
    <sl-radio id="modificarExistente" value="1">Modificar ` +
        dialogColagem.nomeDispositivoPlural +
        ` existentes</sl-radio>
    <sl-radio id="adicionarNovo" value="2">Adicionar nov` +
        getConcordanciaAsOs(dialogColagem.nomeDispositivoSingular) +
        dialogColagem.nomeDispositivoPlural +
        `</sl-radio>
  </sl-radio-group>
  `);
};
const getRadioGroupSimNao = () => {
    return `
  <sl-radio-group id="rdgSimNao">
    <sl-radio id="sim" value="1">Sim</sl-radio>
    <sl-radio id="nao" value="2">Não</sl-radio>
  </sl-radio-group>
  `;
};
const getTipoRodape = (dialogColagem) => (dialogColagem.tipoRodape === RODAPE_CONFIRMAR ? getRodapeConfirmar(dialogColagem) : getRodapeFechar());
const getRodapeFechar = () => {
    return `
    <div class="rodape-confirmar">
      <br/>
      <sl-button slot="footer" variant="primary">Fechar</sl-button>
    </div>
  `;
};
const getRodapeConfirmar = (dialogColagem) => {
    const disabled = dialogColagem.idDialog === ID_DIALOGO_TIPO_COLAGEM ? '' : 'disabled';
    return `
    <div class="rodape-confirmar" id="rodapeConfirmar">
      <br/>
      <sl-button id="btnConfirmar" slot="footer" variant="primary" ${disabled}>Confirmar</sl-button>
      <sl-button slot="footer" variant="default">Fechar</sl-button>
    </div>
  `;
};
const habilitaBotaoConfirmar = () => {
    document.getElementById('btnConfirmar').disabled = false;
    setFocusButtonConfirmar();
};
var TipoSubstantivoEnum;
(function (TipoSubstantivoEnum) {
    TipoSubstantivoEnum[TipoSubstantivoEnum["PLURAL"] = 0] = "PLURAL";
    TipoSubstantivoEnum[TipoSubstantivoEnum["SINGULAR"] = 1] = "SINGULAR";
})(TipoSubstantivoEnum || (TipoSubstantivoEnum = {}));
/**
 * Retorna o nome do dispositivo no singular ou plural
 */
const getNomeDispositivo = (tipoSubstantivo, infoTextoColado) => {
    if (infoTextoColado.infoElementos.tiposColados.includes('DispositivoAgrupadorGenerico')) {
        return '';
    }
    const dispositivo = infoTextoColado.infoElementos.tiposColados[0].toLowerCase();
    return tipoSubstantivo === TipoSubstantivoEnum.PLURAL ? TipoDispositivo[dispositivo].descricaoPlural.toLowerCase() : TipoDispositivo[dispositivo].descricao.toLowerCase();
};
// /**
//  * Retorna a concordância de início de frase
//  */
// const getConcordanciaInicialMensagem = (nomeDispositivo: string): string => (isGeneroFeminino(nomeDispositivo) ? 'A ' : 'O ');
const isGeneroFeminino = (nomeDispositivo) => ['parte', 'seção', 'subseção', 'alínea'].includes(nomeDispositivo);
/**
 * retorna concordância de meio de frase 'todos' e 'todas'
 */
const getConcordanciaTodosTodas = (nomeDispositivo) => (isGeneroFeminino(nomeDispositivo) ? 'todas ' : 'todos ');
/**
 * retorna concordância de meio de frase 'as' e 'os'
 */
const getConcordanciaAsOs = (nomeDispositivo) => (isGeneroFeminino(nomeDispositivo) ? 'as ' : 'os ');

const adicionarAgrupadorArtigoDialog = (elemento, quill, store) => {
    var _a, _b;
    Array.from(document.querySelectorAll('#slDialogAdicionarAgrupadorArtigo')).forEach(el => document.body.removeChild(el));
    const tipoPai = (_b = (_a = elemento.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.tipo;
    const defaultValue = elemento.agrupador ? elemento.tipo : tipoPai === 'Articulacao' ? 'Capitulo' : tipoPai;
    const dialogElem = document.createElement('sl-dialog');
    dialogElem.id = 'slDialogAdicionarAgrupadorArtigo';
    document.body.appendChild(dialogElem);
    dialogElem.label = 'Adicionar agrupador de artigo';
    dialogElem.addEventListener('sl-request-close', (event) => {
        if (event.detail.source === 'overlay') {
            event.preventDefault();
        }
    });
    const content = document.createRange().createContextualFragment(`
  <style>

    #chkManterNoMesmoGrupoDeAspas {
      margin: 10px;
    }
    #chkManterNoMesmoGrupoDeAspas[disabled] {
      display: none;
    }
    #rdgPosicao {
      margin-top: 20px;
    }

  </style>
  <div class="agrupadores">
    <sl-radio-group fieldset label="Tipo de agrupador" id="rdgTipoAgrupador">
      <sl-radio class="tipo-agrupador" id="Parte" value="Parte">Parte</sl-radio>
      <sl-radio class="tipo-agrupador" id="Livro" value="Livro">Livro</sl-radio>
      <sl-radio class="tipo-agrupador" id="Titulo" value="Titulo">Título</sl-radio>
      <sl-radio class="tipo-agrupador" id="Capitulo" value="Capitulo">Capítulo</sl-radio>
      <sl-radio class="tipo-agrupador" id="Secao" value="Secao">Seção</sl-radio>
      <sl-radio class="tipo-agrupador" id="Subsecao" value="Subsecao">Subseção</sl-radio>
    </sl-radio-group>
  </div>
  <div style="display: ${elemento.tipo === 'Artigo' ? 'none' : 'block'};">
    <sl-radio-group fieldset label="Posicionamento" id="rdgPosicao">
      <sl-radio class="posicao-agrupador" id="posicao-antes" value="antes">Antes</sl-radio>
      <sl-radio class="posicao-agrupador" id="posicao-depois" value="depois" checked>Depois</sl-radio>
    </sl-radio-group>
  </div>
  <div>
    <sl-checkbox id="chkManterNoMesmoGrupoDeAspas">Manter no mesmo grupo de aspas</sl-checkbox>
  </div>
  <sl-button slot="footer" variant="default">Cancelar</sl-button>
  <sl-button slot="footer" variant="primary">Ok</sl-button>
  `);
    const opcoes = Array.from(content.querySelectorAll('.tipo-agrupador'));
    const tiposPermitidos = [...elemento.tiposAgrupadoresQuePodemSerInseridosAntes];
    if (elemento.tipo !== 'Artigo') {
        tiposPermitidos.push(...elemento.tiposAgrupadoresQuePodemSerInseridosDepois);
    }
    const defaultAux = tiposPermitidos.length === 1 ? tiposPermitidos[0] : defaultValue;
    const elTipoAgrupadorDefault = opcoes.find(el => el.value === defaultAux);
    elTipoAgrupadorDefault.checked = true;
    opcoes.forEach(el => {
        el.disabled = !tiposPermitidos.includes(el.value);
        el.checked = el.disabled ? false : el.checked;
    });
    const botoes = content.querySelectorAll('sl-button');
    const cancelar = botoes[0];
    const ok = botoes[1];
    const optPosicaoAntes = content.querySelector('#posicao-antes');
    const optPosicaoDepois = content.querySelector('#posicao-depois');
    const chkManterNoMesmoGrupoDeAspas = content.querySelector('#chkManterNoMesmoGrupoDeAspas');
    let ultimoValorDeChkManterNoMesmoGrupoDeAspasSelecionadoPorUsuario = false;
    chkManterNoMesmoGrupoDeAspas.checked = ultimoValorDeChkManterNoMesmoGrupoDeAspasSelecionadoPorUsuario;
    const action = elemento.tipo === 'Artigo' ? adicionarAgrupadorArtigoAction : adicionarAgrupadorArtigoAntesAction;
    const validarStatusChkManterNoMesmoGrupoDeAspas = () => {
        var _a;
        const posicao = (_a = document.querySelector('sl-radio.posicao-agrupador[aria-checked="true"]')) === null || _a === void 0 ? void 0 : _a.value;
        const isCabecaAlteracao = elemento.abreAspas && elemento.fechaAspas;
        if (elemento.agrupador) {
            if (isCabecaAlteracao) {
                chkManterNoMesmoGrupoDeAspas.disabled = false;
                chkManterNoMesmoGrupoDeAspas.checked = ultimoValorDeChkManterNoMesmoGrupoDeAspasSelecionadoPorUsuario;
            }
            else if ((!elemento.abreAspas && !elemento.fechaAspas) || (elemento.abreAspas && posicao === 'depois') || (elemento.fechaAspas && posicao === 'antes')) {
                chkManterNoMesmoGrupoDeAspas.disabled = true;
                chkManterNoMesmoGrupoDeAspas.checked = true;
            }
            else {
                chkManterNoMesmoGrupoDeAspas.disabled = false;
                chkManterNoMesmoGrupoDeAspas.checked = ultimoValorDeChkManterNoMesmoGrupoDeAspasSelecionadoPorUsuario;
            }
        }
        else {
            chkManterNoMesmoGrupoDeAspas.disabled = true;
            chkManterNoMesmoGrupoDeAspas.checked = !elemento.abreAspas;
        }
    };
    chkManterNoMesmoGrupoDeAspas.onchange = (evt) => {
        ultimoValorDeChkManterNoMesmoGrupoDeAspasSelecionadoPorUsuario = evt.target.checked;
    };
    setTimeout(() => validarStatusChkManterNoMesmoGrupoDeAspas(), 0);
    content.querySelector('#rdgPosicao').onclick = () => {
        validarStatusChkManterNoMesmoGrupoDeAspas();
    };
    content.querySelector('#rdgTipoAgrupador').onclick = (evt) => {
        if (elemento.tipo === 'Artigo' || !tiposPermitidos.includes(evt.target.value)) {
            return;
        }
        optPosicaoAntes.disabled = !elemento.tiposAgrupadoresQuePodemSerInseridosAntes.includes(evt.target.value);
        optPosicaoDepois.disabled = !elemento.tiposAgrupadoresQuePodemSerInseridosDepois.includes(evt.target.value);
        if (!optPosicaoAntes.disabled && !optPosicaoDepois.disabled) {
            optPosicaoAntes.checked = false;
            optPosicaoDepois.checked = true;
        }
        else {
            optPosicaoAntes.checked = !optPosicaoAntes.disabled;
            optPosicaoDepois.checked = !optPosicaoDepois.disabled;
        }
        // optPosicaoDepois.checked = tiposAgrupadorArtigo.indexOf(evt.target.value) >= tiposAgrupadorArtigo.indexOf(elemento.tipo!);
        // optPosicaoAntes.checked = !optPosicaoDepois.checked;
        validarStatusChkManterNoMesmoGrupoDeAspas();
    };
    ok.onclick = () => {
        const tipo = document.querySelector('sl-radio.tipo-agrupador[aria-checked="true"]').value;
        const posicao = elemento.tipo === 'Artigo' ? 'antes' : document.querySelector('sl-radio.posicao-agrupador[aria-checked="true"]').value;
        const manterNoMesmoGrupoDeAspas = chkManterNoMesmoGrupoDeAspas.checked;
        if (tipo) {
            // const manterNoMesmoGrupoDeAspas = elemento.tipo !== 'Artigo' || elemento.hierarquia?.pai?.tipo !== 'Articulacao';
            store.dispatch(action.execute(elemento, tipo, undefined, posicao, manterNoMesmoGrupoDeAspas));
        }
        dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
        document.body.removeChild(dialogElem);
    };
    cancelar.onclick = () => {
        quill.focus();
        dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
        document.body.removeChild(dialogElem);
    };
    setTimeout(() => elTipoAgrupadorDefault.click(), 0);
    quill.blur();
    dialogElem.appendChild(content);
    dialogElem.show();
};

/**
 * Utilitário para montar uma tag usando o pattern composite. Essa classe foi retirada do livro
 * Refactoring to Patterns
 */
class TagNode {
    constructor(nome) {
        this.nome = nome;
        this.valores = new Array();
        this.atributos = new StringBuilder();
    }
    toString() {
        if (!this.valores.length) {
            return '<' + this.nome + this.atributos + '/>';
        }
        const resultado = new StringBuilder('<' + this.nome + this.atributos + '>');
        this.valores.forEach(valor => {
            resultado.append(valor);
        });
        resultado.append('</' + this.nome + '>');
        return resultado.toString();
    }
    add(valor) {
        if (valor) {
            this.valores.push(valor);
        }
        return this;
    }
    addAtributo(atributo, valor) {
        this.atributos.append(' ');
        this.atributos.append(atributo);
        if (valor) {
            this.atributos.append('="');
            this.atributos.append(valor);
            this.atributos.append('"');
        }
        return this;
    }
}

class DispositivoComparator {
    static compare(d1, d2) {
        if (!d1 || !d2) {
            throw new Error('Tentativa de comparação de dispositivo nulo.');
        }
        if (!d1.pai) {
            return -1;
        }
        if (!d2.pai) {
            return 1;
        }
        const i1 = DispositivoComparator.getIndices(d1);
        const i2 = DispositivoComparator.getIndices(d2);
        return DispositivoComparator.comparaIndices(i1, i2);
    }
    static getIndices(d) {
        const indices = [];
        // Considera alteração como filha do caput
        let pai = this.getPaiParaComparacao(d);
        while (pai) {
            indices.push(this.getIndexDoFilho(pai, d));
            d = pai;
            pai = this.getPaiParaComparacao(d);
        }
        indices.reverse();
        return indices;
    }
    // Considera alteração em artigo como filha do caput
    static getPaiParaComparacao(d) {
        if (!d.pai) {
            return undefined;
        }
        if (isArtigo(d.pai) && isArticulacaoAlteracao(d)) {
            return d.pai.caput;
        }
        return d.pai;
    }
    static getIndexDoFilho(pai, d) {
        if (isCaput(d)) {
            return 0;
        }
        if (isParagrafo(d) || (isOmissis(d) && isArtigo(pai))) {
            // Após o caput
            return pai.filhos.indexOf(d) + 1;
        }
        if (isArticulacaoAlteracao(d)) {
            // Antes dos filhos
            return -1;
        }
        return pai.filhos.indexOf(d);
    }
    static comparaIndices(indices1, indices2) {
        let ret = 0;
        const size1 = indices1.length;
        const size2 = indices2.length;
        for (let i = 0; i < size1 && i < size2 && ret === 0; i++) {
            ret = indices1[i] - indices2[i];
        }
        if (ret === 0) {
            ret = size1 - size2;
        }
        return ret;
    }
}

class DispositivoEmendaUtil {
    static getAlteracao(dispositivo) {
        let d = dispositivo;
        if (d.tipo === TipoDispositivo.alteracao.tipo) {
            return d;
        }
        if (!isDispositivoAlteracao(d)) {
            return undefined;
        }
        while (d && d.tipo !== TipoDispositivo.alteracao.tipo) {
            d = d.pai;
        }
        return d;
    }
    static existeNaNormaAlterada(dispositivo) {
        return dispositivo.situacao.existeNaNormaAlterada;
    }
}

class CmdEmdUtil {
    static getDispositivosNaoOriginais(articulacao) {
        var _a, _b;
        const ret = [];
        if (((_b = (_a = articulacao.projetoNorma) === null || _a === void 0 ? void 0 : _a.ementa) === null || _b === void 0 ? void 0 : _b.situacao.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_MODIFICADO) {
            ret.push(articulacao.projetoNorma.ementa);
        }
        percorreHierarquiaDispositivos(articulacao, d => {
            if (d.pai && d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
                ret.push(d);
            }
        });
        return ret;
    }
    static getDispositivosAdicionados(articulacao) {
        const ret = [];
        percorreHierarquiaDispositivos(articulacao, d => {
            if (d.pai && d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                ret.push(d);
            }
        });
        return ret;
    }
    static getDispositivosComando(dispositivosEmenda) {
        const dispositivos = new Array();
        for (const d of dispositivosEmenda) {
            if (d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ORIGINAL || isDispositivoAlteracao(d) || isArticulacaoAlteracao(d)) {
                continue;
            }
            const dispositivoAfetado = CmdEmdUtil.getDispositivoAfetado(d);
            if (dispositivoAfetado && !dispositivos.includes(dispositivoAfetado)) {
                dispositivos.push(dispositivoAfetado);
            }
        }
        return dispositivos;
    }
    static getDispositivoAfetado(d) {
        const pai = d.pai;
        if (isDispositivoRaiz(pai)) {
            return d;
        }
        // Verifica alteração integral de caput
        if (isCaput(pai) && pai.pai.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
            if (pai.filhos.find(f => f.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ORIGINAL)) {
                // Não é alteração integral de caput
                return d;
            }
            // É alteração integral de caput
            return CmdEmdUtil.getDispositivoAfetado(pai.pai);
        }
        // O caso de artigos adicionados junto com seu agrupador já foi tratado antes. Ver uso de retiraPrimeirosFilhosAdicionadosAgrupador
        if (isArtigo(d) && d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
            return d;
        }
        // Se o pai for uma alteração integral
        if (CmdEmdUtil.isAlteracaoIntegral(pai)) {
            // Chama recursivamente para o pai
            return CmdEmdUtil.getDispositivoAfetado(pai);
        }
        return d;
    }
    // Retira da lista de dispositivos os primeiros artigos e agrupadores adicionados, filhos de um agrupador adicionado.
    // Considera que os dispositivos estejam ordenados
    static retiraPrimeirosFilhosAdicionadosAgrupador(dispositivos) {
        const primeiro = dispositivos[0];
        if (isDispositivoAlteracao(primeiro) || primeiro.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
            return dispositivos;
        }
        if (!dispositivos.find(d => isAgrupadorNaoArticulacao(d))) {
            return dispositivos;
        }
        const ret = [];
        let filhosAdicionadosComAgrupador = [];
        dispositivos.forEach(d => {
            if (filhosAdicionadosComAgrupador.indexOf(d) < 0) {
                ret.push(d);
                if (isAgrupadorNaoArticulacao(d)) {
                    filhosAdicionadosComAgrupador = this.listaFilhosAdicionadosComAgrupador(d);
                }
            }
        });
        return ret;
    }
    static listaFilhosAdicionadosComAgrupador(d) {
        const ret = [];
        buscaNaHierarquiaDispositivos(d, f => {
            if (f.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO || isCaput(f) || isArticulacaoAlteracao(f)) {
                ret.push(f);
                return false;
            }
            return true;
        });
        return ret;
    }
    static getDispositivoAfetadoEmAlteracao(d) {
        if (isOmissis(d)) {
            if (CmdEmdUtil.isOmissisAdjacenteADispositivoDeEmenda(d)) {
                return undefined;
            }
        }
        else if (d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO && CmdEmdUtil.isTextoOmitido(d)) {
            return undefined;
        }
        const pai = isCaput(d.pai) ? d.pai.pai : d.pai;
        // Se o pai for uma alteração integral
        if (CmdEmdUtil.isAlteracaoIntegralEmAlteracao(pai)) {
            // Chama recursivamente para o pai
            return CmdEmdUtil.getDispositivoAfetadoEmAlteracao(pai);
        }
        return d;
    }
    // Considero texto omitido do Artigo se o seu caput tiver o texto omitido.
    static isTextoOmitido(d) {
        var _a;
        return isOmissis(d) || d.texto.startsWith(TEXTO_OMISSIS) || (isAgrupador(d) && !!((_a = d.caput) === null || _a === void 0 ? void 0 : _a.texto.startsWith(TEXTO_OMISSIS)));
    }
    static getDescricaoSituacaoParaComandoEmenda(d) {
        // Trata dispositivo já existente na norma adicionado em bloco de alteração como dispositivo modificado
        return d.isDispositivoAlteracao && d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO && DispositivoEmendaUtil.existeNaNormaAlterada(d) && !isOmissis(d)
            ? DescricaoSituacao.DISPOSITIVO_MODIFICADO
            : d.situacao.descricaoSituacao;
    }
    static isMesmaSituacaoParaComandoEmenda(d1, d2) {
        return this.getDescricaoSituacaoParaComandoEmenda(d1) === this.getDescricaoSituacaoParaComandoEmenda(d2);
    }
    static isAlteracaoIntegral(d) {
        const descricaoSituacao = this.getDescricaoSituacaoParaComandoEmenda(d);
        if (descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
            return false;
        }
        if (isDispositivoAlteracao(d) && isAgrupadorNaoArticulacao(d) && descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
            return false;
        }
        if (descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
            return true;
        }
        if (descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
            return !isAgrupadorNaoArticulacao(d);
        }
        if (!d.filhos.length) {
            if (isArtigo(d)) {
                return descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL;
            }
            return true;
        }
        for (const filho of d.filhos) {
            if (!CmdEmdUtil.isAlteracaoIntegral(filho)) {
                return false;
            }
        }
        return true;
    }
    static isAlteracaoIntegralEmAlteracao(d) {
        if (isArticulacaoAlteracao(d)) {
            return false;
        }
        if (isAgrupadorNaoArticulacao(d) && d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
            return false;
        }
        return ((d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO && !CmdEmdUtil.isTextoOmitido(d)) ||
            d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO);
    }
    static getArvoreDispositivos(dispositivos) {
        const mapa = new Map();
        if (!dispositivos.length) {
            return mapa;
        }
        dispositivos.forEach(dispositivo => {
            this.atualizaMapa(dispositivo, mapa);
        });
        return mapa;
    }
    static atualizaMapa(dispositivo, mapa) {
        const hierarquia = this.getHierarquiaDispositivosDeUmDispositivo(dispositivo);
        let mapaAtual = mapa;
        hierarquia.forEach(dispositivoAtual => {
            const mapaFilho = mapaAtual.get(dispositivoAtual);
            if (mapaFilho) {
                mapaAtual = mapaFilho;
            }
            else {
                const novoMapa = new Map();
                mapaAtual.set(dispositivoAtual, novoMapa);
                mapaAtual = novoMapa;
            }
        });
    }
    static getHierarquiaDispositivosDeUmDispositivo(dispositivo) {
        const hierarquia = new Array();
        hierarquia.push(dispositivo);
        let pai = dispositivo.pai;
        while (pai && !isDispositivoRaiz(pai) && !isAgrupadorNaoArticulacao(pai)) {
            hierarquia.push(pai);
            pai = pai.pai;
        }
        hierarquia.reverse();
        return hierarquia;
    }
    static getArvoreDispositivosDeAlteracaoDeNorma(dispositivos) {
        const mapa = new Map();
        if (!dispositivos.length) {
            return mapa;
        }
        for (const dispositivo of dispositivos) {
            this.atualizaMapaDeAlteracaoDeNorma(dispositivo, mapa);
        }
        return mapa;
    }
    static atualizaMapaDeAlteracaoDeNorma(dispositivo, mapa) {
        const hierarquia = this.getHierarquiaDispositivosDeUmDispositivo(dispositivo);
        let mapaAtual = mapa;
        for (const dispositivoAtual of hierarquia) {
            if (!isDispositivoAlteracao(dispositivoAtual) || isArticulacaoAlteracao(dispositivoAtual)) {
                continue;
            }
            if (mapaAtual.has(dispositivoAtual)) {
                mapaAtual = mapaAtual.get(dispositivoAtual);
            }
            else {
                const novoMapa = new Map();
                mapaAtual.set(dispositivoAtual, novoMapa);
                mapaAtual = novoMapa;
            }
        }
        mapa = mapaAtual;
    }
    // public static List<Dispositivo> filtraDispositivosModificados(final List<Dispositivo> dispositivos) {
    //     List<Dispositivo> ret = new ArrayList<Dispositivo>();
    //     // No caso de dispositivo modificado pode ocorrer o caso de alteração integral de artigo,
    //     // onde o próprio artigo não está marcado como modificado.
    //     for (Dispositivo d : dispositivos) {
    //         if (d.isSituacao(DispositivoModificado.class) || d.isSituacao(DispositivoOriginal.class)
    //             && CmdEmdUtil.isAlteracaoIntegral(d)) {
    //             ret.add(d);
    //         }
    //     }
    //     return ret;
    // }
    static isSequenciasPlural(sequencias) {
        const qtdSequencias = sequencias.length;
        if (qtdSequencias === 0) {
            return false;
        }
        return qtdSequencias > 1 || CmdEmdUtil.isSequenciaPlural(sequencias[0]);
    }
    static isSequenciaPlural(sequencia) {
        const qtdRanges = sequencia.getQuantidadeRanges();
        if (qtdRanges === 0) {
            return false;
        }
        return qtdRanges > 1 || sequencia.getPrimeiroRange().getQuantidadeDispositivos() > 1;
    }
    static getProximoAgrupador(disp) {
        let ret = disp;
        do {
            ret = getDispositivoPosterior(ret);
        } while (ret && !isAgrupador(ret));
        return ret;
    }
    static getDispositivoIrmaoPosterior(dispositivo) {
        if (isArtigo(dispositivo) || isAgrupador(dispositivo)) {
            return this.getArtigoPosterior(dispositivo);
        }
        if (!this.isUltimoDispositivoDoMesmoTipo(dispositivo)) {
            const pai = dispositivo.pai;
            const index = pai.filhos.indexOf(dispositivo) + 1;
            return pai.filhos[index];
        }
        return undefined;
    }
    static getArtigoPosterior(dispositivo) {
        const pai = dispositivo.pai;
        if (pai.filhos.length) {
            const iFilho = pai.filhos.indexOf(dispositivo);
            for (let i = iFilho + 1; i < pai.filhos.length; i++) {
                const d = pai.filhos[i];
                if (isArtigo(d)) {
                    return d;
                }
                else if (isAgrupador(d)) {
                    const atual = this.buscaProximoArtigo(d);
                    if (atual) {
                        return atual;
                    }
                }
            }
            if (pai.pai) {
                return this.getArtigoPosterior(pai);
            }
        }
        return undefined;
    }
    static buscaProximoArtigo(dispositivo) {
        const filhos = dispositivo.filhos;
        for (const d of filhos) {
            if (isArtigo(d)) {
                return d;
            }
            if (isAgrupador(d)) {
                return this.buscaProximoArtigo(d);
            }
        }
        return undefined;
    }
    static isUltimoDispositivoDoMesmoTipo(dispositivo) {
        if (!dispositivo.pai) {
            return true;
        }
        const pai = dispositivo.pai;
        const index = pai.filhos.indexOf(dispositivo);
        if (pai.filhos.length === index + 1) {
            return true;
        }
        if (pai.filhos[index + 1].tipo === dispositivo.tipo) {
            return false;
        }
        return true;
    }
    // TODO Alterar referências a este método para função na hierarquiaUtil e excluir o método
    static getFilhosEstiloLexML(d) {
        return getFilhosEstiloLexML(d);
    }
    // TODO Alterar referências a este método para função na hierarquiaUtil e excluir o método
    static getDispositivoAnteriorDireto(d) {
        return getDispositivoAnteriorDireto(d);
    }
    static getDispositivoPosteriorDireto(d) {
        // primeiro o primeiro filho ou o primeiro irmão do pai (recursivamente)
        const filhos = this.getFilhosEstiloLexML(d);
        if (filhos.length) {
            return filhos[0];
        }
        else {
            return this.getProximoIrmaoRecursivo(d);
        }
    }
    static getProximoIrmaoRecursivo(d) {
        if (!d)
            return;
        const irmao = getDispositivoPosterior(d);
        if (irmao) {
            return irmao;
        }
        else {
            const pai = d.pai;
            return pai ? undefined : this.getProximoIrmaoRecursivo(pai);
        }
    }
    // /**
    //  * Retorna rótulo do dispositivo gerado pelo numerador. Não confia no rótulo informado pelo
    //  * dispositivo original.
    //  */
    // public static String getRotulo(final Dispositivo d) {
    //     return d.getNumeradorDispositivo().getRotulo(d);
    // }
    static getRotuloPais(disp) {
        const sb = new StringBuilder();
        let pai;
        while (disp && !isArtigo(disp)) {
            pai = disp.pai;
            sb.append(pai.pronomePossessivoSingular);
            sb.append(pai.getNumeracaoComRotuloParaComandoEmenda(disp));
            disp = pai;
        }
        return sb.toString();
    }
    static getDispositivosNaAlteracaoParaComando(alteracao) {
        const dispositivosAlterados = new Array();
        percorreHierarquiaDispositivos(alteracao, d => {
            if (d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
                dispositivosAlterados.push(d);
            }
        });
        const dispositivos = new Array();
        dispositivosAlterados.forEach(d => {
            const dispositivoAfetado = CmdEmdUtil.getDispositivoAfetadoEmAlteracao(d);
            if (dispositivoAfetado && !dispositivos.includes(dispositivoAfetado)) {
                dispositivos.push(dispositivoAfetado);
            }
        });
        dispositivos.sort(DispositivoComparator.compare);
        return dispositivos;
    }
    static isOmissisAdjacenteADispositivoDeEmenda(d) {
        if (!isOmissis(d)) {
            return false;
        }
        let anterior = CmdEmdUtil.getDispositivoAnteriorDireto(d);
        if (isCaput(anterior)) {
            anterior = anterior.pai;
        }
        if (anterior && anterior.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
            return true;
        }
        const posterior = CmdEmdUtil.getDispositivoPosteriorDireto(d);
        if (posterior && posterior.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
            return true;
        }
        return false;
    }
    static isMesmoTipoParaComandoEmenda(d1, d2) {
        if (d1.tipo !== d2.tipo) {
            return false;
        }
        if (isArtigo(d1) && CmdEmdUtil.isAlteracaoIntegral(d1) !== CmdEmdUtil.isAlteracaoIntegral(d2)) {
            return false;
        }
        return true;
    }
    static getTextoDoDispositivoOuOmissis(d, alteracaoNormaVigente = false) {
        if (d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO || d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO || isCaput(d)) {
            return ' ' + CmdEmdUtil.trataTextoParaCitacao(d, alteracaoNormaVigente);
        }
        else if (d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
            return isOmissis(d) ? ' (Suprimir omissis)' : ' (Suprimir)';
        }
        else {
            return ' ' + new TagNode('Omissis');
        }
    }
    static trataTextoParaCitacao(d, alteracaoNormaVigente = false) {
        var _a;
        let texto = isArtigo(d) ? d.caput.texto : (_a = d.texto) !== null && _a !== void 0 ? _a : '';
        if (texto.includes(TEXTO_OMISSIS)) {
            texto = texto.replace(TEXTO_OMISSIS, new TagNode('Omissis').toString());
        }
        if (alteracaoNormaVigente) {
            texto = texto.replace(/”( *(?:\(NR\)) *)?/, '');
        }
        else {
            texto = texto.replace(/”( *(?:\(NR\)) *)?/, '’$1 ');
        }
        return texto
            .trim()
            .replace(/\s{2,}/g, ' ')
            .replace(/^<p>\s?/i, '')
            .replace(/\s?<\/p>$/i, '')
            .replace(/<\/?a.*?>/gi, '')
            .replace(/\s([\\.,:?!])/g, '$1');
    }
    static isFechaAspas(d) {
        return isUltimaAlteracao(d);
    }
    // Considera que dispositivosAdicionadosProposicao é uma lista de dispositivos adicionados à proposição
    // e que não contém dispositivos adicionados em bloco de alteração.
    // Podem ser utilizados apenas os dispositivos raiz em um grupo de dispositivos adicionados.
    static verificaNecessidadeRenumeracaoRedacaoFinal(dispositivosAdicionadosProposicao) {
        for (const d of dispositivosAdicionadosProposicao) {
            if (CmdEmdUtil.implicaEmRenumeracaoRedacaoFinal(d)) {
                return true;
            }
        }
        return false;
    }
    // Testa características do dispositivo (considerado fora de bloco de alteração) que implicam
    // em necessidade de renumeração na redação final.
    static implicaEmRenumeracaoRedacaoFinal(d) {
        // rótulo 0 (zero) ou possui sufixo de encaixe (-A, -B...)
        if (d.rotulo && (d.numero === '0' || /.*(?:-\d).*/i.test(d.rotulo))) {
            return true;
        }
        // adjacente a parágrafo ou artigo único
        if (isArtigo(d) || isParagrafo(d)) {
            // Se o dispositivo tiver sido adicionado antes do único cairá no caso anterior de rótulo com 0 (zero)
            // Não é possível testar pelo rótulo porque o parágrafo único está sendo renumerado.
            if (irmaosMesmoTipo(d).filter(i => i.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ORIGINAL).length === 1) {
                return true;
            }
        }
        return false;
    }
    static normalizaCabecalhoComandoEmenda(texto) {
        return removeEspacosDuplicados(texto.replace(/caput/g, '<i>caput</i>'));
    }
    /*
    Dados dois agrupadores adicionados, verifica se são sequenciais e não existe artigo ou agrupador não adicionado entre eles.
    */
    static verificaAgrupadoresAdicionadosEmSequencia(a1, a2) {
        if (!isAgrupadorNaoArticulacao(a1) && !isAgrupadorNaoArticulacao(a2)) {
            return false;
        }
        const filhoNaoAdicionado = this.getFilhoNaoAdicionadoDeAgrupadorAdicionado(a1);
        return !filhoNaoAdicionado && getIrmaoPosteriorIndependenteDeTipo(a1) === a2;
    }
    /*
    Dado um agrupador adicionado retorna o primeiro artigo ou agrupador em sua hierarquia que não seja adicionado.
    Retorna undefined se todos forem adicionados.
    */
    static getFilhoNaoAdicionadoDeAgrupadorAdicionado(agrupador) {
        return buscaNaHierarquiaDispositivos(agrupador, f => {
            return (isArtigo(f) || isAgrupadorNaoArticulacao(f)) && f.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO ? f : undefined;
        });
    }
}

class Referencia {
}
class Elemento extends Referencia {
    constructor() {
        super(...arguments);
        this.nivel = 0;
        this.rotulo = '';
        this.agrupador = false;
        this.editavel = true;
        this.sendoEditado = false;
        this.index = 0;
    }
}

const Block$2 = Quill.import('blots/block');
class EtaBlot extends Block$2 {
    constructor(domNode) {
        super(domNode);
    }
    get instanceBlotName() {
        return EtaBlot.blotName;
    }
    get linha() {
        return this.parent.parent.parent;
    }
    get tamanho() {
        return this.length() - 1;
    }
    get tagName() {
        return this.domNode.tagName;
    }
    get html() {
        return this.domNode.innerHTML !== '<br>' ? this.domNode.innerHTML.replace('&nbsp;', '') : '';
    }
    set html(html) {
        this.domNode.innerHTML = html;
    }
}
EtaBlot.blotName = 'EtaBlot';

var AlinhamentoMenu$4;
(function (AlinhamentoMenu) {
    AlinhamentoMenu[AlinhamentoMenu["Esquerda"] = 0] = "Esquerda";
    AlinhamentoMenu[AlinhamentoMenu["Direita"] = 1] = "Direita";
})(AlinhamentoMenu$4 || (AlinhamentoMenu$4 = {}));
class EtaBlotMenu extends EtaBlot {
    constructor() {
        super(EtaBlotMenu.create());
    }
    get instanceBlotName() {
        return EtaBlotMenu.blotName;
    }
    static create() {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotMenu.className);
        return node;
    }
}
// Site https://www.w3schools.com/howto/tryit.asp?filename=tryhow_css_dropdown_right
EtaBlotMenu.blotName = 'EtaBlotMenu';
EtaBlotMenu.tagName = 'sl-dropdown';
EtaBlotMenu.className = 'lx-eta-dropdown';

class EtaBlotMenuBotao extends EtaBlot {
    constructor() {
        super(EtaBlotMenuBotao.create());
    }
    get instanceBlotName() {
        return EtaBlotMenuBotao.blotName;
    }
    static create() {
        const node = super.create();
        node.setAttribute('variant', 'text');
        node.setAttribute('size', 'small');
        node.setAttribute('slot', 'trigger');
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotMenuBotao.className);
        node.innerHTML = '&vellip;';
        return node;
    }
}
EtaBlotMenuBotao.blotName = 'EtaBlotMenuBotao';
EtaBlotMenuBotao.tagName = 'sl-button';
EtaBlotMenuBotao.className = 'lx-eta-dropbtn';

class EtaBlotMenuConteudo extends EtaBlot {
    constructor(alinhamentoMenu) {
        super(EtaBlotMenuConteudo.create(alinhamentoMenu));
    }
    get instanceBlotName() {
        return EtaBlotMenuConteudo.blotName;
    }
    static create(alinhamentoMenu) {
        const node = super.create();
        const classeAdicional = alinhamentoMenu === AlinhamentoMenu$4.Esquerda ? '' : ' lx-eta-dropdown-content-right';
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotMenuConteudo.className + classeAdicional);
        return node;
    }
}
EtaBlotMenuConteudo.blotName = 'EtaBlotMenuConteudo';
EtaBlotMenuConteudo.tagName = 'sl-menu';
EtaBlotMenuConteudo.className = 'lx-eta-dropdown-content';

class EtaBlotMenuItem extends EtaBlot {
    constructor(acao, callback) {
        super(EtaBlotMenuItem.create(acao, callback));
    }
    get instanceBlotName() {
        return EtaBlotMenuItem.blotName;
    }
    static create(acao, callback) {
        var _a;
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotMenuItem.className);
        node.innerHTML = ((_a = acao.descricao) !== null && _a !== void 0 ? _a : '') + (acao.hotkey ? `<span slot="suffix"> ${acao.hotkey} </span>` : '');
        node.addEventListener('mousedown', () => {
            var _a;
            if (acao.descricao === informarNormaAction.descricao || acao.descricao === InformarDadosAssistenteAction.descricao) {
                const index = (_a = document.getSelection()) === null || _a === void 0 ? void 0 : _a.focusOffset;
                localStorage.setItem('indexCursor', JSON.stringify(index));
            }
            callback(acao);
        });
        return node;
    }
}
EtaBlotMenuItem.blotName = 'EtaBlotMenuItem';
EtaBlotMenuItem.tagName = 'sl-menu-item';
EtaBlotMenuItem.className = 'lx-eta-dropdown-content-item';

class EtaBlotRotulo extends EtaBlot {
    constructor(elemento) {
        super(EtaBlotRotulo.create(elemento));
    }
    get instanceBlotName() {
        return EtaBlotRotulo.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotRotulo.getClasseCSS(elemento));
        node.setAttribute('data-rotulo', elemento.rotulo);
        if (elemento.abreAspas) {
            node.setAttribute('abre-aspas', 'true');
        }
        if (podeInformarNumeracao(elemento)) {
            node.setAttribute('pode-informar-numeracao', 'true');
        }
        if (elemento.tipo) {
            node.setAttribute('tipo-dispositivo', elemento.tipo);
        }
        node.innerHTML = EtaBlotRotulo.montarRotulo(elemento);
        if (elemento.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO && elemento.dispositivoAlteracao) {
            node.title = elemento.existeNaNormaAlterada ? 'Dispositivo existente na norma alterada' : 'Dispositivo a ser adicionado à norma';
        }
        // node.onclick = (): boolean => node.dispatchEvent(new CustomEvent('rotulo', { bubbles: true, cancelable: true, detail: { elemento } }));
        node.onclick = onclick$2(node, elemento);
        return node;
    }
    get rotulo() {
        return this.domNode.getAttribute('data-rotulo');
    }
    format(name, value, abreAspas) {
        if (name === EtaBlotRotulo.blotName) {
            this.domNode.setAttribute('data-rotulo', (abreAspas ? '\u201C' : '') + value);
            if (abreAspas) {
                this.domNode.setAttribute('abre-aspas', 'true');
            }
            this.domNode.innerHTML = value;
        }
        else if (name === EtaBlotRotulo.formatoStyle) {
            this.domNode.setAttribute('style', EtaBlotRotulo.criarAtributoStyle(value));
        }
        else {
            super.format(name, value);
        }
    }
    static criarAtributoStyle(elemento) {
        let style = elemento.tipo === 'Articulacao' ? 'color: #373634; font-weight: 600; line-height: 0.42;' : 'color: #373634; font-weight: 600; line-height: 1.42;';
        if (elemento.agrupador) {
            style = `${style} display: block; font-size: 1rem; text-align: center;`;
        }
        else {
            style = `${style} float: left; margin-right: 10px;`;
        }
        return style;
    }
    static getClasseCSS(elemento) {
        var _a, _b, _c;
        const classeSituacao = {
            [DescricaoSituacao.DISPOSITIVO_ADICIONADO]: 'dispositivo--adicionado',
            [DescricaoSituacao.DISPOSITIVO_MODIFICADO]: 'dispositivo--modificado',
            [DescricaoSituacao.DISPOSITIVO_SUPRIMIDO]: 'dispositivo--suprimido',
        };
        const isAdicionado = elemento.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO;
        return ('texto__rotulo' +
            (elemento.agrupador ? ' texto__rotulo--agrupador' : ' texto__rotulo--padrao') +
            (isAdicionado && elemento.dispositivoAlteracao ? ' rotulo' : '') +
            (' texto__rotulo--' + ((_a = elemento.tipo) === null || _a === void 0 ? void 0 : _a.toLowerCase())) +
            (' ' + ((_c = classeSituacao[(_b = elemento.descricaoSituacao) !== null && _b !== void 0 ? _b : '']) !== null && _c !== void 0 ? _c : '')));
    }
    setEstilo(elemento) {
        this.domNode.setAttribute('class', `${EtaBlotRotulo.getClasseCSS(elemento)}`);
    }
    atualizarAtributos(elemento) {
        this.setEstilo(elemento);
        this.domNode.setAttribute('data-rotulo', elemento.rotulo);
        if (elemento.abreAspas) {
            this.domNode.setAttribute('abre-aspas', 'true');
        }
        else {
            this.domNode.removeAttribute('abre-aspas');
        }
        if (podeInformarNumeracao(elemento)) {
            this.domNode.setAttribute('pode-informar-numeracao', 'true');
        }
        else {
            this.domNode.removeAttribute('pode-informar-numeracao');
        }
        this.domNode.onclick = onclick$2(this.domNode, elemento);
        this.domNode.innerHTML = EtaBlotRotulo.montarRotulo(elemento);
    }
    static montarRotulo(elemento) {
        const descricaoTipo = TipoDispositivo[elemento.tipo.toLowerCase()].descricao;
        return elemento.revisao && EtaBlotRotulo.isRevisaoPrincipalDeExclusaoDeDispositivo(elemento) ? descricaoTipo !== null && descricaoTipo !== void 0 ? descricaoTipo : '' : elemento.rotulo;
    }
    static isRevisaoPrincipalDeExclusaoDeDispositivo(elemento) {
        const r = elemento.revisao;
        return isRevisaoPrincipal(r) && isRevisaoDeExclusao(r);
    }
}
EtaBlotRotulo.blotName = 'EtaBlotRotulo';
EtaBlotRotulo.tagName = 'LABEL';
EtaBlotRotulo.formatoStyle = 'STYLE';
const podeInformarNumeracao = (elemento) => {
    var _a, _b, _c;
    return !!(elemento.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO &&
        elemento.dispositivoAlteracao &&
        (elemento.abreAspas || elemento.tipo === 'Artigo' || ((_c = (_b = (_a = elemento.hierarquia) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.existeNaNormaAlterada) !== null && _c !== void 0 ? _c : true)));
};
const onclick$2 = (node, elemento) => {
    if (podeInformarNumeracao(elemento)) {
        return () => node.dispatchEvent(new CustomEvent('rotulo', { bubbles: true, cancelable: true, detail: { elemento } }));
    }
    else {
        return () => false;
    }
};

class EtaBlotAbreAspas extends EtaBlot {
    constructor(elemento) {
        super(EtaBlotAbreAspas.create(elemento));
        this.elemento = elemento;
    }
    get instanceBlotName() {
        return EtaBlotAbreAspas.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotAbreAspas.className);
        node.innerHTML = EtaBlotAbreAspas.montarHTML(elemento);
        return node;
    }
    static formats() {
        return true;
    }
    atualizarAtributos(elemento) {
        this.elemento = elemento;
        this.domNode.innerHTML = EtaBlotAbreAspas.montarHTML(elemento);
    }
    static montarHTML(elemento) {
        return elemento.abreAspas ? '“' : '';
    }
}
EtaBlotAbreAspas.blotName = 'EtaBlotAbreAspas';
EtaBlotAbreAspas.tagName = 'abre-aspas';
EtaBlotAbreAspas.className = 'abre-aspas';

class EtaBlotConteudo extends EtaBlot {
    constructor(elemento) {
        super(EtaBlotConteudo.create(elemento));
        this._htmlAnt = '';
    }
    get instanceBlotName() {
        return EtaBlotConteudo.blotName;
    }
    static create(elemento) {
        var _a, _b;
        const node = super.create();
        const conteudo = normalizaSeForOmissis((_b = (_a = elemento.conteudo) === null || _a === void 0 ? void 0 : _a.texto) !== null && _b !== void 0 ? _b : '').trim();
        node.setAttribute('class', EtaBlotConteudo.getClasseCSS(elemento));
        node.setAttribute('contenteditable', (elemento === null || elemento === void 0 ? void 0 : elemento.editavel) ? 'true' : 'false');
        node.setAttribute('id', 'texto__dispositivo' + elemento.uuid);
        if (elemento.notaAlteracao) {
            node.setAttribute('nota-alteracao', elemento.notaAlteracao || '');
        }
        if (elemento.fechaAspas) {
            node.setAttribute('fecha-aspas', 'true');
        }
        if (elemento.tipo === 'Omissis' || conteudo.indexOf(TEXTO_OMISSIS) >= 0) {
            node.innerHTML = '<span class="texto__omissis">' + TEXTO_OMISSIS + '</span>';
        }
        else {
            node.innerHTML = conteudo !== '' ? conteudo : '<br>';
        }
        return node;
    }
    set htmlAnt(htmlAnt) {
        this._htmlAnt = htmlAnt;
    }
    get htmlAnt() {
        return this._htmlAnt;
    }
    get alterado() {
        return this._htmlAnt !== this.html;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getClasseCSS(elemento) {
        return 'texto__dispositivo';
    }
    atualizarAtributos(elemento) {
        this.htmlAnt = this.html;
        if (elemento.notaAlteracao) {
            this.domNode.setAttribute('nota-alteracao', elemento.notaAlteracao || '');
        }
        else {
            this.domNode.removeAttribute('nota-alteracao');
        }
        if (elemento.fechaAspas) {
            this.domNode.setAttribute('fecha-aspas', 'true');
        }
        else {
            this.domNode.removeAttribute('fecha-aspas');
        }
    }
}
EtaBlotConteudo.blotName = 'EtaBlotConteudo';
EtaBlotConteudo.tagName = 'P';
EtaBlotConteudo.className = 'texto__dispositivo';

class EtaBlotEspaco extends EtaBlot {
    constructor() {
        super(EtaBlotEspaco.create());
    }
    get instanceBlotName() {
        return EtaBlotEspaco.blotName;
    }
    static create() {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.innerHTML = '&nbsp;';
        return node;
    }
}
EtaBlotEspaco.blotName = 'EtaBlotEspaco';
EtaBlotEspaco.tagName = 'ESPACO';
EtaBlotEspaco.className = 'espaco';

class EtaBlotExistencia extends EtaBlot {
    constructor(elemento) {
        super(EtaBlotExistencia.create(elemento));
    }
    get instanceBlotName() {
        return EtaBlotExistencia.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('id', 'blot-existencia' + elemento.uuid);
        node.classList.add(EtaBlotExistencia.className);
        EtaBlotExistencia._atualizarAtributos(elemento, node);
        return node;
    }
    static formats() {
        return true;
    }
    atualizarElemento(elemento) {
        this.atualizarAtributos(elemento);
    }
    atualizarAtributos(elemento) {
        EtaBlotExistencia._atualizarAtributos(elemento, this.domNode);
    }
    static _atualizarAtributos(elemento, node) {
        node.innerHTML = EtaBlotExistencia.montarHTML(elemento);
        node.onclick = onclick$1(node, elemento);
        if (podeAdicionarAtributoDeExistencia(elemento)) {
            node.classList.add('existencia');
            node.title = elemento.existeNaNormaAlterada ? 'Dispositivo existente na norma alterada' : 'Dispositivo a ser adicionado à norma';
        }
        else {
            node.classList.remove('existencia');
        }
    }
    static montarHTML(elemento) {
        if (podeAdicionarAtributoDeExistencia(elemento)) {
            return elemento.existeNaNormaAlterada ? 'Existente' : 'Novo';
        }
        else {
            return '';
        }
    }
}
EtaBlotExistencia.blotName = 'EtaBlotExistencia';
EtaBlotExistencia.tagName = 'blot-existencia';
EtaBlotExistencia.className = 'blot-existencia';
const onclick$1 = (node, elemento) => {
    if (podeAdicionarAtributoDeExistencia(elemento)) {
        return () => node.dispatchEvent(new CustomEvent('toggle-existencia', { bubbles: true, cancelable: true, detail: { elemento } }));
    }
    else {
        return () => false;
    }
};

class EtaBlotFechaAspas extends EtaBlot {
    constructor(elemento) {
        super(EtaBlotFechaAspas.create(elemento));
        this.elemento = elemento;
    }
    get instanceBlotName() {
        return EtaBlotFechaAspas.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotFechaAspas.className);
        node.innerHTML = EtaBlotFechaAspas.montarHTML(elemento);
        return node;
    }
    static formats() {
        return true;
    }
    atualizarAtributos(elemento) {
        this.elemento = elemento;
        this.domNode.innerHTML = EtaBlotFechaAspas.montarHTML(elemento);
    }
    static montarHTML(elemento) {
        return elemento.fechaAspas ? '” ' : ' ';
    }
}
EtaBlotFechaAspas.blotName = 'EtaBlotFechaAspas';
EtaBlotFechaAspas.tagName = 'fecha-aspas';
EtaBlotFechaAspas.className = 'fecha-aspas';

class EtaBlotNotaAlteracao extends EtaBlot {
    constructor(elemento) {
        super(EtaBlotNotaAlteracao.create(elemento));
    }
    get instanceBlotName() {
        return EtaBlotNotaAlteracao.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotNotaAlteracao.className);
        EtaBlotNotaAlteracao._atualizarAtributos(elemento, node);
        return node;
    }
    static formats() {
        return true;
    }
    atualizarAtributos(elemento) {
        EtaBlotNotaAlteracao._atualizarAtributos(elemento, this.domNode);
    }
    static _atualizarAtributos(elemento, node) {
        node.innerHTML = EtaBlotNotaAlteracao.montarHTML(elemento);
        node.onclick = onclick(node, elemento);
        if (elemento.notaAlteracao) {
            node.setAttribute('nota-alteracao', elemento.notaAlteracao || '');
        }
        else {
            node.removeAttribute('nota-alteracao');
        }
        if (elemento.podeEditarNotaAlteracao) {
            node.classList.add('nota-alteracao-editavel');
        }
        else {
            node.classList.remove('nota-alteracao-editavel');
        }
    }
    static montarHTML(elemento) {
        return elemento.notaAlteracao ? '(' + elemento.notaAlteracao + ')' : ' ';
        // if (!elemento.notaAlteracao) {
        //   return '';
        // } else {
        //   if (elemento.podeEditarNotaAlteracao) {
        //     return '” <span class="nota-alteracao-editavel">(' + elemento.notaAlteracao + ')</span>';
        //   } else {
        //     return '” (' + elemento.notaAlteracao + ')';
        //   }
        // }
    }
}
EtaBlotNotaAlteracao.blotName = 'EtaBlotNotaAlteracao';
EtaBlotNotaAlteracao.tagName = 'nota-alteracao';
EtaBlotNotaAlteracao.className = 'nota-alteracao';
const onclick = (node, elemento) => {
    if (elemento.podeEditarNotaAlteracao) {
        return () => node.dispatchEvent(new CustomEvent('nota-alteracao', { bubbles: true, cancelable: true, detail: { elemento } }));
    }
    else {
        return () => false;
    }
};

var AlinhamentoMenu$3;
(function (AlinhamentoMenu) {
    AlinhamentoMenu[AlinhamentoMenu["Esquerda"] = 0] = "Esquerda";
    AlinhamentoMenu[AlinhamentoMenu["Direita"] = 1] = "Direita";
})(AlinhamentoMenu$3 || (AlinhamentoMenu$3 = {}));
class EtaBlotRevisaoRecusar extends EtaBlot {
    constructor(elemento) {
        super(EtaBlotRevisaoRecusar.create(elemento));
    }
    get instanceBlotName() {
        return EtaBlotRevisaoRecusar.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.innerHTML = ' ';
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotRevisaoRecusar.className);
        node.setAttribute('title', 'Recusar revisão');
        EtaBlotRevisaoRecusar.atualizarAtributos(elemento, node);
        return node;
    }
    atualizarElemento(elemento) {
        EtaBlotRevisaoRecusar.atualizarAtributos(elemento, this.domNode);
    }
    static atualizarAtributos(elemento, node) {
        node.setAttribute('id', 'buttonRevisaoRecusar' + elemento.uuid);
        node.onclick = () => node.dispatchEvent(new CustomEvent('rejeitar-revisao', { bubbles: true, cancelable: true, detail: { elemento } }));
    }
}
EtaBlotRevisaoRecusar.blotName = 'EtaBlotRevisaoRecusar';
EtaBlotRevisaoRecusar.className = 'blot__revisao_recusar';
EtaBlotRevisaoRecusar.tagName = 'button';

var AlinhamentoMenu$2;
(function (AlinhamentoMenu) {
    AlinhamentoMenu[AlinhamentoMenu["Esquerda"] = 0] = "Esquerda";
    AlinhamentoMenu[AlinhamentoMenu["Direita"] = 1] = "Direita";
})(AlinhamentoMenu$2 || (AlinhamentoMenu$2 = {}));
class EtaBlotRevisaoAceitar extends EtaBlot {
    constructor(elemento) {
        super(EtaBlotRevisaoAceitar.create(elemento));
    }
    get instanceBlotName() {
        return EtaBlotRevisaoAceitar.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.innerHTML = ' ';
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotRevisaoAceitar.className);
        node.setAttribute('title', 'Aceitar revisão');
        EtaBlotRevisaoAceitar.atualizarAtributos(elemento, node);
        return node;
    }
    atualizarElemento(elemento) {
        EtaBlotRevisaoAceitar.atualizarAtributos(elemento, this.domNode);
    }
    static atualizarAtributos(elemento, node) {
        node.setAttribute('id', 'buttonRevisaoAceitar' + elemento.uuid);
        node.onclick = () => node.dispatchEvent(new CustomEvent('aceitar-revisao', { bubbles: true, cancelable: true, detail: { elemento } }));
    }
}
EtaBlotRevisaoAceitar.blotName = 'EtaBlotRevisaoAceitar';
EtaBlotRevisaoAceitar.className = 'blot__revisao_aceitar';
EtaBlotRevisaoAceitar.tagName = 'button';

const Container$4 = Quill.import('blots/container');
class EtaContainer extends Container$4 {
    constructor(node) {
        super(node);
    }
    get firstBlot() {
        return this.children.head;
    }
    findBlot(blotName) {
        if (!this.firstBlot) {
            return undefined;
        }
        return this.findBlotByBlotName(this.firstBlot, blotName);
    }
    findBlotByBlotName(node, blotName) {
        if ((node === null || node === void 0 ? void 0 : node.instanceBlotName) === blotName) {
            return node;
        }
        // Verifica se o nó atual é um objeto
        if (typeof node === 'object' && node) {
            // Percorre as propriedades do objeto
            for (const key in node) {
                if (['children', 'head', 'next'].includes(key)) {
                    // Chamada recursiva para cada propriedade do objeto
                    const result = this.findBlotByBlotName(node[key], blotName);
                    if ((result === null || result === void 0 ? void 0 : result.instanceBlotName) === blotName) {
                        return result;
                    }
                }
            }
        }
        return undefined;
    }
    findBlotByClass(node, clazz) {
        // Verifica se o nó atual é do tipo T
        if (node instanceof clazz) {
            return node;
        }
        // Verifica se o nó atual é um objeto
        if (typeof node === 'object' && node) {
            // Percorre as propriedades do objeto
            for (const key in node) {
                if (['children', 'head', 'next'].includes(key)) {
                    // Chamada recursiva para cada propriedade do objeto
                    const result = this.findBlotByClass(node[key], clazz);
                    // Se um nó do tipo T for encontrado, retorna o resultado
                    if (result instanceof clazz) {
                        return result;
                    }
                }
            }
        }
        // Caso nenhum nó do tipo T seja encontrado, retorna undefined
        return undefined;
    }
}

var AlinhamentoMenu$1;
(function (AlinhamentoMenu) {
    AlinhamentoMenu[AlinhamentoMenu["Esquerda"] = 0] = "Esquerda";
    AlinhamentoMenu[AlinhamentoMenu["Direita"] = 1] = "Direita";
})(AlinhamentoMenu$1 || (AlinhamentoMenu$1 = {}));
class EtaBlotRevisao extends EtaBlot {
    constructor(elemento) {
        super(EtaBlotRevisao.create(elemento));
    }
    get instanceBlotName() {
        return EtaBlotRevisao.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotRevisao.className);
        EtaBlotRevisao.atualizarAtributos(elemento, node);
        return node;
    }
    atualizarElemento(elemento) {
        EtaBlotRevisao.atualizarAtributos(elemento, this.domNode);
    }
    static atualizarAtributos(elemento, node) {
        node.setAttribute('id', 'buttonInfoRevisao' + elemento.uuid);
        node.setAttribute('title', EtaBlotRevisao.montarMensagem(elemento));
        node.innerHTML = elemento.revisao.usuario.sigla || getIniciais(elemento.revisao.usuario.nome).charAt(0) || 'R';
        // node.onclick =
        //   isRevisaoDeModificacao(elemento.revisao!) || isRevisaoDeRestauracao(elemento.revisao!)
        //     ? (): boolean => node.dispatchEvent(new CustomEvent('exibir-diferencas', { bubbles: true, cancelable: true, detail: { elemento } }))
        //     : (): boolean => false;
    }
    static montarMensagem(elemento) {
        const revisao = elemento.revisao;
        const pipe = ' | ';
        return 'Ação: ' + revisao.descricao + pipe + 'Usuário: ' + revisao.usuario.nome + pipe + 'Data/Hora: ' + revisao.dataHora;
    }
}
EtaBlotRevisao.blotName = 'EtaBlotRevisao';
EtaBlotRevisao.className = 'blot__revisao';
EtaBlotRevisao.tagName = 'button';

class EtaContainerRevisao extends EtaContainer {
    constructor(elemento) {
        super(EtaContainerRevisao.create(elemento));
    }
    get instanceBlotName() {
        return EtaContainerRevisao.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaContainerRevisao.className);
        EtaContainerRevisao.atualizarAtributos(elemento, node);
        return node;
    }
    atualizarElemento(elemento) {
        EtaContainerRevisao.atualizarAtributos(elemento, this.domNode);
        this.atualizarBlots(elemento);
    }
    atualizarBlots(elemento) {
        var _a, _b, _c;
        (_a = this.blotBotaoAceitarRevisao) === null || _a === void 0 ? void 0 : _a.atualizarElemento(elemento);
        (_b = this.blotBotaoRejeitarRevisao) === null || _b === void 0 ? void 0 : _b.atualizarElemento(elemento);
        (_c = this.blotInfoRevisao) === null || _c === void 0 ? void 0 : _c.atualizarElemento(elemento);
    }
    static atualizarAtributos(elemento, node) {
        node.setAttribute('id', EtaContainerRevisao.className + elemento.uuid);
    }
    get blotBotaoAceitarRevisao() {
        return this.findBlot(EtaBlotRevisaoAceitar.blotName);
    }
    get blotBotaoRejeitarRevisao() {
        return this.findBlot(EtaBlotRevisaoRecusar.blotName);
    }
    get blotInfoRevisao() {
        return this.findBlot(EtaBlotRevisao.blotName);
    }
}
EtaContainerRevisao.blotName = 'EtaContainerRevisao';
EtaContainerRevisao.tagName = 'DIV';
EtaContainerRevisao.className = 'container__revisao';

class EtaContainerTable extends EtaContainer {
    constructor(elemento) {
        var _a, _b, _c, _d;
        super(EtaContainerTable.create(elemento));
        this.elemento = elemento;
        this._lexmlId = (_a = elemento.lexmlId) !== null && _a !== void 0 ? _a : '';
        this._uuid2 = (_b = elemento.uuid2) !== null && _b !== void 0 ? _b : '';
        this._editavel = elemento.editavel;
        this._nivel = elemento.nivel;
        this._numero = (_c = elemento.numero) !== null && _c !== void 0 ? _c : '';
        this._tipo = (_d = elemento.tipo) !== null && _d !== void 0 ? _d : '';
        this._agrupador = elemento.agrupador;
        this._hierarquia = elemento.hierarquia;
        this._descricaoSituacao = elemento.descricaoSituacao ? elemento.descricaoSituacao : undefined;
        this._existeNaNormaAlterada = elemento.existeNaNormaAlterada;
    }
    get instanceBlotName() {
        return EtaContainerTable.blotName;
    }
    static criarId(uuid) {
        return `lxEtaId${uuid !== null && uuid !== void 0 ? uuid : 0}`;
    }
    static create(elemento) {
        var _a, _b;
        const node = super.create();
        const conteudo = normalizaSeForOmissis((_b = (_a = elemento.conteudo) === null || _a === void 0 ? void 0 : _a.texto) !== null && _b !== void 0 ? _b : '').trim();
        // node.setAttribute('contenteditable', 'false'); //elemento?.editavel ? 'true' : 'false');
        node.setAttribute('class', EtaContainerTable.className + ' ' + EtaContainerTable.getClasseCSS(elemento));
        node.setAttribute('id', EtaContainerTable.criarId(elemento.uuid));
        EtaContainerTable.atualizarAtributoRevisao(elemento, node);
        EtaContainerTable.atualizarAtributoExistenciaNormaAlterada(elemento, node);
        if (elemento.tipo === 'Omissis' || conteudo.indexOf(TEXTO_OMISSIS) >= 0) {
            node.classList.add('container_elemento--omissis');
        }
        return node;
    }
    findBlot(blotName) {
        if (!this.blotRotulo) {
            return undefined;
        }
        return this.findBlotRef(this.blotRotulo.next, blotName);
    }
    findBlotRef(blotRef, blotName) {
        if (!blotRef) {
            return;
        }
        return blotRef.instanceBlotName === blotName ? blotRef : this.findBlotRef(blotRef.next, blotName);
    }
    searchBlotRotuloNode(node) {
        // Verifica se o nó atual é do tipo BlotRotulo
        if (node instanceof EtaBlotRotulo) {
            return node;
        }
        // Verifica se o nó atual é um objeto
        if (typeof node === 'object' && node) {
            // Percorre as propriedades do objeto
            for (const key in node) {
                if (['children', 'head', 'next'].includes(key)) {
                    // Chamada recursiva para cada propriedade do objeto
                    const result = this.searchBlotRotuloNode(node[key]);
                    // Se um nó EtaBlotRotulo for encontrado, retorna o resultado
                    if (result instanceof EtaBlotRotulo) {
                        return result;
                    }
                }
            }
        }
        // Caso nenhum nó EtaBlotRotulo seja encontrado, retorna undefined
        return undefined;
    }
    get blotRotulo() {
        // const node = this.children.head?.children?.head.children.head || this.children.head.children.head.next.children.head;
        // return node instanceof EtaBlotRotulo ? node : node?.next;
        return this.searchBlotRotuloNode(this.children.head);
    }
    get blotExistencia() {
        return this.findBlot(EtaBlotExistencia.blotName);
    }
    get blotConteudo() {
        return this.findBlot(EtaBlotConteudo.blotName);
    }
    get blotAbreAspas() {
        return this.findBlot(EtaBlotAbreAspas.blotName);
    }
    get blotFechaAspas() {
        return this.findBlot(EtaBlotFechaAspas.blotName);
    }
    get blotNotaAlteracao() {
        return this.findBlot(EtaBlotNotaAlteracao.blotName);
    }
    get containerRevisao() {
        return this.findBlotByBlotName(this.children, EtaContainerRevisao.blotName);
    }
    get containerDireito() {
        return this.children.head.children.tail;
    }
    get blotInsideContainerDireito() {
        return this.containerDireito.children.head;
    }
    get tamanho() {
        return this.length() - 1;
    }
    get id() {
        var _a;
        return (_a = this.domNode.getAttribute('id')) !== null && _a !== void 0 ? _a : '';
    }
    set agrupador(agrupador) {
        this._agrupador = agrupador;
    }
    get agrupador() {
        return this._agrupador;
    }
    set editavel(editavel) {
        this._editavel = editavel;
        // this.blotConteudo.domNode.contentEditable = this._editavel;
    }
    get editavel() {
        return this._editavel;
    }
    set hierarquia(hierarquia) {
        this._hierarquia = hierarquia;
    }
    get hierarquia() {
        return this._hierarquia;
    }
    set nivel(nivel) {
        this._nivel = nivel;
    }
    get nivel() {
        return this._nivel;
    }
    set numero(numero) {
        this._numero = numero;
    }
    get numero() {
        return this._numero;
    }
    set tipo(tipo) {
        this._tipo = tipo;
    }
    get tipo() {
        return this._tipo;
    }
    set descricaoSituacao(situacao) {
        this._descricaoSituacao = situacao;
    }
    get descricaoSituacao() {
        return this._descricaoSituacao;
    }
    set existeNaNormaAlterada(existeNaNormaAlterada) {
        this._existeNaNormaAlterada = existeNaNormaAlterada;
    }
    get existeNaNormaAlterada() {
        return this._existeNaNormaAlterada;
    }
    get uuid() {
        return parseInt(this.id.substr(7), 0);
    }
    set uuid2(uuid2) {
        this._uuid2 = uuid2;
    }
    get uuid2() {
        return this._uuid2;
    }
    set lexmlId(lexmlId) {
        this._lexmlId = lexmlId;
    }
    get lexmlId() {
        var _a;
        return (_a = this._lexmlId) !== null && _a !== void 0 ? _a : '';
    }
    get html() {
        return this.domNode.innerHTML !== '<br>' ? this.domNode.innerHTML : '';
    }
    set html(html) {
        this.domNode.innerHTML = html;
    }
    resetClasses() {
        this.domNode.classList.remove('dispositivo--adicionado');
        this.domNode.classList.remove('dispositivo--modificado');
        this.domNode.classList.remove('dispositivo--suprimido');
    }
    // TODO Rever a forma atual de se atribuir estilos
    setEstilo(elemento) {
        let classeCSS = '';
        this.resetClasses();
        switch (elemento.descricaoSituacao) {
            case DescricaoSituacao.DISPOSITIVO_ADICIONADO:
                classeCSS = 'dispositivo--adicionado';
                break;
            case DescricaoSituacao.DISPOSITIVO_MODIFICADO:
                classeCSS = 'dispositivo--modificado';
                break;
            case DescricaoSituacao.DISPOSITIVO_SUPRIMIDO:
                classeCSS = 'dispositivo--suprimido';
                break;
        }
        if (classeCSS) {
            this.domNode.classList.add(classeCSS);
        }
        this.blotRotulo.setEstilo(elemento);
    }
    static atualizarAtributoRevisao(elemento, node) {
        if (elemento.revisao) {
            node.setAttribute('em-revisao', 'true');
            if (elemento.revisao.stateType === 'ElementoRemovido') {
                node.setAttribute('excluido', 'true');
            }
            else {
                node.removeAttribute('excluido');
            }
        }
        else {
            node.removeAttribute('em-revisao');
            node.removeAttribute('excluido');
        }
    }
    static atualizarAtributoExistenciaNormaAlterada(elemento, node) {
        if (podeAdicionarAtributoDeExistencia(elemento)) {
            node.setAttribute('existenanormaalterada', (!!elemento.existeNaNormaAlterada).toString());
        }
        else {
            node.removeAttribute('existenanormaalterada');
        }
    }
    atualizarAtributos(elemento) {
        var _a, _b, _c, _d, _e;
        EtaContainerTable.atualizarAtributoRevisao(elemento, this.domNode);
        EtaContainerTable.atualizarAtributoExistenciaNormaAlterada(elemento, this.domNode);
        (_a = this.blotAbreAspas) === null || _a === void 0 ? void 0 : _a.atualizarAtributos(elemento);
        (_b = this.blotRotulo) === null || _b === void 0 ? void 0 : _b.atualizarAtributos(elemento);
        (_c = this.blotExistencia) === null || _c === void 0 ? void 0 : _c.atualizarAtributos(elemento);
        this.blotConteudo.atualizarAtributos(elemento);
        (_d = this.blotFechaAspas) === null || _d === void 0 ? void 0 : _d.atualizarAtributos(elemento);
        (_e = this.blotNotaAlteracao) === null || _e === void 0 ? void 0 : _e.atualizarAtributos(elemento);
    }
    atualizarElemento(elemento) {
        var _a, _b, _c, _d;
        this.elemento = elemento;
        this._lexmlId = (_a = elemento.lexmlId) !== null && _a !== void 0 ? _a : '';
        this._uuid2 = (_b = elemento.uuid2) !== null && _b !== void 0 ? _b : '';
        this._editavel = elemento.editavel;
        this._nivel = elemento.nivel;
        this._numero = (_c = elemento.numero) !== null && _c !== void 0 ? _c : '';
        this._tipo = (_d = elemento.tipo) !== null && _d !== void 0 ? _d : '';
        this._agrupador = elemento.agrupador;
        this._hierarquia = elemento.hierarquia;
        this._descricaoSituacao = elemento.descricaoSituacao ? elemento.descricaoSituacao : undefined;
        this._existeNaNormaAlterada = elemento.existeNaNormaAlterada;
        this.setEstilo(elemento);
        this.atualizarAtributos(elemento);
    }
    format(name, value) {
        if (name === EtaContainerTable.blotName) {
            this.domNode.setAttribute('style', EtaContainerTable.criarAtributoStyle(value));
        }
        else {
            super.format(name, value);
        }
    }
    ativarBorda() {
        this.domNode.classList.add('container__elemento--ativo');
    }
    desativarBorda() {
        this.domNode.classList.remove('container__elemento--ativo');
        this.limparContainerDireito();
    }
    limparContainerDireito() {
        if (this.blotInsideContainerDireito instanceof EtaBlotMenu) {
            this.blotInsideContainerDireito.remove();
            new EtaBlotEspaco().insertInto(this.containerDireito);
        }
    }
    static criarAtributoStyle(elemento) {
        let style = elemento.tipo === 'Articulacao'
            ? `width: 100%; min-height: 1px; line-height: 0.42; margin: 1px`
            : `width: 100%; min-height: 26px; border: 1px solid #ffffff; line-height: 1.42; margin: 0px 2px 0px 5px !important;`;
        if (elemento.agrupador) {
            style = `${style} text-align: center;`;
        }
        return style;
    }
    static getClasseCSS(elemento) {
        var _a;
        let classe = elemento.tipo === 'Articulacao' ? 'container__elemento--articulacao' : 'container__elemento--padrao';
        classe = `${classe} elemento-tipo-${(_a = elemento.tipo) === null || _a === void 0 ? void 0 : _a.toLowerCase()}`;
        if (elemento.agrupador) {
            classe = `${classe} agrupador`;
        }
        else if (elemento.tipo === 'Ementa') {
            classe = `${classe} ementa`;
        }
        else {
            classe = `${classe} h-artigo`;
        }
        if (elemento.dispositivoAlteracao) {
            classe = `${classe} dispositivo-alteracao`;
        }
        return classe;
    }
    isLinhaComMarcacaoDeExclusao() {
        return this.domNode.hasAttribute('excluido');
    }
}
EtaContainerTable.blotName = 'EtaContainerTable';
EtaContainerTable.tagName = 'DIV';
EtaContainerTable.className = 'container__elemento';

/* eslint-disable @typescript-eslint/no-explicit-any */
function cancelarPropagacaoDoEvento(ev) {
    ev.stopPropagation();
    ev.preventDefault();
}

const strCaracteresValidos = "a-z0-9áéíóúÁÉÍÓÚãẽĩõũÃẼĨÕŨàèìòùÀÈÌÒÙäëïöüÄËÏÖÜâêîôûÂÊÎÔÛçÇýÝỹỸỳỲÿŸŶŷñÑ\\s'!@#$%&\\*\\(\\)_\\-+=`{}\\[\\]\\^~<,>.:;?/|\\ªº¹²³£¢¬§¿¡“”";
const CaracteresValidos = new RegExp(`[${strCaracteresValidos}]`, 'i');
const CaracteresNaoValidos = new RegExp(`[^${strCaracteresValidos}]`, 'gi');
const Keyboard = Quill.import('modules/keyboard');
class EtaKeyboard extends Keyboard {
    constructor(quill, options) {
        super(quill, options);
        this.operacaoTecladoInvalida = new Observable();
        this.adicionaElementoTeclaEnter = new Observable();
        this.removeElemento = new Observable();
        this.removeElementoSemTexto = new Observable();
        this.renumeraElemento = new Observable();
        this.transformaElemento = new Observable();
        this.moveElemento = new Observable();
        this.onChange = new Observable();
        this.toggleExistencia = new Observable();
        this.adicionaAgrupador = new Observable();
        this.altGraphPressionado = false;
    }
    listen() {
        this.quill.root.addEventListener('keyup', (ev) => {
            // Trata atalhos de formatação (negrito, itálico, ...)
            if (ev.ctrlKey && !ev.altKey && !ev.shiftKey && 'biBI'.includes(ev.key)) {
                this.onHotKeyToolbar();
                return;
            }
        });
        this.quill.root.addEventListener('keydown', (ev) => {
            var _a;
            this.altGraphPressionado = ev.altKey && ev.location === 2;
            const elementoLinhaAtual = (_a = this.quill.linhaAtual) === null || _a === void 0 ? void 0 : _a.elemento;
            if (!(this.quill.cursorDeTextoEstaSobreLink() || (ev.key === 'Backspace' && this.quill.cursorDeTextoEstaSobreLink(-1))) && this.isTeclaQueAlteraTexto(ev)) {
                this.onChange.notify('keyboard');
            }
            if (this.quill.cursorDeTextoEstaSobreLink() && this.quill.cursorDeTextoEstaSobreLink(-1) && !['Delete', 'Backspace'].includes(ev.key)) {
                if ((!ev.ctrlKey && ev.key.length === 1) || (ev.ctrlKey && 'xvXV'.includes(ev.key)) || (ev.altKey && '0123456789'.includes(ev.key)) || ev.key === 'Enter') {
                    cancelarPropagacaoDoEvento(ev);
                    return;
                }
            }
            else if (this.verificaSelecaoComLink()) {
                cancelarPropagacaoDoEvento(ev);
                return;
            }
            else if (this.quill.linhaAtual.tipo === 'Omissis' &&
                !['ArrowUp', 'ArrowDown'].includes(ev.key) &&
                (this.isTeclaQueAlteraTexto(ev) || ev.key === 'Enter' || ev.altKey || ev.metaKey) &&
                !ev.ctrlKey) {
                if (ev.key === 'Enter') {
                    this.enterEmOmissis();
                }
                cancelarPropagacaoDoEvento(ev);
                return;
            }
            else if (this.quill.cursorDeTextoEstaSobreOmissis() &&
                !['Delete', 'Backspace'].includes(ev.key) &&
                (this.isTeclaQueAlteraTexto(ev) || ev.key === 'Enter' || ev.altKey) &&
                !ev.ctrlKey) {
                if (ev.key === 'Enter') {
                    this.enterEmOmissis();
                }
                cancelarPropagacaoDoEvento(ev);
                return;
            }
            else if ((elementoLinhaAtual === null || elementoLinhaAtual === void 0 ? void 0 : elementoLinhaAtual.descricaoSituacao) === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO && this.isNotTeclasDeNavegacao(ev)) {
                cancelarPropagacaoDoEvento(ev);
            }
            else if (ev.ctrlKey) {
                if (!ev.altKey && !ev.metaKey) {
                    if (['Delete', 'Backspace'].includes(ev.key)) {
                        cancelarPropagacaoDoEvento(ev);
                    }
                    else if (ev.key === 'Home') {
                        this.onTeclaHome(ev);
                    }
                    else if (ev.key === 'End') {
                        this.onTeclaEnd(ev);
                    }
                    else if (ev.key.toLowerCase() === 'a' && !ev.shiftKey) {
                        this.onTeclaCtrlA(ev);
                    }
                    else if (ev.key.toLowerCase() === 'd') {
                        this.onTeclaCtrlD(ev);
                    }
                    else if (ev.key.toLowerCase() === 'z') {
                        this.onTeclaCtrlZ(ev);
                    }
                    else if (ev.key.toLowerCase() === 'y') {
                        this.onTeclaCtrlY(ev);
                    }
                    else if (ev.ctrlKey && ev.shiftKey && ev.key.toLowerCase() === 'a') {
                        this.onTeclaCtrlShiftA(ev);
                    }
                    else if (ev.key === 'b' || ev.key === 'i' || ev.key === 'x' || ev.key === 'v') {
                        this.onValidarTecla(ev);
                    }
                }
                if (ev.altKey || ev.metaKey) {
                    if (['o'].includes(ev.key.toLowerCase())) {
                        this.onHotKeyTransformacaoTipo(ev);
                    }
                    else if (['n', '®'].includes(ev.key.toLowerCase())) {
                        this.onHotKeyRenumeraDispositivo(ev);
                    }
                    else if (['x', '≈'].includes(ev.key.toLowerCase())) {
                        this.onHotKeyToggleExistencia(ev);
                    }
                    else if (['g'].includes(ev.key.toLowerCase())) {
                        this.onHotKeyAdicionaAgrupador(ev);
                    }
                    // Trata caracteres especiais da tecla Alt mo MacOS/Chrome
                    // para os atalhos a, l, n, o, p, t
                    if (['229', '172', '68', '248', '960', '8224'].includes(ev.key.charCodeAt(0).toString())) {
                        let keyFake = '';
                        switch (ev.key.charCodeAt(0).toString()) {
                            case '229':
                                keyFake = 'a';
                                break;
                            case '172':
                                keyFake = 'l';
                                break;
                            case '68':
                                keyFake = 'n';
                                break;
                            case '248':
                                keyFake = 'o';
                                break;
                            case '960':
                                keyFake = 'p';
                                break;
                            case '8224':
                                keyFake = 't';
                                break;
                        }
                        if (keyFake) {
                            // Cria um evento para manipular a tecla pressionada
                            const keyDownFake = new KeyboardEvent('keydown', {
                                key: keyFake,
                            });
                            this.onHotKeyTransformacaoTipo(keyDownFake);
                        }
                    }
                }
            }
            else if (ev.altKey) {
                if (ev.key === 'ArrowUp' || ev.key === 'ArrowDown') {
                    this.onHotKeyMover(ev);
                }
            }
            else if (ev.key === 'ArrowRight') {
                this.onTeclaArrowRight(ev);
            }
            else if (ev.key === 'ArrowLeft') {
                this.onTeclaArrowLeft(ev);
            }
            else if (ev.key === 'ArrowDown') {
                this.onTeclaArrowDown(ev);
            }
            else if (ev.key === 'ArrowUp') {
                this.onTeclaArrowUp(ev);
            }
            else if (ev.key === 'Enter') {
                this.onTeclaEnter(ev);
            }
            else if (ev.key === 'Escape') {
                this.onTeclaEscape(ev);
            }
            else if (ev.key === 'Delete') {
                this.onTeclaDelete(ev);
            }
            else if (ev.key === 'Backspace') {
                this.onTeclaBackspace(ev);
            }
            else if (ev.key === 'Tab') {
                this.onTeclaTab(ev);
            }
            else if (ev.key.length === 1 && CaracteresValidos.test(ev.key)) {
                this.onValidarTecla(ev);
            }
        });
        super.listen();
    }
    isNotTeclasDeNavegacao(ev) {
        return (!ev.ctrlKey && ev.key !== 'ArrowUp' && ev.key !== 'ArrowDown' && ev.key !== 'ArrowRight' && ev.key !== 'ArrowLeft' && ev.key !== 'Home' && ev.key !== 'End' && !ev.shiftKey);
    }
    isTeclaComCaracterGrafico(ev) {
        const teclasComCaracterGrafico = '123456=[]/';
        const DOM_KEY_LOCATION_NUMPAD = 3; //
        return ev.location !== DOM_KEY_LOCATION_NUMPAD && teclasComCaracterGrafico.includes(ev.key);
    }
    isTeclaQueAlteraTexto(ev) {
        // Se teclas Ctrl, Alt ou Meta(?) estiverem pressionadas não faz nada
        // Atalhos para recortar e colar serão tratados em outro lugar
        if (ev.ctrlKey || ev.altKey || ev.metaKey) {
            return false;
        }
        if (this.altGraphPressionado && !this.isTeclaComCaracterGrafico(ev)) {
            return false;
        }
        // Verifica se é um caracter que altera texto
        // OBS: 'Enter' não será tratado porque essa tecla cria um novo elemento e esta ação irá disparar
        //      um evento onchange por conta própria.
        if (['Delete', 'Backspace'].includes(ev.key) || ev.key.length === 1) {
            return true;
        }
        return false;
    }
    verificarOperacaoTecladoPermitida() {
        const textoSelec = this.quill.textoSelecionado;
        if (textoSelec.conteudo) {
            if (textoSelec.quantidadeCR > 0) {
                if (textoSelec.quantidadeCR === 1 && /\n$/gi.test(textoSelec.conteudo)) {
                    const range = this.quill.getSelection();
                    range && this.quill.setSelection(range.index, range.length - 1, Quill.sources.API);
                    return true;
                }
                else {
                    this.operacaoTecladoInvalida.notify();
                    return false;
                }
            }
        }
        return true;
    }
    onTeclaArrowRight(ev) {
        const range = this.quill.getSelection(true);
        const [blotCursor, offset] = this.quill.getLine(range.index);
        if (offset === blotCursor.tamanho) {
            if (blotCursor.linha.next) {
                this.quill.setIndex(this.quill.getIndex(blotCursor.linha.next.blotConteudo), Quill.sources.USER);
            }
            cancelarPropagacaoDoEvento(ev);
        }
    }
    onTeclaArrowLeft(ev) {
        const range = this.quill.getSelection(true);
        const [blotCursor, offset] = this.quill.getLine(range.index);
        if (offset === 0) {
            if (blotCursor.linha.prev) {
                const linhaAnt = blotCursor.linha.prev;
                const index = this.quill.getIndex(linhaAnt.blotConteudo) + linhaAnt.blotConteudo.tamanho;
                this.quill.setIndex(index, Quill.sources.USER);
            }
            cancelarPropagacaoDoEvento(ev);
        }
    }
    onTeclaArrowUp(ev) {
        const range = this.quill.getSelection(true);
        const [blotCursor, offset] = this.quill.getLine(range.index);
        if (offset === 0 || this.quill.cursorDeTextoEstaSobreOmissis()) {
            if (blotCursor.linha.prev) {
                const linhaAnt = blotCursor.linha.prev;
                const index = this.quill.getIndex(linhaAnt.blotConteudo) + linhaAnt.blotConteudo.tamanho;
                this.quill.setIndex(index, Quill.sources.USER);
            }
            cancelarPropagacaoDoEvento(ev);
        }
        if (this.quill.isProcessandoMudancaLinha) {
            cancelarPropagacaoDoEvento(ev);
        }
    }
    onTeclaArrowDown(ev) {
        const range = this.quill.getSelection(true);
        const [blotCursor, offset] = this.quill.getLine(range.index);
        if (offset === blotCursor.tamanho || this.quill.cursorDeTextoEstaSobreOmissis()) {
            if (blotCursor.linha.next) {
                this.quill.setIndex(this.quill.getIndex(blotCursor.linha.next.blotConteudo), Quill.sources.USER);
            }
            cancelarPropagacaoDoEvento(ev);
        }
        if (this.quill.isProcessandoMudancaLinha) {
            cancelarPropagacaoDoEvento(ev);
        }
    }
    onTeclaEnter(ev) {
        if (this.verificarOperacaoTecladoPermitida() && !this.quill.cursorDeTextoEstaSobreLink(-1)) {
            const range = this.quill.getSelection(true);
            this.quill.setSelection(range.index, 0, Quill.sources.SILENT);
            this.adicionaElementoTeclaEnter.notify(range);
        }
        cancelarPropagacaoDoEvento(ev);
    }
    onTeclaEscape(ev) {
        const range = this.quill.getSelection(true);
        this.quill.setIndex(range.index, Quill.sources.SILENT);
        this.quill.setSelection(this.quill.inicioConteudoAtual, 0, Quill.sources.SILENT);
        cancelarPropagacaoDoEvento(ev);
    }
    onTeclaDelete(ev) {
        const range = this.quill.getSelection(true);
        if (!this.quill.linhaAtual.blotConteudo.html) {
            cancelarPropagacaoDoEvento(ev);
            this.removeElementoSemTexto.notify(ev.key);
        }
        else if (!this.verificarOperacaoTecladoPermitida() || range.index === this.quill.fimConteudoAtual) {
            cancelarPropagacaoDoEvento(ev);
        }
        else if (this.quill.cursorDeTextoEstaSobreLink()) {
            let posicao = this.quill.getSelection().index;
            if (!this.quill.cursorDeTextoEstaSobreLink(-1)) {
                posicao += 1;
            }
            this.apagaTextoNaPosicao(posicao);
            cancelarPropagacaoDoEvento(ev);
        }
        else if (this.quill.cursorDeTextoEstaSobreOmissis()) {
            this.quill.linhaAtual.domNode.classList.remove('container_elemento--omissis');
            const posicao = this.quill.getSelection().index;
            this.apagaTextoNaPosicao(posicao);
            cancelarPropagacaoDoEvento(ev);
        }
    }
    onTeclaBackspace(ev) {
        const range = this.quill.getSelection(true);
        if (!this.quill.linhaAtual.blotConteudo.html) {
            cancelarPropagacaoDoEvento(ev);
            this.removeElementoSemTexto.notify(ev.key);
        }
        else if (!this.verificarOperacaoTecladoPermitida() || (range.index === this.quill.inicioConteudoAtual && range.length === 0)) {
            cancelarPropagacaoDoEvento(ev);
        }
        else if (this.quill.cursorDeTextoEstaSobreLink(-1)) {
            const posicao = this.quill.getSelection().index;
            this.apagaTextoNaPosicao(posicao);
            cancelarPropagacaoDoEvento(ev);
        }
        else if (this.quill.cursorDeTextoEstaSobreOmissis()) {
            this.quill.linhaAtual.domNode.classList.remove('container_elemento--omissis');
            const posicao = this.quill.getSelection().index;
            this.apagaTextoNaPosicao(posicao);
            cancelarPropagacaoDoEvento(ev);
        }
    }
    onValidarTecla(ev) {
        if (!this.verificarOperacaoTecladoPermitida()) {
            cancelarPropagacaoDoEvento(ev);
        }
    }
    onTeclaHome(ev) {
        const articulacao = this.quill.getPrimeiraLinha();
        const index = this.quill.getIndex(articulacao.next.blotConteudo);
        this.quill.setIndex(index, Quill.sources.USER);
        this.quill.scroll.domNode.scrollTo(0, 0);
        cancelarPropagacaoDoEvento(ev);
    }
    onTeclaEnd(ev) {
        var _a, _b;
        const index = (_b = this.quill.getIndex(this.quill.getUltimaLinha().blotConteudo) + ((_a = this.quill.getUltimaLinha().blotConteudo) === null || _a === void 0 ? void 0 : _a.tamanho)) !== null && _b !== void 0 ? _b : 0;
        this.quill.setIndex(index, Quill.sources.USER);
        this.quill.scroll.domNode.scrollTo(0, this.quill.scroll.domNode.scrollHeight);
        cancelarPropagacaoDoEvento(ev);
    }
    onTeclaCtrlD(ev) {
        this.removeElemento.notify();
        cancelarPropagacaoDoEvento(ev);
    }
    onTeclaTab(ev) {
        this.transformaElemento.notify(ev);
        cancelarPropagacaoDoEvento(ev);
    }
    onTeclaCtrlZ(ev) {
        this.quill.undo();
        cancelarPropagacaoDoEvento(ev);
    }
    onTeclaCtrlY(ev) {
        this.quill.redo();
        cancelarPropagacaoDoEvento(ev);
    }
    onTeclaCtrlA(ev) {
        // const index: number = this.quill.getIndex(this.quill.scroll.children.head.blotConteudo);
        // this.quill.setSelection(index, this.quill.getLength(), Quill.sources.SILENT);
        cancelarPropagacaoDoEvento(ev);
    }
    onTeclaCtrlShiftA(ev) {
        this.quill.setSelection(this.quill.inicioConteudoAtual, this.quill.linhaAtual.blotConteudo.tamanho, Quill.sources.SILENT);
        cancelarPropagacaoDoEvento(ev);
    }
    onHotKeyRenumeraDispositivo(ev) {
        this.renumeraElemento.notify(ev);
        cancelarPropagacaoDoEvento(ev);
    }
    onHotKeyMover(ev) {
        this.moveElemento.notify(ev);
        cancelarPropagacaoDoEvento(ev);
    }
    onHotKeyTransformacaoTipo(ev) {
        this.transformaElemento.notify(ev);
        cancelarPropagacaoDoEvento(ev);
    }
    onHotKeyToolbar() {
        var _a;
        const texto = (_a = document.getSelection()) === null || _a === void 0 ? void 0 : _a.toString();
        if (texto) {
            this.onChange.notify('toolbar(hotkey)');
        }
    }
    onHotKeyToggleExistencia(ev) {
        this.toggleExistencia.notify(ev);
        cancelarPropagacaoDoEvento(ev);
    }
    onHotKeyAdicionaAgrupador(ev) {
        this.adicionaAgrupador.notify(ev);
        cancelarPropagacaoDoEvento(ev);
    }
    verificaSelecaoComLink() {
        var _a, _b, _c, _d;
        const range = this.quill.getSelection();
        if (!range) {
            return false;
        }
        let iniciaOuTerminaComLink = false;
        const ops = this.quill.getContents(range).ops;
        if (((_b = (_a = ops[0]) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.link) || ((_d = (_c = ops[ops.length - 1]) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.link)) {
            iniciaOuTerminaComLink = true;
        }
        return iniciaOuTerminaComLink;
    }
    apagaTextoNaPosicao(posicao) {
        const [leaf, offset] = this.quill.getLeaf(posicao);
        this.quill.deleteText(posicao - offset, leaf.text.length);
    }
    enterEmOmissis() {
        if (this.verificarOperacaoTecladoPermitida()) {
            const range = this.quill.getSelection(true);
            const inicioLinha = this.quill.getIndex(this.quill.linhaAtual.blotConteudo);
            const tamanho = this.quill.linhaAtual.blotConteudo.length();
            if (range.index !== inicioLinha) {
                range.index = inicioLinha + tamanho - 1;
            }
            this.adicionaElementoTeclaEnter.notify(range);
        }
    }
}

const negrito = `
<svg class="icon-negrito" id="negrito" viewBox="0 0 16 16">
<path class="ql-fill" d="M10.7,13.5c-0.1,0-0.4,0-0.6-0.2L6,7.8C6,7.7,5.8,7.7,5.8,7.8l0,5.1c0,0.3-0.2,0.5-0.5,0.5H3.7
	c-0.3,0-0.5-0.2-0.5-0.5l0-9.5c-0.1-0.2,0-0.4,0.1-0.5c0.1-0.2,0.4-0.4,0.7-0.4h1c0.1,0,0.4,0,0.6,0.2l4.4,5.9
	c0.1,0.1,0.2,0,0.2-0.1V3c0-0.3,0.2-0.5,0.5-0.5h1.5c0.3,0,0.5,0.2,0.5,0.5V13c0,0.3-0.2,0.5-0.5,0.5H10.7z"/>
</svg>
`;
const sublinhado = `
<svg class="icon-sublinhado" id="sublinhado" viewBox="0 0 16 16">
<path class="ql-fill" d="M4.3,9.4c0-0.2,0.1-0.3,0.4-0.3h0.7c0.2,0,0.4,0.1,0.4,0.3C5.8,10.4,6.7,11,8.1,11c1.3,0,2.2-0.5,2.2-1.4
	c0-1.1-1.2-1.4-2.5-1.9C6.3,7.3,4.5,6.8,4.5,5c0-1.6,1.5-2.7,3.5-2.7c1.9,0,3.3,1.1,3.4,2.6c0,0.2-0.1,0.3-0.4,0.3h-0.7
	c-0.2,0-0.3-0.1-0.4-0.3C9.9,4.1,9.2,3.7,8.1,3.7C6.8,3.7,6,4.2,6,5c0,0.9,0.9,1.2,2.2,1.6c1.6,0.5,3.5,1.1,3.5,3.1
	c0,1.6-1.5,2.7-3.6,2.7C5.9,12.3,4.3,11.2,4.3,9.4z"/>
<rect x="3" y="12.9" class="ql-fill" width="9.9" height="0.8"/>
</svg>
`;
const iconeMarginBottom = `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16">
<path class="ql-fill" d="M 13.55 8.55 L 13.55 7.4 1.8 7.4 1.8 8.55 13.55 8.55 M 13.05 2.55 L 13.05 1.4 1.8 1.4 1.8 2.55 13.05 2.55 M 10.55 5.55 L 10.55 4.4 1.8 4.4 1.8 5.55 10.55 5.55 M 10.3 14.65 L 10.3 10.4 1.8 10.4 1.8 14.65 10.3 14.65 M 2.8 11.4 L 9.3 11.4 9.3 13.55 2.8 13.55 2.8 11.4 M 14.6 10.55 L 13.85 9.8 11.3 12.55 13.85 15.2 14.6 14.45 12.8 12.55 14.6 10.55 Z"/>
</svg>
`;
const iconeTextIndent = `
<svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">
<path class="ql-fill" d="M 1.65,2.3 0.9,3.05 2.65,4.95 0.9,6.9 1.65,7.65 4.15,4.95 1.65,2.3 M 2.5,12.45 v 1.1 h 11.25 v -1.1 H 2.5 m 11.25,-2.1 V 9.25 H 2.5 v 1.1 h 11.25 m 0,-4.3 H 6.25 V 7.1 h 7.5 V 6.05 m 0,-3.25 h -7.5 v 1.1 h 7.5 z"></path>
</svg>
`;

const Inline = Quill.import('blots/inline');
class EtaBlotConteudoOmissis extends Inline {
    get instanceBlotName() {
        return EtaBlotConteudoOmissis.blotName;
    }
    static formats() {
        return true;
    }
}
EtaBlotConteudoOmissis.blotName = 'EtaBlotConteudoOmissis';
EtaBlotConteudoOmissis.tagName = 'span';
EtaBlotConteudoOmissis.className = 'texto__omissis';

class EtaBlotMensagem extends EtaBlot {
    constructor(mensagem) {
        super(EtaBlotMensagem.create(mensagem));
    }
    get instanceBlotName() {
        return EtaBlotMensagem.blotName;
    }
    static create(mensagem) {
        const node = super.create();
        let classe = '';
        if (mensagem.tipo === TipoMensagem.INFO) {
            classe = 'mensagem--info';
        }
        else if (mensagem.tipo === TipoMensagem.WARNING) {
            classe = 'mensagem--warning';
        }
        else {
            classe = 'mensagem--danger';
        }
        node.setAttribute('contenteditable', 'false');
        node.classList.add(classe);
        node.innerHTML = mensagem.descricao ? mensagem.descricao : '';
        if (mensagem.fix) {
            node.innerHTML += `. <span class="mensagem__fix">Corrigir agora.</span>`;
            node.onclick = () => node.dispatchEvent(new CustomEvent('mensagem', { bubbles: true, cancelable: true, detail: { mensagem } }));
        }
        return node;
    }
}
EtaBlotMensagem.blotName = 'EtaBlotMensagem';
EtaBlotMensagem.tagName = 'div';
EtaBlotMensagem.className = 'mensagem';

class EtaBlotMensagens extends EtaBlot {
    constructor() {
        super(EtaBlotMensagens.create());
    }
    get instanceBlotName() {
        return EtaBlotMensagens.blotName;
    }
    static create() {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('style', 'font-size: 0.8em;');
        return node;
    }
}
EtaBlotMensagens.blotName = 'mensagens';
EtaBlotMensagens.tagName = 'MENSAGENS';

var AlinhamentoMenu;
(function (AlinhamentoMenu) {
    AlinhamentoMenu[AlinhamentoMenu["Esquerda"] = 0] = "Esquerda";
    AlinhamentoMenu[AlinhamentoMenu["Direita"] = 1] = "Direita";
})(AlinhamentoMenu || (AlinhamentoMenu = {}));
class EtaBlotOpcoesDiff extends EtaBlot {
    constructor(elemento) {
        super(EtaBlotOpcoesDiff.create(elemento));
    }
    get instanceBlotName() {
        return EtaBlotOpcoesDiff.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.innerHTML = ' ';
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaBlotOpcoesDiff.className);
        node.setAttribute('title', 'Exibir diferenças');
        EtaBlotOpcoesDiff.atualizarAtributos(elemento, node);
        return node;
    }
    atualizarElemento(elemento) {
        EtaBlotOpcoesDiff.atualizarAtributos(elemento, this.domNode);
    }
    static atualizarAtributos(elemento, node) {
        node.setAttribute('id', 'buttonExibirDiferencas' + elemento.uuid);
        node.onclick = () => node.dispatchEvent(new CustomEvent('exibir-diferencas', { bubbles: true, cancelable: true, detail: { elemento } }));
    }
}
EtaBlotOpcoesDiff.blotName = 'EtaBlotOpcoesDiff';
EtaBlotOpcoesDiff.className = 'blot__opcoes_diff';
EtaBlotOpcoesDiff.tagName = 'button';

class EtaBlotTipoOmissis extends EtaBlot {
    constructor(elemento) {
        super(EtaBlotTipoOmissis.create(elemento));
    }
    get instanceBlotName() {
        return EtaBlotTipoOmissis.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.classList.add(EtaBlotTipoOmissis.className);
        EtaBlotTipoOmissis._atualizarAtributos(elemento, node);
        return node;
    }
    static formats() {
        return true;
    }
    atualizarElemento(elemento) {
        this.atualizarAtributos(elemento);
    }
    atualizarAtributos(elemento) {
        EtaBlotTipoOmissis._atualizarAtributos(elemento, this.domNode);
    }
    static _atualizarAtributos(elemento, node) {
        node.innerHTML = EtaBlotTipoOmissis.getDescricaoTipoOmissis(elemento);
        if (elemento.tipo === 'Omissis') {
            node.classList.add('tipo-omissis');
        }
        else {
            node.classList.remove('tipo-omissis');
        }
    }
    static getDescricaoTipoOmissis(elemento) {
        switch (elemento.tipoOmissis) {
            case 'inciso-caput':
            case 'inciso-paragrafo':
                return ' Incisos omitidos ';
            case 'paragrafo':
                return ' Parágrafos omitidos ';
            case 'alinea':
                return ' Alíneas omitidas ';
            case 'item':
                return ' Itens omitidos ';
            default:
                return '';
        }
    }
}
EtaBlotTipoOmissis.blotName = 'EtaBlotTipoOmissis';
EtaBlotTipoOmissis.tagName = 'blot-tipo-omissis';
EtaBlotTipoOmissis.className = 'blot-tipo-omissis';

const Clipboard = Quill.import('modules/clipboard');
class EtaClipboard extends connect(rootStore)(Clipboard) {
    constructor(quill, options) {
        super(quill, options);
        this.onChange = new Observable();
        this.onPasteTextoArticulado = new Observable();
        this.quill.root.addEventListener('cut', (ev) => {
            var _a;
            if (this.quill.cursorDeTextoEstaSobreLink()) {
                cancelarPropagacaoDoEvento(ev);
                return;
            }
            const text = (_a = document.getSelection()) === null || _a === void 0 ? void 0 : _a.toString();
            if (text) {
                this.onChange.notify('clipboard');
            }
        });
    }
    convert(html) {
        if (typeof html === 'string') {
            this.container.innerHTML = html;
            return super.convert();
        }
        this.container.innerHTML = this.container.innerHTML
            .replace(CaracteresNaoValidos, '')
            .replace(/(<p\s*)/gi, ' <p')
            .replace(/(<br\s*\/>)/gi, ' ')
            .replace(/<(?!strong)(?!\/strong)(?!em)(?!\/em)(?!sub)(?!\/sub)(?!sup)(?!\/sup)(.*?)>/gi, '')
            .replace(/<([a-z]+) .*?=".*?( *\/?>)/gi, '<$1$2');
        const delta = super.convert();
        this.container.innerHTML = '';
        return delta;
    }
    onPaste(e) {
        var _a, _b;
        if (this.quill.cursorDeTextoEstaSobreLink()) {
            cancelarPropagacaoDoEvento(e);
            return;
        }
        e.preventDefault();
        let html = (_a = e === null || e === void 0 ? void 0 : e.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');
        const textoClipboard = (_b = e === null || e === void 0 ? void 0 : e.clipboardData) === null || _b === void 0 ? void 0 : _b.getData('text/plain');
        const range = this.quill.getSelection();
        if (html) {
            html = removeTagHead(removeTagScript(removeTagStyle(html)));
        }
        if (html && html.length > 0 && removeAllHtmlTags(html).length > 0) {
            const text = ajustaHtmlParaColagem(html);
            if (text !== undefined && this.hasRotulo(text)) {
                this.adicionaDispositivos(textoClipboard, text, range);
                return;
            }
            this.quill.deleteText(range.index, range.length);
            this.quill.clipboard.dangerouslyPasteHTML(range.index, text);
            if (text) {
                this.onChange.notify('clipboard');
            }
        }
        else if (textoClipboard) {
            if (textoClipboard.trim() !== '' && this.hasRotulo(textoClipboard)) {
                this.adicionaDispositivos(textoClipboard, textoClipboard, range);
                return;
            }
            this.quill.clipboard.dangerouslyPasteHTML(range.index, textoClipboard);
            if (textoClipboard) {
                this.onChange.notify('clipboard');
            }
        }
    }
    hasRotulo(texto) {
        var _a;
        const t = (_a = removeAllHtmlTags(texto)) === null || _a === void 0 ? void 0 : _a.replace(/&nbsp;/g, ' ').replace(/["“']/g, '').trim();
        const regexRotulo = /^(parte|livro|t[ií]tulo|cap[ií]tulo|se[cç][aã]o|subse[cç][aã]o|art\.|art|§|par[aá]grafo [uú]nico|[IVXMDC]{1,3}\s*[-–]{1}|[az]{1,2}\)|\d{1,3}[\t .]+).*/i;
        if (t && t.length > 0 && regexRotulo.test(t)) {
            return true;
        }
        return false;
    }
    adicionaDispositivos(textoColadoOriginal, textoColadoAjustado, range) {
        this.onPasteTextoArticulado.notify({ textoColadoOriginal, textoColadoAjustado, range });
    }
}

class EtaContainerOpcoes extends EtaContainer {
    constructor(elemento) {
        super(EtaContainerOpcoes.create(elemento));
    }
    get instanceBlotName() {
        return EtaContainerOpcoes.blotName;
    }
    static create(elemento) {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaContainerOpcoes.className);
        EtaContainerOpcoes.atualizarAtributos(elemento, node);
        return node;
    }
    atualizarElemento(elemento) {
        EtaContainerOpcoes.atualizarAtributos(elemento, this.domNode);
        this.atualizarBlots(elemento);
    }
    atualizarBlots(elemento) {
        var _a;
        (_a = this.blotBotaoExibirDiferencas) === null || _a === void 0 ? void 0 : _a.atualizarElemento(elemento);
    }
    static atualizarAtributos(elemento, node) {
        node.setAttribute('id', EtaContainerOpcoes.className + elemento.uuid);
    }
    get blotBotaoExibirDiferencas() {
        return this.findBlot(EtaBlotOpcoesDiff.blotName);
    }
}
EtaContainerOpcoes.blotName = 'EtaContainerOpcoes';
EtaContainerOpcoes.tagName = 'DIV';
EtaContainerOpcoes.className = 'container__opcoes';

class EtaContainerTdDireito extends EtaContainer {
    constructor(alinhamentoMenu) {
        super(EtaContainerTdDireito.create());
        this.alinhamentoMenu = alinhamentoMenu;
    }
    get instanceBlotName() {
        return EtaContainerTdDireito.blotName;
    }
    static create() {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.setAttribute('class', EtaContainerTdDireito.className);
        return node;
    }
}
EtaContainerTdDireito.blotName = 'EtaContainerTdDireito';
EtaContainerTdDireito.tagName = 'DIV';
EtaContainerTdDireito.className = 'container__menu';

class EtaContainerTdEsquerdo extends EtaContainer {
    constructor(elemento) {
        super(EtaContainerTdEsquerdo.create(elemento));
    }
    get instanceBlotName() {
        return EtaContainerTdEsquerdo.blotName;
    }
    static create(elemento) {
        const node = super.create();
        // node.setAttribute('contenteditable', 'false');
        // node.setAttribute('contenteditable', elemento.editavel ? 'true' : 'false');
        node.setAttribute('class', EtaContainerTdEsquerdo.className + ' container__texto--nivel' + elemento.nivel);
        const fator = Number(getComputedStyle(document.documentElement).getPropertyValue('--elemento-padding-factor'));
        if (fator) {
            const padding = (elemento.agrupador || elemento.tipo === 'Ementa' ? 0 : elemento.nivel) * fator + 5;
            node.setAttribute('style', `padding-left: ${padding}px;`);
        }
        if (elemento.tipoOmissis) {
            node.setAttribute('tipo-omissis', elemento.tipoOmissis);
        }
        return node;
    }
}
EtaContainerTdEsquerdo.blotName = 'EtaContainerTdEsquerdo';
EtaContainerTdEsquerdo.tagName = 'DIV';
EtaContainerTdEsquerdo.className = 'container__texto';
EtaContainerTdEsquerdo.classLevel = 'level';

class EtaContainerTr extends EtaContainer {
    constructor(editavel, alinhamentoMenu) {
        super(EtaContainerTr.create(editavel, alinhamentoMenu));
    }
    get instanceBlotName() {
        return EtaContainerTr.blotName;
    }
    static create(editavel, alinhamentoMenu) {
        const node = super.create();
        const classeAdicional = alinhamentoMenu === AlinhamentoMenu$4.Esquerda ? ' container__linha--reverse' : '';
        // node.setAttribute('contenteditable', editavel ? 'true' : 'false');
        node.setAttribute('class', EtaContainerTr.className + classeAdicional);
        return node;
    }
}
EtaContainerTr.blotName = 'EtaContainerTr';
EtaContainerTr.tagName = 'DIV';
EtaContainerTr.className = 'container__linha';

class EtaQuillBuffer extends Quill {
    constructor(editorHtml, op) {
        super(editorHtml, op);
    }
    getConteudoHtml(html, offset, tamanho) {
        const blotBuffer = this.scroll.children.head;
        this.setConteudo(this.converterHtmlParaDelta(html), Quill.sources.SILENT);
        this.deleteText(offset + tamanho, blotBuffer.length() - tamanho - 1, Quill.sources.SILENT);
        if (offset > 0) {
            this.deleteText(0, offset, Quill.sources.SILENT);
        }
        return blotBuffer.domNode.innerHTML;
    }
    converterHtmlParaDelta(html) {
        return this.clipboard.convert(html !== null && html !== void 0 ? html : '');
    }
    converterDeltaParaHtml(delta) {
        this.setConteudo(delta, Quill.sources.SILENT);
        return this.scroll.children.head.domNode.innerHTML;
    }
    setConteudo(delta, source) {
        var _a;
        const blotBuffer = this.scroll.children.head;
        let index = 0;
        if (blotBuffer.length() > 1) {
            this.deleteText(index, blotBuffer.length() - 1, source !== null && source !== void 0 ? source : Quill.sources.SILENT);
        }
        this.insertText(index, ' ', Quill.sources.SILENT);
        (_a = delta.ops) === null || _a === void 0 ? void 0 : _a.forEach((op) => {
            if (op.attributes) {
                this.insertText(index, op.insert, op.attributes, source !== null && source !== void 0 ? source : Quill.sources.SILENT);
            }
            else {
                this.insertText(index, op.insert, source !== null && source !== void 0 ? source : Quill.sources.SILENT);
            }
            index += op.insert.length;
        });
        this.deleteText(index, 1, Quill.sources.SILENT);
    }
}

class EtaQuill extends Quill {
    constructor(editorHtml, bufferHtml, op) {
        super(editorHtml, op);
        this._undoEstruturaVazio = true;
        this._redoEstruturaVazio = true;
        // Utilizado no modulo keyboard para anular eventos subrepostos durante o
        // processamento da mudança de elemento atual. Isso acontece quando o usuário
        // aperta as teclas que provocam a mudança de elemento muito rápido
        // (ArrowDown e ArrowUp).
        this._processandoMudancaLinha = false;
        this.undoRedoEstrutura = new Observable();
        this.elementoSelecionado = new Observable();
        this.aspasAberta = false;
        this.customClickHandler = (ev) => {
            try {
                let blot = EtaQuill.find(ev.target);
                if (['EtaBlotOpcoesDiff'].includes(blot.instanceBlotName)) {
                    return;
                }
                while (blot && blot.instanceBlotName !== 'EtaContainerTable') {
                    blot = blot.parent;
                }
                blot && blot === this.linhaAtual && blot.blotConteudo.domNode.focus();
            }
            catch (error) {
                // não faz nada
            }
        };
        this.observableSelectionChange = new Observable();
        this.onSelectionChange = (range, oldRange) => {
            // Guarda a linhaAtual corrente
            // OBS: o valor de "this.linhaAtual" será alterado dentro de "this.verificarMudouLinha" de acordo com alguns critérios.
            const linhaAtualAux = this.linhaAtual;
            this._mudouDeLinha = this.verificarMudouLinha(range, oldRange);
            if (this._mudouDeLinha) {
                this.observableSelectionChange.notify(linhaAtualAux);
                this.aspasAberta = false;
                this.limparHistory();
            }
        };
        this.onTextChange = () => {
            if (this._linhaAtual) {
                setTimeout(() => {
                    var _a;
                    ((_a = this.linhaAtual) === null || _a === void 0 ? void 0 : _a.blotConteudo) && this.acertarAspas();
                }, 0);
            }
        };
        this.on('text-change', this.onTextChange);
        this.on('selection-change', this.onSelectionChange);
        this.buffer = new EtaQuillBuffer(bufferHtml, {});
        this.root.addEventListener('dragstart', (e) => {
            e.preventDefault();
        });
        this.root.addEventListener('drop', (e) => {
            e.preventDefault();
        });
        this.root.addEventListener('click', this.customClickHandler);
    }
    get mudouDeLinha() {
        var _a;
        return (_a = this._mudouDeLinha) !== null && _a !== void 0 ? _a : false;
    }
    get linhaAnterior() {
        return this._linhaAnterior;
    }
    get linhaAtual() {
        return this._linhaAtual;
    }
    get inicioConteudoAtual() {
        return this.linhaAtual.blotConteudo ? this.getIndex(this.linhaAtual.blotConteudo) : 0;
    }
    get fimConteudoAtual() {
        return this.inicioConteudoAtual + this.linhaAtual.blotConteudo.tamanho;
    }
    get textoSelecionado() {
        var _a, _b, _c;
        const range = (_a = this.getSelection()) !== null && _a !== void 0 ? _a : { index: 0, length: 0 };
        const texto = this.getText().substr(range.index, range.length);
        return {
            conteudo: texto,
            quantidadeCR: (_c = (_b = texto.match(/(\n)/gi)) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0,
        };
    }
    get isUndoEstruturaVazio() {
        return this._undoEstruturaVazio;
    }
    set undoEstruturaVazio(undoVazio) {
        this._undoEstruturaVazio = undoVazio;
    }
    get isRedoEstruturaVazio() {
        return this._redoEstruturaVazio;
    }
    set redoEstruturaVazio(redoVazio) {
        this._redoEstruturaVazio = redoVazio;
    }
    get isProcessandoMudancaLinha() {
        return this._processandoMudancaLinha;
    }
    set processandoMudancaLinha(processando) {
        this._processandoMudancaLinha = processando;
    }
    static configurar() {
        const Parchment = EtaQuill.import('parchment');
        const id = new Parchment.Attributor.Attribute('id', 'id', { scope: Parchment.Scope.BLOCK });
        const paddingLeft = new Parchment.Attributor.Style('paddingLeft', 'padding-left', { scope: Parchment.Scope.BLOCK });
        const border = new Parchment.Attributor.Style('border', 'border', { scope: Parchment.Scope.BLOCK });
        const borderColor = new Parchment.Attributor.Style('borderColor', 'border-color', { scope: Parchment.Scope.BLOCK });
        const display = new Parchment.Attributor.Style('display', 'display', { scope: Parchment.Scope.BLOCK });
        const ariaLabel = new Parchment.Attributor.Style('aria-label', 'aria-label', { scope: Parchment.Scope.BLOCK });
        const DataRotulo = new Parchment.Attributor.Attribute('dataRotulo', 'data-rotulo', { scope: Parchment.Scope.BLOCK });
        const icons = Quill.import('ui/icons');
        icons['bold'] = negrito;
        // set Quill to use <b> and <i>, not <strong> and <em>
        const bold = Quill.import('formats/bold');
        bold.tagName = 'b'; // Quill uses <strong> by default
        Quill.register(bold, true);
        const italic = Quill.import('formats/italic');
        italic.tagName = 'i'; // Quill uses <em> by default
        Quill.register(italic, true);
        EtaQuill.register('modules/clipboard', EtaClipboard, true);
        EtaQuill.register('modules/keyboard', EtaKeyboard, true);
        EtaQuill.register(EtaBlotConteudoOmissis, true);
        EtaQuill.register(EtaBlotAbreAspas, true);
        EtaQuill.register(EtaBlotFechaAspas, true);
        EtaQuill.register(EtaBlotNotaAlteracao, true);
        EtaQuill.register(EtaBlotExistencia, true);
        EtaQuill.register(EtaBlotTipoOmissis, true);
        EtaQuill.register(EtaBlotConteudo, true);
        EtaQuill.register(EtaBlotEspaco, true);
        EtaQuill.register(EtaBlotMensagem, true);
        EtaQuill.register(EtaBlotMensagens, true);
        EtaQuill.register(EtaBlotMenuBotao, true);
        EtaQuill.register(EtaBlotMenuConteudo, true);
        EtaQuill.register(EtaBlotMenuItem, true);
        EtaQuill.register(EtaBlotMenu, true);
        EtaQuill.register(EtaBlotRotulo, true);
        EtaQuill.register(EtaContainerTable, true);
        EtaQuill.register(EtaContainerTdEsquerdo, true);
        EtaQuill.register(EtaContainerTdDireito, true);
        EtaQuill.register(EtaContainerTr, true);
        EtaQuill.register(EtaContainerRevisao, true);
        EtaQuill.register(EtaBlotRevisao, true);
        EtaQuill.register(EtaBlotRevisaoAceitar, true);
        EtaQuill.register(EtaBlotRevisaoRecusar, true);
        EtaQuill.register(EtaContainerOpcoes, true);
        EtaQuill.register(EtaBlotOpcoesDiff, true);
        EtaQuill.register(id, true);
        EtaQuill.register(paddingLeft, true);
        EtaQuill.register(border, true);
        EtaQuill.register(borderColor, true);
        EtaQuill.register(display, true);
        EtaQuill.register(ariaLabel, true);
        EtaQuill.register(DataRotulo, true);
    }
    destroi() {
        var _a, _b, _c;
        (_a = this.root) === null || _a === void 0 ? void 0 : _a.removeEventListener('click', this.customClickHandler);
        this.off('text-change', this.onTextChange);
        this.off('selection-change', this.onSelectionChange);
        (_b = this.keyboard) === null || _b === void 0 ? void 0 : _b.operacaoTecladoInvalida.clean();
        (_c = this.keyboard) === null || _c === void 0 ? void 0 : _c.adicionaElementoTeclaEnter.clean();
    }
    getConteudoHtmlParteLinha(blotConteudo, offset, tamanho) {
        return this.buffer.getConteudoHtml(blotConteudo.html, offset, tamanho);
    }
    getPrimeiraLinha() {
        return this.scroll.children.head;
    }
    getUltimaLinha() {
        return this.scroll.children.tail;
    }
    getLinhaByUuid2(uuid2, linha = this.getPrimeiraLinha()) {
        if (linha.uuid2 === uuid2) {
            return linha;
        }
        if (linha.next) {
            return this.getLinhaByUuid2(uuid2, linha.next);
        }
        else {
            return undefined;
        }
    }
    getLinha(uuid, linha = this.getPrimeiraLinha()) {
        if (linha.uuid === uuid) {
            return linha;
        }
        if (linha.next) {
            return this.getLinha(uuid, linha.next);
        }
        else {
            return undefined;
        }
    }
    getLinhaPorId(uuid) {
        return Quill.find(this.getHtmlElement(EtaContainerTable.criarId(uuid)), false);
    }
    setIndex(index, source = Quill.sources.USER) {
        var _a;
        const range = (_a = this.getSelection(true)) !== null && _a !== void 0 ? _a : { index: 0, length: 0 };
        if (index !== range.index || range.length !== 0) {
            try {
                this.setSelection(index, 0, source);
            }
            catch (error) {
                this.setSelection(index - 1, 0, source);
            }
        }
    }
    setConteudoLinha(blotConteudo, delta, source) {
        var _a;
        let index = this.getIndex(blotConteudo);
        if (blotConteudo.length() > 1) {
            this.deleteText(index, blotConteudo.length() - 1, source !== null && source !== void 0 ? source : Quill.sources.SILENT);
        }
        this.insertText(index, ' ', Quill.sources.SILENT);
        (_a = delta.ops) === null || _a === void 0 ? void 0 : _a.forEach((op) => {
            if (op.attributes) {
                this.insertText(index, op.insert, op.attributes, source !== null && source !== void 0 ? source : Quill.sources.SILENT);
            }
            else {
                this.insertText(index, op.insert, source !== null && source !== void 0 ? source : Quill.sources.SILENT);
            }
            index += op.insert.length;
        });
        this.deleteText(index, 1, Quill.sources.SILENT);
    }
    converterHtmlParaDelta(html) {
        return this.buffer.converterHtmlParaDelta(html);
    }
    converterDeltaParaHtml(delta) {
        return this.buffer.converterDeltaParaHtml(delta);
    }
    irProximaLinha() {
        var _a;
        const index = this.getIndex((_a = this._linhaAtual) === null || _a === void 0 ? void 0 : _a.next.blotConteudo);
        this.setSelection(index, 0);
    }
    desmarcarLinhaAtual(linhaCursorAnt) {
        this._linhaAnterior = linhaCursorAnt;
        linhaCursorAnt === null || linhaCursorAnt === void 0 ? void 0 : linhaCursorAnt.desativarBorda();
    }
    marcarLinhaAtual(linhaCursor) {
        if (linhaCursor && linhaCursor.tipo !== 'Articulacao') {
            this.atualizarLinhaCorrente(linhaCursor);
            this.elementoSelecionado.notify(linhaCursor.uuid);
        }
    }
    undo() {
        if (this.history.stack.undo.length === 0) {
            if (!this.isUndoEstruturaVazio) {
                this.undoRedoEstrutura.notify(EtaQuill.UNDO);
            }
        }
        else {
            this.history.undo();
            this.focus();
        }
    }
    redo() {
        if (this.history.stack.redo.length === 0) {
            if (!this.isRedoEstruturaVazio) {
                this.undoRedoEstrutura.notify(EtaQuill.REDO);
            }
        }
        else {
            this.history.redo();
            this.focus();
        }
    }
    limparHistory() {
        setTimeout(() => {
            this.history.clear();
        }, 0);
    }
    desmarcarLinhas() {
        document.querySelectorAll('.container__elemento--ativo').forEach(elemento => {
            const linha = this.getLinhaPorId(parseInt(elemento.id.substr(7), 0));
            linha.desativarBorda();
        });
    }
    verificarMudouLinha(range, oldRange) {
        // correção bug: cursor se perde ao teclar ↑ na primeira linha
        if (oldRange && (range === null || range === void 0 ? void 0 : range.index) === 0 && (range === null || range === void 0 ? void 0 : range.length) === 0) {
            this.setSelection(oldRange.index, 0);
            return false;
        }
        if (range) {
            const blotCursor = this.getLine(range.index)[0];
            const linhaCursor = blotCursor.linha;
            if (blotCursor.tagName === EtaBlotRotulo.tagName ||
                blotCursor.tagName === EtaBlotEspaco.tagName ||
                blotCursor.tagName === EtaBlotMenu.tagName ||
                blotCursor.tagName === EtaBlotMensagens.tagName ||
                blotCursor.tagName === EtaBlotAbreAspas.tagName ||
                blotCursor.tagName === EtaBlotTipoOmissis.tagName ||
                blotCursor.tagName === EtaBlotExistencia.tagName) {
                this.setSelection(this.getIndex(blotCursor.linha.blotConteudo), 0, Quill.sources.SILENT);
            }
            else if (blotCursor.tagName === EtaBlotFechaAspas.tagName || blotCursor.tagName === EtaBlotNotaAlteracao.tagName) {
                this.setSelection(this.getIndex(blotCursor.linha.blotFechaAspas) - 1, 0, Quill.sources.SILENT);
            }
            if (oldRange) {
                const blotCursorAnt = this.getLine(oldRange.index)[0];
                if (blotCursorAnt) {
                    const linhaCursorAnt = blotCursorAnt.linha;
                    if (linhaCursor === linhaCursorAnt) {
                        return false;
                    }
                }
            }
            this.desmarcarLinhas();
            this.marcarLinhaAtual(linhaCursor);
            return true;
        }
        return false;
    }
    getHtmlElement(id) {
        return this.root.querySelector(`#${id}`);
    }
    acertarAspas() {
        var _a, _b;
        if (this._linhaAtual) {
            const index = this.inicioConteudoAtual;
            const texto = (_b = this.getText(index, (_a = this.linhaAtual) === null || _a === void 0 ? void 0 : _a.blotConteudo.tamanho)) !== null && _b !== void 0 ? _b : '';
            let posicaoTexto = index;
            if (texto.indexOf('"') > -1) {
                for (let i = 0; i < texto.length; i++) {
                    if (texto[i] === '"') {
                        posicaoTexto += i;
                        this.deleteText(posicaoTexto, 1, Quill.sources.SILENT);
                        this.insertText(posicaoTexto, this.aspasAberta ? '”' : '“', Quill.sources.SILENT);
                        this.aspasAberta = !this.aspasAberta;
                        posicaoTexto = index;
                    }
                }
            }
        }
    }
    atualizarLinhaCorrente(linha) {
        this.processandoMudancaLinha = true;
        this._linhaAtual = linha;
        this._linhaAtual.blotConteudo.htmlAnt = this._linhaAtual.blotConteudo.html;
        linha.ativarBorda();
        this.scrollToElemento(linha.uuid);
    }
    scrollToElemento(uuid) {
        const el = this.getHtmlElement(EtaContainerTable.criarId(uuid));
        setTimeout(() => {
            if (!this.isInEtaBoxViewport(el)) {
                this.scrollIntoEtaBox(el);
                // el.scrollIntoView({behavior: 'smooth', block: 'center'});
            }
        }, 0);
    }
    scrollIntoEtaBox(el) {
        var _a;
        const offsetTopElement = el.offsetTop;
        (_a = el.closest('.ql-editor')) === null || _a === void 0 ? void 0 : _a.scrollTo(0, offsetTopElement);
    }
    isInEtaBoxViewport(el) {
        const rect = el.getBoundingClientRect();
        const lxEtaBox = el.closest('#lx-eta-box');
        const etaBoxHeight = (lxEtaBox === null || lxEtaBox === void 0 ? void 0 : lxEtaBox.getBoundingClientRect().bottom) || 0;
        return rect.top >= 0 && rect.bottom <= etaBoxHeight;
    }
    cursorDeTextoEstaSobreLink(deslocamento = 0) {
        var _a;
        const range = this.getSelection();
        if (range) {
            const ops = this.getContents(range.index + deslocamento, 1).ops;
            return !ops || !ops[0] ? false : (_a = ops[0].attributes) === null || _a === void 0 ? void 0 : _a.link;
        }
        return false;
    }
    cursorDeTextoEstaSobreOmissis() {
        const range = this.getSelection();
        if (range) {
            const textBlot = this.getLeaf(range.index);
            return textBlot[0].text === TEXTO_OMISSIS;
        }
        return false;
    }
}
EtaQuill.UNDO = 'undo';
EtaQuill.REDO = 'redo';

class EtaBlotQuebraLinha extends EtaBlot {
    constructor() {
        super(EtaBlotQuebraLinha.create());
    }
    // static className = 'espaco';
    get instanceBlotName() {
        return EtaBlotQuebraLinha.blotName;
    }
    static create() {
        const node = super.create();
        //node.setAttribute('contenteditable', 'false');
        //node.innerHTML = '&nbsp;';
        return node;
    }
}
EtaBlotQuebraLinha.blotName = 'EtaBlotQuebraLinha';
EtaBlotQuebraLinha.tagName = 'BR';

class EtaQuillUtil {
    static criarContainerLinha(elemento) {
        const etaTable = new EtaContainerTable(elemento);
        const etaTrContainer = new EtaContainerTr(elemento.editavel, this.alinhamentoMenu);
        const etaTdTexto = new EtaContainerTdEsquerdo(elemento);
        const etaTdEspaco = new EtaContainerTdDireito(this.alinhamentoMenu);
        if (elemento.abreAspas) {
            new EtaBlotAbreAspas(elemento).insertInto(etaTdTexto);
        }
        new EtaBlotRotulo(elemento).insertInto(etaTdTexto);
        if (elemento.dispositivoAlteracao === true && elemento.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
            new EtaBlotExistencia(elemento).insertInto(etaTdTexto);
        }
        if (elemento.tipo === 'Omissis') {
            new EtaBlotTipoOmissis(elemento).insertInto(etaTdTexto);
        }
        if (elemento.agrupador) {
            new EtaBlotQuebraLinha().insertInto(etaTdTexto);
        }
        new EtaBlotConteudo(elemento).insertInto(etaTdTexto);
        // new EtaBlotFechaAspas(elemento).insertInto(etaTdTexto);
        // new EtaBlotNotaAlteracao(elemento).insertInto(etaTdTexto);
        if (elemento.fechaAspas !== undefined && elemento.fechaAspas) {
            new EtaBlotFechaAspas(elemento).insertInto(etaTdTexto);
            new EtaBlotNotaAlteracao(elemento).insertInto(etaTdTexto);
        }
        new EtaBlotEspaco().insertInto(etaTdEspaco);
        if (elemento.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO ||
            (elemento.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO && elemento.revisao && elemento.revisao.descricao === 'Texto do dispositivo foi alterado')) {
            EtaQuillUtil.criarContainerOpcoes(elemento).insertInto(etaTrContainer);
        }
        if (elemento.revisao && isRevisaoPrincipal(elemento.revisao)) {
            EtaQuillUtil.criarContainerRevisao(elemento).insertInto(etaTrContainer);
        }
        etaTdTexto.insertInto(etaTrContainer);
        etaTdEspaco.insertInto(etaTrContainer);
        etaTrContainer.insertInto(etaTable);
        return etaTable;
    }
    static criarContainerRevisao(elemento) {
        const etaContainerRevisao = new EtaContainerRevisao(elemento);
        new EtaBlotRevisaoAceitar(elemento).insertInto(etaContainerRevisao);
        new EtaBlotRevisaoRecusar(elemento).insertInto(etaContainerRevisao);
        new EtaBlotRevisao(elemento).insertInto(etaContainerRevisao);
        return etaContainerRevisao;
    }
    static criarContainerOpcoes(elemento) {
        const etaContainerOpcoes = new EtaContainerOpcoes(elemento);
        new EtaBlotOpcoesDiff(elemento).insertInto(etaContainerOpcoes);
        return etaContainerOpcoes;
    }
    static criarContainerMensagens(elemento) {
        const etaTrContainer = new EtaContainerTr(false, this.alinhamentoMenu);
        const etaTdMensagens = new EtaContainerTdEsquerdo(elemento);
        const etaTdEspaco = new EtaContainerTdDireito(this.alinhamentoMenu);
        if (elemento.mensagens && elemento.mensagens.length > 0) {
            elemento.mensagens.forEach((mensagem) => {
                new EtaBlotMensagem(mensagem).insertInto(etaTdMensagens);
            });
        }
        new EtaBlotEspaco().insertInto(etaTdEspaco);
        etaTdMensagens.domNode.classList.add('container__texto--mensagem');
        etaTdMensagens.insertInto(etaTrContainer);
        etaTdEspaco.insertInto(etaTrContainer);
        return etaTrContainer;
    }
}
EtaQuillUtil.alinhamentoMenu = AlinhamentoMenu$4.Esquerda;

class Norma {
    constructor(urn = '', nomePreferido = '', nomePorExtenso = '', nomes = [], nomesAlternativos = [], ementa = '') {
        this.urn = '';
        this.nomePreferido = '';
        this.nomesAlternativos = [];
        this.nomes = [];
        this.ementa = '';
        this.nomePorExtenso = '';
        this.urn = urn;
        this.nomePreferido = nomePreferido;
        this.nomesAlternativos = nomesAlternativos;
        this.nomes = nomes;
        this.ementa = ementa;
        this.nomePorExtenso = nomePorExtenso;
    }
    numero() {
        return this.urn.split(';')[1];
    }
    tipo() {
        return this.urn.split(':')[4];
    }
    sData() {
        return this.urn.split(':')[5].split(';')[0];
    }
    data() {
        const stringData = this.sData();
        return new Date(stringData);
    }
    dataDDMMYYYY() {
        return formatDDMMYYYY(this.data());
    }
}

let AutocompleteAsync = class AutocompleteAsync extends s {
    constructor() {
        super(...arguments);
        this.placeholder = '';
        this.label = '';
        this.items = [];
        this.opened = false;
        this.maxSuggestions = 10;
        this.onSearch = (value) => console.log('Texto da pesquisa', value);
        this.onSelect = (value) => console.log('Item selecionado:', value);
        this.onChange = (value) => console.log('Mudança texto:', value);
        this._interval = 1000;
        this._bound = {};
        this._blur = false;
        this._mouseEnter = false;
        this._search = () => {
            const { value } = this.contentElement;
            clearTimeout(this._timer);
            if (value.length >= 5) {
                this._timer = setTimeout(() => {
                    this.onSearch(value);
                }, this._interval);
            }
        };
    }
    render() {
        var _a;
        return $ `
      <style>
        .suggest-container {
          position: relative;
        }

        ul {
          position: absolute;
          display: block;
          list-style-type: none;
          margin: 0;
          padding: 0;
          z-index: 10000;
          border: 1px solid grey;
          background: white;
        }
        li {
          padding: 4px;
          cursor: pointer;
        }
        li.active {
          background: whitesmoke;
        }
        [hidden] {
          display: none;
        }

        .lexml-autocomplete-input {
          width: 100%;
        }

        @media (max-width: 576px) {
          .lexml-autocomplete-label {
            width: calc(100% - 2px);
            display: block;
          }
          .lexml-autocomplete-input {
            width: calc(100% - 2px);
          }
        }
      </style>
      <slot id="dropdown-input">
        <sl-input
          id="defaultInput"
          class="lexml-autocomplete-input"
          type="text"
          label=${this.label}
          placeholder=${this.placeholder}
          .value=${((_a = this.value) === null || _a === void 0 ? void 0 : _a.description) || ''}
          @change=${e => this._handleChange(e.target.value)}
        ></sl-input>
      </slot>
      <div class="suggest-container">
        <ul id="suggestions" ?hidden=${!this.opened} @mouseenter=${this._handleItemMouseEnter} @mouseleave=${this._handleItemMouseLeave}>
          ${this.items.map((item) => $ `<li @click=${() => this.autocomplete(item)}>${item.description}</li>`)}
        </ul>
      </div>
    `;
    }
    /**
     * Input element getter
     */
    get contentElement() {
        if (this._inputEl)
            return this._inputEl; // Cache
        if (!this.hasUpdated)
            return undefined; // No shadow root, no element to use
        const slotElement = this.shadowRoot.getElementById('dropdown-input');
        const slotInputList = slotElement.assignedElements();
        this._inputEl = slotInputList.length ? slotInputList[0] : this.shadowRoot.getElementById('defaultInput');
        return this._inputEl;
    }
    /**
     * Value getter from input element.
     */
    get value() {
        return this.contentElement && this.contentElement.value;
    }
    /**
     * Value setter to input element.
     */
    set value(value) {
        if (!this.contentElement) {
            this._tempValue = value;
            return;
        }
        this.contentElement.value = value;
    }
    firstUpdated() {
        this._suggestionEl = this.shadowRoot.getElementById('suggestions');
        this._suggestionEl.style.width = `${this.contentElement.getBoundingClientRect().width}px`;
        this._bound.onKeyDown = this._handleKeyDown.bind(this);
        this._bound.onKeyUp = this._handleKeyUp.bind(this);
        this._bound.onFocus = this._handleFocus.bind(this);
        this._bound.onBlur = this._handleBlur.bind(this);
        this._bound.onChange = this._handleChange.bind(this);
        this.contentElement.addEventListener('keydown', this._bound.onKeyDown);
        this.contentElement.addEventListener('keyup', this._bound.onKeyUp);
        this.contentElement.addEventListener('focus', this._bound.onFocus);
        this.contentElement.addEventListener('blur', this._bound.onBlur);
        this.contentElement.addEventListener('sl-input', this._bound.onChange);
        if (this._tempValue !== undefined) {
            this.contentElement.value = this._tempValue;
        }
    }
    disconnectedCallback() {
        if (!this.contentElement)
            return; // no events to remove
        this.contentElement.removeEventListener('keydown', this._bound.onKeyDown);
        this.contentElement.removeEventListener('keyup', this._bound.onKeyUp);
        this.contentElement.removeEventListener('focus', this._bound.onFocus);
        this.contentElement.removeEventListener('blur', this._bound.onBlur);
        this.contentElement.removeEventListener('sl-input', this._bound.onChange);
    }
    focus(options) {
        if (this.contentElement) {
            this.contentElement.focus(options);
        }
    }
    updated(changed) {
        if (changed.has('items')) {
            this.items.length > 1 || (this.items.length === 1 && this.items[0] !== this.contentElement.value) ? this.open() : this.close();
        }
        if (changed.has('opened') && this.opened && this._suggestionEl.childElementCount) {
            // Highlight the first when there are suggestions
            // eslint-disable-next-line prefer-destructuring
            this._highlightedEl = this._suggestionEl.children[0];
            this._highlightedEl.classList.add('active');
        }
    }
    /**
     * Open suggestions.
     */
    open() {
        if (this._suggestionEl.style.width === '0px') {
            this._suggestionEl.style.width = `${this.contentElement.getBoundingClientRect().width}px`;
        }
        if (this.items.length) {
            this.opened = true;
        }
    }
    /**
     * Close suggestions.
     */
    close() {
        this.opened = false;
        this._highlightedEl = null;
    }
    /**
     * Autocomplete input with `value`.
     * @param {String} value
     */
    autocomplete(value) {
        this.contentElement.value = value;
        this.onSelect(value);
        this.close();
    }
    _highlightPrev() {
        if (!this._highlightedEl || !this._highlightedEl.previousElementSibling)
            return;
        this._highlightedEl.classList.remove('active');
        this._highlightedEl = this._highlightedEl.previousElementSibling;
        this._highlightedEl.classList.add('active');
    }
    _highlightNext() {
        if (!this._highlightedEl || !this._highlightedEl.nextElementSibling)
            return;
        this._highlightedEl.classList.remove('active');
        this._highlightedEl = this._highlightedEl.nextElementSibling;
        this._highlightedEl.classList.add('active');
    }
    // eslint-disable-next-line class-methods-use-this
    _handleChange(value) {
        this.onChange(value);
    }
    _handleKeyDown(ev) {
        // Prevent up and down from behaving as home and end on some browsers
        if (ev.key === 'ArrowUp' || ev.key === 'ArrowDown') {
            ev.preventDefault();
            ev.stopPropagation();
        }
    }
    _handleKeyUp(ev) {
        var _a, _b;
        switch (ev.key) {
            case 'ArrowUp':
                if ((_a = this._highlightedEl) === null || _a === void 0 ? void 0 : _a.previousElementSibling) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    this._highlightPrev();
                }
                break;
            case 'ArrowDown':
                if ((_b = this._highlightedEl) === null || _b === void 0 ? void 0 : _b.nextElementSibling) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    this._highlightNext();
                }
                break;
            case 'Enter':
                // eslint-disable-next-line no-unused-expressions
                this._highlightedEl && this._highlightedEl.click();
                this.contentElement.blur();
                break;
            default:
                this._search();
        }
    }
    _handleFocus() {
        this._blur = false;
        // eslint-disable-next-line no-unused-expressions
        this.items.length > 1 && this.open();
    }
    _handleBlur() {
        this._blur = true;
        // eslint-disable-next-line no-unused-expressions
        setTimeout(() => this.close(), 200);
        //this.items = [];
    }
    // Handle mouse change focus to suggestions
    _handleItemMouseEnter() {
        this._mouseEnter = true;
    }
    _handleItemMouseLeave() {
        this._mouseEnter = false;
        // eslint-disable-next-line no-unused-expressions
        this._blur && setTimeout(() => this.close(), 500); // Give user some slack before closing
    }
};
__decorate([
    e$3({ type: String })
], AutocompleteAsync.prototype, "placeholder", void 0);
__decorate([
    e$3({ type: String })
], AutocompleteAsync.prototype, "label", void 0);
__decorate([
    e$3({ type: Array, reflect: true })
], AutocompleteAsync.prototype, "items", void 0);
__decorate([
    e$3({ type: Boolean, reflect: true })
], AutocompleteAsync.prototype, "opened", void 0);
__decorate([
    e$3({ type: Number })
], AutocompleteAsync.prototype, "maxSuggestions", void 0);
__decorate([
    e$3({ type: Function })
], AutocompleteAsync.prototype, "onSearch", void 0);
__decorate([
    e$3({ type: Function })
], AutocompleteAsync.prototype, "onSelect", void 0);
__decorate([
    e$3({ type: Function })
], AutocompleteAsync.prototype, "onChange", void 0);
__decorate([
    e$3({ type: String })
], AutocompleteAsync.prototype, "value", null);
AutocompleteAsync = __decorate([
    n$1('autocomplete-async')
], AutocompleteAsync);
class Option {
    constructor(value, description) {
        this.description = description;
        this.value = value;
    }
}

let AutocompleteNorma = class AutocompleteNorma extends s {
    constructor() {
        super(...arguments);
        this.urnInicial = '';
        // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function
        this.onSelect = (value) => { };
        //onSelect = (value: Norma): void => console.log('Norma selecionado:', value);
        this._selectedNorma = new Norma();
        this._optionsNorma = [];
        this._normas = [];
    }
    async _searchNormas(query) {
        try {
            const _response = await fetch(`${this.urlAutocomplete}?query=${query}`);
            const _normas = await _response.json();
            return _normas.map(n => new Norma(n.urn, n.nomePreferido, n.nomePorExtenso, n.nomes, n.nomesAlternativos, n.ementa));
        }
        catch (err) {
            console.log('Erro inesperado ao consultar as normas');
            console.log(err);
        }
        return Promise.resolve([]);
    }
    _updateNormas(paramQuery) {
        const query = paramQuery
            .replace(/[,;]| nº /gi, ' ')
            .replaceAll('.', '')
            .toLowerCase();
        this._searchNormas(query).then(normas => {
            this._normas = normas;
            this._optionsNorma = normas.map(n => new Option(n.urn, n.nomePreferido));
        });
    }
    _handleSearch(value) {
        this._updateNormas(value);
    }
    _handleSelect(option) {
        const norma = this._normas.find(norma => norma.urn === option.value);
        if (norma) {
            this._selectedNorma = norma;
            this.onSelect(this._selectedNorma);
        }
    }
    _getNormaByURN(urn) {
        const norma = new Norma(urn);
        const query = `${norma.sData()} ${norma.numero()}`;
        this._searchNormas(query).then(normas => {
            this._selectedNorma = normas.find(n => n.urn === urn);
            this.onSelect(this._selectedNorma);
            this._autoCompleteAsync.value = this._selectedNorma.nomePreferido;
        });
    }
    firstUpdated() {
        if (this.urnInicial) {
            this._getNormaByURN(this.urnInicial);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _handleChange(value) {
        // console.log('_handleChange', value);
        this._selectedNorma = new Norma();
        this.onSelect(this._selectedNorma);
    }
    render() {
        return $ `<style>
        .ajuda,
        .sp-ementa {
          font-size: var(--sl-font-size-small);
          font-weight: normal;
        }
        .wp-ementa {
          height: 85px;
          margin-top: 10px;
          overflow-y: auto;
        }
        .wp-ementa p {
          margin: 0;
        }
        .lb-ementa {
          display: block;
          margin-top: 10px;
        }
      </style>
      <div>
        <autocomplete-async
          id="auto-complete-async"
          label="Identificação da norma"
          placeholder="ex: Lei 10406 ou Código Civil"
          .items=${this._optionsNorma}
          .onSearch=${value => this._handleSearch(value)}
          .onSelect=${value => this._handleSelect(value)}
          .onChange=${value => this._handleChange(value)}
        ></autocomplete-async>
        <span class="ajuda">Informar a identificação da norma com tipo e número ou o apelido da norma. São aceitas abreviações como LCP e MPV.</span>
        <label class="lb-ementa">Ementa:</label>
        <div class="wp-ementa"><span class="sp-ementa">${(this._selectedNorma.ementa || '').slice(0, 450)}</span></div>
      </div>`;
    }
};
__decorate([
    e$3({ type: String })
], AutocompleteNorma.prototype, "urnInicial", void 0);
__decorate([
    e$3({ type: String })
], AutocompleteNorma.prototype, "urlAutocomplete", void 0);
__decorate([
    e$3({ type: Function })
], AutocompleteNorma.prototype, "onSelect", void 0);
__decorate([
    t$1()
], AutocompleteNorma.prototype, "_selectedNorma", void 0);
__decorate([
    t$1()
], AutocompleteNorma.prototype, "_optionsNorma", void 0);
__decorate([
    i$1('#auto-complete-async')
], AutocompleteNorma.prototype, "_autoCompleteAsync", void 0);
AutocompleteNorma = __decorate([
    n$1('autocomplete-norma')
], AutocompleteNorma);

async function assistenteAlteracaoDialog(elemento, quill, store, action, urlAutocomplete) {
    const dialogElem = document.createElement('sl-dialog');
    document.body.appendChild(dialogElem);
    dialogElem.label = 'Assistente de alteração de norma';
    dialogElem.addEventListener('sl-request-close', (event) => {
        if (event.detail.source === 'overlay') {
            event.preventDefault();
        }
    });
    const content = document.createRange().createContextualFragment(`
  <style>
    .ajuda {
      font-size: var(--sl-font-size-small);
      font-weight: normal;
    }

    sl-radio-group::part(base) {
      display: grid;
      grid-template-columns: 230px 1fr;
      grid-gap: 0px;
      flex-wrap: wrap;
    }

    sl-radio::part(base) {
      display: flex;
      flex-direction: row;
    }

    sl-radio-group sl-input::part(form-control) {
      display: flex;
      flex-direction: row;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    #dataNorma::part(form-control-input){
      max-width: 160px;
    }
    #anoNorma::part(form-control-input){
      max-width: 90px;
    }

    @media (max-width: 520px) {
      sl-radio-group::part(base) {
        display: flex;
        grid-template-columns: column;
        gap: 10px;
        flex-wrap: wrap;
      }
    }
  </style>
  <autocomplete-norma id="auto-norma" urlAutocomplete="${urlAutocomplete}"></autocomplete-norma>
  <br />
    <sl-input name="dispositivos" id="dispositivos" placeholder="ex: inciso I do § 3º do Art.1º" label="Dispositivo da norma" clearable></sl-input>
    <span class="ajuda">Informar apenas um dispositivo. Depois poderão ser adicionados outros.</span>
    <p class="ajuda" style="margin-block-end: 0;">
      Terminar sempre com o artigo, por exemplo:
    </p>
    <ul class="ajuda" style="margin-block-start: .3em; margin-block-end: 0;">
      <li>item 9 da alínea b do inciso V do parágrafo 4º do artigo 12-B</li>
      <li>ali c, inc X, par 6, art 1</li>
      <li>§ 8 art 32</li>
      <li>parágrafo único do art 7º</li>
    </ul>
  </div>
  <br/>
  <sl-alert variant="warning" closable class="alert-closable">
    <sl-icon slot="icon" name="exclamation-triangle"></sl-icon>
    <strong>Dados inválidos.</strong><br/>
    <span>Revise os dados informados.</span>
  </sl-alert>
  <sl-button slot="footer" variant="default">Cancelar</sl-button>
  <sl-button slot="footer" variant="primary">Ok</sl-button>
  `);
    let normaAlteracao = new Norma();
    const autocompleteNorma = content.querySelector('#auto-norma');
    const dispositivos = content.querySelector('#dispositivos');
    const botoes = content.querySelectorAll('sl-button');
    const cancelar = botoes[0];
    const ok = botoes[1];
    const alerta = content.querySelector('sl-alert');
    const alertaMensagem = alerta.querySelector('strong');
    const alertaComplemento = alerta.querySelector('span');
    const preencheAlerta = (mensagem = 'Dados inválidos.', complemento = 'Revise os dados informados.') => {
        alertaMensagem['innerHTML'] = mensagem;
        alertaComplemento['innerHTML'] = complemento;
    };
    autocompleteNorma['onSelect'] = (norma) => {
        normaAlteracao = norma;
    };
    ok.onclick = () => {
        let temErro = false;
        const textoDispositivo = dispositivos === null || dispositivos === void 0 ? void 0 : dispositivos.value;
        preencheAlerta();
        if (!normaAlteracao.urn) {
            preencheAlerta('Dados inválidos', 'Identifique uma norma a ser alterada.');
            temErro = true;
        }
        else if (textoDispositivo && textoDispositivo.length > 0) {
            try {
                validaDispositivoAssistente(textoDispositivo);
            }
            catch (err) {
                preencheAlerta('Dispositivo da norma não identificado.', 'Informe apenas um dispositivo em um dos formatos acima. Depois será possível alterar outros dispositivos.');
                temErro = true;
            }
        }
        else {
            preencheAlerta('Informe o dispositivo da norma a ser alterada.', 'Informe apenas um dispositivo em um dos formatos acima. Depois será possível alterar outros dispositivos.');
            temErro = true;
        }
        if (!temErro) {
            quill.focus();
            alerta === null || alerta === void 0 ? void 0 : alerta.hide();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.remove();
            elemento.norma = normaAlteracao.urn;
            store.dispatch(action.execute(elemento, normaAlteracao.urn, textoDispositivo));
        }
        else {
            alerta === null || alerta === void 0 ? void 0 : alerta.show();
        }
    };
    cancelar.onclick = () => {
        quill.focus();
        dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
        dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.remove();
    };
    quill.blur();
    await dialogElem.appendChild(content);
    await dialogElem.show();
    autocompleteNorma.focus();
}

const editarNotaAlteracaoDialog = (elemento, quill, store) => {
    if (podeMostrarDialog(elemento)) {
        const dialogElem = document.createElement('sl-dialog');
        document.body.appendChild(dialogElem);
        dialogElem.label = 'Nota de alteração';
        dialogElem.addEventListener('sl-request-close', (event) => {
            if (event.detail.source === 'overlay') {
                event.preventDefault();
            }
        });
        const content = document.createRange().createContextualFragment(`
    <sl-radio-group fieldset label="Selecione o tipo de nota de alteração:">
      <sl-radio class="nota" id="nota-nr" value="NR">Nova redação '(NR)'</sl-radio>
      <sl-radio class="nota" id="nota-vazia" value="">Sem nota de alteração</sl-radio>
    </sl-radio-group>
    <sl-button slot="footer" variant="default">Cancelar</sl-button>
    <sl-button slot="footer" variant="primary">Ok</sl-button>
    `);
        const opcoes = {
            NR: content.querySelector('#nota-nr'),
            VZ: content.querySelector('#nota-vazia'),
        };
        const notaAlteracao = elemento.notaAlteracao === 'AC' ? undefined : elemento.notaAlteracao;
        opcoes[notaAlteracao || 'VZ'].checked = true;
        const botoes = content.querySelectorAll('sl-button');
        const cancelar = botoes[0];
        const ok = botoes[1];
        ok.onclick = () => {
            const newValue = document.querySelector('sl-radio.nota[aria-checked="true"]').value;
            if (elemento.notaAlteracao !== newValue) {
                store.dispatch(atualizarNotaAlteracaoAction.execute(elemento, newValue));
            }
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.remove();
        };
        cancelar.onclick = () => {
            quill.focus();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.remove();
        };
        quill.blur();
        dialogElem.appendChild(content);
        dialogElem.show();
        // opcoes[elemento.notaAlteracao || 'VZ'].focus();
    }
};
const podeMostrarDialog = (elemento) => {
    if (elemento.revisao) {
        if (elemento.revisao.descricao === 'Dispositivo removido') {
            return false;
        }
    }
    return true;
};

async function informarNormaDialog(elemento, quill, store, action, urlAutocomplete) {
    const dialogElem = document.createElement('sl-dialog');
    document.body.appendChild(dialogElem);
    dialogElem.label = 'Dados da norma vigente';
    dialogElem.addEventListener('sl-request-close', (event) => {
        if (event.detail.source === 'overlay') {
            event.preventDefault();
        }
    });
    const content = document.createRange().createContextualFragment(`

  <div class="input-validation-required">
    <autocomplete-norma id="auto-norma" urnInicial="${elemento.norma}" urlAutocomplete="${urlAutocomplete}"></autocomplete-norma>
  </div>
  <br/>
  <sl-alert variant="warning" closable class="alert-closable">
    <sl-icon slot="icon" name="exclamation-triangle"></sl-icon>
    <strong>Dados inválidos.</strong><br/>
    Identifique uma norma a ser alterada.
  </sl-alert>
  <sl-button slot="footer" variant="default">Cancelar</sl-button>
  <sl-button slot="footer" variant="primary">Ok</sl-button>
  `);
    const autocompleteNorma = content.querySelector('#auto-norma');
    const botoes = content.querySelectorAll('sl-button');
    const cancelar = botoes[0];
    const ok = botoes[1];
    const alerta = content.querySelector('sl-alert');
    let urn = '';
    autocompleteNorma['onSelect'] = (norma) => {
        urn = norma.urn;
    };
    ok['onclick'] = () => {
        if (urn) {
            quill.focus();
            alerta === null || alerta === void 0 ? void 0 : alerta.hide();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.remove();
            elemento.norma = urn;
            store.dispatch(action.execute(elemento));
        }
        else {
            alerta === null || alerta === void 0 ? void 0 : alerta.show();
        }
    };
    cancelar.onclick = () => {
        quill.focus();
        dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
        dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.remove();
    };
    quill.blur();
    await dialogElem.appendChild(content);
    await dialogElem.show();
    autocompleteNorma.focus();
}

const transformarAction = (elemento, novoTipo) => {
    const action = new TransformarElemento(TipoDispositivo[novoTipo.toLowerCase()], 'Transformar ' + elemento.tipo + 'em ' + TipoDispositivo[novoTipo.toLowerCase()].name, 'transformar' + elemento.tipo + 'Em' + TipoDispositivo[novoTipo.toLowerCase()].name);
    return action.execute(elemento);
};

class TextoDiff {
    constructor() {
        this.adicionado = false;
    }
}
const OMISSIS = '....................';
const exibirDiferencasDialog = (diff) => {
    Array.from(document.querySelectorAll('#slDialogExibirDiferencas')).forEach(el => document.body.removeChild(el));
    const dialogElem = document.createElement('sl-dialog');
    dialogElem.id = 'slDialogExibirDiferencas';
    document.body.appendChild(dialogElem);
    dialogElem.label = 'Exibir diferenças do texto atual com';
    const fnDestroy = () => {
        try {
            diff.quill && diff.quill.focus();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
            document.body.removeChild(dialogElem);
        }
        catch (error) {
            // console.log(error);
        }
    };
    dialogElem.addEventListener('sl-after-hide', () => {
        setTimeout(() => fnDestroy(), 0);
    });
    diff = trataOmissisDiff(diff);
    const contemRevisao = !!diff.textoAntesRevisao;
    let diferencaModificado = textoDiffAsHtml(diff.textoOriginal, diff.textoAtual, 'diffWords');
    let diferencaSemEspacosDuplicados = diferencaModificado.replace(/\s+/g, ' ');
    diferencaModificado = substituiEspacosEntreTagsPorNbsp(textoDiffAsHtml(diferencaSemEspacosDuplicados, diferencaModificado, 'diffChars'), ['ins', 'del']);
    const tabModificado = !diff.adicionado && diferencaModificado !== diff.textoOriginal ? `<sl-tab slot="nav" panel="modificado"> Texto original </sl-tab>` : '';
    const tabModificadoRevisao = contemRevisao ? `<sl-tab slot="nav" panel="modificadoRevisao">Texto antes da revisão</sl-tab>` : '';
    let diferencaEntreTextoAtualETextoAntesRevisao = contemRevisao ? textoDiffAsHtml(diff.textoAntesRevisao, diff.textoAtual, 'diffWords') : undefined;
    if (contemRevisao) {
        diferencaSemEspacosDuplicados = diferencaEntreTextoAtualETextoAntesRevisao.replace(/\s+/g, ' ');
        diferencaEntreTextoAtualETextoAntesRevisao = substituiEspacosEntreTagsPorNbsp(textoDiffAsHtml(diferencaSemEspacosDuplicados, diferencaEntreTextoAtualETextoAntesRevisao, 'diffChars'), ['ins', 'del']);
    }
    diff.textoOriginal = substituiMultiplosEspacosPorNbsp(diff.textoOriginal);
    diff.textoAtual = substituiMultiplosEspacosPorNbsp(diff.textoAtual);
    if (contemRevisao) {
        diff.textoAntesRevisao = substituiMultiplosEspacosPorNbsp(diff.textoAntesRevisao);
    }
    const tabPanelModificado = !diff.adicionado && diferencaModificado !== diff.textoOriginal
        ? `<sl-tab-panel name="modificado">

        <sl-card class="card-header texto-alterado">
          <div slot="header">
            Texto original
          </div>
          <p class="texto-quill">
            ${diff.textoOriginal}
          </p>
        </sl-card>

        <sl-card class="card-header texto-alterado">
          <div slot="header">
            Diferença
          </div>
          <p class="texto-quill">
            ${diferencaModificado}
          </p>
        </sl-card>

        <sl-card class="card-header texto-alterado">
          <div slot="header">
          Texto atual
          </div>
          <p class="texto-quill">
            ${diff.textoAtual}
          </p>
        </sl-card>

      </sl-tab-panel>`
        : '';
    const tabPanelModificadoRevisao = contemRevisao
        ? `<sl-tab-panel name="modificadoRevisao">

          <sl-card class="card-header texto-alterado">
            <div slot="header">
              Texto antes da revisão
            </div>
            <p class="texto-quill">
              ${diff.textoAntesRevisao}
            </p>
          </sl-card>

          <sl-card class="card-header texto-alterado">
            <div slot="header">
              Diferença
            </div>
            <p class="texto-quill">
              ${diferencaEntreTextoAtualETextoAntesRevisao}
            </p>
          </sl-card>

          <sl-card class="card-header texto-alterado">
            <div slot="header">
              Texto atual
            </div>
            <p class="texto-quill">
              ${diff.textoAtual}
            </p>
          </sl-card>

        </sl-tab-panel>`
        : '';
    const content = document.createRange().createContextualFragment(`
  <style>

    sl-dialog {
      --width: 90vw;
    }
    sl-dialog::part(base) {
      max-width: 1200px;
      margin: 0 auto;
    }

    .texto-alterado ins {
      background-color: #c6ffc6;
      text-decoration: none;
    }

    .texto-alterado del {
      background-color: #ffc6c6;
    }

    p .texto-quill {
      white-space: pre-wrap;
      text-align: justify;
      text-indent: 0 !important;
    }

    sl-tab-panel::part(base) {
      padding-top: 1rem;
      display: flex;
      flex-direction: row;
      gap: 1rem;
      align-items: stretch;
      justify-content: center;
    }

    sl-card {
      box-shadow: var(--sl-shadow-x-large) !important;
      width: 33%;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    @media (max-width: 768px) {
      sl-card {
        width: 100%;
      }
    }

    sl-card::part(base){
      height: 100%;
    }

    sl-card::part(header) {
      background-color: var(--sl-color-neutral-200);
    }


    @media (max-width: 768px) {
      sl-tab-panel::part(base) {
        flex-direction: column;
      }
      sl-dialog {
        --width: 100vw !important;
      }
    }

  </style>
  <div class="texto-alterado">
    <sl-tab-group>
      ${tabModificado}
      ${tabModificadoRevisao}

      ${tabPanelModificado}
      ${tabPanelModificadoRevisao}
    </sl-tab-group>
  </div>


  <sl-button slot="footer" variant="primary">Fechar</sl-button>
  `);
    const fechar = content.querySelectorAll('sl-button')[0];
    fechar.onclick = () => dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
    diff.quill && diff.quill.blur();
    dialogElem.appendChild(content);
    dialogElem.show();
};
const trataOmissisDiff = (diff) => {
    if (diff.textoAtual.includes('....')) {
        diff.textoAtual = OMISSIS;
    }
    return diff;
};

const alertarInfo = (mensagem) => {
    const idAlert = 'alertaInfo';
    const currentAlert = document.getElementById(idAlert);
    if (!currentAlert) {
        const alert = Object.assign(document.createElement('sl-alert'), {
            variant: 'danger',
            closable: true,
            duration: 4000,
            innerHTML: `
          <sl-icon name="exclamation-octagon" slot="icon" id="${idAlert}"></sl-icon>
          ${mensagem}
        `,
        });
        document.body.append(alert);
        alert.toast();
    }
};

let EditorComponent = class EditorComponent extends connect(rootStore)(s) {
    constructor() {
        super();
        this.lexmlEtaConfig = new LexmlEmendaConfig();
        this.modo = ClassificacaoDocumento.EMENDA;
        this.eventosOnChange = [];
        this.inscricoes = [];
        this._idSwitchRevisao = 'chk-em-revisao';
        this._idBadgeQuantidadeRevisao = 'badge-marca-alteracao';
        this.exibirBotoesParaTratarTodas = false;
        this.onSelectionChange = (range, oldRange, source) => {
            if ((range === null || range === void 0 ? void 0 : range.length) === 0 && source === Quill.sources.USER) {
                this.ajustarLinkParaNorma();
            }
        };
        this.listenerRotulo = (event) => {
            event.stopImmediatePropagation();
            this.renumerarElemento();
        };
        this.listenerNotaAlteracao = (event) => {
            event.stopImmediatePropagation();
            this.editarNotaAlteracao(event.detail.elemento);
        };
        this.listenerToggleExistencia = (event) => {
            event.stopImmediatePropagation();
            this.toggleExistenciaElemento(event.detail.elemento);
        };
        this.listenerMensagem = (event) => {
            var _a, _b;
            event.stopImmediatePropagation();
            const linha = this.quill.linhaAtual;
            if (linha) {
                if (AutoFix.RENUMERAR_DISPOSITIVO === ((_b = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.mensagem) === null || _b === void 0 ? void 0 : _b.descricao)) {
                    this.renumerarElemento();
                }
                else {
                    const blotConteudo = linha.blotConteudo;
                    const elemento = this.criarElemento(linha.uuid, linha.uuid2, linha.lexmlId, linha.tipo, blotConteudo.html, linha.numero, linha.hierarquia);
                    rootStore.dispatch(autofixAction.execute(elemento, event.detail.mensagem));
                }
            }
        };
        this.listenerAceitarRevisao = (event) => {
            event.stopImmediatePropagation();
            this.aceitarRevisao(event.detail.elemento);
        };
        this.listenerRejeitarRevisao = (event) => {
            event.stopImmediatePropagation();
            this.rejeitarRevisao(event.detail.elemento);
        };
        /**
         * Método utilizado para navegar entre as marcas de revisão
         * @param direcao
         */
        this.navegarEntreMarcasRevisao = (direcao) => {
            const atributo = direcao === 'abaixo' ? 'next' : 'prev';
            let linha = this.quill.linhaAtual;
            if (linha.elemento.revisao) {
                linha = linha[atributo];
            }
            while (linha && !linha.elemento.revisao) {
                linha = linha[atributo];
            }
            if (linha) {
                this.quill.desmarcarLinhaAtual(this.quill.linhaAtual);
                this.quill.marcarLinhaAtual(linha);
            }
        };
        this.checkedSwitchMarcaAlteracao = () => {
            const switchMarcaAlteracaoView = document.getElementById(this._idSwitchRevisao);
            setCheckedElement(switchMarcaAlteracaoView, rootStore.getState().elementoReducer.emRevisao);
        };
        this.disabledParagrafoElementoRemovido = (event) => {
            var _a;
            const elementos = (_a = event.elementos) !== null && _a !== void 0 ? _a : [];
            elementos.forEach((elemento) => {
                const paragrafo = document.getElementById('texto__dispositivo' + elemento.uuid);
                if (paragrafo) {
                    if (elemento.revisao && elemento.revisao.descricao === 'Dispositivo removido') {
                        paragrafo.setAttribute('contenteditable', 'false');
                    }
                    else {
                        paragrafo.setAttribute('contenteditable', 'true');
                    }
                }
            });
        };
        this.tabIndex = -1;
    }
    get quill() {
        return this._quill;
    }
    createRenderRoot() {
        return this;
    }
    async firstUpdated() {
        this.inicializar(this.configEditor());
        this.querySelectorAll('.ql-bold, .ql-italic, .ql-script').forEach(tool => {
            tool.addEventListener('click', (event) => {
                event.stopImmediatePropagation();
            });
        });
    }
    stateChanged(state) {
        var _a, _b, _c;
        if (!this.quill) {
            this.quillNaoInicializado(state);
            return;
        }
        this.quill.undoEstruturaVazio = ((_a = state.elementoReducer.past) !== null && _a !== void 0 ? _a : []).length === 0;
        this.quill.redoEstruturaVazio = ((_b = state.elementoReducer.future) !== null && _b !== void 0 ? _b : []).length === 0;
        if (state.elementoReducer.ui) {
            if (state.elementoReducer.ui.message) {
                //this.alertar(state.elementoReducer.ui.message.descricao);
                alertarInfo(state.elementoReducer.ui.message.descricao);
            }
            else if (((_c = state.elementoReducer.ui.events[0]) === null || _c === void 0 ? void 0 : _c.stateType) !== 'AtualizacaoAlertas') {
                this.processarStateEvents(state.elementoReducer.ui.events);
            }
        }
    }
    disconnectedCallback() {
        this.inscricoes.forEach((i) => i.cancel());
        this.destroiQuill();
        super.disconnectedCallback();
    }
    render() {
        return $ `
      <style>
        :host {
          --lx-eta-editor-height: 100%;
          --lx-eta-editor-overflow: display;
        }

        lexml-eta-editor .ql-editor {
          white-space: normal;
        }

        #lx-eta-editor {
          overflow: var(--lx-eta-editor-overflow);
          display: block;
          height: var(--heightEmenda);
        }
        .sl-toast-stack sl-alert::part(base) {
          background-color: var(--sl-color-danger-100);
        }
        .checkBoxRevisao {
          padding: 3px 5px;
          margin: 5px 5px 5px 4px;
        }
      </style>
      <div id="lx-eta-box">
        <div id="lx-eta-barra-ferramenta">
          <button class="ql-bold" title="Negrito (Ctrl+b)"></button>
          <button class="ql-italic" title="Itálico (Ctrl+i)"></button>
          <button class="ql-script" value="sub" title="Subscrito"></button>
          <button class="ql-script" value="super" title="Sobrescrito"></button>

          <button @click=${this.onClickUndo} class="lx-eta-ql-button lx-eta-btn-desfazer" title="Desfazer (Ctrl+Z)">
            <svg class="icon-undo-redo" id="undo" viewBox="0 0 512 512">
              <path
                d="M488,256c0,123.4-100.5,223.9-223.9,223.9c-48.8,0-95.2-15.6-134.2-44.9c-14.1-10.6-17-30.7-6.4-44.8 c10.6-14.1,30.6-16.9,44.8-6.4c27.8,20.9,61,31.9,95.9,31.9c88.1,0,159.8-71.7,159.8-159.8S352.3,96.2,264.2,96.2 c-37.5,0-73.1,13.5-101.3,36.6L208,178c17,17,5,46.1-19.1,46.1H43.2c-10.6,0-19.2-8.6-19.2-19.2V59C24,35,53.1,23,70.1,40l47.6,47.6 c40.2-34.9,91.8-55.5,146.4-55.5C387.5,32.1,488,132.6,488,256z"
              />
            </svg>
          </button>
          <button @click=${this.onClickRedo} class="lx-eta-ql-button" title="Refazer (Ctrl+y)">
            <svg class="icon-undo-redo lx-eta-rebate-180-graus" id="redo" viewBox="0 0 512 512">
              <path
                d="M488,256c0,123.4-100.5,223.9-223.9,223.9c-48.8,0-95.2-15.6-134.2-44.9c-14.1-10.6-17-30.7-6.4-44.8 c10.6-14.1,30.6-16.9,44.8-6.4c27.8,20.9,61,31.9,95.9,31.9c88.1,0,159.8-71.7,159.8-159.8S352.3,96.2,264.2,96.2 c-37.5,0-73.1,13.5-101.3,36.6L208,178c17,17,5,46.1-19.1,46.1H43.2c-10.6,0-19.2-8.6-19.2-19.2V59C24,35,53.1,23,70.1,40l47.6,47.6 c40.2-34.9,91.8-55.5,146.4-55.5C387.5,32.1,488,132.6,488,256z"
              />
            </svg>
          </button>
          <button type="button" class="ql-clean" title="Remover formatação">
            <svg class="" viewBox="0 0 18 18">
              <line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"></line>
              <line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"></line>
              <line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"></line>
              <line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"></line>
              <rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"></rect>
            </svg>
          </button>

          <lexml-switch-revisao
          class="revisao-container"
          .nomeSwitch="${this._idSwitchRevisao}"
          .nomeBadgeQuantidadeRevisao="${this._idBadgeQuantidadeRevisao}"
          modo="${this.modo}"
          >
          </lexml-switch-revisao>

          <sl-button class="button-navegacao-marca" variant="default" size="small" circle @click=${() => this.navegarEntreMarcasRevisao('abaixo')}>
            <sl-icon-button name="arrow-down"></sl-icon-button>
          </sl-button>

          <sl-button class="button-navegacao-marca" variant="default" size="small" circle @click=${() => this.navegarEntreMarcasRevisao('acima')}>
            <sl-icon-button name="arrow-up"></sl-icon-button>
          </sl-button>

          ${this.exibirBotoesParaTratarTodas ? this.renderBotoesParaTratarTodasRevisoes() : ''}

          <input type="button" @click=${this.artigoOndeCouber} class="${'ql-hidden'} btn--artigoOndeCouber" value="Propor artigo onde couber" title="Artigo onde couber"></input>
          <div class="mobile-buttons">
            <button class="mobile-button btn-comando" title="Comando" @click=${this.showComandoEmendaModal}>
              <sl-icon name="code"></sl-icon>
              <span>Comando</span>
            </button>
            <button class="mobile-button btn-dicas" title="Dicas" @click=${this.showAjudaModal}>
              <sl-icon name="lightbulb"></sl-icon>
              <span>Dicas</span>
            </button>
            <button class="mobile-button" title="Atalhos" @click=${this.showAtalhosModal}>
              <sl-icon name="keyboard"></sl-icon>
              <span>Atalhos</span>
            </button>
          </div>
        </div>
        <div id="lx-eta-editor"></div>
      </div>
      <elix-toast id="toast-alerta" duration="3000">
        <div id="toast-msg"></div>
      </elix-toast>
      <div id="lx-eta-buffer"><p></p></div>
      <lexml-ajuda-modal></lexml-ajuda-modal>
      <lexml-emenda-comando-modal></lexml-emenda-comando-modal>
      <lexml-atalhos-modal></lexml-atalhos-modal>
    `;
    }
    renderBotoesParaTratarTodasRevisoes() {
        return $ `
      <sl-icon-button id="btnRejeitarTodasRevisoes" name="x" label="" title="Rejeitar Revisões" ?disabled=${true} @click=${() => this.rejeitarTodasRevisoes()}>
        Rejeitar Revisões
      </sl-icon-button>

      <sl-icon-button id="btnAceitarTodasRevisoes" name="check-lg" label="" title="Aceitar Revisões" ?disabled=${true} @click=${() => this.aceitarTodasRevisoes()}>
        Aceitar Revisões
      </sl-icon-button>
    `;
    }
    showAjudaModal() {
        this.ajudaModal.show();
    }
    showAtalhosModal() {
        this.atalhosModal.show();
    }
    showComandoEmendaModal() {
        this.comandoEmendaModal.show();
    }
    formatacaoAlterada() {
        var _a;
        const texto = (_a = document.getSelection()) === null || _a === void 0 ? void 0 : _a.toString();
        if (texto) {
            this.agendarEmissaoEventoOnChange('toolbar');
        }
    }
    onClickUndo() {
        this.quill.undo();
    }
    onClickRedo() {
        this.quill.redo();
    }
    artigoOndeCouber() {
        //rootStore.dispatch(validarArticulacaAction.execute());
    }
    ajustarLinkParaNorma() {
        const linkTooltip = document.querySelector('a.ql-preview');
        const href = linkTooltip === null || linkTooltip === void 0 ? void 0 : linkTooltip.getAttribute('href');
        if (href === null || href === void 0 ? void 0 : href.startsWith('urn')) {
            const url = 'https://normas.leg.br/?urn=' + href;
            linkTooltip.setAttribute('href', url);
            linkTooltip.innerHTML = getNomeExtenso(href);
        }
    }
    onBold(value) {
        if (this.quill.keyboard.verificarOperacaoTecladoPermitida()) {
            this.quill.format('bold', value);
            this.formatacaoAlterada();
        }
    }
    onItalic(value) {
        if (this.quill.keyboard.verificarOperacaoTecladoPermitida()) {
            this.quill.format('italic', value);
            this.formatacaoAlterada();
        }
    }
    onScript(value) {
        if (this.quill.keyboard.verificarOperacaoTecladoPermitida()) {
            this.quill.format('script', value);
            this.formatacaoAlterada();
        }
    }
    onOperacaoInvalida() {
        this.alertar('Operação não permitida.');
    }
    isDesmembramento(textoAnterior, textoLinhaAtual, textoNovaLinha) {
        return (textoLinhaAtual + textoNovaLinha).localeCompare(textoAnterior) !== 0;
    }
    adicionarElemento(range) {
        var _a, _b;
        const linha = this.quill.linhaAtual;
        const blotConteudo = linha.blotConteudo;
        const indexInicio = (_a = this.quill.inicioConteudoAtual) !== null && _a !== void 0 ? _a : 0;
        const indexFim = (_b = indexInicio + blotConteudo.tamanho) !== null && _b !== void 0 ? _b : 0;
        let textoLinha = '';
        let textoNovaLinha = '';
        if (range.index === indexInicio) {
            textoLinha = '';
            textoNovaLinha = blotConteudo.html;
        }
        else if (range.index === indexFim) {
            textoLinha = blotConteudo.html;
            textoNovaLinha = '';
        }
        else {
            const tamanhoNovaLinha = indexFim - range.index;
            textoLinha = this.quill.getConteudoHtmlParteLinha(blotConteudo, 0, blotConteudo.tamanho - tamanhoNovaLinha);
            textoNovaLinha = this.quill.getConteudoHtmlParteLinha(blotConteudo, range.index - indexInicio, tamanhoNovaLinha);
        }
        const elemento = this.criarElemento(linha.uuid, linha.uuid2, linha.lexmlId, linha.tipo, textoLinha, linha.numero, linha.hierarquia);
        if (this.isDesmembramento(blotConteudo.htmlAnt, textoLinha, textoNovaLinha)) {
            const elemento = this.criarElemento(linha.uuid, linha.uuid2, linha.lexmlId, linha.tipo, textoLinha + textoNovaLinha, linha.numero, linha.hierarquia);
            rootStore.dispatch(atualizarTextoElementoAction.execute(elemento));
        }
        rootStore.dispatch(adicionarElementoAction.execute(elemento, textoNovaLinha));
    }
    editarNotaAlteracao(elemento) {
        editarNotaAlteracaoDialog(elemento, this.quill, rootStore);
    }
    async renumerarElemento() {
        var _a, _b, _c, _d;
        const linha = this.quill.linhaAtual;
        const elemento = this.criarElemento((_a = linha.uuid) !== null && _a !== void 0 ? _a : 0, (_b = linha.uuid2) !== null && _b !== void 0 ? _b : '', linha.lexmlId, (_c = linha.tipo) !== null && _c !== void 0 ? _c : '', '', linha.numero, linha.hierarquia, linha.descricaoSituacao, linha.existeNaNormaAlterada);
        if (!podeRenumerar(rootStore.getState().elementoReducer.articulacao, elemento)) {
            this.alertar('Nessa situação, não é possível renumerar o dispositivo');
            return;
        }
        const dialogElem = document.createElement('sl-dialog');
        document.body.appendChild(dialogElem);
        dialogElem.label = 'Informar numeração';
        dialogElem.addEventListener('sl-request-close', (event) => {
            if (event.detail.source === 'overlay') {
                event.preventDefault();
            }
        });
        const getMsgPlaceholder = (tipo) => {
            var _a;
            const tp = tipo.toLowerCase();
            const descricao = (_a = TipoDispositivo[tp].descricao) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (!tp) {
                return '';
            }
            else if (['artigo', 'paragrafo', 'item'].includes(tp)) {
                return 'Digite o número do ' + descricao + '. Ex: 5, 6-A' + (tp === 'paragrafo' ? ', único' : '');
            }
            else if (tp === 'alinea') {
                return 'Digite a letra da ' + descricao + '. Ex: b, c-A';
            }
            else {
                const genero = ['parte', 'secao', 'subsecao'].includes(tp) ? 'a' : 'o';
                return `Digite o número romano d${genero} ${descricao}. Ex: II, III-A'`;
            }
        };
        const content = document.createRange().createContextualFragment(`
      <div class="input-validation-required">
        <sl-input type="text" help-text="${getMsgPlaceholder((_d = elemento.tipo) !== null && _d !== void 0 ? _d : '')}" label="Numeração do dispositivo:" clearable></sl-input>
        <br/>
      </div>
      <br/>
      <sl-alert variant="warning" closable class="alert-closable">
        <sl-icon slot="icon" name="exclamation-triangle"></sl-icon>
        <div class="erro"></div>
      </sl-alert>
      <sl-button slot="footer" variant="default">Cancelar</sl-button>
      <sl-button slot="footer" variant="primary">Ok</sl-button>
    `);
        const input = content.querySelector('sl-input');
        const rotuloAtual = `${rotuloParaEdicao(linha.blotRotulo.rotulo)}`;
        input.value = rotuloAtual;
        const botoes = content.querySelectorAll('sl-button');
        const cancelar = botoes[0];
        const ok = botoes[1];
        const erro = content.querySelector('.erro');
        const alerta = content.querySelector('sl-alert');
        ok.onclick = () => {
            var _a;
            this.quill.focus();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.remove();
            if (((_a = input.value) === null || _a === void 0 ? void 0 : _a.trim().toLowerCase()) !== (rotuloAtual === null || rotuloAtual === void 0 ? void 0 : rotuloAtual.toLowerCase())) {
                rootStore.dispatch(renumerarElementoAction.execute(elemento, input.value.trim()));
            }
        };
        cancelar.onclick = () => {
            this.quill.focus();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
            dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.remove();
        };
        const validar = () => {
            const numeracao = input.value;
            if (/^\s*$/.test(numeracao)) {
                return 'A numeração não pode ser vazia.';
            }
            return '';
        };
        const validarInput = (evt) => {
            let msgErro = validar();
            if (!msgErro && elemento.tipo && !isNumeracaoValidaPorTipo(input.value, elemento.tipo)) {
                msgErro = 'Numeração inválida.';
            }
            erro.innerText = msgErro;
            msgErro ? alerta === null || alerta === void 0 ? void 0 : alerta.show() : alerta === null || alerta === void 0 ? void 0 : alerta.hide();
            ok.disabled = Boolean(msgErro);
            if (!ok.disabled) {
                if (evt.key === 'Enter') {
                    ok.click();
                }
            }
        };
        input.addEventListener('keyup', validarInput);
        input.addEventListener('sl-clear', validarInput);
        dialogElem.appendChild(content);
        await (dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.show());
        ok.disabled = Boolean(validar());
        input.focus();
    }
    toggleExistencia() {
        var _a, _b, _c;
        const linha = this.quill.linhaAtual;
        const elemento = this.criarElemento((_a = linha.uuid) !== null && _a !== void 0 ? _a : 0, (_b = linha.uuid2) !== null && _b !== void 0 ? _b : '', linha.lexmlId, (_c = linha.tipo) !== null && _c !== void 0 ? _c : '', '', linha.numero, linha.hierarquia, linha.descricaoSituacao, linha.existeNaNormaAlterada);
        this.toggleExistenciaElemento(elemento);
    }
    adicionaAgrupador() {
        this.adicionarAgrupadorArtigo(this.quill.linhaAtual.elemento);
    }
    adicionarAgrupadorArtigo(elemento) {
        adicionarAgrupadorArtigoDialog(elemento, this.quill, rootStore);
    }
    toggleExistenciaElemento(elemento) {
        const action = elemento.existeNaNormaAlterada ? considerarElementoNovoNaNorma : considerarElementoExistenteNaNorma;
        rootStore.dispatch(action.execute(elemento));
    }
    removerElementoSemTexto(key) {
        var _a, _b;
        const linha = this.quill.linhaAtual;
        const elemento = this.criarElemento((_a = linha.uuid) !== null && _a !== void 0 ? _a : 0, linha.uuid2, linha.lexmlId, (_b = linha.tipo) !== null && _b !== void 0 ? _b : '', '', linha.numero, linha.hierarquia);
        rootStore.dispatch(removerElementoSemTextoAction.execute(elemento, key));
    }
    removerElemento() {
        var _a, _b, _c;
        const linha = this.quill.linhaAtual;
        const elementoLinhaAnterior = (_a = this.quill.linhaAtual.prev) === null || _a === void 0 ? void 0 : _a.elemento;
        const elemento = this.criarElemento((_b = linha.uuid) !== null && _b !== void 0 ? _b : 0, linha.uuid2, linha.lexmlId, (_c = linha.tipo) !== null && _c !== void 0 ? _c : '', '', linha.numero, linha.hierarquia);
        rootStore.dispatch(removerElementoAction.execute(elemento, elementoLinhaAnterior));
    }
    moverElemento(ev) {
        const linha = this.quill.linhaAtual;
        if (linha) {
            const blotConteudo = linha.blotConteudo;
            const textoLinha = blotConteudo.html;
            const elemento = this.criarElemento(linha.uuid, linha.uuid2, linha.lexmlId, linha.tipo, textoLinha, linha.numero, linha.hierarquia);
            if (ev.key === 'ArrowUp') {
                rootStore.dispatch(moverElementoAcimaAction.execute(elemento));
            }
            else if (ev.key === 'ArrowDown') {
                rootStore.dispatch(moverElementoAbaixoAction.execute(elemento));
            }
        }
    }
    transformarElemento(ev) {
        const linha = this.quill.linhaAtual;
        const blotConteudo = linha.blotConteudo;
        const textoLinha = blotConteudo.html;
        const elemento = this.criarElemento(linha.uuid, linha.uuid2, linha.lexmlId, linha.tipo, textoLinha, linha.numero, linha.hierarquia);
        if (ev.key.toLowerCase() === 'o') {
            rootStore.dispatch(transformarAction(elemento, TipoDispositivo.omissis.name));
        }
        else if (Keyboard.keys.TAB) {
            rootStore.dispatch(ev.shiftKey ? shiftTabAction(elemento) : tabAction(elemento));
        }
    }
    elementoSelecionado(uuid) {
        var _a;
        const linha = this.quill.linhaAtual;
        if (linha) {
            const elemento = this.criarElemento(uuid, linha.uuid2, linha.lexmlId, (_a = linha.tipo) !== null && _a !== void 0 ? _a : '', '', linha.numero, linha.hierarquia);
            rootStore.dispatch(elementoSelecionadoAction.execute(elemento));
            this.quill.processandoMudancaLinha = false;
        }
    }
    undoRedoEstrutura(tipo) {
        //
        // TODO: Chamar action para undo ou redo - estrutura.
        //
        if (tipo === 'undo') {
            rootStore.dispatch(UndoAction());
        }
        else {
            rootStore.dispatch(redoAction());
        }
    }
    processarStateEvents(events) {
        const ultimoEventoElementoSelecionado = events.filter((ev) => ev.stateType === StateType.ElementoSelecionado).slice(-1)[0];
        events === null || events === void 0 ? void 0 : events.forEach((event) => {
            var _a;
            switch (event.stateType) {
                case StateType.DocumentoCarregado:
                    this.destroiQuill();
                    this.inicializar(this.configEditor());
                    this.carregarArticulacao((_a = event.elementos) !== null && _a !== void 0 ? _a : []);
                    break;
                case StateType.InformarDadosAssistente:
                    assistenteAlteracaoDialog(event.elementos[0], this.quill, rootStore, adicionarAlteracaoComAssistenteAction, this.lexmlEtaConfig.urlAutocomplete);
                    break;
                case StateType.InformarNorma:
                    informarNormaDialog(event.elementos[0], this.quill, rootStore, atualizarReferenciaElementoAction, this.lexmlEtaConfig.urlAutocomplete);
                    break;
                case StateType.ElementoIncluido:
                    this.inserirNovoElementoNoQuill(event.elementos[0], event.referencia, true);
                    this.inserirNovosElementosNoQuill(event, true);
                    // this.atualizarReferenciaEmRevisoesDeExclusaoSeNecessario(events, event);
                    break;
                case StateType.ElementoModificado:
                case StateType.ElementoRestaurado:
                    this.atualizarQuill(event);
                    this.atualizarOmissis(event);
                    if (events[events.length - 1] === event) {
                        this.marcarLinha(event);
                    }
                    break;
                case StateType.ElementoSuprimido:
                    this.atualizarSituacao(event);
                    if (events[events.length - 1] === event) {
                        this.marcarLinha(event);
                    }
                    break;
                case StateType.ElementoRemovido:
                    this.removerLinhaQuill(event);
                    break;
                case StateType.ElementoRenumerado:
                    this.renumerarQuill(event);
                    break;
                case StateType.ElementoValidado:
                    this.atualizarMensagemQuill(event);
                    break;
                case StateType.ElementoSelecionado:
                    this.atualizarAtributos(event);
                    if (ultimoEventoElementoSelecionado === event) {
                        this.montarMenuContexto(event);
                    }
                    this.atualizarMensagemQuill(event);
                    break;
                case StateType.ElementoMarcado:
                    setTimeout(() => this.marcarLinha(event), 100);
                    break;
                case StateType.SituacaoElementoModificada:
                    this.atualizarQuill(event);
                    this.atualizarSituacao(event);
                    this.atualizarAtributos(event);
                    this.atualizarMensagemQuill(event);
                    this.atualizarOmissis(event);
                    break;
                case StateType.RevisaoAtivada:
                    this.checkedSwitchMarcaAlteracao();
                    break;
                case StateType.RevisaoDesativada:
                    this.checkedSwitchMarcaAlteracao();
                    this.atualizarEstiloBotaoRevisao();
                    break;
                case StateType.RevisaoAceita:
                    this.processaRevisoesAceitas(events, event);
                    break;
                case StateType.RevisaoAdicionalRejeitada:
                    this.removerLinhaQuill(event);
                    break;
            }
            this.disabledParagrafoElementoRemovido(event);
            this.quill.limparHistory();
        });
        this.indicadorMarcaRevisao(events);
        this.indicadorTextoModificado(events);
        //this.atualizaQuantidadeRevisao();
        this.atualizarStatusBotoesRevisao();
        // Os eventos que estão no array abaixo devem emitir um custom event "ontextchange"
        const eventosQueDevemEmitirTextChange = [
            StateType.ElementoModificado,
            StateType.ElementoSuprimido,
            StateType.ElementoRestaurado,
            StateType.ElementoIncluido,
            StateType.ElementoRemovido,
            StateType.ElementoRenumerado,
        ];
        const eventosFiltrados = events === null || events === void 0 ? void 0 : events.filter(ev => eventosQueDevemEmitirTextChange.includes(ev.stateType)).map(ev => ev.stateType);
        if (eventosFiltrados === null || eventosFiltrados === void 0 ? void 0 : eventosFiltrados.length) {
            // TODO: Implementar lógica do atributo eventosFiltrados, sem repetir os itens
            this.eventosOnChange.push(...eventosFiltrados);
            this.agendarEmissaoEventoOnChange('stateEvents', eventosFiltrados);
        }
    }
    processaRevisoesAceitas(events, event) {
        if (this.isAceitandoRevisoesDeExclusao(event)) {
            this.removerLinhaQuill(event);
        }
        else {
            this.atualizarAtributos(event);
            if (events[events.length - 1] === event) {
                this.montarMenuContexto(event);
            }
            this.atualizarMensagemQuill(event);
        }
    }
    isAceitandoRevisoesDeExclusao(event) {
        var _a, _b;
        return (_b = (_a = event.elementos) === null || _a === void 0 ? void 0 : _a.some(e => { var _a, _b; return ((_b = (_a = this.quill.getLinha(e.uuid)) === null || _a === void 0 ? void 0 : _a.elemento.revisao) === null || _b === void 0 ? void 0 : _b.stateType) === StateType.ElementoRemovido; })) !== null && _b !== void 0 ? _b : false;
    }
    existeReinclusaoDoElemento(elementosIncluidos, elemento) {
        return elementosIncluidos.some(elementoIncluido => elementoIncluido.uuid === elemento.uuid);
    }
    marcarLinha(event) {
        try {
            this.quill.desmarcarLinhaAtual(this.quill.linhaAtual);
            const elemento = event.elementos[0];
            const linha = this.quill.getLinha(elemento.uuid);
            this.quill.atualizarLinhaCorrente(linha);
            this.elementoSelecionado(linha.uuid);
            const index = this.quill.getIndex(linha.blotConteudo);
            try {
                this.quill.setIndex(index, Quill.sources.SILENT);
                // eslint-disable-next-line no-empty
            }
            catch (error) { }
            if (event.moverParaFimLinha) {
                setTimeout(() => {
                    const posicao = this.quill.getSelection().index + this.quill.linhaAtual.blotConteudo.html.length;
                    this.quill.setSelection(posicao, 0, Quill.sources.USER);
                }, 0);
            }
        }
        catch (error) {
            // linha, provavelmente, foi removida do Quill
        }
    }
    processarEscolhaMenu(itemMenu) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (itemMenu === renumerarElementoAction) {
            this.renumerarElemento();
        }
        else if (itemMenu === atualizarNotaAlteracaoAction) {
            this.editarNotaAlteracao(this.quill.linhaAtual.elemento);
        }
        else if (itemMenu instanceof AdicionarAgrupadorArtigo) {
            this.adicionarAgrupadorArtigo(this.quill.linhaAtual.elemento);
        }
        else if (itemMenu === removerElementoAction) {
            const linha = this.quill.linhaAtual;
            const elemento = this.criarElemento((_a = linha.uuid) !== null && _a !== void 0 ? _a : 0, linha.uuid2, linha.lexmlId, (_b = linha.tipo) !== null && _b !== void 0 ? _b : '', '', linha.numero, linha.hierarquia);
            elemento.conteudo.texto = (_c = linha.blotConteudo.html) !== null && _c !== void 0 ? _c : '';
            const elementoLinhaAnterior = (_d = this.quill.linhaAtual.prev) === null || _d === void 0 ? void 0 : _d.elemento;
            rootStore.dispatch(itemMenu.execute(elemento, elementoLinhaAnterior));
        }
        else if (itemMenu === exibirDiferencaAction) {
            this.exibirDiferencas(this.quill.linhaAtual.elemento);
        }
        else {
            const linha = this.quill.linhaAtual;
            const elemento = this.criarElemento((_e = linha.uuid) !== null && _e !== void 0 ? _e : 0, linha.uuid2, linha.lexmlId, (_f = linha.tipo) !== null && _f !== void 0 ? _f : '', '', linha.numero, linha.hierarquia);
            elemento.conteudo.texto = (_g = linha.blotConteudo.html) !== null && _g !== void 0 ? _g : '';
            rootStore.dispatch(itemMenu.execute(elemento));
        }
    }
    inserirNovoElementoNoQuill(elemento, referencia, selecionarLinha) {
        var _a, _b;
        const fnSelecionarNovaLinha = (linha, linhaAtual) => {
            this.quill.desmarcarLinhaAtual(linhaAtual);
            this.quill.marcarLinhaAtual(linha);
            try {
                this.quill.setIndex(this.quill.getIndex(linha.blotConteudo), Quill.sources.SILENT);
            }
            catch (e) {
                // console.log(e);
            }
        };
        const linhaASerReinserida = this.quill.getLinha(elemento.uuid);
        if (linhaASerReinserida) {
            linhaASerReinserida.atualizarElemento(elemento);
            selecionarLinha && fnSelecionarNovaLinha(linhaASerReinserida, this.quill.linhaAtual);
            return;
        }
        const linhaRef = this.quill.getLinha(((_a = elemento.elementoAnteriorNaSequenciaDeLeitura) === null || _a === void 0 ? void 0 : _a.uuid) || referencia.uuid);
        if (linhaRef) {
            const novaLinha = EtaQuillUtil.criarContainerLinha(elemento);
            if (linhaRef.next) {
                novaLinha.insertInto(this.quill.scroll, linhaRef.next);
            }
            else {
                novaLinha.insertInto(this.quill.scroll);
            }
            const isEmendaArtigoOndeCouber = rootStore.getState().elementoReducer.modo === ClassificacaoDocumento.EMENDA_ARTIGO_ONDE_COUBER;
            if (((_b = this.quill.linhaAtual) === null || _b === void 0 ? void 0 : _b.blotConteudo.html) !== '' || novaLinha.blotConteudo.html === '' || isEmendaArtigoOndeCouber || elemento.tipo === 'Omissis') {
                selecionarLinha && !this.timerOnChange && fnSelecionarNovaLinha(novaLinha, this.quill.linhaAtual);
            }
            else {
                this.quill.linhaAtual.blotConteudo.htmlAnt = this.quill.linhaAtual.blotConteudo.html;
            }
            novaLinha.descricaoSituacao = elemento.descricaoSituacao;
            novaLinha.existeNaNormaAlterada = elemento.existeNaNormaAlterada;
            novaLinha.setEstilo(elemento);
        }
    }
    inserirNovosElementosNoQuill(event, selecionarLinha) {
        var _a;
        const elementos = (_a = event.elementos) !== null && _a !== void 0 ? _a : [];
        for (let i = 1; i < elementos.length; i++) {
            this.inserirNovoElementoNoQuill(elementos[i], elementos[i - 1], selecionarLinha);
        }
    }
    atualizarSituacao(event) {
        var _a;
        const elementos = (_a = event.elementos) !== null && _a !== void 0 ? _a : [];
        let linha;
        elementos.forEach((elemento) => {
            var _a;
            linha = this.quill.getLinha((_a = elemento.uuid) !== null && _a !== void 0 ? _a : 0, elemento.tipo === 'Ementa' ? undefined : linha);
            if (linha) {
                if (elemento.descricaoSituacao !== linha.descricaoSituacao) {
                    linha.descricaoSituacao = elemento.descricaoSituacao;
                    linha.setEstilo(elemento);
                    linha.atualizarElemento(elemento);
                }
            }
        });
    }
    atualizarAtributos(event) {
        var _a;
        const elementos = (_a = event.elementos) !== null && _a !== void 0 ? _a : [];
        let linha;
        elementos.forEach((elemento) => {
            var _a;
            linha = this.quill.getLinha((_a = elemento.uuid) !== null && _a !== void 0 ? _a : 0, elemento.tipo === 'Ementa' ? undefined : linha);
            if (linha) {
                linha.atualizarElemento(elemento);
            }
        });
    }
    atualizarOmissis(event) {
        var _a;
        const elementos = (_a = event.elementos) !== null && _a !== void 0 ? _a : [];
        let linha;
        elementos.forEach((elemento) => {
            var _a, _b, _c, _d, _e;
            if (elemento.dispositivoAlteracao) {
                linha = this.quill.getLinha((_a = elemento.uuid) !== null && _a !== void 0 ? _a : 0, linha);
                if (linha && normalizaSeForOmissis((_b = linha.blotConteudo) === null || _b === void 0 ? void 0 : _b.html).indexOf(TEXTO_OMISSIS) >= 0) {
                    linha.blotConteudo.html = '';
                    const index = this.quill.getIndex(linha.blotConteudo);
                    this.quill.insertText(index, TEXTO_OMISSIS, { EtaBlotConteudoOmissis: true });
                }
                if (((_c = elemento.conteudo) === null || _c === void 0 ? void 0 : _c.texto) !== (linha === null || linha === void 0 ? void 0 : linha.blotConteudo.html)) {
                    const texto = normalizaSeForOmissis((_e = (_d = elemento.conteudo) === null || _d === void 0 ? void 0 : _d.texto) !== null && _e !== void 0 ? _e : '');
                    if (texto.indexOf(TEXTO_OMISSIS) >= 0) {
                        linha === null || linha === void 0 ? void 0 : linha.domNode.classList.add('container_elemento--omissis');
                    }
                }
            }
        });
    }
    atualizarQuill(event) {
        var _a;
        const elementos = (_a = event.elementos) !== null && _a !== void 0 ? _a : [];
        let linha;
        elementos.map((elemento) => {
            var _a, _b, _c, _d, _e, _f, _g;
            linha = this.quill.getLinha((_a = elemento.uuid) !== null && _a !== void 0 ? _a : 0, elemento.tipo === 'Ementa' ? undefined : linha);
            if (linha) {
                let nivelAlerado = false;
                if (elemento.editavel !== linha.editavel) {
                    linha.editavel = elemento.editavel;
                }
                if (elemento.rotulo !== ((_b = linha.blotRotulo) === null || _b === void 0 ? void 0 : _b.html)) {
                    linha.numero = (_c = elemento.numero) !== null && _c !== void 0 ? _c : '';
                    (_d = linha.blotRotulo) === null || _d === void 0 ? void 0 : _d.format(EtaBlotRotulo.blotName, elemento.rotulo);
                }
                if (elemento.nivel !== linha.nivel) {
                    linha.nivel = elemento.nivel;
                    linha.format(EtaContainerTable.blotName, elemento);
                    nivelAlerado = true;
                }
                if (elemento.agrupador !== linha.agrupador) {
                    linha.agrupador = elemento.agrupador;
                    (_e = linha.blotRotulo) === null || _e === void 0 ? void 0 : _e.format(EtaBlotRotulo.formatoStyle, elemento);
                    if (!nivelAlerado) {
                        linha.format(EtaContainerTable.blotName, elemento);
                    }
                }
                // Substituir o texto apenas quando precisa evita retorno do cursor para o início da linha.
                const novoTexto = (_g = (_f = elemento.conteudo) === null || _f === void 0 ? void 0 : _f.texto) !== null && _g !== void 0 ? _g : '';
                if (linha.blotConteudo.html !== novoTexto) {
                    linha.blotConteudo.html = novoTexto;
                }
                if (elemento.descricaoSituacao !== linha.descricaoSituacao) {
                    linha.descricaoSituacao = elemento.descricaoSituacao;
                    linha.setEstilo(elemento);
                }
                linha.atualizarElemento(elemento);
                if (linha.children.length === 2) {
                    linha.children.tail.remove();
                }
                if (elemento.mensagens && elemento.mensagens.length > 0 && !this.elementoRemovidoEmRevisao(elemento)) {
                    EtaQuillUtil.criarContainerMensagens(elemento).insertInto(linha);
                }
            }
        });
    }
    elementoRemovidoEmRevisao(elemento) {
        if (elemento.revisao && elemento.revisao.stateType === StateType.ElementoRemovido) {
            return true;
        }
        return false;
    }
    removerLinhaQuill(event) {
        var _a;
        const elementos = (_a = event.elementos) !== null && _a !== void 0 ? _a : [];
        let linha;
        elementos.forEach((elemento, index) => {
            var _a, _b;
            linha = this.quill.getLinha((_a = elemento.uuid) !== null && _a !== void 0 ? _a : 0, linha) || this.quill.getLinha((_b = elemento.uuid) !== null && _b !== void 0 ? _b : 0);
            if (linha) {
                if (elemento.revisao && (!linha.elemento.revisao || !isRevisaoDeExclusao(linha.elemento.revisao))) {
                    linha.atualizarElemento(elemento);
                    index === 0 && this.montarMenuContexto(event);
                }
                else {
                    linha.remove();
                }
            }
        });
        const range = this.quill.getSelection();
        if (range) {
            const linhaCursor = this.quill.getLine(range.index - 1)[0].linha;
            const index = this.quill.getIndex(linhaCursor.blotConteudo);
            this.quill.setSelection(index, 0, Quill.sources.SILENT);
            this.quill.marcarLinhaAtual(linhaCursor);
        }
    }
    renumerarQuill(event) {
        var _a;
        const elementos = (_a = event.elementos) !== null && _a !== void 0 ? _a : [];
        let linha;
        elementos.map((elemento) => {
            var _a, _b, _c;
            linha = this.quill.getLinha((_a = elemento.uuid) !== null && _a !== void 0 ? _a : 0, linha) || this.quill.getLinha((_b = elemento.uuid) !== null && _b !== void 0 ? _b : 0);
            if (linha) {
                (_c = linha.blotRotulo) === null || _c === void 0 ? void 0 : _c.format(EtaBlotRotulo.blotName, elemento.rotulo);
            }
        });
    }
    atualizarMensagemQuill(event) {
        var _a;
        const elementos = (_a = event.elementos) !== null && _a !== void 0 ? _a : [];
        let linha;
        elementos.map((elemento) => {
            var _a;
            linha = this.quill.getLinha((_a = elemento.uuid) !== null && _a !== void 0 ? _a : 0, linha);
            if (linha) {
                if ((linha === null || linha === void 0 ? void 0 : linha.children.length) === 2) {
                    linha.children.tail.remove();
                }
                if (elemento.mensagens && elemento.mensagens.length > 0 && !this.elementoRemovidoEmRevisao(elemento)) {
                    EtaQuillUtil.criarContainerMensagens(elemento).insertInto(linha);
                }
            }
        });
    }
    montarMenuContexto(event) {
        var _a, _b;
        const elemento = event.elementos ? event.elementos[0] : new Elemento();
        const acoesMenu = ((_a = elemento === null || elemento === void 0 ? void 0 : elemento.acoesPossiveis) !== null && _a !== void 0 ? _a : []).filter((acao) => isAcaoMenu(acao));
        if (acoesMenu.length > 0) {
            const blotMenu = new EtaBlotMenu();
            const blotMenuConteudo = new EtaBlotMenuConteudo(this.quill.linhaAtual.containerDireito.alinhamentoMenu);
            const callback = (itemMenu) => {
                this.processarEscolhaMenu(itemMenu);
                this.quill.focus();
            };
            new EtaBlotMenuBotao().insertInto(blotMenu);
            acoesMenu.forEach((acao) => {
                new EtaBlotMenuItem(acao, callback).insertInto(blotMenuConteudo);
            });
            blotMenuConteudo.insertInto(blotMenu);
            (_b = this.quill.linhaAtual.blotInsideContainerDireito) === null || _b === void 0 ? void 0 : _b.remove();
            blotMenu.insertInto(this.quill.linhaAtual.containerDireito);
        }
    }
    criarElemento(uuid, uuid2, lexmlId, tipo, html, numero, hierarquia, descricaoSituacao, existeNaNormaAlterada) {
        const elemento = new Elemento();
        elemento.uuid = uuid;
        elemento.uuid2 = uuid2;
        elemento.lexmlId = lexmlId;
        elemento.tipo = tipo;
        elemento.numero = numero;
        elemento.conteudo = { texto: html };
        elemento.hierarquia = hierarquia;
        elemento.descricaoSituacao = descricaoSituacao;
        elemento.existeNaNormaAlterada = existeNaNormaAlterada;
        return elemento;
    }
    inicializar(op) {
        const editorHtml = this.getHtmlElement('lx-eta-editor');
        const bufferHtml = this.getHtmlElement('lx-eta-buffer');
        EtaQuill.configurar();
        this._quill = new EtaQuill(editorHtml, bufferHtml, op);
        this.quill.on('selection-change', this.onSelectionChange);
        this.inscricoes.push(this.quill.keyboard.operacaoTecladoInvalida.subscribe(this.onOperacaoInvalida.bind(this)));
        this.inscricoes.push(this.quill.keyboard.adicionaElementoTeclaEnter.subscribe(this.adicionarElemento.bind(this)));
        this.inscricoes.push(this.quill.keyboard.moveElemento.subscribe(this.moverElemento.bind(this)));
        this.inscricoes.push(this.quill.keyboard.removeElemento.subscribe(this.removerElemento.bind(this)));
        this.inscricoes.push(this.quill.keyboard.removeElementoSemTexto.subscribe(this.removerElementoSemTexto.bind(this)));
        this.inscricoes.push(this.quill.keyboard.renumeraElemento.subscribe(this.renumerarElemento.bind(this)));
        this.inscricoes.push(this.quill.keyboard.transformaElemento.subscribe(this.transformarElemento.bind(this)));
        this.inscricoes.push(this.quill.keyboard.toggleExistencia.subscribe(this.toggleExistencia.bind(this)));
        this.inscricoes.push(this.quill.keyboard.adicionaAgrupador.subscribe(this.adicionaAgrupador.bind(this)));
        this.inscricoes.push(this.quill.undoRedoEstrutura.subscribe(this.undoRedoEstrutura.bind(this)));
        this.inscricoes.push(this.quill.elementoSelecionado.subscribe(this.elementoSelecionado.bind(this)));
        this.inscricoes.push(this.quill.observableSelectionChange.subscribe(this.atualizarTextoElemento.bind(this)));
        this.inscricoes.push(this.quill.keyboard.onChange.subscribe(this.agendarEmissaoEventoOnChange.bind(this)));
        this.inscricoes.push(this.quill.clipboard.onChange.subscribe(this.agendarEmissaoEventoOnChange.bind(this)));
        this.inscricoes.push(onChangeColarDialog.subscribe(this.agendarEmissaoEventoOnChange.bind(this)));
        this.inscricoes.push(this.quill.clipboard.onPasteTextoArticulado.subscribe(this.onPasteTextoArticulado.bind(this)));
        editorHtml.addEventListener('rotulo', (event) => {
            event.stopImmediatePropagation();
            this.renumerarElemento();
        });
        editorHtml.addEventListener('nota-alteracao', (event) => {
            event.stopImmediatePropagation();
            this.editarNotaAlteracao(event.detail.elemento);
        });
        editorHtml.addEventListener('toggle-existencia', (event) => {
            event.stopImmediatePropagation();
            this.toggleExistenciaElemento(event.detail.elemento);
        });
        editorHtml.addEventListener('mensagem', (event) => {
            var _a, _b;
            event.stopImmediatePropagation();
            const linha = this.quill.linhaAtual;
            if (linha) {
                if (AutoFix.RENUMERAR_DISPOSITIVO === ((_b = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.mensagem) === null || _b === void 0 ? void 0 : _b.descricao)) {
                    this.renumerarElemento();
                }
                else {
                    const blotConteudo = linha.blotConteudo;
                    const elemento = this.criarElemento(linha.uuid, linha.uuid2, linha.lexmlId, linha.tipo, blotConteudo.html, linha.numero, linha.hierarquia);
                    rootStore.dispatch(autofixAction.execute(elemento, event.detail.mensagem));
                }
            }
        });
        editorHtml.addEventListener('aceitar-revisao', (event) => {
            event.stopImmediatePropagation();
            this.aceitarRevisao(event.detail.elemento);
        });
        editorHtml.addEventListener('rejeitar-revisao', (event) => {
            event.stopImmediatePropagation();
            this.rejeitarRevisao(event.detail.elemento);
        });
        editorHtml.addEventListener('exibir-diferencas', (event) => {
            event.stopImmediatePropagation();
            this.exibirDiferencas(event.detail.elemento);
        });
        this.configListenersEta();
    }
    exibirDiferencas(elemento) {
        var _a;
        const diff = new TextoDiff();
        diff.textoAtual = elemento.conteudo.texto;
        diff.quill = this.quill;
        const revisao = elemento.revisao;
        const d = buscaDispositivoById(rootStore.getState().elementoReducer.articulacao, elemento.lexmlId);
        if (revisao) {
            diff.textoAntesRevisao = revisao.elementoAntesRevisao.conteudo.texto;
            if (d && d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO && d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
                diff.textoOriginal = d.situacao.dispositivoOriginal.conteudo.texto;
            }
            else {
                diff.textoOriginal = elemento.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ORIGINAL ? diff.textoAtual : diff.textoAntesRevisao;
                diff.adicionado = true;
            }
            exibirDiferencasDialog(diff);
        }
        else {
            if (d && ((_a = d.situacao.dispositivoOriginal) === null || _a === void 0 ? void 0 : _a.conteudo) !== undefined) {
                diff.textoOriginal = d.situacao.dispositivoOriginal.conteudo.texto;
            }
            exibirDiferencasDialog(diff);
        }
    }
    aceitarRevisao(elemento) {
        rootStore.dispatch(aceitarRevisaoAction.execute(elemento, undefined));
        this.alertaGlobalRevisao();
    }
    rejeitarRevisao(elemento) {
        rootStore.dispatch(rejeitarRevisaoAction.execute(elemento, undefined));
    }
    aceitarTodasRevisoes() {
        rootStore.dispatch(aceitarRevisaoAction.execute(undefined, undefined));
    }
    rejeitarTodasRevisoes() {
        rootStore.dispatch(rejeitarRevisaoAction.execute(undefined, undefined));
    }
    agendarEmissaoEventoOnChange(origemEvento, statesType = []) {
        clearTimeout(this.timerOnChange);
        this.timerOnChange = setTimeout(() => this.emitirEventoOnChange(origemEvento, statesType), 1000);
    }
    atualizarTextoElemento(linhaAtual) {
        var _a, _b, _c;
        if ((_a = linhaAtual === null || linhaAtual === void 0 ? void 0 : linhaAtual.blotConteudo) === null || _a === void 0 ? void 0 : _a.alterado) {
            const elemento = this.criarElemento(linhaAtual.uuid, linhaAtual.uuid2, linhaAtual.lexmlId, linhaAtual.tipo, (_c = (_b = linhaAtual.blotConteudo) === null || _b === void 0 ? void 0 : _b.html) !== null && _c !== void 0 ? _c : '', linhaAtual.numero, linhaAtual.hierarquia);
            rootStore.dispatch(atualizarTextoElementoAction.execute(elemento));
        }
    }
    alertaGlobalVerificaRenumeracao() {
        const idAlerta = 'alerta-global-renumeracao';
        const dispositivos = CmdEmdUtil.getDispositivosAdicionados(rootStore.getState().elementoReducer.articulacao);
        if (dispositivos.length && CmdEmdUtil.verificaNecessidadeRenumeracaoRedacaoFinal(dispositivos)) {
            const alerta = {
                id: idAlerta,
                tipo: 'warning',
                mensagem: 'Os rótulos apresentados servem apenas para o posicionamento correto do novo dispositivo no texto. Serão feitas as renumerações necessárias no momento da consolidação das emendas.',
                podeFechar: true,
            };
            rootStore.dispatch(adicionarAlerta$1(alerta));
        }
        else {
            rootStore.dispatch(removerAlerta(idAlerta));
        }
    }
    alertaGlobalVerificaCorrelacao() {
        var _a, _b;
        const dispositivosEmenda = document.querySelector('lexml-eta').getDispositivosEmenda() || [];
        const listaLexmlIds = Object.values(dispositivosEmenda)
            .flat(1)
            .map(obj => obj.id);
        const artigos = [...new Set(listaLexmlIds.map(lexmlId => lexmlId.split('_').filter(dispositivo => dispositivo.startsWith('art'))[0]))];
        if (artigos.length > 1) {
            const alerta = {
                id: 'alerta-global-correlacao',
                tipo: 'info',
                mensagem: 'Cada emenda pode referir-se a apenas um dispositivo, salvo se houver correlação entre dispositivos. Verifique se há correlação entre os dispositivos emendados antes de submetê-la.',
                podeFechar: true,
                exibirComandoEmenda: true,
            };
            rootStore.dispatch(adicionarAlerta$1(alerta));
        }
        else if ((_b = (_a = rootStore.getState().elementoReducer.ui) === null || _a === void 0 ? void 0 : _a.alertas) === null || _b === void 0 ? void 0 : _b.some(alerta => alerta.id === 'alerta-global-correlacao')) {
            rootStore.dispatch(removerAlerta('alerta-global-correlacao'));
        }
    }
    alertaGlobalRevisao() {
        var _a, _b;
        const id = 'alerta-global-revisao';
        const revisoesElementos = document.getElementsByClassName('blot__revisao');
        if (revisoesElementos.length > 0) {
            const alerta = {
                id: id,
                tipo: 'info',
                mensagem: 'Este documento contém marcas de revisão e não deve ser protocolado até que estas sejam removidas.',
                podeFechar: true,
                exibirComandoEmenda: true,
            };
            rootStore.dispatch(adicionarAlerta$1(alerta));
        }
        else if ((_b = (_a = rootStore.getState().elementoReducer.ui) === null || _a === void 0 ? void 0 : _a.alertas) === null || _b === void 0 ? void 0 : _b.some(alerta => alerta.id === id)) {
            rootStore.dispatch(removerAlerta(id));
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    emitirEventoOnChange(origemEvento, statesType = []) {
        var _a;
        this.atualizarTextoElemento(this.quill.linhaAtual);
        this.dispatchEvent(new CustomEvent('onchange', {
            bubbles: true,
            composed: true,
            detail: {
                origemEvento,
            },
        }));
        if (((_a = this.eventosOnChange) === null || _a === void 0 ? void 0 : _a.length) && (this.eventosOnChange.includes(StateType.ElementoIncluido) || this.eventosOnChange.includes(StateType.ElementoRemovido))) {
            this.alertaGlobalVerificaRenumeracao();
        }
        this.alertaGlobalVerificaCorrelacao();
        this.alertaGlobalRevisao();
        this.eventosOnChange = [];
        this.timerOnChange = null;
    }
    carregarArticulacao(elementos) {
        setTimeout(() => {
            this.quill.getLine(0)[0].remove();
            elementos.forEach((elemento) => {
                const etaContainerTable = EtaQuillUtil.criarContainerLinha(elemento);
                etaContainerTable.insertInto(this.quill.scroll);
                etaContainerTable.setEstilo(elemento);
                elemento.tipo === TipoDispositivo.generico.tipo && rootStore.dispatch(validarElementoAction.execute(elemento));
            });
            this.quill.limparHistory();
            if (elementos.length > 1) {
                setTimeout(() => {
                    const el = this.quill.getLinha(elementos[1].uuid);
                    if (el === null || el === void 0 ? void 0 : el.blotConteudo) {
                        this.quill.setSelection(this.quill.getIndex(el === null || el === void 0 ? void 0 : el.blotConteudo), 0, Quill.sources.USER);
                    }
                }, 0);
            }
            rootStore.dispatch(validarArticulacaAction.execute());
        }, 0);
    }
    configEditor() {
        return {
            formats: ['bold', 'italic', 'link', 'script', 'EtaBlotConteudoOmissis'],
            modules: {
                toolbar: {
                    container: '#lx-eta-barra-ferramenta',
                    handlers: {
                        bold: this.onBold.bind(this),
                        italic: this.onItalic.bind(this),
                        script: this.onScript.bind(this),
                    },
                },
                history: {
                    delay: 0,
                    maxStack: 500,
                    userOnly: true,
                },
            },
            theme: 'snow',
        };
    }
    async confirmar(mensagem, botoes, callback) {
        let choice = '';
        const dialog = document.createElement('sl-dialog');
        dialog.label = 'Confirmação';
        const botoesHtml = `
      <sl-button slot="footer" variant="default">Não</sl-button>
      <sl-button slot="footer" variant="primary">Sim</sl-button>
    `;
        dialog.innerHTML = mensagem + botoesHtml;
        document.body.appendChild(dialog);
        await dialog.show();
        const botoesDialog = dialog.querySelectorAll('sl-button');
        const nao = botoesDialog[0];
        const sim = botoesDialog[1];
        sim.focus();
        nao.onclick = () => {
            choice = 'Não';
            dialog === null || dialog === void 0 ? void 0 : dialog.hide();
            dialog === null || dialog === void 0 ? void 0 : dialog.remove();
        };
        sim.onclick = () => {
            choice = 'Sim';
            dialog === null || dialog === void 0 ? void 0 : dialog.hide();
            dialog === null || dialog === void 0 ? void 0 : dialog.remove();
        };
        dialog.addEventListener('sl-request-close', (event) => {
            if (event.detail.source === 'overlay') {
                event.preventDefault();
            }
        });
        dialog.addEventListener('sl-hide', (event) => {
            event.detail.closeResult = choice;
            callback(event);
        });
    }
    alertar(mensagem) {
        const alert = Object.assign(document.createElement('sl-alert'), {
            variant: 'danger',
            closable: true,
            duration: 4000,
            innerHTML: `
        <sl-icon name="exclamation-octagon" slot="icon"></sl-icon>
        ${mensagem}
      `,
        });
        document.body.append(alert);
        alert.toast();
    }
    quillNaoInicializado(state) {
        var _a;
        let elementos = [];
        const verificarQuillInicializado = (elementos) => {
            setTimeout(() => {
                if (!this.quill) {
                    verificarQuillInicializado(elementos);
                }
                else if (elementos.length > 0) {
                    this.carregarArticulacao(elementos);
                }
            }, 70);
        };
        if (state.elementoReducer.ui) {
            const event = state.elementoReducer.ui.events.find((event) => event.stateType === StateType.DocumentoCarregado);
            elementos = (_a = event === null || event === void 0 ? void 0 : event.elementos) !== null && _a !== void 0 ? _a : [];
        }
        verificarQuillInicializado(elementos);
    }
    getHtmlElement(id) {
        return this.querySelector(`#${id}`);
    }
    destroiQuill() {
        this.removeListenersEta();
        this.getHtmlElement('lx-eta-editor').innerHTML = '';
        this.getHtmlElement('lx-eta-buffer').innerHTML = '';
        if (this.quill) {
            this.quill.off('selection-change', this.onSelectionChange);
            this.quill.destroi();
        }
        this._quill = undefined;
    }
    configListenersEta() {
        const editorHtml = this.getHtmlElement('lx-eta-editor');
        editorHtml.addEventListener('rotulo', this.listenerRotulo);
        editorHtml.addEventListener('nota-alteracao', this.listenerNotaAlteracao);
        editorHtml.addEventListener('toggle-existencia', this.listenerToggleExistencia);
        editorHtml.addEventListener('mensagem', this.listenerMensagem);
        editorHtml.addEventListener('aceitar-revisao', this.listenerAceitarRevisao);
        editorHtml.addEventListener('rejeitar-revisao', this.listenerRejeitarRevisao);
    }
    removeListenersEta() {
        const editorHtml = this.getHtmlElement('lx-eta-editor');
        editorHtml.removeEventListener('rotulo', this.listenerRotulo);
        editorHtml.removeEventListener('nota-alteracao', this.listenerNotaAlteracao);
        editorHtml.removeEventListener('toggle-existencia', this.listenerToggleExistencia);
        editorHtml.removeEventListener('mensagem', this.listenerMensagem);
        editorHtml.removeEventListener('aceitar-revisao', this.listenerAceitarRevisao);
        editorHtml.removeEventListener('rejeitar-revisao', this.listenerRejeitarRevisao);
    }
    async onPasteTextoArticulado(payload) {
        const linha = this.quill.linhaAtual;
        const elemento = new Elemento();
        elemento.uuid = linha.uuid;
        elemento.tipo = linha.tipo;
        const infoTextoColado = await InfoTextoColado.newInstanceFromTexto(payload.textoColadoOriginal, payload.textoColadoAjustado, rootStore.getState().elementoReducer.articulacao, linha.elemento);
        colarTextoArticuladoDialog(this.quill, rootStore, infoTextoColado, payload.range);
    }
    atualizarEstiloBotaoRevisao() {
        const botaoRevisao = this.getHtmlElement('lx-eta-btn-revisao');
        if (botaoRevisao) {
            botaoRevisao.classList.toggle('revisao-ativa', rootStore.getState().elementoReducer.emRevisao);
        }
    }
    indicadorTextoModificado(events) {
        const ignorarStateTypes = [
            StateType.DocumentoCarregado,
            StateType.ElementoIncluido,
            StateType.ElementoValidado,
            StateType.AtualizaUsuario,
            StateType.AtualizacaoAlertas,
        ];
        const mapElementos = new Map();
        events
            .filter(ev => !ignorarStateTypes.includes(ev.stateType))
            .map(ev => ev.elementos || [])
            .flat()
            .forEach(e => mapElementos.set(e.uuid, e));
        const elementos = [...mapElementos.values()];
        const uuidsElementosSemModificacao = elementos.filter(e => e.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_MODIFICADO).map(e => e.uuid);
        const uuidsElementosComModificacao = elementos
            .filter(e => {
            var _a, _b, _c;
            return e.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO ||
                (e.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO && e.revisao && e.revisao.descricao === 'Texto do dispositivo foi alterado') ||
                (e.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ORIGINAL &&
                    e.revisao &&
                    ((_b = (_a = e.revisao.elementoAntesRevisao) === null || _a === void 0 ? void 0 : _a.conteudo) === null || _b === void 0 ? void 0 : _b.texto) !== ((_c = e.conteudo) === null || _c === void 0 ? void 0 : _c.texto));
        }
        // || (e.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ORIGINAL && e.revisao
        //   && (e.revisao.descricao === 'Dispositivo restaurado' || e.revisao.descricao === 'Texto do dispositivo foi alterado'))
        )
            .map(e => e.uuid);
        uuidsElementosSemModificacao.forEach(uuid => {
            var _a;
            const containerOpcoes = document.getElementById(EtaContainerOpcoes.className + uuid);
            if (containerOpcoes) {
                const linha = this.quill.getLinha(uuid);
                (_a = linha === null || linha === void 0 ? void 0 : linha.containerOpcoes) === null || _a === void 0 ? void 0 : _a.remove();
                containerOpcoes.remove();
            }
        });
        uuidsElementosComModificacao.forEach(uuid => {
            var _a;
            const linha = this.quill.getLinha(uuid);
            if (linha) {
                this.adicionaRemoveOpcaoDiffMenu(linha.elemento, uuidsElementosComModificacao);
                if ((_a = linha.containerOpcoes) === null || _a === void 0 ? void 0 : _a.blotBotaoExibirDiferencas) {
                    linha.containerOpcoes.atualizarElemento(mapElementos.get(uuid));
                }
                else {
                    const containerOpcoes = document.getElementById(EtaContainerOpcoes.className + uuid);
                    if (containerOpcoes) {
                        containerOpcoes.remove();
                    }
                    const containerTr = linha.children.head;
                    containerTr.insertBefore(EtaQuillUtil.criarContainerOpcoes(mapElementos.get(uuid)), linha.containerDireito.prev);
                }
            }
        });
    }
    adicionaRemoveOpcaoDiffMenu(elemento, uuidsElementosComModificacao) {
        var _a;
        if (uuidsElementosComModificacao.includes(elemento.uuid)) {
            (_a = elemento.acoesPossiveis) === null || _a === void 0 ? void 0 : _a.push(exibirDiferencaAction);
        }
    }
    indicadorMarcaRevisao(events) {
        const ignorarStateTypes = [
            StateType.DocumentoCarregado,
            StateType.ElementoIncluido,
            StateType.ElementoValidado,
            StateType.AtualizaUsuario,
            StateType.AtualizacaoAlertas,
        ];
        const mapElementos = new Map();
        events
            .filter(ev => !ignorarStateTypes.includes(ev.stateType))
            .map(ev => ev.elementos || [])
            .flat()
            .forEach(e => mapElementos.set(e.uuid, e));
        const elementos = [...mapElementos.values()];
        const uuidsElementosSemRevisao = elementos.filter(e => !e.revisao).map(e => e.uuid);
        const uuidsElementosComRevisao = elementos.filter(e => e.revisao && isRevisaoPrincipal(e.revisao)).map(e => e.uuid);
        // Remove container de revisão de elementos que não estão mais em revisão
        uuidsElementosSemRevisao.forEach(uuid => {
            var _a;
            const containerRevisao = document.getElementById(EtaContainerRevisao.className + uuid);
            if (containerRevisao) {
                const linha = this.quill.getLinha(uuid);
                (_a = linha === null || linha === void 0 ? void 0 : linha.containerRevisao) === null || _a === void 0 ? void 0 : _a.remove();
            }
        });
        // Adiciona (ou atualiza) container de revisão para elementos que estão em revisão
        uuidsElementosComRevisao.forEach(uuid => {
            var _a;
            const linha = this.quill.getLinha(uuid);
            if (linha) {
                if ((_a = linha.containerRevisao) === null || _a === void 0 ? void 0 : _a.blotBotaoAceitarRevisao) {
                    linha.containerRevisao.atualizarElemento(mapElementos.get(uuid));
                }
                else {
                    const containerTr = linha.children.head;
                    containerTr.insertBefore(EtaQuillUtil.criarContainerRevisao(mapElementos.get(uuid)), linha.containerDireito.prev);
                }
            }
        });
    }
    // private atualizaQuantidadeRevisao = (): void => {
    //   atualizaQuantidadeRevisao(rootStore.getState().elementoReducer.revisoes, document.getElementById(this._idBadgeQuantidadeRevisao) as any);
    // };
    atualizarStatusBotoesRevisao() {
        const numRevisoes = getQuantidadeRevisoes(rootStore.getState().elementoReducer.revisoes);
        this.btnAceitarTodasRevisoes && (this.btnAceitarTodasRevisoes.disabled = numRevisoes === 0);
        this.btnRejeitarTodasRevisoes && (this.btnRejeitarTodasRevisoes.disabled = numRevisoes === 0);
    }
};
__decorate([
    e$3({ type: Object })
], EditorComponent.prototype, "lexmlEtaConfig", void 0);
__decorate([
    i$1('lexml-ajuda-modal')
], EditorComponent.prototype, "ajudaModal", void 0);
__decorate([
    i$1('lexml-atalhos-modal')
], EditorComponent.prototype, "atalhosModal", void 0);
__decorate([
    i$1('lexml-emenda-comando-modal')
], EditorComponent.prototype, "comandoEmendaModal", void 0);
__decorate([
    i$1('#btnAceitarTodasRevisoes')
], EditorComponent.prototype, "btnAceitarTodasRevisoes", void 0);
__decorate([
    i$1('#btnRejeitarTodasRevisoes')
], EditorComponent.prototype, "btnRejeitarTodasRevisoes", void 0);
__decorate([
    e$3({ type: Boolean })
], EditorComponent.prototype, "exibirBotoesParaTratarTodas", void 0);
EditorComponent = __decorate([
    n$1('lexml-eta-editor')
], EditorComponent);

let ElementoComponent = class ElementoComponent extends s {
    constructor() {
        super(...arguments);
        this.htmlAgrupador = () => {
            var _a, _b, _c;
            return $ `<p class="rotulo">${this.elemento.rotulo}</p>
      <p class="texto-agrupador">${o((_c = (_b = (_a = this.elemento) === null || _a === void 0 ? void 0 : _a.conteudo) === null || _b === void 0 ? void 0 : _b.texto) !== null && _c !== void 0 ? _c : '')}</p>`;
        };
        this.htmlDispositivo = () => {
            var _a, _b, _c;
            return $ `
      <p class="texto" style="${`padding-left: ${this.elemento.nivel * 20}px;`}">
        <span class="rotulo">${this.elemento.rotulo}</span>
        ${o((_c = (_b = (_a = this.elemento) === null || _a === void 0 ? void 0 : _a.conteudo) === null || _b === void 0 ? void 0 : _b.texto) !== null && _c !== void 0 ? _c : '')}
      </p>
    `;
        };
    }
    render() {
        return $ `
      <div class="box">
        <div class="conteudo">${this.elemento.agrupador ? this.htmlAgrupador() : this.htmlDispositivo()}</div>
      </div>
    `;
    }
};
ElementoComponent.styles = r$2 `
    :host {
      display: block;
      padding: 0px;
      margin: 0px;
      font-family: sans-serif, 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
        'Noto Color Emoji';
      font-size: 1.1em;
      line-height: 1.2;
      color: #646260;
      text-transform: none !important;
    }

    p.rotulo {
      margin: 5px !important;
      color: #373634;
      font-weight: 600;
      text-align: center;
    }

    p.texto {
      margin: 5px !important;
    }

    p.texto-agrupador {
      margin: 5px !important;
      text-align: center;
    }

    span.rotulo {
      color: #373634;
      font-weight: 600;
    }
  `;
__decorate([
    e$3({ type: Object })
], ElementoComponent.prototype, "elemento", void 0);
ElementoComponent = __decorate([
    n$1('lexml-eta-elemento')
], ElementoComponent);

let AtalhosComponent = class AtalhosComponent extends s {
    render() {
        return $ `
      <div class="lx-eta-help">
        <div class="lx-eta-help-content">
          <h4>Desfazer e refazer</h4>
          <div class="lx-eta-help-group">
            <div><sl-badge variant="neutral">Ctrl</sl-badge>+<sl-badge variant="neutral">Z</sl-badge>&nbsp;-&nbsp;Desfaz ultima alteração</div>
            <div><sl-badge variant="neutral">Ctrl</sl-badge>+<sl-badge variant="neutral">Y</sl-badge>&nbsp;-&nbsp;Refaz alteração</div>
          </div>
          <h4>Seleção e navegação</h4>
          <div class="lx-eta-help-group">
            <div>
              <sl-badge variant="neutral">Ctrl</sl-badge>+<sl-badge variant="neutral">Shift</sl-badge>+<sl-badge variant="neutral">A</sl-badge>&nbsp;-&nbsp;Seleciona o texto do
              dispositivo atual
            </div>
            <div><sl-badge variant="neutral">Ctrl</sl-badge>+<sl-badge variant="neutral">Home</sl-badge>&nbsp;-&nbsp;Vai para o primeiro dispositivo</div>
            <div><sl-badge variant="neutral">Ctrl</sl-badge>+<sl-badge variant="neutral">End</sl-badge>&nbsp;-&nbsp;Vai para o último dispositivo</div>
            <div><sl-badge variant="neutral">Ctrl</sl-badge>+<sl-badge variant="neutral">F</sl-badge>&nbsp;-&nbsp;Localizar texto</div>
          </div>
          <h4>Criação e edição de dispositivos adicionados</h4>
          <div class="lx-eta-help-group">
            <div>
              <sl-badge variant="neutral">Enter</sl-badge>&nbsp;-&nbsp;Cria um novo dispositivo do mesmo tipo ou cria dispositivo subordinado quando termina com dois pontos
            </div>
            <div><span class="lx-eta-help-info">Os atalhos abaixo funcionam apenas para dispositivos adicionados</span></div>
            <div><sl-badge variant="neutral">Tab</sl-badge>&nbsp;-&nbsp;Indenta para a direita o dispositivo, transformando-o no tipo mais provável</div>
            <div>
              <sl-badge variant="neutral">Shift</sl-badge>+<sl-badge variant="neutral">Tab</sl-badge>&nbsp;-&nbsp;Recua o dispositivo para a esquerda, transformando-o no tipo mais
              provável
            </div>
            <div><sl-badge variant="neutral">Alt</sl-badge>+<sl-badge variant="neutral">&uarr;</sl-badge>&nbsp;-&nbsp;Move o dispositivo para cima</div>
            <div><sl-badge variant="neutral">Alt</sl-badge>+<sl-badge variant="neutral">&darr;</sl-badge>&nbsp;-&nbsp;Move o dispositivo para baixo</div>
            <div><sl-badge variant="neutral">Ctrl</sl-badge>+<sl-badge variant="neutral">D</sl-badge>&nbsp;-&nbsp;Remove dispositivo atual</div>
            <div><span class="lx-eta-help-info">Os atalhos abaixo funcionam apenas para dispositivos adicionados em alteração de normas</span></div>
            <div>
              <sl-badge variant="neutral">Ctrl</sl-badge>+<sl-badge variant="neutral">Alt</sl-badge>+<sl-badge variant="neutral">N</sl-badge>&nbsp;-&nbsp;Numera o dispositivo que
              foi adicionado em alteração de norma
            </div>
            <div>
              <sl-badge variant="neutral">Ctrl</sl-badge>+<sl-badge variant="neutral">Alt</sl-badge>+<sl-badge variant="neutral">O</sl-badge>&nbsp;-&nbsp;Omite dispositivos
              (transforma em linha pontilhada que representa um ou mais dispositivos omitidos)
            </div>
            <div><sl-badge variant="neutral">...</sl-badge>&nbsp;-&nbsp;Digitando três pontos no texto do dispositivo, cria-se uma linha pontilhada</div>
          </div>
          <h4>Formatação de texto</h4>
          <div class="lx-eta-help-group">
            <div><sl-badge variant="neutral">Ctrl</sl-badge>+<sl-badge variant="neutral">B</sl-badge>&nbsp;-&nbsp;Aplica <b>negrito</b> ao texto selecionado</div>
            <div><sl-badge variant="neutral">Ctrl</sl-badge>+<sl-badge variant="neutral">I</sl-badge>&nbsp;-&nbsp;Aplica <i>itálico</i> ao texto selecionado</div>
          </div>
        </div>
      </div>
    `;
    }
};
AtalhosComponent.styles = r$2 `
    :host {
      display: block;
      padding: 10px;
      font-family: var(--sl-font-sans);
    }
    .lx-eta-help-content div div {
      color: black;
      padding: 0.4rem 0;
      text-decoration: none;
      display: block;
      white-space: wrap;
      font-size: 0.8em;
      font-weight: normal !important;
      text-align: left;
    }

    .lx-eta-help-info {
      display: block;
      font-weight: normal !important;
      text-align: left;
      color: #555555;
      background-color: #fefefe;
      border: 0.5px solid #ccc;
      padding: 0.5rem;
      margin-block: 0.1rem;
      border-radius: 0.5rem;
      font-style: italic;
    }
    .lx-eta-help-content h4 {
      padding: 1rem 0 0.5rem 0;
      margin: 0;
    }

    .lx-eta-help-group {
      background-color: #eeeeee;
      padding: 0.5rem;
      border-radius: 0.5rem;
      border: 0.5px solid #ccc;
      box-shadow: var(--sl-shadow-x-large);
      margin-block-end: 1rem;
    }
  `;
AtalhosComponent = __decorate([
    n$1('lexml-eta-atalhos')
], AtalhosComponent);

const atualizaRevisaoJustificativa = (state, removeAllRevisoesJustificativa = false) => {
    if (!state.emRevisao) {
        return state;
    }
    if (!removeAllRevisoesJustificativa) {
        let revisoes = [];
        revisoes = criaRevisaoJustificativa(state);
        if (revisoes.length > 0) {
            state.revisoes.push(...revisoes);
        }
    }
    else {
        remove$1(state);
    }
    return state;
};
const remove$1 = (state) => {
    var _a;
    state.revisoes = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => r.descricao !== RevisaoJustificativaEnum.JustificativaAlterada);
};
const criaRevisaoJustificativa = (state) => {
    const result = [];
    if (!jaExisteRevisaoUsuarioAtual$1(state)) {
        result.push(new RevisaoJustificativa(state.usuario, formatDateTime(new Date()), RevisaoJustificativaEnum.JustificativaAlterada));
    }
    return result;
};
const jaExisteRevisaoUsuarioAtual$1 = (state) => {
    var _a;
    const revisoesUsuarioAtual = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => { var _a; return r.usuario.nome === ((_a = state.usuario) === null || _a === void 0 ? void 0 : _a.nome) && r.descricao === RevisaoJustificativaEnum.JustificativaAlterada; });
    if (revisoesUsuarioAtual.length > 0) {
        const revisaoDataHoraModificada = revisoesUsuarioAtual[0];
        revisaoDataHoraModificada.dataHora = formatDateTime(new Date());
        return true;
    }
    return false;
};

async function uploadAnexoDialog(anexos, atualizaAnexo, editorTextoRico) {
    const dialogElem = document.createElement('sl-dialog');
    editorTextoRico.appendChild(dialogElem);
    dialogElem.label = 'Anexo';
    dialogElem.addEventListener('sl-request-close', (event) => {
        if (event.detail.source === 'overlay') {
            event.preventDefault();
        }
    });
    const content = document.createRange().createContextualFragment(`
  <style>
    .anexo-item {
      display: flex;
      align-items: center;
      gap: 0.5em;
      margin-bottom: 1em;
    }

    sl-icon[name="paperclip"] {
      width: 1.5em;
      height: 1.5em;
    }

    sl-button sl-icon {
      font-size: 1.5em;
      pointer-events: none;
      vertical-align: -4px;
    }

    #input-upload::part(form-control) {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 1em;
    }
  </style>
  <div id="wp-upload">
    <label for="input-upload">Selecione o arquivo a ser anexado à emenda</label>
    <br/>
    <br/>
    <input id="input-upload" type="file" accept="application/pdf" size="small"></input>
  </div>
  <br/>
  <div id="form" class="input-validation-required"></div>
  <br/>
  <sl-button class="controls" slot="footer" variant="primary">Confirmar</sl-button>
  <sl-button class="controls" slot="footer" variant="default">Cancelar</sl-button>
  `);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const removerAnexo = (e) => {
        const nomeArquivo = e.target.getAttribute('nomeArquivo');
        anexos = anexos.filter(a => a.nomeArquivo !== nomeArquivo);
        conteudoDinamico();
    };
    // cria função para exibir anexo em nova aba
    const exibirAnexo = (e) => {
        var _a, _b;
        const nomeArquivo = e.target.getAttribute('nomeArquivo');
        const anexo = anexos.find(a => a.nomeArquivo === nomeArquivo);
        const win = window.open();
        if ((_a = anexo === null || anexo === void 0 ? void 0 : anexo.nomeArquivo) === null || _a === void 0 ? void 0 : _a.match(/\.(pdf)$/)) {
            win === null || win === void 0 ? void 0 : win.document.write(`<embed src="${anexo === null || anexo === void 0 ? void 0 : anexo.base64}" width="100%" height="100%" type="application/pdf"></embed>`);
            return;
        }
        if ((_b = anexo === null || anexo === void 0 ? void 0 : anexo.nomeArquivo) === null || _b === void 0 ? void 0 : _b.match(/\.(jpeg|jpg|gif|png|svg)$/)) {
            win === null || win === void 0 ? void 0 : win.document.write(`<img src="${anexo === null || anexo === void 0 ? void 0 : anexo.base64}" style="width:100%; height:auto;">`);
            return;
        }
        win === null || win === void 0 ? void 0 : win.document.write(`<a href="${anexo === null || anexo === void 0 ? void 0 : anexo.base64}" download="${anexo === null || anexo === void 0 ? void 0 : anexo.nomeArquivo}">Download do arquivo anexo</a>`);
    };
    const conteudoDinamico = () => {
        let htmlConteudo = '';
        wpUpload.hidden = anexos.length ? true : false;
        anexos.forEach(a => (htmlConteudo += `<span class="anexo-item">
                            <sl-icon name="paperclip"></sl-icon>
                            <span>${a.nomeArquivo}</span>
                            <!--
                            <sl-button class="btn-preview-anexo" size="small" title="Visualizar o anexo em uma nova janela" nomeArquivo="${a.nomeArquivo}">
                              <sl-icon name="eye"></sl-icon>
                            </sl-button>
                            -->
                            <sl-button class="btn-remove-anexo" size="small" title="Remover anexo" nomeArquivo="${a.nomeArquivo}">
                              <sl-icon name="x"></sl-icon>
                            </sl-button>
                          </span>`));
        form.innerHTML = htmlConteudo;
        const btns = form === null || form === void 0 ? void 0 : form.querySelectorAll('.btn-remove-anexo');
        (btns || []).forEach(btn => (btn.onclick = removerAnexo));
        const btns_preview = form === null || form === void 0 ? void 0 : form.querySelectorAll('.btn-preview-anexo');
        (btns_preview || []).forEach(btn_preview => (btn_preview.onclick = exibirAnexo));
    };
    const wpUpload = content.querySelector('#wp-upload');
    const inputUpload = content.querySelector('#input-upload');
    const form = content.querySelector('#form');
    const botoes = content.querySelectorAll('.controls');
    const confirmar = botoes[0];
    const fechar = botoes[1];
    inputUpload.oninput = () => {
        addAnexo();
    };
    confirmar.onclick = () => {
        atualizaAnexo(anexos);
        agendarEmissaoEventoOnChange(dialogElem);
        dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
        dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.remove();
        anexos = [];
    };
    fechar.onclick = () => {
        dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.hide();
        dialogElem === null || dialogElem === void 0 ? void 0 : dialogElem.remove();
        anexos = [];
    };
    const agendarEmissaoEventoOnChange = (elemento) => {
        elemento.dispatchEvent(new CustomEvent('onchange', {
            bubbles: true,
            composed: true,
            detail: {
                origemEvento: 'anexo',
            },
        }));
    };
    const addAnexo = async () => {
        if (inputUpload === null || inputUpload === void 0 ? void 0 : inputUpload.files) {
            const file = inputUpload.files[0];
            const anexo = await convertAnexo(file);
            anexos.push(anexo);
            inputUpload.files = null;
            conteudoDinamico();
        }
    };
    const convertAnexo = (file) => {
        return new Promise((resolve, reject) => {
            confirmar.disabled = true;
            fechar.disabled = true;
            const fileReader = new FileReader();
            fileReader.readAsDataURL(file);
            fileReader.onload = () => {
                var _a;
                confirmar.disabled = false;
                fechar.disabled = false;
                resolve({ nomeArquivo: file.name, base64: (((_a = fileReader.result) === null || _a === void 0 ? void 0 : _a.toString()) || '').replace(/.*;base64,/, '') });
            };
            fileReader.onerror = error => reject(error);
        });
    };
    conteudoDinamico();
    await dialogElem.appendChild(content);
    await dialogElem.show();
}

const atualizaRevisaoTextoLivre = (state, removeAllRevisoesTextoLivre = false) => {
    if (!state.emRevisao) {
        return state;
    }
    if (!removeAllRevisoesTextoLivre) {
        let revisoes = [];
        revisoes = criaRevisaoTextoLivre(state);
        if (revisoes.length > 0) {
            state.revisoes.push(...revisoes);
        }
    }
    else {
        remove(state);
    }
    return state;
};
const remove = (state) => {
    var _a;
    state.revisoes = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => r.descricao !== RevisaoTextoLivreEnum.TextoLivreAlterado);
};
const criaRevisaoTextoLivre = (state) => {
    const result = [];
    if (!jaExisteRevisaoUsuarioAtual(state)) {
        result.push(new RevisaoTextoLivre(state.usuario, formatDateTime(new Date()), RevisaoTextoLivreEnum.TextoLivreAlterado));
    }
    return result;
};
const jaExisteRevisaoUsuarioAtual = (state) => {
    var _a;
    const revisoesUsuarioAtual = (_a = state.revisoes) === null || _a === void 0 ? void 0 : _a.filter(r => { var _a; return r.usuario.nome === ((_a = state.usuario) === null || _a === void 0 ? void 0 : _a.nome) && r.descricao === RevisaoTextoLivreEnum.TextoLivreAlterado; });
    if (revisoesUsuarioAtual.length > 0) {
        const revisaoDataHoraModificada = revisoesUsuarioAtual[0];
        revisaoDataHoraModificada.dataHora = formatDateTime(new Date());
        return true;
    }
    return false;
};

const editorTextoRicoCss = $ `
  <style>
    .editor-texto-rico {
      height: 375px;
      font-size: 18px !important;
    }
    .editor-texto-rico p,
    .editor-texto-rico ol,
    .editor-texto-rico ul {
      margin-bottom: 0.7rem;
    }
    .editor-texto-rico p:not(.ql-align-rigth, .ql-align-center) {
      text-indent: 3rem;
    }
    .ql-toolbar.ql-snow .ql-formats {
      margin-right: 8px;
    }
    .editor-texto-rico .estilo-ementa {
      text-indent: 0 !important;
      text-align: justify;
      margin-left: 40%;
    }
    .editor-texto-rico .estilo-norma-alterada {
      margin-left: 3rem;
    }

    #revisoes-justificativa-icon sl-icon,
    #revisoes-texto-livre-icon sl-icon,
    #aceita-revisao-justificativa {
      margin-right: 0.1rem;
    }

    .revisoes-justificativa-icon__ativo {
      color: white;
      background-color: var(--sl-color-warning-600) !important;
      border-color: white !important;
    }
    .revisoes-texto-livre-icon__ativo {
      color: white;
      background-color: var(--sl-color-warning-600) !important;
      border-color: white !important;
    }
    .lista-revisoes-justificativa {
      padding-left: 1rem;
      padding-right: 0.5rem;
    }
    #chk-em-revisao-justificativa {
      border: 1px solid #ccc !important;
      padding: 5px 10px !important;
      border-radius: 20px !important;
      margin-left: auto;
      margin-right: 5px;
      font-weight: bold;
      background-color: #eee;
    }
    #chk-em-revisao-justificativa[checked] {
      background-color: var(--sl-color-blue-100);
    }

    #chk-em-revisao-texto-livre {
      border: 1px solid #ccc !important;
      padding: 5px 10px !important;
      border-radius: 20px !important;
      margin-left: auto;
      margin-right: 5px;
      font-weight: bold;
      background-color: #eee;
    }
    #chk-em-revisao-texto-livre[checked] {
      background-color: var(--sl-color-blue-100);
    }
    #toolbar {
      padding: 1.5px 0 1.5px 8px;
    }

    #badge-marca-alteracao-justificativa::part(base) {
      min-width: 1.4rem;
    }

    #badge-marca-alteracao-texto-livre::part(base) {
      min-width: 1.4rem;
    }
    revisao-container {
      margin-left: auto;
    }

    .ql-toolbar .panel-revisao {
      display: flex;
      flex-grow: 1;
    }

    .ql-picker.ql-estilo .ql-picker-label {
      width: 160px;
    }

    .ql-picker.ql-estilo .ql-picker-label::before,
    .ql-picker.ql-estilo .ql-picker-item::before {
      content: 'Texto normal';
    }

    .ql-picker.ql-estilo .ql-picker-label[data-value='ementa']:before,
    .ql-picker.ql-estilo .ql-picker-item[data-value='ementa']:before {
      content: 'Ementa';
    }

    .ql-picker.ql-estilo .ql-picker-label[data-value='norma-alterada']:before,
    .ql-picker.ql-estilo .ql-picker-item[data-value='norma-alterada']:before {
      content: 'Norma alterada';
    }

    .ql-estilo span.ql-picker-label {
      border-color: #ccc !important;
    }

    .ql-picker-item[data-value='insert']::after {
      content: 'Inserir tabela';
    }

    .ql-picker-item[data-value='append-col']::after {
      content: 'Inserir coluna';
    }

    .ql-picker-item[data-value='append-col-before']::after {
      content: 'Inserir coluna à esquerda';
    }

    .ql-picker-item[data-value='append-col-after']::after {
      content: 'Inserir coluna à direita';
    }

    .ql-picker-item[data-value='remove-col']::after {
      content: 'Remover coluna';
    }

    .ql-picker-item[data-value='append-row']::after {
      content: 'Inserir linha';
    }

    .ql-picker-item[data-value='append-row-above']::after {
      content: 'Inserir linha acima';
    }

    .ql-picker-item[data-value='append-row-below']::after {
      content: 'Inserir linha abaixo';
    }

    .ql-picker-item[data-value='remove-row']::after {
      content: 'Remover linha';
    }

    .ql-picker-item[data-value='split-cell']::after {
      content: 'Dividir célula';
    }

    .ql-picker-item[data-value='merge-selection']::after {
      content: 'Mesclar células';
    }

    .ql-picker-item[data-value='remove-cell']::after {
      content: 'Remover célula';
    }

    .ql-picker-item[data-value='remove-selection']::after {
      content: 'Remover seleção';
    }

    .ql-picker-item[data-value='undo']::after {
      content: 'Desfazer';
    }

    .ql-picker-item[data-value='redo']::after {
      content: 'Refazer';
    }

    .ql-picker-item[data-value='remove-table']:before {
      content: 'Remover tabela';
    }

    .ql-editor td > p {
      text-indent: 0 !important;
      margin-bottom: 0 !important;
    }

    .table-selected {
      border: 1px solid #87ceeb; /* Define a borda sólida em tom azul claro */
      box-shadow: 0 0 10px rgba(135, 206, 235, 0.5); /* Adiciona sombra com tom azul claro */
    }

    .ql-snow .ql-editor img {
      max-width: 60%;
    }

    .editor-texto-rico p.ql-text-indent-0px {
      text-indent: 0;
    }

    .editor-texto-rico p.ql-margin-bottom-0px {
      margin-bottom: 0;
    }

    @media (max-width: 768px) {
      .mobile-buttons {
        display: inline-block !important;
      }
      #chk-em-revisao-justificativa span {
        display: none;
      }
      .ql-snow .ql-editor img {
        max-width: 100%;
      }
    }
  </style>
`;

const Parchment$9 = Quill.import('parchment');
const config$2 = {
    scope: Parchment$9.Scope.BLOCK,
    whitelist: ['ementa', 'norma-alterada'],
};
const EstiloTextoClass = new Parchment$9.Attributor.Class('estilo', 'estilo', config$2);

const quillTableCss = $ `<style>
  .ql-editor table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
    overflow: hidden;
    white-space: nowrap;
  }

  .ql-editor table td {
    border: 1px solid black;
    padding: 2px 5px;
    height: 25px;
    vertical-align: top;
    white-space: pre-wrap; /* https://github.com/quilljs/quill/issues/1760 */
  }

  .ql-editor table td[rowspan='2'] {
    height: 50px;
  }

  .ql-editor table td[rowspan='3'] {
    height: 75px;
  }

  .ql-editor table td[rowspan='4'] {
    height: 100px;
  }

  .ql-editor table td[rowspan='5'] {
    height: 125px;
  }

  .ql-editor table td[rowspan='6'] {
    height: 150px;
  }

  .ql-editor table td[rowspan='7'] {
    height: 175px;
  }

  .ql-editor table td[rowspan='8'] {
    height: 200px;
  }

  .ql-editor table td[rowspan='9'] {
    height: 225px;
  }

  .ql-editor table td.ql-cell-selected {
    background-color: #cce0f8;
  }

  .ql-editor table td[merge_id] {
    display: none;
  }

  .quill-better-table-wrapper {
    overflow-x: auto;
  }

  .ql-picker.ql-table {
    width: auto !important;
    margin-right: 0;
  }

  .ql-picker.ql-table .ql-picker-label svg {
    display: none;
  }

  .ql-picker.ql-table .ql-picker-label::before {
    display: block;
    font-size: 14px;
  }

  .ql-table:nth-of-type(1) .ql-picker-label {
    background: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-table" viewBox="0 0 16 16"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2zm15 2h-4v3h4V4zm0 4h-4v3h4V8zm0 4h-4v3h3a1 1 0 0 0 1-1v-2zm-5 3v-3H6v3h4zm-5 0v-3H1v2a1 1 0 0 0 1 1h3zm-4-4h4V8H1v3zm0-4h4V4H1v3zm5-3v3h4V4H6zm4 4H6v3h4V8z"/></svg>')
        no-repeat center,
      white;
    background-size: 16px;
  }

  .ql-picker.ql-table .ql-picker-label::before {
    font-family: 'Font Awesome 6 Free';
    font-weight: 900;
    padding-top: 2px;
    line-height: 1em;
  }

  .ql-table:nth-of-type(1),
  .ql-contain {
    width: 90px;
    margin-right: 0;
  }

  .ql-picker.ql-table:nth-of-type(1) {
    font-size: 11px;
    font-weight: normal;
  }

  .ql-picker.ql-table .ql-picker-label {
    padding: 2px 3px;
    width: 23px;
  }

  .ql-picker.ql-table:nth-of-type(1) .ql-picker-options {
    width: 180px;
  }

  .ql-picker.ql-table:nth-of-type(1) .ql-picker-item {
    display: block;
    float: left;
    width: 30px;
    height: 30px;
    line-height: 30px;
    text-align: center;
    padding: 0px;
    margin: 1px;
  }

  .ql-toolbar .ql-picker.ql-table .ql-picker-item {
    display: none;
  }

  .ql-toolbar .ql-picker.ql-table .ql-picker-item.enabled {
    display: block;
  }

  .ql-picker.ql-table:nth-of-type(2) {
    display: flex;
    width: 145px;
  }

  .ql-table:nth-of-type(2) .ql-picker-label {
    background: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-border" viewBox="0 0 16 16"><path d="M0 0h.969v.5H1v.469H.969V1H.5V.969H0V0zm2.844 1h-.938V0h.938v1zm1.875 0H3.78V0h.938v1zm1.875 0h-.938V0h.938v1zm.937 0V.969H7.5V.5h.031V0h.938v.5H8.5v.469h-.031V1H7.53zm2.813 0h-.938V0h.938v1zm1.875 0h-.938V0h.938v1zm1.875 0h-.938V0h.938v1zM15.5 1h-.469V.969H15V.5h.031V0H16v.969h-.5V1zM1 1.906v.938H0v-.938h1zm6.5.938v-.938h1v.938h-1zm7.5 0v-.938h1v.938h-1zM1 3.78v.938H0V3.78h1zm6.5.938V3.78h1v.938h-1zm7.5 0V3.78h1v.938h-1zM1 5.656v.938H0v-.938h1zm6.5.938v-.938h1v.938h-1zm7.5 0v-.938h1v.938h-1zM.969 8.5H.5v-.031H0V7.53h.5V7.5h.469v.031H1v.938H.969V8.5zm1.875 0h-.938v-1h.938v1zm1.875 0H3.78v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875-.031V8.5H7.53v-.031H7.5V7.53h.031V7.5h.938v.031H8.5v.938h-.031zm1.875.031h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.406 0h-.469v-.031H15V7.53h.031V7.5h.469v.031h.5v.938h-.5V8.5zM0 10.344v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM0 12.22v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM0 14.094v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM.969 16H0v-.969h.5V15h.469v.031H1v.469H.969v.5zm1.875 0h-.938v-1h.938v1zm1.875 0H3.78v-1h.938v1zm1.875 0h-.938v-1h.938v1zm.937 0v-.5H7.5v-.469h.031V15h.938v.031H8.5v.469h-.031v.5H7.53zm2.813 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm.937 0v-.5H15v-.469h.031V15h.469v.031h.5V16h-.969z"/></svg>')
        no-repeat center,
      white;
    background-size: 16px;
  }
  .ql-picker.ql-table:nth-of-type(2) {
    color: #444;
  }

  .ql-picker.ql-table:nth-of-type(1) .ql-picker-item {
    border: 1px solid #444;
    color: #444;
  }

  .ql-table:nth-of-type(2) .ql-picker-label.ql-active {
    color: #444 !important;
  }

  .ql-toolbar .ql-picker-item.ql-selected:before,
  .ql-picker.ql-table:nth-of-type(2) .ql-picker-item {
    color: #444;
  }

  /* .ql-picker-label.ql-active .ql-stroke {
    stroke: #444 !important;
  } */

  .ql-picker-item[data-value='remove-table'] {
    border: none !important;
    width: 100%;
  }

  .ql-picker-item[data-value='newtable_1_1']:before {
    content: '1x1';
  }

  .ql-picker-item[data-value='newtable_1_2']:before {
    content: '1x2';
  }

  .ql-picker-item[data-value='newtable_1_3']:before {
    content: '1x3';
  }

  .ql-picker-item[data-value='newtable_1_4']:before {
    content: '1x4';
  }

  .ql-picker-item[data-value='newtable_1_5']:before {
    content: '1x5';
  }

  .ql-picker-item[data-value='newtable_2_1']:before {
    content: '2x1';
  }

  .ql-picker-item[data-value='newtable_2_2']:before {
    content: '2x2';
  }

  .ql-picker-item[data-value='newtable_2_3']:before {
    content: '2x3';
  }

  .ql-picker-item[data-value='newtable_2_4']:before {
    content: '2x4';
  }

  .ql-picker-item[data-value='newtable_2_5']:before {
    content: '2x5';
  }

  .ql-picker-item[data-value='newtable_3_1']:before {
    content: '3x1';
  }

  .ql-picker-item[data-value='newtable_3_2']:before {
    content: '3x2';
  }

  .ql-picker-item[data-value='newtable_3_3']:before {
    content: '3x3';
  }

  .ql-picker-item[data-value='newtable_3_4']:before {
    content: '3x4';
  }

  .ql-picker-item[data-value='newtable_3_5']:before {
    content: '3x5';
  }

  .ql-picker-item[data-value='newtable_4_1']:before {
    content: '4x1';
  }

  .ql-picker-item[data-value='newtable_4_2']:before {
    content: '4x2';
  }

  .ql-picker-item[data-value='newtable_4_3']:before {
    content: '4x3';
  }

  .ql-picker-item[data-value='newtable_4_4']:before {
    content: '4x4';
  }

  .ql-picker-item[data-value='newtable_4_5']:before {
    content: '4x5';
  }

  .ql-picker-item[data-value='newtable_5_1']:before {
    content: '5x1';
  }

  .ql-picker-item[data-value='newtable_5_2']:before {
    content: '5x2';
  }

  .ql-picker-item[data-value='newtable_5_3']:before {
    content: '5x3';
  }

  .ql-picker-item[data-value='newtable_5_4']:before {
    content: '5x4';
  }

  .ql-picker-item[data-value='newtable_5_5']:before {
    content: '5x5';
  }

  p:has(img) {
    text-align: center !important;
    text-indent: 0 !important;
  }
</style>`;

// import Quill from 'quill';

const Container$3 = Quill.import('blots/container');
const Block$1 = Quill.import('blots/block');
const BlockEmbed$1 = Quill.import('blots/block/embed');
const Parchment$8 = Quill.import('parchment');

class ContainBlot extends Container$3 {
  static create(value) {
    return super.create(value);
  }

  formats(domNode) {
    if (domNode) {
      return domNode.tagName;
    }
    return this.domNode.tagName;
  }
}

ContainBlot.blotName = 'contain';
ContainBlot.tagName = 'contain';
ContainBlot.scope = Parchment$8.Scope.BLOCK_BLOT;
ContainBlot.defaultChild = 'block';
ContainBlot.allowedChildren = [Block$1, BlockEmbed$1, Container$3];

// import Quill from 'quill';

const Container$2 = Quill.import('blots/container');
const Block = Quill.import('blots/block');
const BlockEmbed = Quill.import('blots/block/embed');
const Parchment$7 = Quill.import('parchment');

class TableCell extends ContainBlot {
  static create(value) {
    const tagName = 'td';
    let node = super.create(tagName);
    let ids = value.split('|');
    node.setAttribute('table_id', ids[0]);
    node.setAttribute('row_id', ids[1]);
    node.setAttribute('cell_id', ids[2]);
    if (ids[3]) {
      node.setAttribute('merge_id', ids[3]);
    }
    if (ids[4]) {
      node.setAttribute('colspan', ids[4]);
    }
    if (ids[5]) {
      node.setAttribute('rowspan', ids[5]);
    }
    return node;
  }

  format() {}

  formats() {
    // We don't inherit from FormatBlot
    return {
      [this.statics.blotName]:
        [
          this.domNode.getAttribute('table_id'),
          this.domNode.getAttribute('row_id'),
          this.domNode.getAttribute('cell_id'),
          this.domNode.getAttribute('merge_id'),
          this.domNode.getAttribute('colspan'),
          this.domNode.getAttribute('rowspan')
        ].join('|')
    }
  }

  optimize(context) {
    super.optimize(context);

    let parent = this.parent;
    if (parent != null) {
      if (parent.statics.blotName === 'td') {
        this.moveChildren(parent, this);
        this.remove();
        return;
      } else if (parent.statics.blotName !== 'tr') {
        // we will mark td position, put in table and replace mark
        let mark = Parchment$7.create('block');
        this.parent.insertBefore(mark, this.next);
        let table = Parchment$7.create('table', this.domNode.getAttribute('table_id'));
        let tr = Parchment$7.create('tr', this.domNode.getAttribute('row_id'));
        table.appendChild(tr);
        tr.appendChild(this);
        table.replace(mark);
      }
    }

    // merge same TD id
    let next = this.next;
    if (next != null && next.prev === this &&
      next.statics.blotName === this.statics.blotName &&
      next.domNode.tagName === this.domNode.tagName &&
      next.domNode.getAttribute('cell_id') === this.domNode.getAttribute('cell_id')
    ) {
      next.moveChildren(this);
      next.remove();
    }
  }

  insertBefore(childBlot, refBlot) {
    if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function (child) {
      return childBlot instanceof child;
    })) {
      let newChild = Parchment$7.create(this.statics.defaultChild);
      newChild.appendChild(childBlot);
      childBlot = newChild;
    }
    super.insertBefore(childBlot, refBlot);
  }

  replace(target) {
    if (target.statics.blotName !== this.statics.blotName) {
      let item = Parchment$7.create(this.statics.defaultChild);
      target.moveChildren(item);
      this.appendChild(item);
    }
    if (target.parent == null) return;
    super.replace(target);
  }

  moveChildren(targetParent, refNode) {
    this.children.forEach(function (child) {
      targetParent.insertBefore(child, refNode);
    });
  }
}

TableCell.blotName = 'td';
TableCell.tagName = 'td';
TableCell.className = 'td-q';
TableCell.scope = Parchment$7.Scope.BLOCK_BLOT;
TableCell.allowedChildren = [Block, BlockEmbed, Container$2];

// import Quill from 'quill';

const Parchment$6 = Quill.import('parchment');

class TableHistory {
  // Register DOM change into current table history entry
  static register(type, change) {
    TableHistory.changes.push({ type, ...change });
  }

  // Add table history entry
  static add(quill) {
    if (!TableHistory.changes.length) return;

    const historyChangeStatus = quill.history.ignoreChange;
    // ignore history change and reset last recorded time for adding later changes in a new history entry
    quill.history.ignoreChange = true;
    quill.history.lastRecorded = 0;

    // wait history update
    setTimeout(() => {
      // reset history changes value
      quill.history.ignoreChange = historyChangeStatus;

      // add new entry in table stack
      const id = TableTrick.random_id();
      quill.history.tableStack[id] = TableHistory.changes;

      // set reference to table stack entry in a new history entry
      quill.history.stack.undo.push({ type: 'tableHistory', id: id });

      TableHistory.changes = [];
    }, 0);
  }

  static undo(quill, id) {
    const historyChangeStatus = quill.history.ignoreChange;
    quill.history.ignoreChange = true;

    const entry = quill.history.tableStack[id];
    if (typeof entry !== 'undefined') {
      // apply changes from last change to first change (undo)
      entry.reverse().forEach(change => {
        const oldDelta = quill.getContents();
        switch (change.type) {
          case 'insert':
            // remove node (undo)
            TableHistory.remove(change);
            break;
          case 'remove':
            // add node (undo)
            TableHistory.insert(change);
            break;
          case 'split':
            // merge cell (redo)
            TableHistory.merge(change, true);
            // force triggering text-change event
            TableTrick.emitTextChange(quill, oldDelta);
            break;
          case 'merge':
            // split cell (redo)
            TableHistory.split(change, true);
            break;
          case 'propertyChange':
            // property change (undo)
            TableHistory.propertyChange(change, true);
            break;
        }
      });
    }

    // wait history update
    setTimeout(() => {
      // update history
      const historyEntry = quill.history.stack.undo.pop();
      quill.history.stack.redo.push(historyEntry);
      quill.history.ignoreChange = historyChangeStatus;
    }, 0);
  }

  static redo(quill, id) {
    const historyChangeStatus = quill.history.ignoreChange;
    quill.history.ignoreChange = true;

    const entry = quill.history.tableStack[id];
    if (typeof entry !== 'undefined') {
      // apply changes from first change to last change (redo)
      entry.forEach(change => {
        switch (change.type) {
          case 'insert':
            // add node (redo)
            TableHistory.insert(change);
            break;
          case 'remove':
            // remove node (redo)
            TableHistory.remove(change);
            break;
          case 'split':
            // split cell (redo)
            TableHistory.split(change, false);
            break;
          case 'merge':
            // merge cell (redo)
            TableHistory.merge(change, false);
            break;
          case 'propertyChange':
            // property change (redo)
            TableHistory.propertyChange(change, false);
            break;
        }
      });
    }

    // wait history update
    setTimeout(() => {
      // update history
      const historyEntry = quill.history.stack.redo.pop();
      quill.history.stack.undo.push(historyEntry);
      quill.history.ignoreChange = historyChangeStatus;
    }, 0);
  }

  static insert(change) {
    const parentNode = change.parentNode || change.nextNode.parentNode;
    if (parentNode) {
      const _parentNode = Parchment$6.find(parentNode);
      if (_parentNode) {
        const _node = Parchment$6.create(change.node);
        if (change.nextNode) {
          const _nextNode = Parchment$6.find(change.nextNode);
          if (_nextNode) {
            _parentNode.insertBefore(_node, _nextNode);
          }
        } else {
          _parentNode.appendChild(_node);
        }
      }

      // force re-rendering cells border (Firefox bug)
      const tableNode = change.node.nodeName === 'TABLE' ? change.node : parentNode.closest('table');
      tableNode.style.setProperty('overflow', (window.getComputedStyle(tableNode)['overflow'] || 'visible') === 'visible' ? 'hidden' : 'visible');
      setTimeout(() => {
        tableNode.style.removeProperty('overflow');
      }, 0);

      return true;
    }
    return false;
  }

  static remove(change) {
    change.node.remove();
    return true;
  }

  static split(change, revert) {
    const td = change.node;
    // remove colspan and rowspan attributes
    td.removeAttribute('colspan');
    td.removeAttribute('rowspan');
    // for each merged node, remove merge_id attribute and restore content
    change.mergedNodes.forEach(cell => {
      cell.node.removeAttribute('merge_id');
      cell.node.innerHTML = cell[revert ? 'oldContent' : 'newContent'];
    });
    // restore content
    td.innerHTML = change[revert ? 'oldContent' : 'newContent'];
    return true;
  }

  static merge(change, revert) {
    const td = change.node;
    const cell_id = td.getAttribute('cell_id');
    // set colspan and rowspan attributes
    td.setAttribute('colspan', change.colSpan);
    td.setAttribute('rowspan', change.rowSpan);
    // for each node to merge, set merge_id attribute and restore content
    change.mergedNodes.forEach(cell => {
      cell.node.innerHTML = cell[revert ? 'oldContent' : 'newContent'];
      cell.node.setAttribute('merge_id', cell_id);
    });
    // restore content
    td.innerHTML = change[revert ? 'oldContent' : 'newContent'];
    return true;
  }

  static propertyChange(change, revert) {
    const { node, property, oldValue, newValue } = change;
    const value = revert ? oldValue : newValue;
    if (value !== null) {
      node.setAttribute(property, value);
    } else {
      node.removeAttribute(property);
    }
  }
}

TableHistory.changes = [];

class TableToolbar {
  static get(quill) {
    if (quill.container.previousSibling && quill.container.previousSibling.classList && quill.container.previousSibling.classList.contains('ql-toolbar')) {
      return quill.container.previousSibling;
    }
    return null;
  }

  static toggle(quill, actions = [], enable = true) {
    const toolbar = TableToolbar.get(quill);
    if (!toolbar) return;
    if (typeof actions === 'string') actions = [actions];

    actions.forEach(action => {
      let selector = `.ql-table .ql-picker-item[data-value="${action}"], .ql-table[value="${action}"]`;
      if (action.startsWith('*') && action.endsWith('*')) {
        selector = `.ql-table .ql-picker-item[data-value*="${action.substring(1, action.length - 1)}"], .ql-table[value*="${action.substring(1, action.length - 1)}"]`;
      } else if (action.startsWith('*')) {
        selector = `.ql-table .ql-picker-item[data-value$="${action.substring(1)}"], .ql-table[value$="${action.substring(1)}"]`;
      } else if (action.endsWith('*')) {
        selector = `.ql-table .ql-picker-item[data-value^="${action.substring(0, action.length - 1)}"], .ql-table[value^="${action.substring(0, action.length - 1)}"]`;
      }

      toolbar.querySelectorAll(selector).forEach(item => {
        item.classList[enable ? 'add' : 'remove']('enabled');
      });
    });
  }

  static enable(quill, actions) {
    TableToolbar.toggle(quill, actions, true);
  }

  static disable(quill, actions) {
    TableToolbar.toggle(quill, actions, false);
  }

  static disableAll(quill) {
    const toolbar = TableToolbar.get(quill);
    if (!toolbar) return false;
    toolbar.querySelectorAll('.ql-table .ql-picker-item.enabled, .ql-table.enabled[value]').forEach(item => item.classList.remove('enabled'));
  }

  static isEnabled(quill, action) {
    const toolbar = TableToolbar.get(quill);
    if (!toolbar) return false;
    const item = toolbar.querySelector(`.ql-table .ql-picker-item[data-value="${action}"], .ql-table[value="${action}"]`);
    return item && item.classList.contains('enabled');
  }
}

class TableSelection {
  static mouseDown(quill, e, inCellSelectionOnClick) {
    if (inCellSelectionOnClick !== undefined){ //we may have no options set for onClick
      TableSelection.cellSelectionOnClick = inCellSelectionOnClick;
    }

    if (e.which !== 1) {
      // do nothing with center or right click
      return;
    }

    TableSelection.resetSelection();

    if ((!TableSelection.cellSelectionOnClick && e.ctrlKey) || TableSelection.cellSelectionOnClick){
      TableSelection.isMouseDown = true;
      // reset cell selection
      TableSelection.previousSelection = [TableSelection.selectionStartElement, TableSelection.selectionEndElement];
      TableSelection.selectionStartElement = TableSelection.selectionEndElement = null;
      TableSelection.resetSelection();

      const targetCell = TableSelection.getTargetCell(e);
      if (!targetCell) {
        // default mouse down event when clicking outside a cell
        TableSelection.focusedCell = null;
        return;
      }

      if ((!TableSelection.preventMouseDown && targetCell === TableSelection.clickedCellTimeout) || TableSelection.focusedCell === targetCell) {
        // default mouse down event when multiple click in less than 500ms in the same cell or if the cell is already focused
        TableSelection.focusedCell = targetCell;
        return;
      }

      // single mouse left click = start selection
      e.preventDefault();
      TableSelection.focusedCell = null;

      clearTimeout(TableSelection.dblClickTimeout);
      TableSelection.dblClickTimeout = setTimeout(() => {
        TableSelection.preventMouseDown = true;
        TableSelection.clickedCellTimeout = null;
      }, 500);
      TableSelection.preventMouseDown = false;

      TableSelection.selectionStartElement = TableSelection.clickedCellTimeout = targetCell;

      if (TableSelection.selectionStartElement) {
        TableSelection.selectionStartElement.classList.add('ql-cell-selected');
      }
    }
  }

  static mouseMove(quill, e) {
    if (TableSelection.isMouseDown && TableSelection.selectionStartElement) {
      const previousSelectionEndElement = TableSelection.selectionEndElement;
      TableSelection.selectionEndElement = TableSelection.getTargetCell(e);
      // Update selection if: mouse button is down, selection changed, start and end element exist and are in the same table
      if (
        TableSelection.selectionEndElement &&
        TableSelection.selectionEndElement !== previousSelectionEndElement &&
        TableSelection.selectionStartElement.closest('table') === TableSelection.selectionEndElement.closest('table')
      ) {
        TableSelection.resetSelection();

        // set new selection
        const coords = TableSelection.getSelectionCoords();
        for (let y = coords.minY; y <= coords.maxY; y++) {
          for (let x = coords.minX; x <= coords.maxX; x++) {
            let cell = TableSelection.getCellAt(x, y);
            if (cell) {
              cell.classList.add('ql-cell-selected');
            }
          }
        }
      }
    }
  }

  static mouseUp(quill, e) {
    TableSelection.isMouseDown = false;
    if (!TableSelection.selectionEndElement) {
      TableSelection.selectionEndElement = TableSelection.selectionStartElement;
    }

    if (
      TableSelection.previousSelection[0] !== TableSelection.selectionStartElement &&
      TableSelection.previousSelection[1] !== TableSelection.selectionEndElement
    ) {
      TableSelection.selectionChange(quill);
    }
  }

  static selectionChange(quill, range = null, oldRange = null) {
    let isInTable = false;
    if (TableSelection.selectionStartElement || TableSelection.selectionEndElement) {
      // there is a table selection
      isInTable = true;
      TableToolbar.enable(quill, ['split-cell', 'merge-selection', 'remove-selection']);
    } else {
      // Text selection
      TableToolbar.disable(quill, ['split-cell', 'merge-selection', 'remove-selection']);
      let selectionStartElement, selectionEndElement;
      if (range === null && oldRange !== null) {
        // There is a previous Quill selection but editor is no longer focused (selection-change event)
        const [startLeaf] = quill.getLeaf(oldRange.index);
        const [endLeaf] = quill.getLeaf(oldRange.index + oldRange.length);
        selectionStartElement = startLeaf.parent.domNode;
        selectionEndElement = endLeaf.parent.domNode;
      } else {
        // No Quill selection, use window.getSelection instead
        const selection = window.getSelection();
        selectionStartElement = selection.anchorNode ? (selection.anchorNode.nodeType === Node.TEXT_NODE ? selection.anchorNode.parentElement : selection.anchorNode) : null;
        selectionEndElement = selection.focusNode ? (selection.focusNode.nodeType === Node.TEXT_NODE ? selection.focusNode.parentElement : selection.focusNode) : null;
      }

      if (selectionStartElement && selectionEndElement) {
        // there is a text selection
        let closestTable = selectionStartElement.closest('table');
        if (closestTable && closestTable.closest('.ql-editor')) {
          if (selectionEndElement !== selectionStartElement) {
            closestTable = selectionEndElement.closest('table');
            isInTable = closestTable && closestTable.closest('.ql-editor');
          } else {
            isInTable = true;
          }
        }
      } // no selection = not in table
    }

    if (!isInTable && quill.table.isInTable) {
      // disable
      quill.table.isInTable = false;
      TableToolbar.disableAll(quill);
      TableToolbar.enable(quill, ['newtable_*', 'insert', 'undo', 'redo']);
    }

    if (isInTable && !quill.table.isInTable) {
      // enable
      quill.table.isInTable = true;
      TableToolbar.enable(quill, ['append-row*', 'append-col*', 'remove-cell', 'remove-row', 'remove-col', 'remove-table']);
    }
  }

  static getSelectionCoords() {
    if (TableSelection.selectionStartElement && TableSelection.selectionEndElement) {
      const coords = [
        [
          Array.prototype.indexOf.call(TableSelection.selectionStartElement.parentElement.children, TableSelection.selectionStartElement),
          Array.prototype.indexOf.call(TableSelection.selectionStartElement.parentElement.parentElement.children, TableSelection.selectionStartElement.parentElement)
        ],
        [
          Array.prototype.indexOf.call(TableSelection.selectionEndElement.parentElement.children, TableSelection.selectionEndElement),
          Array.prototype.indexOf.call(TableSelection.selectionEndElement.parentElement.parentElement.children, TableSelection.selectionEndElement.parentElement)
        ]
      ];

      return {
        coords,
        minX: Math.min(coords[0][0], coords[1][0]),
        maxX: Math.max(coords[0][0], coords[1][0]),
        minY: Math.min(coords[0][1], coords[1][1]),
        maxY: Math.max(coords[0][1], coords[1][1])
      };
    }
    return null;
  }

  static getCellAt(x, y) {
    const currentTable = TableSelection.selectionStartElement.closest('table');
    if (currentTable) {
      if (typeof currentTable.children[y] !== 'undefined' && typeof currentTable.children[y].children[x] !== 'undefined') {
        return currentTable.children[y].children[x];
      }
    }
    return null;
  }

  static getTargetCell(e) {
    let element = e.target;
    let cell = null;
    do {
      if (['td', 'th'].includes(element.tagName.toLowerCase())) {
        cell = element;
        break;
      }
      element = element.parentNode;
    } while (element && element !== e.currentTarget);
    return cell;
  }

  static resetSelection(container) {
    // reset selection for all instances
    document.querySelectorAll('.ql-editor td.ql-cell-selected').forEach(cell => {
      cell.classList.remove('ql-cell-selected');
    });
  }
}

TableSelection.focusedCell = null;
TableSelection.isMouseDown = false;
TableSelection.selectionStartElement = null;
TableSelection.selectionEndElement = null;
TableSelection.previousSelection = [];

TableSelection.dblClickTimeout = null;
TableSelection.clickedCellTimeout = null;
TableSelection.preventMouseDown = true;
TableSelection.cellSelectionOnClick = true;

// import Quill from 'quill';

const Parchment$5 = Quill.import('parchment');
const Container$1 = Quill.import('blots/container');
const Scroll = Quill.import('blots/scroll');

class TableTrick {
  static random_id() {
    return Math.random().toString(36).slice(2);
  }

  static getBlot(quill) {
    let blot = null;
    const selection = quill.getSelection();
    if (selection) {
      blot = quill.getLeaf(selection['index'])[0];
    }
    return blot;
  }

  static find_td(quill) {
    let blot = TableTrick.getBlot(quill);
    if (blot) {
      for (; blot != null && blot.statics.blotName !== 'td';) {
        blot = blot.parent;
      }
    }
    return blot; // return TD or NULL
  }

  static getQuill(el) {
    // Get Quill instance from node/element or blot
    let quill = null;
    if (el instanceof Node) {
      if (!el instanceof Element) {
        el = el.parentElement;
      }
    } else if (typeof el === 'object' && typeof el.domNode !== 'undefined') {
      el = el.domNode;
    }

    if (el instanceof Element) {
      const editorNode = el.closest('.ql-container');
      if (editorNode) {
        quill = Quill.find(editorNode);
      }
    }
    return quill;
  }

  static insertTable(quill, col_count, row_count) {
    const table_id = TableTrick.random_id();
    const table = Parchment$5.create('table', table_id);
    for (let ri = 0; ri < row_count; ri++) {
      const row_id = TableTrick.random_id();
      const tr = Parchment$5.create('tr', row_id);
      table.appendChild(tr);
      for (let ci = 0; ci < col_count; ci++) {
        const cell_id = TableTrick.random_id();
        const value = [table_id, row_id, cell_id].join('|');
        const td = Parchment$5.create('td', value);
        tr.appendChild(td);
        const p = Parchment$5.create('block');
        td.appendChild(p);
        const br = Parchment$5.create('break');
        p.appendChild(br);
      }
    }
    let blot = TableTrick.getBlot(quill);
    let top_branch = null;
    for (; blot != null && !(blot instanceof Container$1 || blot instanceof Scroll);) {
      top_branch = blot;
      blot = blot.parent;
    }
    blot.insertBefore(table, top_branch);
    TableHistory.register('insert', { node: table.domNode, nextNode: top_branch.domNode });
    TableHistory.add(quill);
  }

  static removeTable(quill) {
    const coords = TableSelection.getSelectionCoords();
    TableSelection.resetSelection(quill.container);
    let table;
    if (coords) {
      const _table = TableSelection.selectionStartElement.closest('table');
      table = Parchment$5.find(_table);
    } else {
      const td = TableTrick.find_td(quill);
      if (td) {
        table = td.parent.parent;
      }
    }

    if (table) {
      TableHistory.register('remove', { node: table.domNode, nextNode: table.next ? table.next.domNode : null, parentNode: table.parent.domNode });
      TableHistory.add(quill);
      table.remove();
    }
  }

  static addCol(quill, direction = 'after') {
    // direction = before: append col before current cell or before leftmost cell of selection
    // direction = after: append col after current cell or after rightmost cell of selection
    const coords = TableSelection.getSelectionCoords();
    let td = TableTrick.find_td(quill);
    if (coords) {
      const cell = TableSelection.getCellAt(coords.maxX, coords.minY) || TableSelection.getCellAt(coords.maxX, coords.maxY);
      if (cell) {
        td = Parchment$5.find(cell);
      }
    }

    if (td) {
      if (direction !== 'before' && td.domNode.getAttribute('colspan')) {
        // for direction = after, if the cell is merged, append column at the end of merged cell (not after the first cell)
        const endCell = td.parent.domNode.children[
          Array.prototype.indexOf.call(td.parent.domNode.children, td.domNode) + Number.parseInt(td.domNode.getAttribute('colspan')) - 1
        ];
        if (endCell) {
          td = Parchment$5.find(endCell);
        }
      }

      // get cell index
      const index = Array.prototype.indexOf.call(td.parent.domNode.children, td.domNode) + (direction === 'before' ? 0 : 1);
      // is this the last cell?
      const last_cell = index === td.parent.domNode.children.length;
      const table = td.parent.parent;
      const table_id = table.domNode.getAttribute('table_id');
      let managed_merged_cells = [];

      table.children.forEach(function (tr) {
        const row_id = tr.domNode.getAttribute('row_id');
        const cell_id = TableTrick.random_id();
        const new_td = Parchment$5.create('td', [table_id, row_id, cell_id].join('|'));
        // do not add the cell for this row if selected cell is the last cell and if this row has more or less cells
        if (!last_cell || index === tr.domNode.children.length) {
          if (typeof tr.domNode.children[index] === 'undefined') {
            tr.appendChild(new_td);
            TableHistory.register('insert', { node: new_td.domNode, parentNode: tr.domNode });
          } else {
            const td = Parchment$5.find(tr.domNode.children[index]);
            if (td) {
              // manage merged cells
              if (td.domNode.previousSibling) {
                let merge_id = td.domNode.previousSibling.getAttribute('merge_id');
                const _colSpan = Number.parseInt(td.domNode.previousSibling.getAttribute('colspan') || 1);
                if (_colSpan > 1) {
                  merge_id = td.domNode.previousSibling.getAttribute('cell_id');
                }

                if (merge_id) {
                  new_td.domNode.setAttribute('merge_id', merge_id);
                  if (managed_merged_cells.indexOf(merge_id) === -1) {
                    managed_merged_cells.push(merge_id);
                    const _cell = table.domNode.querySelector('td[cell_id="' + merge_id + '"]');
                    if (_cell) {
                      const colSpan = Number.parseInt(_cell.getAttribute('colspan'));
                      _cell.setAttribute('colspan', colSpan + 1);
                      TableHistory.register('propertyChange', { node: _cell, property: 'colspan', oldValue: colSpan, newValue: colSpan + 1 });
                    }
                  }
                }
              }
              tr.insertBefore(new_td, td);
              TableHistory.register('insert', { node: new_td.domNode, nextNode: td.domNode });
            }
          }
        }
      });
      TableHistory.add(quill);
    }
  }

  static addRow(quill, direction = 'after') {
    // direction = before: append row above current cell or above topmost cell of selection
    // direction = after: append row below current cell or below bottommost cell of selection
    const coords = TableSelection.getSelectionCoords();
    let td = TableTrick.find_td(quill);
    if (coords) {
      const cell = TableSelection.getCellAt(coords.minX, coords.maxY) || TableSelection.getCellAt(coords.maxX, coords.maxY);
      if (cell) {
        td = Parchment$5.find(cell);
      }
    }

    if (td) {
      const tr = td.parent;
      const col_count = tr.domNode.children.length;
      const table = tr.parent;
      const new_row = tr.clone();
      // get row index
      let index = Array.prototype.indexOf.call(table.domNode.children, tr.domNode) + (direction === 'before' ? 0 : 1);

      let manage_merged_cells = true;
      const rowSpan = Number.parseInt(td.domNode.getAttribute('rowspan') || 1);
      if (rowSpan > 1) {
        manage_merged_cells = false;
        if (direction !== 'before') {
          // add row below merged cell
          index += rowSpan - 1;
        }
      }

      const table_id = table.domNode.getAttribute('table_id');
      const row_id = TableTrick.random_id();
      new_row.domNode.setAttribute('row_id', row_id);
      let managed_merged_cells = [];
      let managed_unmerged_cells = [];

      for (let i = 0; i < col_count; i++) {
        const prev_cell = tr.domNode.children[i];
        const cell_id = TableTrick.random_id();
        const td = Parchment$5.create('td', [table_id, row_id, cell_id].join('|'));
        if (prev_cell && manage_merged_cells) {
          // manage merged cells
          let merge_id, merged_cell;
          if (prev_cell.getAttribute('rowspan')) {
            merge_id = prev_cell.getAttribute('cell_id');
            merged_cell = prev_cell;
            if (direction === 'before') {
              // do not merge cells if we add a row before a merged cell
              if (managed_unmerged_cells.indexOf(merge_id) === -1) {
                managed_unmerged_cells.push(merge_id);
              }
            }
          } else if (prev_cell.getAttribute('merge_id')) {
            merge_id = prev_cell.getAttribute('merge_id');
            merged_cell = table.domNode.querySelector('td[cell_id="' + merge_id + '"]');
          }

          if (merge_id && merged_cell && managed_unmerged_cells.indexOf(merge_id) === -1 && merged_cell.getAttribute('rowspan')) {
            // merge cells of the new row according to previous row
            let merge_rowspan = Number.parseInt(merged_cell.getAttribute('rowspan'));
            if (merge_rowspan > 1) {
              if (managed_merged_cells.indexOf(merge_id) === -1) {
                managed_merged_cells.push(merge_id);
                merged_cell.setAttribute('rowspan', merge_rowspan + 1);
                TableHistory.register('propertyChange', { node: merged_cell, property: 'rowspan', oldValue: merge_rowspan, newValue: merge_rowspan + 1 });
              }
              td.domNode.setAttribute('merge_id', merge_id);
            }
          }
        }

        new_row.appendChild(td);
        const p = Parchment$5.create('block');
        td.appendChild(p);
        const br = Parchment$5.create('break');
        p.appendChild(br);
      }

      if (typeof table.domNode.children[index] === 'undefined') {
        table.appendChild(new_row);
        TableHistory.register('insert', { node: new_row.domNode, parentNode: table.domNode });
      } else {
        const row = Parchment$5.find(table.domNode.children[index]);
        if (row) {
          table.insertBefore(new_row, row);
          TableHistory.register('insert', { node: new_row.domNode, nextNode: row.domNode });
        }
      }
      TableHistory.add(quill);
    }
  }

  static removeCol(quill) {
    const coords = TableSelection.getSelectionCoords();
    TableSelection.resetSelection(quill.container);
    let table, colIndex, colsToRemove;
    if (coords) {
      // if we have a selection, remove all selected columns
      const _table = TableSelection.selectionStartElement.closest('table');
      table = Parchment$5.find(_table);
      colIndex = coords.minX;
      colsToRemove = coords.maxX - coords.minX + 1;
    } else {
      // otherwise, remove only the column of current cell
      colsToRemove = 1;
      const currentCell = TableTrick.find_td(quill);
      if (currentCell) {
        table = currentCell.parent.parent;
        colIndex = Array.prototype.indexOf.call(currentCell.parent.domNode.children, currentCell.domNode);
      }
    }

    if (table && typeof colIndex === 'number' && typeof colsToRemove === 'number') {
      // Remove all TDs with the colIndex and repeat it colsToRemove times if there are multiple columns to delete
      for (let i = 0; i < colsToRemove; i++) {
        table.children.forEach(function (tr) {
          const td = tr.domNode.children[colIndex];
          if (td) {
            const merge_id = td.getAttribute('merge_id');
            if (merge_id) {
              // if a cell is merged to another cell, get target cell and decrement colspan
              const cell = table.domNode.querySelector(`td[cell_id="${merge_id}"]`);
              if (cell) {
                const colSpan = Number.parseInt(cell.getAttribute('colspan'));
                cell.setAttribute('colspan', colSpan - 1);
                TableHistory.register('propertyChange', { node: cell, property: 'colspan', oldValue: colSpan, newValue: colSpan - 1 });
              }
            }

            if (td.getAttribute('colspan')) {
              TableTrick._split(td);
            }

            TableHistory.register('remove', { node: td, nextNode: td.nextSibling, parentNode: tr.domNode });
            const _td = Parchment$5.find(td);
            if (_td) { // remove node this way in order to update delta
              _td.remove();
            }
          }
        });
      }
      TableSelection.selectionStartElement = TableSelection.selectionEndElement = null;
      TableHistory.add(quill);
    }
  }

  static removeRow(quill) {
    const coords = TableSelection.getSelectionCoords();
    TableSelection.resetSelection(quill.container);

    const manageMergedCells = (tr) => {
      let managed_merged_cells = [];
      [...tr.children].forEach(function(td) {
        const merge_id = td.getAttribute('merge_id');
        if (merge_id && managed_merged_cells.indexOf(merge_id) === -1) {
          // if a cell is merged to another cell, get target cell and decrement rowspan
          const cell = tr.parentNode.querySelector(`td[cell_id="${merge_id}"]`);
          managed_merged_cells.push(merge_id);
          if (cell) {
            const rowSpan = Number.parseInt(cell.getAttribute('rowspan'));
            cell.setAttribute('rowspan', rowSpan - 1);
            TableHistory.register('propertyChange', { node: cell, property: 'rowspan', oldValue: rowSpan, newValue: rowSpan - 1 });
          }
        }

        if (td.getAttribute('rowspan')) {
          TableTrick._split(td);
        }
      });
    };

    if (coords) {
      // if we have a selection, remove all selected rows
      const table = TableSelection.selectionStartElement.closest('table');
      const rowIndex = coords.minY;
      const rowsToRemove = coords.maxY - coords.minY + 1;

      for (let i = 0; i < rowsToRemove; i++) {
        const tr = table.children[rowIndex];
        if (tr) {
          manageMergedCells(tr);
          TableHistory.register('remove', { node: tr, nextNode: tr.nextSibling, parentNode: table });
          const _tr = Parchment$5.find(tr);
          if (_tr) { // remove node this way in order to update delta
            _tr.remove();
          }
        }
      }
    } else {
      // otherwise, remove only the row of current cell
      const td = TableTrick.find_td(quill);
      if (td) {
        const tr = td.parent;
        manageMergedCells(tr.domNode);
        TableHistory.register('remove', { node: tr.domNode, nextNode: tr.next ? tr.next.domNode : null, parentNode: tr.parent.domNode });
        const _tr = Parchment$5.find(tr.domNode);
        if (_tr) { // remove node this way in order to update delta
          _tr.remove();
        }
      }
    }
    TableSelection.selectionStartElement = TableSelection.selectionEndElement = null;
    TableHistory.add(quill);
  }

  static splitCell(quill) {
    // get cell
    const coords = TableSelection.getSelectionCoords();
    TableSelection.resetSelection(quill.container);
    let td = TableTrick.find_td(quill);
    if (coords && coords.maxX - coords.minX === 0 && coords.maxY - coords.minY === 0) {
      const _td = TableSelection.getCellAt(coords.minX, coords.minY);
      td = Parchment$5.find(_td);
    }

    if (td && TableTrick._split(td.domNode)) {
      // add changes to history
      // TableTrick._split already register 'split' change to history
      TableSelection.selectionStartElement = TableSelection.selectionEndElement = null;
      // force triggering text-change event
      td.domNode.innerHTML = td.domNode.innerHTML;
      TableHistory.add(quill);
    }
  }

  static mergeSelection(quill) {
    // get selection
    const coords = TableSelection.getSelectionCoords();
    TableSelection.resetSelection(quill.container);
    if (coords) {
      const table = TableSelection.selectionStartElement.closest('table');
      const colSpan = coords.maxX - coords.minX + 1;
      const rowSpan = coords.maxY - coords.minY + 1;
      if (colSpan > 1 || rowSpan > 1) {
        let node = null;
        let oldContent = null;
        let mergedNodes = [];
        let mergedCellContent = [];
        let cell_id;
        // get selected cells
        for (let y = coords.minY; y <= coords.maxY; y++) {
          for (let x = coords.minX; x <= coords.maxX; x++) {
            const cell = table.children[y].children[x];
            if (cell) {
              if (cell.textContent !== '') {
                // merge all contents
                mergedCellContent.push(cell.innerHTML);
              }

              if (!node) {
                // first cell (this cell will be kept)
                cell_id = cell.getAttribute('cell_id');
                node = cell;
                oldContent = node.innerHTML;
              } else {
                // other cells that will be merged
                let _oldContent = cell.innerHTML;
                // update mergedNodes array for history purposes
                mergedNodes.push({ node: cell, oldContent: _oldContent, newContent: '<p><br></p>' });
              }

              if (cell.getAttribute('colspan') || cell.getAttribute('rowspan')) {
                // cannot merge cell already merged
                alert('Cannot merge already merged cell');
                return false;
              }
            }
          }
        }

        if (node && mergedNodes.length) {
          mergedNodes.forEach(mergedNode => {
            mergedNode.node.setAttribute('merge_id', cell_id);
            mergedNode.node.innerHTML = mergedNode.newContent;
          });

          // set colspan and rowspan attributes
          node.setAttribute('colspan', colSpan);
          node.setAttribute('rowspan', rowSpan);
          // set merged content
          node.innerHTML = mergedCellContent.join('');
        }
        // add changes to history
        TableSelection.selectionStartElement = TableSelection.selectionEndElement = null;
        TableHistory.register('merge', { node, mergedNodes, colSpan, rowSpan, oldContent, newContent: node.innerHTML });
        TableHistory.add(quill);
      }
    }
  }

  static removeCell(quill) {
    // get cell
    const coords = TableSelection.getSelectionCoords();
    TableSelection.resetSelection(quill.container);
    let td = TableTrick.find_td(quill);
    if (coords && coords.maxX - coords.minX === 0 && coords.maxY - coords.minY === 0) {
      const _td = TableSelection.getCellAt(coords.minX, coords.minY);
      td = Parchment$5.find(_td);
    }

    if (td && TableTrick._removeCell(td.domNode)) {
      // add changes to history
      // TableTrick._removeCell already register 'remove' change to history
      TableSelection.selectionStartElement = TableSelection.selectionEndElement = null;
      TableHistory.add(quill);
    }
  }

  static removeSelection(quill) {
    // get selection
    const coords = TableSelection.getSelectionCoords();
    TableSelection.resetSelection(quill.container);
    if (coords) {
      const table = TableSelection.selectionStartElement.closest('table');
      let nodesToRemove = [];
      for (let y = coords.minY; y <= coords.maxY; y++) {
        for (let x = coords.minX; x <= coords.maxX; x++) {
          const cell = table.children[y].children[x];
          if (cell) {
            // if a cell is merged to another cell, split target cell
            const merge_id = cell.getAttribute('merge_id');
            if (merge_id) {
              const targetCell = table.querySelector(`td[cell_id="${merge_id}"]`);
              if (targetCell) {
                TableTrick._split(targetCell);
              }
            }

            if (cell.getAttribute('rowspan') || cell.getAttribute('colspan')) {
              TableTrick._split(cell);
            }

            // remove cell (and row if empty)
            let node = cell;
            let nextNode = cell.nextSibling;
            let parentNode = cell.parentNode;
            if (parentNode.nodeName === 'TR' && parentNode.childNodes.length <= 1) {
              // remove row if only one node (cell to be removed)
              node = parentNode;
              nextNode = node.nextSibling;
              parentNode = node.parentNode;
            }
            nodesToRemove.push(node);
            TableHistory.register('remove', { node, nextNode, parentNode });
          }
        }
      }

      nodesToRemove.forEach(node => {
        const _node = Parchment$5.find(node);
        if (_node) { // remove node this way in order to update delta
          _node.remove();
        }
      });

      // add changes to history
      TableSelection.selectionStartElement = TableSelection.selectionEndElement = null;
      TableHistory.add(quill);
    }
  }

  static _removeCell(cell, recursive = true) {
    let cell_id = cell.getAttribute('cell_id');
    if (cell.nodeName === 'TD') {
      if (recursive) {
        if (cell.getAttribute('merge_id')) {
          // remove merged cells
          cell = cell.closest('table').querySelector('td[cell_id="' + cell.getAttribute('merge_id') + '"]');
          if (!cell) return false;
          cell_id = cell.getAttribute('cell_id');
        }

        if (cell.getAttribute('colspan') || cell.getAttribute('rowspan')) {
          // remove merged cells
          cell.parentNode.parentNode.querySelectorAll(`td[merge_id="${cell_id}"`).forEach(node => {
            TableTrick._removeCell(node, false);
          });
        }
      }

      let node = cell;
      let nextNode = cell.nextSibling;
      let parentNode = cell.parentNode;
      if (parentNode.nodeName === 'TR' && parentNode.childNodes.length <= 1) {
        // remove row if only one node (cell to be removed)
        node = parentNode;
        nextNode = node.nextSibling;
        parentNode = node.parentNode;
        if (parentNode.nodeName === 'TABLE' && parentNode.childNodes.length <= 1) {
          // remove table if only one node (row to be removed)
          node = parentNode;
          nextNode = node.nextSibling;
          parentNode = node.parentNode;
        }
      }

      const _node = Parchment$5.find(node);
      if (_node) { // remove node this way in order to update delta
        _node.remove();
      }

      TableHistory.register('remove', { node, nextNode, parentNode });
      return true;
    }
    return false;
  }

  static _split(cell) {
    const cell_id = cell.getAttribute('cell_id');
    // get merged nodes and update mergedNodes array for history purposes, remove merge_id attribute
    let mergedNodes = [];
    cell.parentNode.parentNode.querySelectorAll(`td[merge_id="${cell_id}"`).forEach(node => {
      mergedNodes.push({ node, oldContent: node.innerHTML, newContent: node.innerHTML });
      node.removeAttribute('merge_id');
    });

    const colSpan = Number.parseInt(cell.getAttribute('colspan') || 1);
    const rowSpan = Number.parseInt(cell.getAttribute('rowspan') || 1);
    if (colSpan > 1 || rowSpan > 1) {
      // remove colspan and rowspan attributes
      cell.removeAttribute('colspan');
      cell.removeAttribute('rowspan');
      // register changes to history
      TableHistory.register('split', { node: cell, mergedNodes, colSpan, rowSpan, oldContent: cell.innerHTML, newContent: cell.innerHTML });
      return true;
    }
    return false;
  }

  static emitTextChange(quill, oldDelta, source = 'user') {
    const newDelta = quill.getContents();
    quill.emitter.emit('text-change', oldDelta.diff(newDelta), oldDelta, source);
  }

  static table_handler(value, quill) {
    // Check if the selection is for the same Quill instance, otherwise reset selection
    if (
      (TableSelection.selectionStartElement && !quill.container.contains(TableSelection.selectionStartElement)) ||
      (TableSelection.selectionEndElement && !quill.container.contains(TableSelection.selectionEndElement))
    ) {
      TableSelection.selectionStartElement = TableSelection.selectionEndElement = null;
      TableSelection.resetSelection();
    }

    if (value.includes('newtable_')) {
      const sizes = value.split('_');
      const row_count = Number.parseInt(sizes[1]);
      const col_count = Number.parseInt(sizes[2]);
      TableTrick.insertTable(quill, col_count, row_count);
    } else {
      let append_direction = 'after';
      switch (value) {
        case 'append-col-before':
          append_direction = 'before';
        case 'append-col':
        case 'append-col-after':
          TableTrick.addCol(quill, append_direction);
          break;
        case 'remove-col':
          TableTrick.removeCol(quill);
          break;
        case 'append-row-above':
          append_direction = 'before';
        case 'append-row':
        case 'append-row-below':
          TableTrick.addRow(quill, append_direction);
          break;
        case 'remove-row':
          TableTrick.removeRow(quill);
          break;
        case 'insert':
          TableTrick.insertTable(quill, 1, 1);
          break;
        case 'remove-table':
          TableTrick.removeTable(quill);
          break;
        case 'split-cell':
          TableTrick.splitCell(quill);
          break;
        case 'merge-selection':
          TableTrick.mergeSelection(quill);
          break;
        case 'remove-cell':
          TableTrick.removeCell(quill);
          break;
        case 'remove-selection':
          TableTrick.removeSelection(quill);
          break;
        case 'undo':
          if (quill.history.stack.undo.length) {
            const entry = quill.history.stack.undo[quill.history.stack.undo.length - 1];
            if (typeof entry.type !== 'undefined' && typeof entry.id !== 'undefined' && entry.type === 'tableHistory') {
              // Table history entry
              TableHistory.undo(quill, entry.id);
              return false;
            }
            // Classic history entry
          }
          return true;
        case 'redo':
          if (quill.history.stack.redo.length) {
            const entry = quill.history.stack.redo[quill.history.stack.redo.length - 1];
            if (typeof entry.type !== 'undefined' && typeof entry.id !== 'undefined' && entry.type === 'tableHistory') {
              // Table history entry
              TableHistory.redo(quill, entry.id);
              return false;
            }
            // Classic history entry
          }
          return true;
        case 'copy':
          if (TableSelection.selectionStartElement && TableSelection.selectionEndElement) {
            // Copy text in selection
            // Save previous selection
            let { anchorNode, anchorOffset, focusNode, focusOffset } = window.getSelection();
            // Get table selection position
            // Set selection and copy
            window.getSelection().removeAllRanges();
            let range = document.createRange();
            range.setStart(TableSelection.selectionStartElement, 0);
            range.setEnd(TableSelection.selectionEndElement, TableSelection.selectionEndElement.childNodes.length);
            window.getSelection().addRange(range);
            if (TableSelection.selectionStartElement === TableSelection.selectionEndElement) {
              TableSelection.selectionStartElement.classList.remove('ql-cell-selected');
            }
            document.execCommand('copy');
            if (TableSelection.selectionStartElement === TableSelection.selectionEndElement) {
              TableSelection.selectionStartElement.classList.add('ql-cell-selected');
            }
            // Remove selection and restore previous selection
            window.getSelection().removeAllRanges();
            range.setStart(anchorNode, anchorOffset);
            range.setEnd(focusNode, focusOffset);
            window.getSelection().addRange(range);
            return false;
          }
          return true;
      }
    }
  }
}

// import Quill from 'quill';

const Parchment$4 = Quill.import('parchment');

class TableRow extends ContainBlot {
  static create(value) {
    const tagName = 'tr';
    let node = super.create(tagName);
    node.setAttribute('row_id', value ? value : TableTrick.random_id());
    return node;
  }

  format() {}

  optimize(context) {
    if (this.children.length === 0) {
      if (this.statics.defaultChild != null) {
        var child = this.createDefaultChild();
        this.appendChild(child);
        child.optimize(context);
      } else {
        this.remove();
      }
    }
    let next = this.next;
    if (next != null && next.prev === this &&
      next.statics.blotName === this.statics.blotName &&
      next.domNode.tagName === this.domNode.tagName &&
      next.domNode.getAttribute('row_id') === this.domNode.getAttribute('row_id')
    ) {
      next.moveChildren(this);
      next.remove();
    }
  }

  insertBefore(childBlot, refBlot) {
    if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function (child) {
      return childBlot instanceof child;
    })) {
      let newChild = this.createDefaultChild(refBlot);
      newChild.appendChild(childBlot);
      childBlot = newChild;
    }
    super.insertBefore(childBlot, refBlot);
  }

  replace(target) {
    if (target.statics.blotName !== this.statics.blotName) {
      let item = this.createDefaultChild();
      target.moveChildren(item, this);
      this.appendChild(item);
    }
    super.replace(target);
  }

  createDefaultChild(refBlot) {
    let table_id = null;
    if (refBlot) {
      table_id = refBlot.domNode.getAttribute('table_id');
    } else if (this.parent) {
      table_id = this.parent.domNode.getAttribute('table_id');
    } else {
      table_id = this.domNode.parent.getAttribute('table_id');
    }

    return Parchment$4.create(this.statics.defaultChild, [table_id, this.domNode.getAttribute('row_id'), TableTrick.random_id()].join('|'));
  }
}

TableRow.blotName = 'tr';
TableRow.tagName = 'tr';
TableRow.scope = Parchment$4.Scope.BLOCK_BLOT;
TableRow.defaultChild = 'td';
TableRow.allowedChildren = [TableCell];

// import Quill from 'quill';

const Parchment$3 = Quill.import('parchment');

class Table extends ContainBlot {
  static create(value) {
    const tagName = 'table';
    let node = super.create(tagName);
    node.setAttribute('table_id', value ? value : TableTrick.random_id());
    node.setAttribute('border', '1');
    return node;
  }

  format() {}

  optimize(context) {
    super.optimize(context);
    let quill = TableTrick.getQuill(this.domNode);
    if (!quill) return;
    let next = this.next;
    const table_id = this.domNode.getAttribute('table_id');

    if (
      next != null && next.prev === this && next.domNode.getAttribute('table_id') === table_id &&
      next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName
    ) {
      // merge table containing single cell with table
      next.moveChildren(this);
      next.remove();
    }

    if (
      typeof quill.table.tables[table_id] !== 'undefined' &&
      quill.table.tables[table_id].cell_counter === this.domNode.querySelectorAll('td').length &&
      quill.table.tables[table_id].row_counter === this.domNode.querySelectorAll('tr').length
    ) {
      // our table is fully initialized, we can do more optimizations

      // add hidden merged cells
      this.domNode.querySelectorAll('td[cell_id][colspan], td[cell_id][rowspan]').forEach(cell => {
        const index = Array.prototype.indexOf.call(cell.parentNode.children, cell);
        const colSpan = Number.parseInt(cell.getAttribute('colspan') || 1);
        const rowSpan = Number.parseInt(cell.getAttribute('rowspan') || 1);

        if (!this.domNode.querySelector('td[merge_id="' + cell.getAttribute('cell_id') + '"]') && (colSpan > 1 || rowSpan > 1)) {
          let row = cell.parentNode;
          for (let y = 1; y <= rowSpan; y++) {
            if (!row) break;
            // we want to add the cell between cell with colspan/rowspan and next cell
            // for next rows, add the cell before the cell with the same index
            let nextCell = y === 1 ? row.children[index + 1] : row.children[index];
            for (let x = 1; x <= colSpan; x++) {
              if (x === 1 && y === 1) {
                continue; // do not add a cell at the original cell position
              }
              let newCell = document.createElement('td');
              newCell.setAttribute('cell_id', TableTrick.random_id());
              newCell.setAttribute('row_id', row.getAttribute('row_id'));
              newCell.setAttribute('table_id', this.domNode.getAttribute('table_id'));
              newCell.setAttribute('merge_id', cell.getAttribute('cell_id'));
              let p = document.createElement('p');
              let br = document.createElement('br');
              p.appendChild(br);
              newCell.appendChild(p);
              row.insertBefore(newCell, nextCell);
            }
            row = row.nextSibling;
          }
        }
      });

      if (quill.table.tables[table_id].pasted) {
        // add to history
        TableHistory.register('insert', { node: this.domNode, nextNode: this.domNode.nextSibling, parentNode: this.domNode.parentNode });
        TableHistory.add(quill);
      }

      // delete entry for optimizing only once
      delete quill.table.tables[table_id];
    }
  }

  insertBefore(childBlot, refBlot) {
    if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function (child) {
      return childBlot instanceof child;
    })) {
      let newChild = Parchment$3.create(this.statics.defaultChild, TableTrick.random_id());
      newChild.appendChild(childBlot);
      childBlot = newChild;
    }
    super.insertBefore(childBlot, refBlot);
  }
}

Table.blotName = 'table';
Table.tagName = 'table';
Table.scope = Parchment$3.Scope.BLOCK_BLOT;
Table.defaultChild = 'tr';
Table.allowedChildren = [TableRow];

// import Quill from 'quill';

const Container = Quill.import('blots/container');
const Parchment$2 = Quill.import('parchment');
const Delta$1 = Quill.import("delta");

const nodeListToArray = collection => {
  const elementsIndex = [];
  for (let i = 0; i < collection.length; i++) {
    elementsIndex.push(i);
  }
  return elementsIndex.map(i => collection.item(i));
};

Container.order = [
  'list', 'contain',   // Must be lower
  'td', 'tr', 'table'  // Must be higher
];

const emitirEventoTableInTable = (quill) => {
  quill.container.dispatchEvent(
    new CustomEvent('onTableInTable', {
      bubbles: true,
      composed: true,
    })
  );
};

class TableModule {
  static register() {
    Quill.register(TableCell, true);
    Quill.register(TableRow, true);
    Quill.register(Table, true);
    Quill.register(ContainBlot, true);
  }

  constructor(quill, options) {
    quill.history.tableStack = {};
    quill.table = {
      isInTable: false,
      tables: {}
    };

    // selection mouse events
    quill.container.addEventListener('mousedown', (e) => TableSelection.mouseDown(quill, e, options.cellSelectionOnClick));
    quill.container.addEventListener('mousemove', (e) => TableSelection.mouseMove(quill, e));
    quill.container.addEventListener('mouseup', (e) => TableSelection.mouseUp(quill, e));
    quill.on('selection-change', (range, oldRange) => TableSelection.selectionChange(quill, range, oldRange));

    const toolbar = quill.getModule('toolbar');
    toolbar.addHandler('table', function (value) {
      if (isInsertTable(value) && isInTable(quill)) {
        emitirEventoTableInTable(quill);
        return false;
      }
      return TableTrick.table_handler(value, quill);
    });

    const clipboard = quill.getModule('clipboard');
    clipboard.addMatcher('TABLE', function (node, delta) {
      if (isInTable(quill)) {
        emitirEventoTableInTable(quill);
        return new Delta$1();
      }

      const is_pasted_data = node.closest('.ql-editor') === null;
      const table_id = node.getAttribute('table_id');
      if (table_id) {
        quill.table.tables[table_id] = {
          pasted: is_pasted_data,
          row_counter: node.querySelectorAll('tr').length,
          cell_counter: node.querySelectorAll('td').length
        };
      }
      return delta;
    });
    clipboard.addMatcher('TR', function (node, delta) {
      return delta;
    });
    clipboard.addMatcher('TD, TH', function (node, delta) {
      if (delta.length() === 0) {
        // fix https://github.com/dclement8/quill1-table/issues/7 (empty td removed)
        delta.ops = [
          {insert: '\n'}
        ];
      } else if (delta.ops && delta.ops.length) {
        // fix https://github.com/dclement8/quill1-table/issues/7 (td with no child node)
        const lastIndex = delta.ops.reduce((lastIndex, op, idx) => typeof op.insert !== 'undefined' ? idx : lastIndex, -1);
        if (lastIndex >= 0 && !delta.ops[lastIndex].insert.endsWith('\n')) {
          delta.ops[lastIndex].insert += '\n';
        }
      }

      const tableNode = node.closest('table');
      if (!node.getAttribute('table_id') && tableNode) {
        if (!tableNode.getAttribute('table_id')) {
          tableNode.setAttribute('table_id', TableTrick.random_id());
        }
        node.setAttribute('table_id', tableNode.getAttribute('table_id'));
      }

      if (!node.getAttribute('row_id')) {
        const rowNode = node.closest('tr');
        if (rowNode) {
          if (!rowNode.getAttribute('row_id')) {
            rowNode.setAttribute('row_id', TableTrick.random_id());
          }
          node.setAttribute('row_id', rowNode.getAttribute('row_id'));
        }
      }

      if (!node.getAttribute('cell_id')) {
        node.setAttribute('cell_id', TableTrick.random_id());
      }

      const newDelta = delta.compose(new Delta$1().retain(delta.length(), {
        td: [
          node.getAttribute('table_id'),
          node.getAttribute('row_id'),
          node.getAttribute('cell_id'),
          node.getAttribute('merge_id'),
          node.getAttribute('colspan'),
          node.getAttribute('rowspan')
        ].join('|')
      }));
      return newDelta;
    });

    TableToolbar.enable(quill, ['newtable_*', 'insert', 'undo', 'redo']);
  }

  static tableOptions() {
    const maxRows = 5;
    const maxCols = 5;
    const tableOptions = [];
    for (let r = 1; r <= maxRows; r++) {
      for (let c = 1; c <= maxCols; c++) {
        tableOptions.push('newtable_' + r + '_' + c);
      }
    }
    return tableOptions;
  }

  static removeNodeChildren(node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  }

  static keyboardHandler(quill, key, range, keycontext) {
    const format_start = quill.getFormat(range.index - 1);
    const format_end = quill.getFormat(range.index + range.length);

    if (key === 'undo' || key === 'redo' || key === 'copy') {
      return TableTrick.table_handler(key, quill);
    }

    // If the event is not in a cell, then pass the standard handler
    if (!format_start.td && !keycontext.format.td && !format_end.td) {
      return true;
    }

    if (key === 'backspace') {
      // if the selection is at the cell border
      // BUG: after undo brings back deleted cell when backspace comes in the keycontext offset is 0, which throws it to the end
      if (!keycontext.offset && !range.length) {
        const selection = window.getSelection();
        const nodeList = document.querySelectorAll(".ql-editor p");
        // remove selected content
        const resultNodes = nodeListToArray(nodeList).filter(cell =>
          selection.containsNode(cell, true)
        );

        // deletion does not affect the cell
        if (!resultNodes.length) {
          return true;
        }
        // do not delete if we have a selection (TODO: manage selection deletion)
        if (TableSelection.getSelectionCoords()) {
          return false;
        }

        let nodeRemoved = false;
        resultNodes.forEach((resultNode, i) => {
          if (resultNode.previousSibling) {
            if (resultNode.previousSibling.nodeName === 'TABLE') {
              // remove last cell if we are right after a table
              const cells = resultNode.previousSibling.querySelectorAll('td');
              if (cells.length && TableTrick._removeCell(cells[cells.length - 1])) {
                nodeRemoved = true;
              }
            }
          } else if (resultNode.parentNode.nodeName === 'TD') {
            // remove current cell if we are inside it
            if (TableTrick._removeCell(resultNode.parentNode)) {
              nodeRemoved = true;
            }
          }
        });

        if (nodeRemoved) {
          TableHistory.add(quill);
        }

        // if at least one node has been removed, then return false (do not call standard handler)
        return !nodeRemoved;
      }

      // If we delete not at the cell border, then pass the standard handler
      return true;
    }

    if (key === 'tab') {
      TableSelection.resetSelection();
      const [leaf] = quill.getLeaf(quill.getSelection().index);
      let selectionIndex;
      let blot;
      let unmergedCell;
      if (leaf.parent.domNode.closest('td')) {
        if (leaf.parent.domNode.closest('td').nextSibling) {
          unmergedCell = leaf.parent.domNode.closest('td').nextSibling;
          while (unmergedCell && unmergedCell.getAttribute('merge_id')) {
            unmergedCell = unmergedCell.nextSibling;
          }
          blot = Quill.find(unmergedCell ? unmergedCell : leaf.parent.domNode.closest('tr').nextSibling); //we truly dont have any more cells
        } else { //we dont need to find the first child here since quill does the right thing
          if (leaf.parent.domNode.closest('tr').nextSibling) { //no more cells, go to the next row
            blot = Quill.find(leaf.parent.domNode.closest('tr').nextSibling);
          } else { //no more rows to the tables next sibling which will be the next quill run p,h1-h4
            if (leaf.parent.domNode.closest('table').nextSibling) {
              blot = Quill.find(leaf.parent.domNode.closest('table').nextSibling);
            }
          }
        }
        //we get the actual editor index when we have the blot aka element in editor
        selectionIndex = blot.offset(quill.scroll);
        quill.setSelection(selectionIndex, 0);

        return false
      }
      return true
    }

    if (key === "shiftTab") {
      //previous cell
      TableSelection.resetSelection();
      const [leaf] = quill.getLeaf(quill.getSelection().index);
      let selectionIndex;
      let blot;
      let unmergedCell;
      if (leaf.parent.domNode.closest('td')) {
        if (leaf.parent.domNode.closest('td').previousSibling) {
          unmergedCell = leaf.parent.domNode.closest('td').previousSibling;
          while (unmergedCell.getAttribute('merge_id')) { //this a merged cell, in dom but styled/css out
            unmergedCell = unmergedCell.previousSibling;
          }
          blot = Quill.find(unmergedCell);
        } else {
          if (leaf.parent.domNode.closest('tr').previousSibling) { //no more cells, go to the next row
            unmergedCell = leaf.parent.domNode.closest('tr').previousSibling.lastChild;
            while (unmergedCell.getAttribute('merge_id')) { //this a merged cell, in dom but styled/css out
              unmergedCell = unmergedCell.previousSibling;
            }
            blot = Quill.find(unmergedCell);
          } else {
            if (leaf.parent.domNode.closest('table').previousSibling) { //no more rows to the tables prev sibling which will just go to electron default.
              return true;
            }
          }
        }
        //we get the actual editor index when we have the blot aka element in editor
        selectionIndex = blot.offset(quill.scroll);
        quill.setSelection(selectionIndex, 0);

        return false;
      }
      return true;
    }

    let node = quill.selection.getNativeRange().start.node;
    if (!node) return false;
    let blot = Parchment$2.find(node);

    if (
      key === 'delete' && blot &&
      keycontext.offset < (blot.text ? blot.text.length : 0)
    ) {
      return true;
    }

    const [prev] = quill.getLine(range.index - 1);
    const [next] = quill.getLine(range.index + 1);
    // If a cell has multiple rows, you can delete as standard

    if (key === 'selectAll') {
      let [line] = quill.getLine(quill.getSelection().index);
      let blot;
      let nextBlot;
      if (line.parent.domNode.nodeName === "TD") {
        if (line.parent.domNode.nextSibling){
          nextBlot = Quill.find(line.parent.domNode.nextSibling);
        } else { //no next cell to bounce the end to
          if (line.parent.domNode.closest('tr').nextSibling) { //no next row either
            nextBlot = Quill.find(line.parent.domNode.closest('tr').nextSibling);
          } else { //the only other thing is get tables sibling which is the next p in editor
            nextBlot = Quill.find(line.parent.domNode.closest('table').nextSibling);
          }
        }
        blot = Quill.find(line.parent.domNode);
        let selectionIndex = blot.offset(quill.scroll); //index for cell start
        let nextBlotIndex = nextBlot.offset(quill.scroll); //index for cell ending
        quill.setSelection(selectionIndex, nextBlotIndex-selectionIndex-1);
        return false;
      }
      return true;
    }
    if (key === 'backspace' && prev && prev.next) {
      return true;
    }
    if (key === 'delete' && next && next.prev) {
      return true;
    }
  }
}

const isInsertTable = (value = '') => value.includes('newtable_');

const isInTable = (quill) => quill && quill.getSelection(true) && quill.getFormat(quill.getSelection(true)).td;

const removeElementosTDOcultos = (html = '') => {
    // O quill1table adiciona elementos td ocultos para identificar/gerenciar undo de células mescladas.
    // Esses elementos não devem fazer parte do texto html a ser salvo.
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    const elementosOcultos = tempDiv.querySelectorAll('td[merge_id]');
    elementosOcultos.forEach((elemento) => { var _a; return (_a = elemento.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(elemento); });
    return tempDiv.innerHTML;
};

const Parchment$1 = Quill.import('parchment');
const config$1 = {
    scope: Parchment$1.Scope.BLOCK,
    whitelist: ['0px'],
};
// const NoIndentStyle = new Parchment.Attributor.Style('text-indent', 'text-indent', config);
const NoIndentClass = new Parchment$1.Attributor.Class('text-indent', 'ql-text-indent', config$1);

const Parchment = Quill.import('parchment');
const config = {
    scope: Parchment.Scope.BLOCK,
    whitelist: ['0px'],
};
// const MarginBottomStyle = new Parchment.Attributor.Style('margin-bottom', 'margin-bottom', config);
const MarginBottomClass = new Parchment.Attributor.Class('margin-bottom', 'ql-margin-bottom', config);

const DefaultKeyboardModule = Quill.import('modules/keyboard');
const DefaultClipboardModule = Quill.import('modules/clipboard');
const Delta = Quill.import('delta');
let EditorTextoRicoComponent = class EditorTextoRicoComponent extends connect(rootStore)(s) {
    constructor() {
        super();
        this.texto = '';
        this.anexos = [];
        this.registroEvento = '';
        this.modo = '';
        this.onChange = new Observable();
        this.icons = Quill.import('ui/icons');
        this.labelAnexo = () => {
            var _a;
            const lengthAnexos = (_a = this.anexos) === null || _a === void 0 ? void 0 : _a.length;
            return lengthAnexos === 1 ? '1 anexo' : lengthAnexos > 1 ? `${lengthAnexos} anexos` : '';
        };
        this.onTableInTable = () => {
            clearTimeout(this.timerAlerta);
            this.timerAlerta = setTimeout(() => this.alertar('Não é permitido inserir uma tabela dentro de outra tabela.'), 100);
        };
        this.getIdTooltip = () => {
            return this.modo === Modo.JUSTIFICATIVA ? 'revisoes-justificativa-icon' : 'revisoes-texto-livre-icon';
        };
        this.getIdButtonAceitarRevisoes = () => {
            return this.modo === Modo.JUSTIFICATIVA ? 'aceita-revisao-justificativa' : 'aceita-revisao-texto-livre';
        };
        this.init = () => {
            var _a, _b;
            const quillContainer = document.querySelector(`#${this.id}-inner`);
            if (quillContainer) {
                Quill.register('modules/keyboard', DefaultKeyboardModule, true);
                Quill.register('modules/clipboard', DefaultClipboardModule, true);
                Quill.register('modules/table', TableModule, true);
                Quill.register('formats/estilo-texto', EstiloTextoClass, true);
                Quill.register('formats/text-indent', NoIndentClass, true);
                Quill.register('formats/margin-bottom', MarginBottomClass, true);
                this.quill = new Quill(quillContainer, {
                    formats: ['estilo', 'bold', 'italic', 'image', 'underline', 'align', 'list', 'script', 'image', 'table', 'tr', 'td', 'text-indent', 'margin-bottom'],
                    modules: {
                        toolbar: {
                            container: toolbarOptions,
                            handlers: {
                                undo: this.undo,
                                redo: this.redo,
                            },
                        },
                        aspasCurvas: true,
                        table: {
                            cellSelectionOnClick: false,
                        },
                        history: {
                            delay: 1000,
                            maxStack: 500,
                            userOnly: true,
                        },
                        clipboard: {},
                        keyboard: {
                            // Since Quill’s default handlers are added at initialization, the only way to prevent them is to add yours in the configuration.
                            bindings: {
                                tab: {
                                    key: 'tab',
                                    handler: (range, keycontext) => {
                                        const outSideOfTable = TableModule.keyboardHandler(this.quill, 'tab', range, keycontext);
                                        if (outSideOfTable && this.quill) {
                                            //for some reason when you return true as quill says it should hand it to the default like the other bindings... for tab it doesnt.
                                            this.quill.history.cutoff(); //mimic the exact same thing quill does
                                            const delta = new Delta().retain(range.index).delete(range.length).insert('\t');
                                            this.quill.updateContents(delta, Quill.sources.USER);
                                            this.quill.history.cutoff();
                                            this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
                                        }
                                    },
                                },
                                shiftTab: {
                                    key: 'tab',
                                    shiftKey: true,
                                    handler: (range, keycontext) => {
                                        return TableModule.keyboardHandler(this.quill, 'shiftTab', range, keycontext);
                                    },
                                },
                                selectAll: {
                                    key: 'a',
                                    ctrlKey: true,
                                    handler: (range, keycontext) => {
                                        return TableModule.keyboardHandler(this.quill, 'selectAll', range, keycontext);
                                    },
                                },
                                backspace: {
                                    key: 'backspace',
                                    handler: (range, keycontext) => {
                                        return TableModule.keyboardHandler(this.quill, 'backspace', range, keycontext);
                                    },
                                },
                                delete: {
                                    key: 'delete',
                                    handler: (range, keycontext) => {
                                        return TableModule.keyboardHandler(this.quill, 'delete', range, keycontext);
                                    },
                                },
                                undo: {
                                    ctrlKey: true,
                                    key: 'z',
                                    handler: (range, keycontext) => {
                                        return TableModule.keyboardHandler(this.quill, 'undo', range, keycontext);
                                    },
                                },
                                redo: {
                                    ctrlKey: true,
                                    key: 'y',
                                    handler: (range, keycontext) => {
                                        return TableModule.keyboardHandler(this.quill, 'redo', range, keycontext);
                                    },
                                },
                                redo2: {
                                    ctrlKey: true,
                                    shiftKey: true,
                                    key: 'z',
                                    handler: (range, keycontext) => {
                                        return TableModule.keyboardHandler(this.quill, 'redo', range, keycontext);
                                    },
                                },
                                copy: {
                                    ctrlKey: true,
                                    key: 'c',
                                    handler: (range, keycontext) => {
                                        return TableModule.keyboardHandler(this.quill, 'copy', range, keycontext);
                                    },
                                },
                                // Desabilita autoformatação de listas
                                // Referência: https://github.com/quilljs/quill/blob/1.3.7/modules/keyboard.js (linha 249)
                                'list autofill': {
                                    key: ' ',
                                    handler: () => true,
                                },
                            },
                        },
                    },
                    placeholder: '',
                    theme: 'snow',
                });
                this.setContent(this.texto);
                this.addBotoesExtra();
                this.configureTooltip();
                this.elTableManagerButton = this.querySelectorAll('span.ql-table')[1];
                (_a = this.quill) === null || _a === void 0 ? void 0 : _a.on('text-change', this.updateTexto);
                (_b = this.quill) === null || _b === void 0 ? void 0 : _b.on('selection-change', this.onSelectionChange);
            }
        };
        this.onSelectionChange = (range) => {
            setTimeout(() => {
                var _a;
                const format = range && ((_a = this.quill) === null || _a === void 0 ? void 0 : _a.getFormat(range));
                this.highLightBotaoGerenciarTabela(format);
            }, 0);
        };
        this.highLightBotaoGerenciarTabela = (format) => {
            var _a, _b;
            (format === null || format === void 0 ? void 0 : format.td) ? (_a = this.elTableManagerButton) === null || _a === void 0 ? void 0 : _a.classList.add('table-selected') : (_b = this.elTableManagerButton) === null || _b === void 0 ? void 0 : _b.classList.remove('table-selected');
        };
        this.addBotoesExtra = () => {
            const toolbarContainer = this.quill.getModule('toolbar').container;
            const elAnexo = this.querySelector('.panel-anexo');
            const elRevisao = this.querySelector('.panel-revisao');
            if (elAnexo) {
                elAnexo.parentNode.removeChild(elAnexo);
                toolbarContainer.appendChild(elAnexo);
            }
            elRevisao.parentNode.removeChild(elRevisao);
            toolbarContainer.appendChild(elRevisao);
        };
        this.configureTooltip = () => {
            const toolbarContainer = this.quill.getModule('toolbar').container;
            this.setTitle(toolbarContainer, 'button.ql-bold', 'Negrito (Ctrl+b)');
            this.setTitle(toolbarContainer, 'button.ql-italic', 'Itálico (Ctrl+i)');
            this.setTitle(toolbarContainer, 'button.ql-underline', 'Sublinhado (Ctrl+u)');
            this.setTitle(toolbarContainer, 'button.ql-list[value="ordered"]', 'Lista ordenada');
            this.setTitle(toolbarContainer, 'button.ql-list[value="bullet"]', 'Lista não ordenada');
            this.setTitle(toolbarContainer, 'button.ql-blockquote', 'Bloco de citação');
            this.setTitle(toolbarContainer, 'button.ql-script[value="sub"]', 'Subscrito');
            this.setTitle(toolbarContainer, 'button.ql-script[value="super"]', 'Sobrescrito');
            this.setTitle(toolbarContainer, '.ql-align .ql-picker-options > span:nth-child(1)', 'Alinhar à esquerda');
            this.setTitle(toolbarContainer, '.ql-align .ql-picker-options > span:nth-child(2)', 'Centralizar');
            this.setTitle(toolbarContainer, '.ql-align .ql-picker-options > span:nth-child(3)', 'Alinhar à direita');
            this.setTitle(toolbarContainer, '.ql-align .ql-picker-options > span:nth-child(4)', 'Justificar');
            this.setTitle(toolbarContainer, 'button.ql-clean', 'Limpar formatação');
            this.setTitle(toolbarContainer, 'button.ql-image', 'Inserir imagem');
            this.setTitle(toolbarContainer, 'button.ql-undo', 'Desfazer (Ctrl+z)');
            this.setTitle(toolbarContainer, 'button.ql-redo', 'Refazer (Ctrl+y)');
            this.setTitle(toolbarContainer, 'button.ql-margin-bottom', 'Distância entre parágrafos');
            this.setTitle(toolbarContainer, 'button.ql-text-indent', 'Recuo de parágrafo');
        };
        this.setTitle = (toolbarContainer, seletor, title) => { var _a; return (_a = toolbarContainer.querySelector(seletor)) === null || _a === void 0 ? void 0 : _a.setAttribute('title', title); };
        this.setContent = (texto) => {
            if (!this.quill || !this.quill.root) {
                return;
            }
            this.texto = texto;
            const textoAjustado = (texto || '')
                .replace(/align-justify/g, 'ql-align-justify')
                .replace(/align-center/g, 'ql-align-center')
                .replace(/align-right/g, 'ql-align-right');
            this.quill.history.clear(); // Não remover: isso é um workaround para o bug que ocorre ao limpar conteúdo depois de alguma inserção de tabela
            this.quill.setContents(this.quill.clipboard.convert(textoAjustado), 'silent');
            setTimeout(() => this.quill.history.clear(), 100); // A linha anterior gera um history, então é necessário limpar novamente.
        };
        this.updateTexto = () => {
            var _a, _b;
            const texto = this.ajustaHtml((_a = this.quill) === null || _a === void 0 ? void 0 : _a.root.innerHTML);
            this.texto = texto === '<p><br></p>' ? '' : texto;
            this.agendarEmissaoEventoOnChange();
            this.buildRevisoes();
            this.onSelectionChange((_b = this.quill) === null || _b === void 0 ? void 0 : _b.getSelection());
        };
        this.ajustaHtml = (html = '') => {
            const result = html
                .replace(/ql-indent/g, 'indent')
                .replace(/ql-align-justify/g, 'align-justify')
                .replace(/ql-align-center/g, 'align-center')
                .replace(/ql-align-right/g, 'align-right');
            return removeElementosTDOcultos(result);
        };
        this.buildRevisoes = () => {
            if (this.modo === Modo.JUSTIFICATIVA) {
                atualizaRevisaoJustificativa(rootStore.getState().elementoReducer);
            }
            else {
                atualizaRevisaoTextoLivre(rootStore.getState().elementoReducer);
            }
            this.atualizaRevisaoIcon();
            this.desabilitaBtn(this.getRevisoes().length === 0, this.getIdButtonAceitarRevisoes());
        };
        this.undo = () => {
            var _a, _b;
            if (TableModule.keyboardHandler(this.quill, 'undo', (_a = this.quill) === null || _a === void 0 ? void 0 : _a.getSelection(true), undefined)) {
                (_b = this.quill) === null || _b === void 0 ? void 0 : _b.history.undo();
            }
        };
        this.redo = () => {
            var _a, _b;
            if (TableModule.keyboardHandler(this.quill, 'redo', (_a = this.quill) === null || _a === void 0 ? void 0 : _a.getSelection(true), undefined)) {
                (_b = this.quill) === null || _b === void 0 ? void 0 : _b.history.redo();
            }
        };
        this.atualizaAnexo = (anexo) => {
            this.anexos = [...anexo];
        };
        this.getNomeSwitch = () => {
            return this.modo === Modo.JUSTIFICATIVA ? 'chk-em-revisao-justificativa' : 'chk-em-revisao-texto-livre';
        };
        this.getNomeBadge = () => {
            return this.modo === Modo.JUSTIFICATIVA ? 'badge-marca-alteracao-justificativa' : 'badge-marca-alteracao-texto-livre';
        };
        this.atualizaRevisaoIcon = () => {
            const idIcon = '#' + this.getIdTooltip() + '>';
            const contentRevisoes = document.querySelector(idIcon + 'div[slot=content]');
            const iconRevisoes = document.querySelector(idIcon + 'sl-icon');
            if (contentRevisoes && iconRevisoes) {
                if (this.getRevisoes().length !== 0) {
                    contentRevisoes.innerHTML = this.getMensagemRevisoes();
                    iconRevisoes.classList.add(this.getIdTooltip() + '__ativo');
                    iconRevisoes.removeAttribute('disabled');
                }
                else {
                    contentRevisoes.innerHTML = this.getTitle();
                    iconRevisoes.classList.remove(this.getIdTooltip() + '__ativo');
                    this.desabilitaBtn(this.getRevisoes().length === 0, this.getIdButtonAceitarRevisoes());
                }
            }
        };
        this.getTitle = () => {
            return this.modo === Modo.JUSTIFICATIVA ? 'Revisões na justificação' : 'Revisões no texto livre';
        };
        this.getMensagemRevisoes = () => {
            let revisoes;
            if (this.modo === Modo.JUSTIFICATIVA) {
                revisoes = this.getRevisoesJustificativa();
            }
            else {
                revisoes = this.getRevisoesTextoLivre();
            }
            let mensagem = '<ul class="lista-revisoes-justificativa">';
            if (revisoes.length > 0) {
                revisoes.forEach((revisao) => {
                    const pipe = ' | ';
                    mensagem = mensagem + '<li>' + revisao.usuario.nome + pipe + revisao.dataHora + '</li>';
                });
            }
            return mensagem + '</ul>';
        };
        this.aceitarRevisoes = () => {
            if (this.modo === Modo.JUSTIFICATIVA) {
                this.aceitaRevisoesJustificativa();
            }
            else {
                this.aceitaRevisoesTextoLivre();
            }
        };
        this.aceitaRevisoesJustificativa = () => {
            atualizaRevisaoJustificativa(rootStore.getState().elementoReducer, true);
            this.atualizaRevisaoIcon();
            this.desabilitaBtn(this.getRevisoesJustificativa().length === 0, 'aceita-revisao-justificativa');
            this.atualizaQuantidadeRevisao();
        };
        this.aceitaRevisoesTextoLivre = () => {
            atualizaRevisaoTextoLivre(rootStore.getState().elementoReducer, true);
            this.atualizaRevisaoIcon();
            this.desabilitaBtn(this.getRevisoesTextoLivre().length === 0, 'aceita-revisao-texto-livre');
            this.atualizaQuantidadeRevisao();
        };
        this.getRevisoes = () => {
            return this.modo === Modo.JUSTIFICATIVA ? this.getRevisoesJustificativa() : this.getRevisoesTextoLivre();
        };
        this.getRevisoesJustificativa = () => {
            const revisoes = rootStore.getState().elementoReducer.revisoes;
            return revisoes.filter(r => r.descricao === RevisaoJustificativaEnum.JustificativaAlterada);
        };
        this.getRevisoesTextoLivre = () => {
            const revisoes = rootStore.getState().elementoReducer.revisoes;
            return revisoes.filter(r => r.descricao === RevisaoTextoLivreEnum.TextoLivreAlterado);
        };
        this.desabilitaBtn = (desabilita, button) => {
            const contadorView = document.getElementById(button);
            if (contadorView) {
                if (desabilita) {
                    contadorView.setAttribute('disabled', desabilita);
                }
                else {
                    contadorView.removeAttribute('disabled');
                }
            }
        };
        this.atualizaQuantidadeRevisao = () => {
            atualizaQuantidadeRevisao(rootStore.getState().elementoReducer.revisoes, document.getElementById(this.getNomeBadge()), this.modo);
        };
        this.icons['undo'] = `<svg viewbox="0 0 18 18">
    <polygon class="ql-fill ql-stroke" points="6 10 4 12 2 10 6 10"></polygon>
    <path class="ql-stroke" d="M8.09,13.91A4.6,4.6,0,0,0,9,14,5,5,0,1,0,4,9"></path>
    </svg>`;
        this.icons['redo'] = `<svg viewbox="0 0 18 18">
    <polygon class="ql-fill ql-stroke" points="12 10 14 12 16 10 12 10"></polygon>
    <path class="ql-stroke" d="M9.91,13.91A4.6,4.6,0,0,1,9,14a5,5,0,1,1,5-5"></path>
    </svg>`;
        //this.icons['anexo'] = anexo + ;
        this.icons['bold'] = negrito;
        this.icons['underline'] = sublinhado;
        this.icons['text-indent'] = iconeTextIndent;
        this.icons['margin-bottom'] = iconeMarginBottom;
    }
    agendarEmissaoEventoOnChange() {
        clearTimeout(this.timerOnChange);
        this.timerOnChange = setTimeout(() => {
            this.dispatchEvent(new CustomEvent('onchange', {
                bubbles: true,
                composed: true,
                detail: {
                    origemEvento: this.registroEvento,
                },
            }));
            this.onChange.notify(this.registroEvento);
        }, 1000);
    }
    update(changedProperties) {
        super.update(changedProperties);
    }
    createRenderRoot() {
        return this;
    }
    stateChanged(state) {
        var _a;
        if ((_a = state.elementoReducer.ui) === null || _a === void 0 ? void 0 : _a.events) {
            this.atualizaRevisaoIcon();
            this.desabilitaBtn(this.getRevisoes().length === 0, this.getIdButtonAceitarRevisoes());
        }
    }
    render() {
        return $ `
      ${quillTableCss} ${editorTextoRicoCss} ${this.modo === Modo.TEXTO_LIVRE ? this.renderBotaoAnexo() : ''}

      <div class="panel-revisao">
        <lexml-switch-revisao modo="${this.modo}" class="revisao-container" .nomeSwitch="${this.getNomeSwitch()}" .nomeBadgeQuantidadeRevisao="${this.getNomeBadge()}">
        </lexml-switch-revisao>

        <sl-tooltip id="${this.getIdTooltip()}" placement="bottom-end">
          <div slot="content">
            <div>${this.modo === Modo.JUSTIFICATIVA ? 'Revisões na justificação' : 'Revisões no texto livre'}</div>
          </div>
          <sl-icon name="person-check-fill"></sl-icon>
        </sl-tooltip>

        <sl-button id="${this.getIdButtonAceitarRevisoes()}" variant="default" size="small" title="Limpar revisões" @click=${() => this.aceitarRevisoes()} disabled circle>
          <sl-icon name="check-lg"></sl-icon>
        </sl-button>
      </div>
      <div id="${this.id}-inner" class="editor-texto-rico" @onTableInTable=${this.onTableInTable}></div>
    `;
    }
    renderBotaoAnexo() {
        return $ `
      <div class="panel-anexo">
        <button type="button" style="width:auto" title="Anexo" @click=${() => uploadAnexoDialog(this.anexos, this.atualizaAnexo, this)}>
          <span>
            <svg xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 35 35" data-name="Layer 2" id="Layer_2">
              <path
                d="M18,34.75A11.32,11.32,0,0,1,6.69,23.45V8A7.78,7.78,0,0,1,22.25,8V22.49a4.58,4.58,0,1,1-9.15,0V9.29a1.25,1.25,0,0,1,2.5,0v13.2a2.08,2.08,0,1,0,4.15,0V8A5.28,5.28,0,0,0,9.19,8V23.45A8.82,8.82,0,0,0,18,32.25c4.6,0,7.81-3.62,7.81-8.8V9.66a1.25,1.25,0,0,1,2.5,0V23.45C28.31,30,24,34.75,18,34.75Z"
              />
            </svg>
            ${this.labelAnexo()}
          </span>
        </button>
      </div>
    `;
    }
    alertar(mensagem) {
        const alert = Object.assign(document.createElement('sl-alert'), {
            variant: 'danger',
            closable: true,
            duration: 4000,
            innerHTML: `
        <sl-icon name="exclamation-octagon" slot="icon"></sl-icon>
        ${mensagem}
      `,
        });
        document.body.append(alert);
        alert.toast();
    }
    firstUpdated() {
        this.init();
    }
    disconnectedCallback() {
        var _a, _b;
        (_a = this.quill) === null || _a === void 0 ? void 0 : _a.off('text-change', this.updateTexto);
        (_b = this.quill) === null || _b === void 0 ? void 0 : _b.off('selection-change', this.onSelectionChange);
        super.disconnectedCallback();
    }
};
__decorate([
    e$3({ type: String })
], EditorTextoRicoComponent.prototype, "texto", void 0);
__decorate([
    t$1(),
    e$3({ type: Array })
], EditorTextoRicoComponent.prototype, "anexos", void 0);
__decorate([
    e$3({ type: String, attribute: 'registro-evento' })
], EditorTextoRicoComponent.prototype, "registroEvento", void 0);
__decorate([
    e$3({ type: String })
], EditorTextoRicoComponent.prototype, "modo", void 0);
EditorTextoRicoComponent = __decorate([
    n$1('editor-texto-rico')
], EditorTextoRicoComponent);
const toolbarOptions = [
    [{ estilo: [false, 'ementa', 'norma-alterada'] }],
    ['bold', 'italic', 'underline'],
    [{ list: 'ordered' }, { list: 'bullet' }],
    [{ script: 'sub' }, { script: 'super' }],
    // ['blockquote'],
    ['undo', 'redo'],
    [{ align: [] }],
    [{ 'text-indent': '0px' }],
    [{ 'margin-bottom': '0px' }],
    ['clean'],
    [
        {
            table: TableModule.tableOptions(),
        },
        {
            table: [
                // 'insert',
                'append-row-above',
                'append-row-below',
                'append-col-before',
                'append-col-after',
                'remove-col',
                'remove-row',
                'remove-table',
                'split-cell',
                'merge-selection',
                // 'remove-cell',
                // 'remove-selection',
            ],
        },
    ],
    ['image'],
];

// Foi utilizado TemplateResult porque o articulacao.component.ts não usa ShadowDom
const shoelaceLightThemeStyles = $ `
  <style>
    :root,
    :host,
    .sl-theme-light {
      --sl-color-gray-50: hsl(0 0% 97.5%);
      --sl-color-gray-100: hsl(240 4.8% 95.9%);
      --sl-color-gray-200: hsl(240 5.9% 90%);
      --sl-color-gray-300: hsl(240 4.9% 83.9%);
      --sl-color-gray-400: hsl(240 5% 64.9%);
      --sl-color-gray-500: hsl(240 3.8% 46.1%);
      --sl-color-gray-600: hsl(240 5.2% 33.9%);
      --sl-color-gray-700: hsl(240 5.3% 26.1%);
      --sl-color-gray-800: hsl(240 3.7% 15.9%);
      --sl-color-gray-900: hsl(240 5.9% 10%);
      --sl-color-gray-950: hsl(240 7.3% 8%);

      --sl-color-red-50: hsl(0 85.7% 97.3%);
      --sl-color-red-100: hsl(0 93.3% 94.1%);
      --sl-color-red-200: hsl(0 96.3% 89.4%);
      --sl-color-red-300: hsl(0 93.5% 81.8%);
      --sl-color-red-400: hsl(0 90.6% 70.8%);
      --sl-color-red-500: hsl(0 84.2% 60.2%);
      --sl-color-red-600: hsl(0 72.2% 50.6%);
      --sl-color-red-700: hsl(0 73.7% 41.8%);
      --sl-color-red-800: hsl(0 70% 35.3%);
      --sl-color-red-900: hsl(0 62.8% 30.6%);
      --sl-color-red-950: hsl(0 60% 19.6%);

      --sl-color-orange-50: hsl(33.3 100% 96.5%);
      --sl-color-orange-100: hsl(34.3 100% 91.8%);
      --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
      --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
      --sl-color-orange-400: hsl(27 96% 61%);
      --sl-color-orange-500: hsl(24.6 95% 53.1%);
      --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
      --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
      --sl-color-orange-800: hsl(15 79.1% 33.7%);
      --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
      --sl-color-orange-950: hsl(15.2 69.1% 19%);

      --sl-color-amber-50: hsl(48 100% 96.1%);
      --sl-color-amber-100: hsl(48 96.5% 88.8%);
      --sl-color-amber-200: hsl(48 96.6% 76.7%);
      --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
      --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
      --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
      --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
      --sl-color-amber-700: hsl(26 90.5% 37.1%);
      --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
      --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
      --sl-color-amber-950: hsl(22.9 74.1% 16.7%);

      --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
      --sl-color-yellow-100: hsl(54.9 96.7% 88%);
      --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
      --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
      --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
      --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
      --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
      --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
      --sl-color-yellow-800: hsl(31.8 81% 28.8%);
      --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
      --sl-color-yellow-950: hsl(33.1 69% 13.9%);

      --sl-color-lime-50: hsl(78.3 92% 95.1%);
      --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
      --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
      --sl-color-lime-300: hsl(82 84.5% 67.1%);
      --sl-color-lime-400: hsl(82.7 78% 55.5%);
      --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
      --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
      --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
      --sl-color-lime-800: hsl(86.3 69% 22.7%);
      --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
      --sl-color-lime-950: hsl(86.5 60.6% 13.9%);

      --sl-color-green-50: hsl(138.5 76.5% 96.7%);
      --sl-color-green-100: hsl(140.6 84.2% 92.5%);
      --sl-color-green-200: hsl(141 78.9% 85.1%);
      --sl-color-green-300: hsl(141.7 76.6% 73.1%);
      --sl-color-green-400: hsl(141.9 69.2% 58%);
      --sl-color-green-500: hsl(142.1 70.6% 45.3%);
      --sl-color-green-600: hsl(142.1 76.2% 36.3%);
      --sl-color-green-700: hsl(142.4 71.8% 29.2%);
      --sl-color-green-800: hsl(142.8 64.2% 24.1%);
      --sl-color-green-900: hsl(143.8 61.2% 20.2%);
      --sl-color-green-950: hsl(144.3 60.7% 12%);

      --sl-color-emerald-50: hsl(151.8 81% 95.9%);
      --sl-color-emerald-100: hsl(149.3 80.4% 90%);
      --sl-color-emerald-200: hsl(152.4 76% 80.4%);
      --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
      --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
      --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
      --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
      --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
      --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
      --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
      --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);

      --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
      --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
      --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
      --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
      --sl-color-teal-400: hsl(172.5 66% 50.4%);
      --sl-color-teal-500: hsl(173.4 80.4% 40%);
      --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
      --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
      --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
      --sl-color-teal-900: hsl(175.9 60.8% 19%);
      --sl-color-teal-950: hsl(176.5 58.6% 11.4%);

      --sl-color-cyan-50: hsl(183.2 100% 96.3%);
      --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
      --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
      --sl-color-cyan-300: hsl(187 92.4% 69%);
      --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
      --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
      --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
      --sl-color-cyan-700: hsl(192.9 82.3% 31%);
      --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
      --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
      --sl-color-cyan-950: hsl(196.8 61% 16.1%);

      --sl-color-sky-50: hsl(204 100% 97.1%);
      --sl-color-sky-100: hsl(204 93.8% 93.7%);
      --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
      --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
      --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
      --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
      --sl-color-sky-600: hsl(200.4 98% 39.4%);
      --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
      --sl-color-sky-800: hsl(201 90% 27.5%);
      --sl-color-sky-900: hsl(202 80.3% 23.9%);
      --sl-color-sky-950: hsl(202.3 73.8% 16.5%);

      --sl-color-blue-50: hsl(213.8 100% 96.9%);
      --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
      --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
      --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
      --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
      --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
      --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
      --sl-color-blue-700: hsl(224.3 76.3% 48%);
      --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
      --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
      --sl-color-blue-950: hsl(226.2 55.3% 18.4%);

      --sl-color-indigo-50: hsl(225.9 100% 96.7%);
      --sl-color-indigo-100: hsl(226.5 100% 93.9%);
      --sl-color-indigo-200: hsl(228 96.5% 88.8%);
      --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
      --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
      --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
      --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
      --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
      --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
      --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
      --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);

      --sl-color-violet-50: hsl(250 100% 97.6%);
      --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
      --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
      --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
      --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
      --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
      --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
      --sl-color-violet-700: hsl(263.4 70% 50.4%);
      --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
      --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
      --sl-color-violet-950: hsl(265.1 61.5% 21.4%);

      --sl-color-purple-50: hsl(270 100% 98%);
      --sl-color-purple-100: hsl(268.7 100% 95.5%);
      --sl-color-purple-200: hsl(268.6 100% 91.8%);
      --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
      --sl-color-purple-400: hsl(270 95.2% 75.3%);
      --sl-color-purple-500: hsl(270.7 91% 65.1%);
      --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
      --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
      --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
      --sl-color-purple-900: hsl(273.6 65.6% 32%);
      --sl-color-purple-950: hsl(276 59.5% 16.5%);

      --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
      --sl-color-fuchsia-100: hsl(287 100% 95.5%);
      --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
      --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
      --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
      --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
      --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
      --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
      --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
      --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
      --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);

      --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
      --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
      --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
      --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
      --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
      --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
      --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
      --sl-color-pink-700: hsl(335.1 77.6% 42%);
      --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
      --sl-color-pink-900: hsl(335.9 69% 30.4%);
      --sl-color-pink-950: hsl(336.2 65.4% 15.9%);

      --sl-color-rose-50: hsl(355.7 100% 97.3%);
      --sl-color-rose-100: hsl(355.6 100% 94.7%);
      --sl-color-rose-200: hsl(352.7 96.1% 90%);
      --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
      --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
      --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
      --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
      --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
      --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
      --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
      --sl-color-rose-950: hsl(341.3 70.1% 17.1%);

      --sl-color-primary-50: var(--sl-color-sky-50);
      --sl-color-primary-100: var(--sl-color-sky-100);
      --sl-color-primary-200: var(--sl-color-sky-200);
      --sl-color-primary-300: var(--sl-color-sky-300);
      --sl-color-primary-400: var(--sl-color-sky-400);
      --sl-color-primary-500: var(--sl-color-sky-500);
      --sl-color-primary-600: var(--sl-color-sky-600);
      --sl-color-primary-700: var(--sl-color-sky-700);
      --sl-color-primary-800: var(--sl-color-sky-800);
      --sl-color-primary-900: var(--sl-color-sky-900);
      --sl-color-primary-950: var(--sl-color-sky-950);

      --sl-color-success-50: var(--sl-color-green-50);
      --sl-color-success-100: var(--sl-color-green-100);
      --sl-color-success-200: var(--sl-color-green-200);
      --sl-color-success-300: var(--sl-color-green-300);
      --sl-color-success-400: var(--sl-color-green-400);
      --sl-color-success-500: var(--sl-color-green-500);
      --sl-color-success-600: var(--sl-color-green-600);
      --sl-color-success-700: var(--sl-color-green-700);
      --sl-color-success-800: var(--sl-color-green-800);
      --sl-color-success-900: var(--sl-color-green-900);
      --sl-color-success-950: var(--sl-color-green-950);

      --sl-color-warning-50: var(--sl-color-amber-50);
      --sl-color-warning-100: var(--sl-color-amber-100);
      --sl-color-warning-200: var(--sl-color-amber-200);
      --sl-color-warning-300: var(--sl-color-amber-300);
      --sl-color-warning-400: var(--sl-color-amber-400);
      --sl-color-warning-500: var(--sl-color-amber-500);
      --sl-color-warning-600: var(--sl-color-amber-600);
      --sl-color-warning-700: var(--sl-color-amber-700);
      --sl-color-warning-800: var(--sl-color-amber-800);
      --sl-color-warning-900: var(--sl-color-amber-900);
      --sl-color-warning-950: var(--sl-color-amber-950);

      --sl-color-danger-50: var(--sl-color-red-50);
      --sl-color-danger-100: var(--sl-color-red-100);
      --sl-color-danger-200: var(--sl-color-red-200);
      --sl-color-danger-300: var(--sl-color-red-300);
      --sl-color-danger-400: var(--sl-color-red-400);
      --sl-color-danger-500: var(--sl-color-red-500);
      --sl-color-danger-600: var(--sl-color-red-600);
      --sl-color-danger-700: var(--sl-color-red-700);
      --sl-color-danger-800: var(--sl-color-red-800);
      --sl-color-danger-900: var(--sl-color-red-900);
      --sl-color-danger-950: var(--sl-color-red-950);

      --sl-color-neutral-50: var(--sl-color-gray-50);
      --sl-color-neutral-100: var(--sl-color-gray-100);
      --sl-color-neutral-200: var(--sl-color-gray-200);
      --sl-color-neutral-300: var(--sl-color-gray-300);
      --sl-color-neutral-400: var(--sl-color-gray-400);
      --sl-color-neutral-500: var(--sl-color-gray-500);
      --sl-color-neutral-600: var(--sl-color-gray-600);
      --sl-color-neutral-700: var(--sl-color-gray-700);
      --sl-color-neutral-800: var(--sl-color-gray-800);
      --sl-color-neutral-900: var(--sl-color-gray-900);
      --sl-color-neutral-950: var(--sl-color-gray-950);

      --sl-color-neutral-0: hsl(0, 0%, 100%);
      --sl-color-neutral-1000: hsl(0, 0%, 0%);

      --sl-border-radius-small: 0.1875rem;
      --sl-border-radius-medium: 0.25rem;
      --sl-border-radius-large: 0.5rem;
      --sl-border-radius-x-large: 1rem;

      --sl-border-radius-circle: 50%;
      --sl-border-radius-pill: 9999px;

      --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
      --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
      --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
      --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
      --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);

      --sl-spacing-3x-small: 0.125rem;
      --sl-spacing-2x-small: 0.25rem;
      --sl-spacing-x-small: 0.5rem;
      --sl-spacing-small: 0.75rem;
      --sl-spacing-medium: 1rem;
      --sl-spacing-large: 1.25rem;
      --sl-spacing-x-large: 1.75rem;
      --sl-spacing-2x-large: 2.25rem;
      --sl-spacing-3x-large: 3rem;
      --sl-spacing-4x-large: 4.5rem;

      --sl-transition-x-slow: 1000ms;
      --sl-transition-slow: 500ms;
      --sl-transition-medium: 250ms;
      --sl-transition-fast: 150ms;
      --sl-transition-x-fast: 50ms;

      --sl-font-mono: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
      --sl-font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
      --sl-font-serif: Georgia, 'Times New Roman', serif;

      --sl-font-size-2x-small: 0.625rem;
      --sl-font-size-x-small: 0.75rem;
      --sl-font-size-small: 0.875rem;
      --sl-font-size-medium: 1rem;
      --sl-font-size-large: 1.25rem;
      --sl-font-size-x-large: 1.5rem;
      --sl-font-size-2x-large: 2.25rem;
      --sl-font-size-3x-large: 3rem;
      --sl-font-size-4x-large: 4.5rem;

      --sl-font-weight-light: 300;
      --sl-font-weight-normal: 400;
      --sl-font-weight-semibold: 500;
      --sl-font-weight-bold: 700;

      --sl-letter-spacing-denser: -0.03em;
      --sl-letter-spacing-dense: -0.015em;
      --sl-letter-spacing-normal: normal;
      --sl-letter-spacing-loose: 0.075em;
      --sl-letter-spacing-looser: 0.15em;

      --sl-line-height-denser: 1;
      --sl-line-height-dense: 1.4;
      --sl-line-height-normal: 1.8;
      --sl-line-height-loose: 2.2;
      --sl-line-height-looser: 2.6;

      --sl-focus-ring-alpha: 40%;
      --sl-focus-ring-width: 3px;
      --sl-focus-ring: 0 0 0 var(--sl-focus-ring-width) hsl(198.6 88.7% 48.4% / var(--sl-focus-ring-alpha));

      --sl-button-font-size-small: var(--sl-font-size-x-small);
      --sl-button-font-size-medium: var(--sl-font-size-small);
      --sl-button-font-size-large: var(--sl-font-size-medium);

      --sl-input-height-small: 1.875rem;
      --sl-input-height-medium: 2.5rem;
      --sl-input-height-large: 3.125rem;

      --sl-input-background-color: var(--sl-color-neutral-0);
      --sl-input-background-color-hover: var(--sl-input-background-color);
      --sl-input-background-color-focus: var(--sl-input-background-color);
      --sl-input-background-color-disabled: var(--sl-color-neutral-100);
      --sl-input-border-color: var(--sl-color-neutral-300);
      --sl-input-border-color-hover: var(--sl-color-neutral-400);
      --sl-input-border-color-focus: var(--sl-color-primary-500);
      --sl-input-border-color-disabled: var(--sl-color-neutral-300);
      --sl-input-border-width: 1px;

      --sl-input-border-radius-small: var(--sl-border-radius-medium);
      --sl-input-border-radius-medium: var(--sl-border-radius-medium);
      --sl-input-border-radius-large: var(--sl-border-radius-medium);

      --sl-input-font-family: var(--sl-font-sans);
      --sl-input-font-weight: var(--sl-font-weight-normal);
      --sl-input-font-size-small: var(--sl-font-size-small);
      --sl-input-font-size-medium: var(--sl-font-size-medium);
      --sl-input-font-size-large: var(--sl-font-size-large);
      --sl-input-letter-spacing: var(--sl-letter-spacing-normal);

      --sl-input-color: var(--sl-color-neutral-700);
      --sl-input-color-hover: var(--sl-color-neutral-700);
      --sl-input-color-focus: var(--sl-color-neutral-700);
      --sl-input-color-disabled: var(--sl-color-neutral-900);
      --sl-input-icon-color: var(--sl-color-neutral-500);
      --sl-input-icon-color-hover: var(--sl-color-neutral-600);
      --sl-input-icon-color-focus: var(--sl-color-neutral-600);
      --sl-input-placeholder-color: var(--sl-color-neutral-500);
      --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
      --sl-input-spacing-small: var(--sl-spacing-small);
      --sl-input-spacing-medium: var(--sl-spacing-medium);
      --sl-input-spacing-large: var(--sl-spacing-large);

      --sl-input-filled-background-color: var(--sl-color-neutral-100);
      --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
      --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
      --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
      --sl-input-filled-color: var(--sl-color-neutral-800);
      --sl-input-filled-color-hover: var(--sl-color-neutral-800);
      --sl-input-filled-color-focus: var(--sl-color-neutral-700);
      --sl-input-filled-color-disabled: var(--sl-color-neutral-800);

      --sl-input-label-font-size-small: var(--sl-font-size-small);
      --sl-input-label-font-size-medium: var(--sl-font-size-medium);
      --sl-input-label-font-size-large: var(--sl-font-size-large);

      --sl-input-label-color: inherit;

      --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
      --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
      --sl-input-help-text-font-size-large: var(--sl-font-size-medium);

      --sl-input-help-text-color: var(--sl-color-neutral-500);

      --sl-toggle-size: 1rem;

      --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);

      --sl-panel-background-color: var(--sl-color-neutral-0);
      --sl-panel-border-color: var(--sl-color-neutral-200);
      --sl-panel-border-width: 1px;

      --sl-tooltip-border-radius: var(--sl-border-radius-medium);
      --sl-tooltip-background-color: var(--sl-color-neutral-800);
      --sl-tooltip-color: var(--sl-color-neutral-0);
      --sl-tooltip-font-family: var(--sl-font-sans);
      --sl-tooltip-font-weight: var(--sl-font-weight-normal);
      --sl-tooltip-font-size: var(--sl-font-size-small);
      --sl-tooltip-line-height: var(--sl-line-height-dense);
      --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
      --sl-tooltip-arrow-size: 4px;

      --sl-z-index-drawer: 700;
      --sl-z-index-dialog: 800;
      --sl-z-index-dropdown: 900;
      --sl-z-index-toast: 950;
      --sl-z-index-tooltip: 1000;
    }

    .sl-scroll-lock {
      overflow: hidden !important;
    }

    .sl-toast-stack {
      position: fixed;
      top: 0;
      right: 0;
      z-index: var(--sl-z-index-toast);
      width: 28rem;
      max-width: 100%;
      max-height: 100%;
      overflow: auto;
    }

    .sl-toast-stack sl-alert {
      --box-shadow: var(--sl-shadow-large);
      margin: var(--sl-spacing-medium);
    }
  </style>
`;

class Emenda {
    constructor() {
        // Metadados padronizados para o lexml-eta
        this.dataUltimaModificacao = new Date().toISOString();
        this.aplicacao = '';
        this.versaoAplicacao = '';
        this.modoEdicao = ModoEdicaoEmenda.EMENDA;
        // Metadados específicos de sistemas
        this.metadados = {};
        this.proposicao = new RefProposicaoEmendada();
        this.colegiadoApreciador = new ColegiadoApreciador();
        this.epigrafe = new Epigrafe();
        this.componentes = [new ComponenteEmendado()];
        this.comandoEmenda = new ComandoEmenda();
        this.comandoEmendaTextoLivre = new ComandoEmendaTextoLivre();
        this.justificativa = '';
        this.local = '';
        this.data = new Date().toISOString().replace(/T.*/, ''); // formato “YYYY-MM-DD”
        this.autoria = new Autoria();
        this.opcoesImpressao = new OpcoesImpressao();
        this.anexos = [];
        this.revisoes = [];
    }
}
var ModoEdicaoEmenda;
(function (ModoEdicaoEmenda) {
    ModoEdicaoEmenda["EMENDA"] = "emenda";
    ModoEdicaoEmenda["EMENDA_ARTIGO_ONDE_COUBER"] = "emendaArtigoOndeCouber";
    ModoEdicaoEmenda["EMENDA_TEXTO_LIVRE"] = "emendaTextoLivre";
})(ModoEdicaoEmenda || (ModoEdicaoEmenda = {}));
// Dados da proposição ----------------------------
class RefProposicaoEmendada {
    constructor() {
        this.urn = '';
        this.sigla = '';
        this.numero = '';
        this.ano = '';
        this.ementa = '';
        this.identificacaoTexto = '';
    }
}
// Colegiado apreciador da emenda ----------------------------
class ColegiadoApreciador {
    constructor() {
        this.siglaCasaLegislativa = 'CN';
        this.tipoColegiado = 'Plenário';
    }
}
// Epígrafe ----------------------------
class Epigrafe {
    constructor() {
        this.texto = '';
        this.complemento = '';
    }
}
// Componente emendado -------------------------------
class ComponenteEmendado {
    constructor() {
        this.urn = '';
        this.articulado = true;
        this.dispositivos = new DispositivosEmenda();
    }
}
// Dispositivos da emenda ----------------------------
class DispositivosEmenda {
    constructor() {
        this.dispositivosSuprimidos = [];
        this.dispositivosModificados = [];
        this.dispositivosAdicionados = [];
    }
}
class DispositivoEmenda {
    constructor() {
        this.tipo = ''; // Tipo do dispositivo
        this.id = ''; // ID LexML
    }
}
class DispositivoEmendaSuprimido extends DispositivoEmenda {
}
class DispositivoEmendaModificado extends DispositivoEmenda {
}
class DispositivoEmendaAdicionado extends DispositivoEmendaModificado {
}
class ComandoEmenda {
    constructor() {
        this.comandos = [];
    }
}
class ComandoEmendaTextoLivre {
}
class ItemComandoEmenda {
    constructor(cabecalho, citacao) {
        this.cabecalho = cabecalho;
        this.citacao = citacao;
    }
}
// Autoria ----------------------------
var TipoAutoria;
(function (TipoAutoria) {
    TipoAutoria["NAO_IDENTIFICADO"] = "N\u00E3o identificado";
    TipoAutoria["PARLAMENTAR"] = "Parlamentar";
    TipoAutoria["COMISSAO"] = "Comiss\u00E3o";
    TipoAutoria["CASA_LEGISLATIVA"] = "Casa Legislativa";
})(TipoAutoria || (TipoAutoria = {}));
class Autoria {
    constructor() {
        this.tipo = TipoAutoria.PARLAMENTAR;
        this.imprimirPartidoUF = true;
        this.quantidadeAssinaturasAdicionaisSenadores = 0;
        this.quantidadeAssinaturasAdicionaisDeputados = 0;
        // TODO - Tornar opcional quando formos implementar outro tipo de autoria.
        this.parlamentares = [];
    }
}
class Parlamentar {
    constructor() {
        this.identificacao = '';
        this.nome = '';
        this.sexo = 'M';
        this.siglaPartido = '';
        this.siglaUF = '';
        this.siglaCasaLegislativa = 'CD';
        this.cargo = '';
    }
}
// Opções de impressão -----------------------------
class OpcoesImpressao {
    constructor() {
        this.imprimirBrasao = true;
        this.textoCabecalho = '';
        this.reduzirEspacoEntreLinhas = false;
        this.tamanhoFonte = 14;
    }
}

class CitacaoComandoMultiplaAlteracaoNormaVigente {
    constructor() {
        this.ultimoProcessado = undefined;
        this.adjacentesOmissis = []; // Dispositivos da lista que são adjacentes às omissis modificadas
        this.fecharAspasAposOmissis = false;
    }
    getTexto(dispositivos) {
        dispositivos = dispositivos.filter(d => d.pai.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_SUPRIMIDO || isAgrupadorNaoArticulacao(d.pai));
        this.adjacentesOmissis = this.buscaDispositivosAdjacentesAsOmissis(dispositivos);
        dispositivos.push(...this.adjacentesOmissis);
        dispositivos.sort(DispositivoComparator.compare);
        const arvoreDispositivos = CmdEmdUtil.getArvoreDispositivosDeAlteracaoDeNorma(dispositivos);
        const sb = new StringBuilder();
        this.montaCitacaoComando(sb, arvoreDispositivos);
        const fechaAspas = this.fecharAspasAposOmissis || CmdEmdUtil.isFechaAspas(this.ultimoProcessado);
        if (fechaAspas) {
            const primeiro = [...arvoreDispositivos.keys()][0];
            const cabeca = getDispositivoCabecaAlteracao(primeiro);
            const notaAlteracao = cabeca.notaAlteracao ? ' (' + cabeca.notaAlteracao + ')' : '';
            return sb.toString().replace(/(<\/p>)$/, '”' + notaAlteracao + '$1');
        }
        return sb.toString();
    }
    buscaDispositivosAdjacentesAsOmissis(dispositivos) {
        const ret = new Array();
        for (const d of dispositivos) {
            if (isOmissis(d)) {
                // TODO - Verificar necessidade de tratamento de bloco de alteração com omissis como primeiro elemento.
                //    if (!d.isAbreAspas()) {
                const anterior = CmdEmdUtil.getDispositivoAnteriorDireto(d);
                if (!dispositivos.includes(anterior)) {
                    ret.push(anterior);
                }
                //    }
                if (!CmdEmdUtil.isFechaAspas(d)) {
                    const posterior = CmdEmdUtil.getDispositivoPosteriorDireto(d);
                    if (posterior && !dispositivos.includes(posterior)) {
                        ret.push(posterior);
                    }
                }
            }
        }
        return ret;
    }
    montaCitacaoComando(sb, arvoreDispositivos) {
        const cabeca = [...arvoreDispositivos.keys()][0];
        arvoreDispositivos = arvoreDispositivos.get(cabeca);
        const ehAgrupador = isAgrupadorNaoArticulacao(cabeca);
        const classes = cabeca.tipo.toLowerCase() + (ehAgrupador ? ' agrupador' : '');
        const node = new TagNode('p').addAtributo('class', classes);
        if (isArticulacaoAlteracao(cabeca.pai)) {
            node.add('“');
        }
        node.add(new TagNode('Rotulo').add(cabeca.rotulo));
        if (ehAgrupador) {
            if (cabeca.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
                node.add(CmdEmdUtil.getTextoDoDispositivoOuOmissis(cabeca));
                sb.append(node.toString());
            }
            else {
                sb.append(node.toString());
                const nodeDenominacao = new TagNode('p').addAtributo('class', classes).add(CmdEmdUtil.getTextoDoDispositivoOuOmissis(cabeca));
                sb.append(nodeDenominacao.toString());
            }
        }
        else {
            node.add(CmdEmdUtil.getTextoDoDispositivoOuOmissis(cabeca, true));
            sb.append(node.toString());
        }
        this.ultimoProcessado = cabeca;
        if (arvoreDispositivos.size > 0 && cabeca.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
            this.writeDispositivoTo(sb, arvoreDispositivos);
        }
        if (!isAgrupadorNaoArticulacao(cabeca)) {
            this.writeOmissisFinal(sb, cabeca);
        }
    }
    writeDispositivoTo(sb, arvoreDispositivos) {
        const filhos = [...arvoreDispositivos.keys()];
        filhos.sort(DispositivoComparator.compare);
        for (const d of filhos) {
            const arvoreAtual = arvoreDispositivos.get(d);
            const dispositivoAnterior = CmdEmdUtil.getDispositivoAnteriorDireto(d);
            // -------------------------------------------
            // Omissões antes
            // Trata caso específico de primeiro parágrafo
            if (isArtigo(this.ultimoProcessado) && !isCaput(d)) {
                // Omissis entre o caput e o dispositivo
                if (!isCaput(dispositivoAnterior) && !isOmissis(d)) {
                    sb.append(this.tagOmissisSemRotulo().toString());
                }
            }
            else if (this.ultimoProcessado !== dispositivoAnterior && !isOmissis(d) && dispositivoAnterior.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
                sb.append(this.tagOmissisSemRotulo().toString());
            }
            // -------------------------------------------
            // o dispositivo atual
            if (!isCaput(d)) {
                const ehAgrupador = isAgrupadorNaoArticulacao(d);
                const classes = d.tipo.toLowerCase() + (ehAgrupador ? ' agrupador' : '');
                if (d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
                    const node = new TagNode('p').addAtributo('classe', classes);
                    if (!isOmissis(d)) {
                        node.add(new TagNode('Rotulo').add(d.rotulo));
                    }
                    node.add(CmdEmdUtil.getTextoDoDispositivoOuOmissis(d, true));
                    sb.append(node.toString());
                }
                else if (this.hasFilhosPropostos(arvoreAtual) || this.adjacentesOmissis.includes(d)) {
                    const tag = new TagNode('p').addAtributo('classe', classes);
                    tag.add(new TagNode('Rotulo').add(d.rotulo));
                    tag.add(new TagNode('Omissis'));
                    sb.append(tag.toString());
                }
                else {
                    sb.append(new TagNode('Omissis').toString());
                }
            }
            this.ultimoProcessado = d;
            // -------------------------------------------
            // varre os filhos do dispositivo atual
            if (arvoreAtual && arvoreAtual.size > 0) {
                this.writeDispositivoTo(sb, arvoreAtual);
            }
        }
    }
    tagOmissisSemRotulo() {
        return new TagNode('p').addAtributo('class', 'omissis').add(new TagNode('Omissis'));
    }
    writeOmissisFinal(sb, artigo) {
        if (artigo.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
            return;
        }
        // Busca último nó à direita
        let d = artigo;
        let filhos = CmdEmdUtil.getFilhosEstiloLexML(d);
        while (filhos.length) {
            d = filhos[filhos.length - 1];
            filhos = CmdEmdUtil.getFilhosEstiloLexML(d);
        }
        if (isCaput(d)) {
            d = d.pai;
        }
        if (d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ORIGINAL && (!this.adjacentesOmissis.includes(d) || isOmissis(d))) {
            sb.append(this.tagOmissisSemRotulo().toString());
            this.fecharAspasAposOmissis = true;
        }
        else if (!CmdEmdUtil.isFechaAspas(d)) {
            const proximo = CmdEmdUtil.getDispositivoPosteriorDireto(d);
            if (proximo && isOmissis(proximo)) {
                sb.append(this.tagOmissisSemRotulo().toString());
                this.fecharAspasAposOmissis = true;
            }
        }
    }
    hasFilhosPropostos(arvoreDispositivos) {
        if (!arvoreDispositivos || !arvoreDispositivos.size) {
            return false;
        }
        const arvore = arvoreDispositivos;
        let hasPropostos = false;
        for (const [d, value] of arvore.entries()) {
            if (d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
                hasPropostos = true;
                break;
            }
            if (!hasPropostos && value) {
                hasPropostos = this.hasFilhosPropostos(value);
            }
        }
        return hasPropostos;
    }
}

class CitacaoComandoDeNormaVigente {
    getTexto(alteracao) {
        const sb = new StringBuilder();
        // Identifica dispositivos alterados
        const dispositivos = new Array();
        percorreHierarquiaDispositivos(alteracao, d => {
            if (d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
                dispositivos.push(d);
            }
        });
        dispositivos.sort(DispositivoComparator.compare);
        const qtdDispositivos = dispositivos.length;
        const qtdSemCitacaoObrigatoria = dispositivos.filter(d => d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO || isOmissis(d)).length;
        if (qtdDispositivos - qtdSemCitacaoObrigatoria > 0) {
            this.getCitacoesMultiplas(sb, dispositivos);
        }
        return sb.toString();
    }
    getCitacoesMultiplas(sb, dispositivos) {
        let dispositivosDaCabeca = new Array();
        let cabeca, cabecaAtual;
        for (const d of dispositivos) {
            cabeca = isArtigo(d) || isAgrupadorNaoArticulacao(d) ? d : getArtigo(d);
            if (cabeca !== cabecaAtual) {
                if (dispositivosDaCabeca.length) {
                    this.getCitacaoMultipla(sb, dispositivosDaCabeca);
                }
                dispositivosDaCabeca = [cabeca];
                cabecaAtual = cabeca;
            }
            if (!dispositivosDaCabeca.includes(d)) {
                dispositivosDaCabeca.push(d);
            }
        }
        if (dispositivosDaCabeca.length) {
            this.getCitacaoMultipla(sb, dispositivosDaCabeca);
        }
    }
    getCitacaoMultipla(sb, dispositivos) {
        const cit = new CitacaoComandoMultiplaAlteracaoNormaVigente();
        sb.append(cit.getTexto(dispositivos));
    }
}

class CitacaoComandoMultipla {
    constructor() {
        this.emAlteracao = false;
    }
    getTexto(dispositivos, abreAspas = true, fechaAspas = true) {
        let arvoreDispositivos = CmdEmdUtil.getArvoreDispositivos(dispositivos);
        const sb = new StringBuilder();
        const cabeca = [...arvoreDispositivos.keys()][0];
        arvoreDispositivos = arvoreDispositivos.get(cabeca);
        const ehAgrupador = isAgrupadorNaoArticulacao(cabeca);
        const classes = cabeca.tipo.toLowerCase() + (ehAgrupador ? ' agrupador' : '');
        const node = new TagNode('p').addAtributo('class', classes);
        if (abreAspas) {
            node.add('“');
        }
        if (!isEmenta(cabeca)) {
            node.add(new TagNode('Rotulo').add(cabeca.rotulo));
        }
        if (isAgrupadorNaoArticulacao(cabeca)) {
            sb.append(node.toString());
            const nodeDenominacao = new TagNode('p').addAtributo('class', classes).add(CmdEmdUtil.getTextoDoDispositivoOuOmissis(cabeca));
            sb.append(nodeDenominacao.toString());
        }
        else {
            const texto = CmdEmdUtil.getTextoDoDispositivoOuOmissis(cabeca);
            node.add(isEmenta(cabeca) ? texto.trim() : texto);
            sb.append(node.toString());
        }
        if (arvoreDispositivos.size) {
            this.ultimoProcessado = cabeca;
            this.writeDispositivoTo(sb, arvoreDispositivos);
        }
        this.writeOmissisFinal(sb, cabeca);
        return fechaAspas ? sb.toString().replace(/(<\/p>(?:<\/Alteracao>)?)$/, '”$1') : sb.toString();
    }
    writeDispositivoTo(sb, arvoreDispositivos) {
        var _a;
        const dispositivos = Array.from(arvoreDispositivos.keys());
        dispositivos.sort(DispositivoComparator.compare);
        for (const d of dispositivos) {
            const mapFilhos = arvoreDispositivos.get(d);
            if (isArticulacaoAlteracao(d)) {
                sb.append('<Alteracao>');
                this.emAlteracao = true;
                this.ultimoProcessado = d;
                if (mapFilhos.size) {
                    this.writeDispositivoTo(sb, mapFilhos);
                }
                sb.append('</Alteracao>');
                continue;
            }
            if (isCaput(d)) {
                this.ultimoProcessado = d;
                if (mapFilhos.size) {
                    this.writeDispositivoTo(sb, mapFilhos);
                }
                continue;
            }
            const dispositivoAnterior = CmdEmdUtil.getDispositivoAnteriorDireto(d);
            // -------------------------------------------
            // Omissões antes
            // Trata caso específico de parágrafo modificado sem caput modificado
            if (isArtigo(this.ultimoProcessado) && !isCaput(d)) {
                // Omissis entre o caput e o dispositivo
                if (!isCaput(dispositivoAnterior)) {
                    sb.append(this.tagOmissisSemRotulo().toString());
                }
            }
            else if (this.ultimoProcessado !== dispositivoAnterior &&
                !(this.ultimoProcessado.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO && isAscendente(dispositivoAnterior, this.ultimoProcessado))) {
                sb.append(this.tagOmissisSemRotulo().toString());
            }
            // -------------------------------------------
            // o dispositivo atual
            if (d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL || this.hasFilhosPropostos(mapFilhos)) {
                const dispRotulo = isArtigo(d) ? d.caput : d;
                const rotulo = this.emAlteracao ? (_a = d.rotulo) === null || _a === void 0 ? void 0 : _a.replace('“', '') : d.rotulo;
                const ehAgrupador = isAgrupadorNaoArticulacao(d);
                const classes = d.tipo.toLowerCase() + (ehAgrupador ? ' agrupador' : '');
                let tag = new TagNode('p').addAtributo('class', classes);
                if (isDispositivoCabecaAlteracao(d)) {
                    tag.add('‘');
                }
                tag.add(new TagNode('Rotulo').add(rotulo));
                if (ehAgrupador) {
                    sb.append(tag.toString());
                    tag = new TagNode('p').addAtributo('class', classes);
                }
                tag.add(CmdEmdUtil.getTextoDoDispositivoOuOmissis(dispRotulo));
                if (d.isDispositivoAlteracao && isUltimaAlteracao(d)) {
                    tag.add('’');
                    const cabecaAlteracao = getDispositivoCabecaAlteracao(d);
                    if (cabecaAlteracao.notaAlteracao) {
                        tag.add(' (' + cabecaAlteracao.notaAlteracao + ')');
                    }
                }
                sb.append(tag.toString());
            }
            else {
                sb.append(this.tagOmissisSemRotulo().toString());
            }
            this.ultimoProcessado = d;
            // -------------------------------------------
            // varre os filhos do dispositivo atual
            if (mapFilhos.size) {
                this.writeDispositivoTo(sb, mapFilhos);
            }
        }
    }
    tagOmissisSemRotulo() {
        return new TagNode('p').addAtributo('class', 'omissis').add(new TagNode('Omissis'));
    }
    writeOmissisFinal(sb, cabeca) {
        if (cabeca.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO || isAgrupadorNaoArticulacao(cabeca)) {
            return;
        }
        let d = cabeca;
        // Trata caso específico de alteração de caput de artigo com alteração de norma
        if (cabeca.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO && isArtigo(d) && d.hasAlteracao()) {
            sb.append(this.tagOmissisSemRotulo().toString());
            return;
        }
        // Busca último nó à direita
        while (d.filhos.length) {
            d = d.filhos[d.filhos.length - 1];
        }
        if (d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ORIGINAL && !isDescendenteDeSuprimido(d)) {
            sb.append(this.tagOmissisSemRotulo().toString());
        }
    }
    hasFilhosPropostos(map) {
        if (!map.size) {
            return false;
        }
        let hasPropostos = false;
        for (const [d, mapFilhos] of map.entries()) {
            if (d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ORIGINAL) {
                hasPropostos = true;
                break;
            }
            if (!hasPropostos && mapFilhos.size) {
                hasPropostos = this.hasFilhosPropostos(mapFilhos);
                if (hasPropostos) {
                    break;
                }
            }
        }
        return hasPropostos;
    }
}

class CitacaoComandoDispPrj {
    constructor(articulacao) {
        this.articulacao = articulacao;
    }
    getTexto() {
        const sb = new StringBuilder();
        const dispositivos = this.getDispositivosParaCitacao();
        const qtdDispositivos = dispositivos.length;
        const qtdSuprimidos = dispositivos.filter(d => d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO).length;
        if (qtdDispositivos - qtdSuprimidos > 0) {
            this.getCitacoesMultiplas(sb, dispositivos);
        }
        return sb.toString();
    }
    getDispositivosParaCitacao() {
        const dispositivosEmenda = CmdEmdUtil.getDispositivosNaoOriginais(this.articulacao).filter(d => !(isAgrupadorNaoArticulacao(d) && d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO));
        dispositivosEmenda.sort(DispositivoComparator.compare);
        const ret = new Array();
        dispositivosEmenda.forEach(d => {
            if (isArticulacaoAlteracao(d)) {
                // Entram alterações de norma vigente em dispositivos novos,
                if (d.pai.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                    ret.push(d);
                }
            }
            else if (isDispositivoAlteracao(d)) {
                // dispositivos de alteração de norma vigente em dispositivos novos, e
                if (ret.indexOf(d.pai) >= 0) {
                    ret.push(d);
                }
            }
            else if (!isDescendenteDeSuprimido(d)) {
                // dispositivos que não são de alteração de norma vigente e que não são descendentes de suprimidos.
                ret.push(d);
            }
        });
        return ret;
    }
    getCitacoesMultiplas(sb, dispositivos) {
        // O dispositivo de referência será um artigo ou um agrupador de artigo.
        let listaDispRef = new Array();
        let dispRef;
        let dispRefAtual;
        let noGrupoDeAspas = [];
        dispositivos.forEach(d => {
            dispRef = (isArtigo(d) || isAgrupadorNaoArticulacao(d) || isEmenta(d)) && !isDispositivoAlteracao(d) ? d : getArtigoDoProjeto(d);
            if (dispRef !== dispRefAtual) {
                if (listaDispRef.length) {
                    const abreAspas = dispRefAtual.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO || noGrupoDeAspas.indexOf(dispRefAtual) < 0;
                    const fechaAspas = noGrupoDeAspas.indexOf(dispRef) < 0;
                    if (fechaAspas) {
                        noGrupoDeAspas = [];
                    }
                    sb.append(new CitacaoComandoMultipla().getTexto(listaDispRef, abreAspas, fechaAspas));
                }
                listaDispRef = [];
                listaDispRef.push(dispRef);
                dispRefAtual = dispRef;
            }
            // Preenche noGrupoDeAspas para agrupadores adicionados que não estão no último grupo de aspas
            if (isAgrupador(dispRef) && dispRef.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO && noGrupoDeAspas.indexOf(dispRef) < 0) {
                noGrupoDeAspas = this.getDispositivosMesmoGrupoDeAspas(dispRef);
            }
            if (listaDispRef.indexOf(d) < 0) {
                listaDispRef.push(d);
            }
        });
        if (listaDispRef.length) {
            const abreAspas = noGrupoDeAspas.indexOf(dispRefAtual) < 0;
            sb.append(new CitacaoComandoMultipla().getTexto(listaDispRef, abreAspas, true));
        }
    }
    getDispositivosMesmoGrupoDeAspas(agrupador) {
        const ret = new Array();
        buscaNaHierarquiaDispositivos(agrupador, d => {
            if (!isDispositivoAlteracao(d) && (isAgrupadorNaoArticulacao(d) || isArtigo(d))) {
                if (d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                    ret.push(d);
                    return false;
                }
                return true;
            }
            return false;
        });
        return ret.slice(1);
    }
}

const removeFromArray = (array, element) => {
    array.splice(array.indexOf(element), 1);
};

class RangeDispositivos {
    constructor(disp) {
        this.dispositivos = [];
        if (disp) {
            this.add(disp);
        }
    }
    isSituacao(descricaoSituacao) {
        return !!this.dispositivos.length && this.dispositivos[0].situacao.descricaoSituacao === descricaoSituacao;
    }
    isTipo(nomeTipo) {
        return !!this.dispositivos.length && this.dispositivos[0].tipo === nomeTipo;
    }
    add(dispositivo) {
        if (!this.podeAdicionarAoRange(dispositivo)) {
            return false;
        }
        this.dispositivos.push(dispositivo);
        return true;
    }
    addInicio(dispositivo) {
        this.dispositivos.splice(0, 0, dispositivo);
    }
    isUltimo(dispositivo) {
        return this.dispositivos.indexOf(dispositivo) === this.dispositivos.length - 1;
    }
    getPrimeiro() {
        return this.dispositivos[0];
    }
    getUltimo() {
        return this.dispositivos[this.dispositivos.length - 1];
    }
    getQuantidadeDispositivos() {
        return this.dispositivos.length;
    }
    getAnterior(i) {
        if (i < 1) {
            return undefined;
        }
        return this.dispositivos[i - 1];
    }
    getNumeracaoParaComandoEmenda() {
        let numeracao = this.dispositivos[0].getNumeracaoParaComandoEmenda(this.dispositivos[0]);
        if (this.dispositivos.length > 1) {
            numeracao += ' a ' + this.getUltimo().getNumeracaoParaComandoEmenda(this.getUltimo());
        }
        return numeracao;
    }
    print(comando, ranges) {
        if (this.isRotuloNecessario(ranges)) {
            this.printRotuloInicio(comando, ranges);
        }
        else {
            comando.append(this.dispositivos[0].getNumeracaoParaComandoEmenda(this.dispositivos[0]));
        }
        this.printSeparadorProximoDispositivo(comando, ranges);
        this.printRotuloFimSeExistir(comando);
    }
    printRotuloFimSeExistir(comando) {
        if (this.dispositivos.length >= 2) {
            const d = this.dispositivos[this.dispositivos.length - 1];
            comando.append(d.getNumeracaoParaComandoEmenda(d));
        }
    }
    printSeparadorProximoDispositivo(comando, ranges) {
        const rangePosterior = this.getRangeDispositivosPosterior(ranges);
        if (this.dispositivos.length >= 3) {
            comando.append(' a ');
        }
        else if (this.dispositivos.length === 2 && !rangePosterior) {
            comando.append(' e ');
        }
        else if (this.dispositivos.length > 1 && this.dispositivos.length < 3 && rangePosterior) {
            comando.append(', ');
        }
    }
    printRotuloInicio(comando, range) {
        const rangePosterior = this.getRangeDispositivosPosterior(range);
        if ((this.hasApenasUmDispositivo() && !rangePosterior) || (rangePosterior && !this.isMesmoTipoSituacao(rangePosterior))) {
            comando.append(this.getRotuloCompletoSingular(this.dispositivos[0]));
        }
        else {
            comando.append(this.getRotuloCompletoPlural(this.dispositivos[0]));
        }
    }
    isMesmoTipoSituacao(range) {
        return range.isTipo(this.dispositivos[0].tipo) && range.isSituacao(this.dispositivos[0].situacao.descricaoSituacao);
    }
    hasApenasUmDispositivo() {
        return this.dispositivos.length === 1;
    }
    isRotuloNecessario(ranges) {
        const anterior = this.getRangeDispositivosAnterior(ranges);
        if (!anterior || !anterior.isMesmoTipoSituacao(this)) {
            return true;
        }
        if (this.isSituacao(DescricaoSituacao.DISPOSITIVO_ADICIONADO) && !this.isMesmoPai(anterior)) {
            return true;
        }
        return false;
    }
    isMesmoPai(range) {
        return this.getPrimeiro().pai === range.getPrimeiro().pai;
    }
    getRotuloCompletoSingular(dispositivo) {
        const sb = new StringBuilder();
        if (dispositivo.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
            sb.append(dispositivo.artigoDefinidoSingular);
        }
        else {
            sb.append(' ');
        }
        const rotulo = dispositivo.getNumeracaoComRotuloParaComandoEmenda(dispositivo);
        if (rotulo.endsWith('.')) {
            sb.append(rotulo.substring(0, rotulo.indexOf('.')));
        }
        else {
            sb.append(rotulo);
        }
        return sb.toString();
    }
    getRotuloCompletoPlural(dispositivo) {
        const sb = new StringBuilder();
        if (dispositivo.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
            sb.append(dispositivo.artigoDefinidoPlural);
        }
        else {
            sb.append(' ');
        }
        sb.append(this.getTipoDispositivoPlural(dispositivo));
        sb.append(' ');
        sb.append(dispositivo.getNumeracaoParaComandoEmenda(dispositivo));
        return sb.toString();
    }
    getRangeDispositivosAnterior(ranges) {
        const pos = ranges.indexOf(this);
        if (pos > 0) {
            return ranges[pos - 1];
        }
        return undefined;
    }
    getRangeDispositivosPosterior(ranges) {
        if (ranges.length === 1) {
            return undefined;
        }
        const pos = ranges.indexOf(this);
        if (pos >= 0 && pos < ranges.length - 1) {
            return ranges[pos + 1];
        }
        return undefined;
    }
    getTipoDispositivoPlural(dispositivo) {
        var _a;
        if (dispositivo.tipo === TipoDispositivo.artigo.tipo) {
            return 'arts.';
        }
        else if (dispositivo.tipo === TipoDispositivo.paragrafo.tipo) {
            return '§§';
        }
        return ((_a = dispositivo.descricaoPlural) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) + '';
    }
    podeAdicionarAoRange(atual) {
        if (this.isVazio()) {
            return true;
        }
        const ultimo = this.getUltimo();
        // Mesmo tipo
        if (ultimo.tipo !== atual.tipo) {
            return false;
        }
        // Mesma situação
        if (!CmdEmdUtil.isMesmaSituacaoParaComandoEmenda(ultimo, atual)) {
            return false;
        }
        // Devem ter o mesmo pai, exceto no caso de artigo
        if (!isArtigo(atual) && atual.pai !== ultimo.pai) {
            return false;
        }
        // Atual segue o último
        if (getDispositivoPosteriorMesmoTipo(ultimo) !== atual) {
            return false;
        }
        if (isAgrupadorNaoArticulacao(atual)) {
            return CmdEmdUtil.verificaAgrupadoresAdicionadosEmSequencia(ultimo, atual);
        }
        // Ambos (último e atual) apresentam alteração integral
        // ou ambos não apresentam alteração integral
        if (CmdEmdUtil.isAlteracaoIntegral(ultimo) !== CmdEmdUtil.isAlteracaoIntegral(atual)) {
            return false;
        }
        return true;
    }
    isVazio() {
        return this.dispositivos.length === 0;
    }
    toString() {
        const sb = new StringBuilder();
        this.dispositivos.forEach(d => {
            sb.append(' ');
            sb.append('' + d.rotulo);
        });
        return sb.toString();
    }
    getDispositivos() {
        return this.dispositivos;
    }
    getDispositivo(i) {
        return this.dispositivos[i];
    }
}

class SequenciaRangeDispositivos {
    constructor() {
        this.ranges = new Array();
        this.localizarEmAgrupador = false;
        this.informarCaputDoDispositivo = false;
    }
    isVazio() {
        return this.ranges.length === 0;
    }
    add(range) {
        this.ranges.push(range);
    }
    addInicio(range) {
        this.ranges.unshift(range);
    }
    getQuantidadeRanges() {
        return this.ranges.length;
    }
    getPrimeiroRange() {
        return this.ranges[0];
    }
    getPrimeiroDispositivo() {
        return this.ranges[0].getPrimeiro();
    }
    getUltimoDispositivo() {
        return this.ranges[this.ranges.length - 1].getUltimo();
    }
    getRanges() {
        return this.ranges;
    }
    setRanges(ranges) {
        this.ranges = ranges;
    }
    getRange(i) {
        return this.ranges[i];
    }
    getTextoListaDeDispositivos() {
        const sb = new StringBuilder();
        const qtdRanges = this.ranges.length;
        let posRange = 1;
        for (const range of this.ranges) {
            // Conector
            if (posRange > 1) {
                if (posRange === qtdRanges) {
                    sb.append(' e ');
                }
                else {
                    sb.append(', ');
                }
            }
            sb.append(range.getNumeracaoParaComandoEmenda());
            posRange++;
        }
        return sb.toString();
    }
    static debug(sequencias) {
        const sb = new StringBuilder();
        for (const sequencia of sequencias) {
            sb.append('seq: ' + sequencia);
        }
        console.log(sb);
    }
    toString() {
        return this.ranges.toString();
    }
    remove(nr) {
        removeFromArray(this.ranges, nr);
    }
}

class AgrupadorDispositivosCmdEmd {
    getSequencias(dispositivos) {
        const ranges = this.getRanges(dispositivos);
        const sequencias = this.agrupaRanges(ranges);
        // SequenciaRangeDispositivos.debug(sequencias);
        return sequencias;
    }
    getRanges(dispositivos) {
        let ranges = new Array();
        let range = new RangeDispositivos();
        for (const dispositivo of dispositivos) {
            if (!range.add(dispositivo)) {
                ranges.push(range);
                range = new RangeDispositivos();
                range.add(dispositivo);
            }
        }
        if (!range.isVazio()) {
            ranges.push(range);
        }
        ranges = AgrupadorDispositivosCmdEmd.separaRangesDeDoisDispositivos(ranges);
        return ranges;
    }
    static separaRangesDeDoisDispositivos(ranges) {
        const ret = new Array();
        for (const range of ranges) {
            if (range.getQuantidadeDispositivos() === 2) {
                ret.push(new RangeDispositivos(range.getPrimeiro()));
                ret.push(new RangeDispositivos(range.getUltimo()));
            }
            else {
                ret.push(range);
            }
        }
        return ret;
    }
    separaRangesDeDoisDispositivosEmSequencias(sequencias) {
        for (const s of sequencias) {
            s.setRanges(AgrupadorDispositivosCmdEmd.separaRangesDeDoisDispositivos(s.getRanges()));
        }
    }
    agrupaRanges(ranges) {
        const sequencias = new Array();
        let sequencia = new SequenciaRangeDispositivos();
        for (const range of ranges) {
            if (sequencia.isVazio()) {
                sequencia.add(range);
                sequencias.push(sequencia);
            }
            else {
                if (this.isMesmaSequencia(sequencia, range)) {
                    sequencia.add(range);
                }
                else {
                    sequencia = new SequenciaRangeDispositivos();
                    sequencia.add(range);
                    sequencias.push(sequencia);
                }
            }
        }
        return sequencias;
    }
    isMesmaSequencia(sequencia, range) {
        const dispSequencia = sequencia.getPrimeiroDispositivo();
        const dispRange = range.getUltimo();
        return (CmdEmdUtil.isMesmoTipoParaComandoEmenda(dispSequencia, dispRange) &&
            CmdEmdUtil.isMesmaSituacaoParaComandoEmenda(dispSequencia, dispRange) &&
            (dispSequencia.tipo === TipoDispositivo.artigo.tipo || dispSequencia.pai === dispRange.pai) &&
            dispSequencia.tipo !== TipoDispositivo.omissis.tipo &&
            (!isAgrupador(dispSequencia) || CmdEmdUtil.verificaAgrupadoresAdicionadosEmSequencia(sequencia.getUltimoDispositivo(), range.getPrimeiro())));
    }
    separaDispositivosSeguidosDeOmissis(sequencias) {
        const ret = new Array();
        for (const s of sequencias) {
            ret.push(...this.separaDispositivosSeguidosDeOmissis2(s));
        }
        return ret;
    }
    separaDispositivosSeguidosDeOmissis2(s) {
        const ret = new Array();
        let ns = new SequenciaRangeDispositivos();
        ret.push(ns);
        let nr = new RangeDispositivos();
        ns.add(nr);
        for (const r of s.getRanges()) {
            if (nr.getQuantidadeDispositivos() > 0) {
                nr = new RangeDispositivos();
                ns.add(nr);
            }
            for (const d of r.getDispositivos()) {
                // Identifica dispositivo seguido de omissis
                const posterior = getDispositivoPosterior(d);
                if (posterior && posterior.tipo === TipoDispositivo.omissis.tipo) {
                    // Quebra em sequência com apenas este dispositivo
                    if (this.adicionaouDispositivos(ns, nr)) {
                        if (nr.getQuantidadeDispositivos() === 0) {
                            ns.remove(nr);
                        }
                        ns = new SequenciaRangeDispositivos();
                        ret.push(ns);
                        nr = new RangeDispositivos();
                        ns.add(nr);
                    }
                    ns.informarCaputDoDispositivo = true;
                    nr.add(d);
                    ns = new SequenciaRangeDispositivos();
                    ret.push(ns);
                    nr = new RangeDispositivos();
                    ns.add(nr);
                }
                else {
                    nr.add(d);
                }
            }
        }
        if (nr.getQuantidadeDispositivos() === 0) {
            ns.remove(nr);
        }
        if (ns.getQuantidadeRanges() === 0) {
            removeFromArray(ret, ns);
        }
        this.separaRangesDeDoisDispositivosEmSequencias(ret);
        return ret;
    }
    adicionaouDispositivos(s, r) {
        return s.getQuantidadeRanges() > 1 || r.getQuantidadeDispositivos() > 0;
    }
}

/**
 * Representa um comando de emenda que pode ser combinado com outros.
 */
class CmdEmdCombinavel {
    constructor(dispositivos) {
        this.dispositivos = dispositivos;
    }
    static compare(c1, c2) {
        var _a, _b;
        if (!((_a = c1.dispositivos) === null || _a === void 0 ? void 0 : _a.length)) {
            return 1;
        }
        if (!((_b = c2.dispositivos) === null || _b === void 0 ? void 0 : _b.length)) {
            return -1;
        }
        return DispositivoComparator.compare(c1.dispositivos[0], c2.dispositivos[0]);
    }
}

var ArtigoAntesDispositivo;
(function (ArtigoAntesDispositivo) {
    ArtigoAntesDispositivo[ArtigoAntesDispositivo["NENHUM"] = 0] = "NENHUM";
    ArtigoAntesDispositivo[ArtigoAntesDispositivo["DEFINIDO"] = 1] = "DEFINIDO";
    ArtigoAntesDispositivo[ArtigoAntesDispositivo["DEFINIDO_COM_PREPOSICAO_A"] = 2] = "DEFINIDO_COM_PREPOSICAO_A";
})(ArtigoAntesDispositivo || (ArtigoAntesDispositivo = {}));
var TipoReferenciaAgrupador;
(function (TipoReferenciaAgrupador) {
    TipoReferenciaAgrupador[TipoReferenciaAgrupador["APENAS_ROTULO"] = 0] = "APENAS_ROTULO";
    TipoReferenciaAgrupador[TipoReferenciaAgrupador["DENOMINACAO_DO_AGRUPADOR"] = 1] = "DENOMINACAO_DO_AGRUPADOR";
    TipoReferenciaAgrupador[TipoReferenciaAgrupador["TODO_AGRUPADOR"] = 2] = "TODO_AGRUPADOR";
    TipoReferenciaAgrupador[TipoReferenciaAgrupador["O_AGRUPADOR"] = 3] = "O_AGRUPADOR";
    TipoReferenciaAgrupador[TipoReferenciaAgrupador["ADICAO"] = 4] = "ADICAO";
})(TipoReferenciaAgrupador || (TipoReferenciaAgrupador = {}));
class DispositivosWriterCmdEmd {
    constructor() {
        this.artigoAntesDispositivo = ArtigoAntesDispositivo.NENHUM;
        this.tipoReferenciaAgrupador = TipoReferenciaAgrupador.APENAS_ROTULO;
    }
    getTexto(sequencias, citarPais = true) {
        const sb = new StringBuilder();
        const qtdSequencias = sequencias.length;
        let posSequencia = 1;
        for (const sequencia of sequencias) {
            // Conector (, ou e)
            if (posSequencia > 1) {
                if (posSequencia === qtdSequencias) {
                    sb.append(' e ');
                }
                else {
                    sb.append(', ');
                }
            }
            const primeiroDispSeq = sequencia.getPrimeiroDispositivo();
            const primeiroEhAgrupador = isAgrupadorNaoArticulacao(primeiroDispSeq);
            const referenciarDenominacao = this.tipoReferenciaAgrupador === TipoReferenciaAgrupador.DENOMINACAO_DO_AGRUPADOR && primeiroEhAgrupador;
            const referenciarTodoAgrupador = this.tipoReferenciaAgrupador === TipoReferenciaAgrupador.TODO_AGRUPADOR && primeiroEhAgrupador;
            const referenciarOAgrupador = this.tipoReferenciaAgrupador === TipoReferenciaAgrupador.O_AGRUPADOR && primeiroEhAgrupador && !!primeiroDispSeq.filhos.length;
            const posicionarAgrupadores = primeiroEhAgrupador && this.tipoReferenciaAgrupador === TipoReferenciaAgrupador.ADICAO;
            if (sequencia.informarCaputDoDispositivo) {
                sb.append(this.getReferenciaCaputDoDispositivo(sequencia));
            }
            else {
                // Artigo antes do dispositivo
                sb.append(this.getTextoArtigoAntesSequencia(sequencia, referenciarDenominacao, referenciarTodoAgrupador, referenciarOAgrupador));
            }
            // Rótulo do tipo do dispositivo ou denominação
            if (referenciarDenominacao) {
                sb.append('denominação ' + primeiroDispSeq.pronomePossessivoSingular + ' ');
            }
            else if (referenciarOAgrupador) {
                sb.append('agrupador ');
            }
            sb.append(this.getRotuloTipoDispositivo(sequencia, primeiroEhAgrupador));
            sb.append(' ');
            // Dispositivos
            sb.append(sequencia.getTextoListaDeDispositivos());
            // Pai dos dispositivos
            if (citarPais && !posicionarAgrupadores) {
                sb.append(this.getRotuloPaisSequencia(sequencia));
            }
            // Escreve posição do agrupador. 'antes ou depois de xxx'
            if (posicionarAgrupadores) {
                sb.append(DispositivosWriterCmdEmd.getLocalizacaoAgrupadores(sequencia.getRanges()));
            }
            posSequencia++;
        }
        return sb.toString().replace('ementa ', 'ementa');
    }
    getReferenciaCaputDoDispositivo(sequencia) {
        const sb = new StringBuilder();
        const disp = sequencia.getPrimeiroDispositivo();
        if (disp.tipo === TipoDispositivo.caput.tipo) {
            return this.getTextoArtigoAntesSequencia(sequencia);
        }
        const plural = CmdEmdUtil.isSequenciaPlural(sequencia);
        sb.append(this.getTextoArtigoAntesDispositivo(this.artigoAntesDispositivo, generoMasculino, plural));
        sb.append(' caput ');
        if (sequencia.getRange(0).getQuantidadeDispositivos() === 1) {
            sb.append(disp.pronomePossessivoSingular);
        }
        else {
            sb.append(disp.pronomePossessivoPlural);
        }
        return sb.toString();
    }
    getTextoArtigoAntesSequencia(sequencia, referenciarDenominacao = false, referenciarTodoAgrupador = false, referenciarOAgrupador = false) {
        const primeiro = sequencia.getPrimeiroDispositivo();
        const genero = referenciarDenominacao ? generoFeminino : referenciarOAgrupador ? generoMasculino : primeiro;
        const plural = CmdEmdUtil.isSequenciaPlural(sequencia);
        const textoTodo = referenciarTodoAgrupador ? (primeiro.tipoGenero === 'feminino' ? 'toda ' : 'todo ') : '';
        return textoTodo + this.getTextoArtigoAntesDispositivo(this.artigoAntesDispositivo, genero, plural);
    }
    getTextoArtigoAntesDispositivo(tipo, genero, plural) {
        switch (tipo) {
            case ArtigoAntesDispositivo.DEFINIDO:
                if (plural) {
                    return genero.artigoDefinidoPlural;
                }
                return genero.artigoDefinidoSingular;
            case ArtigoAntesDispositivo.DEFINIDO_COM_PREPOSICAO_A:
                if (plural) {
                    return genero.artigoDefinidoPrecedidoPreposicaoAPlural;
                }
                return genero.artigoDefinidoPrecedidoPreposicaoASingular;
            default:
                return '';
        }
    }
    getRotuloTipoDispositivo(sequencia, iniciarComMaiuscula) {
        const disp = sequencia.getPrimeiroDispositivo();
        const rotulo = DispositivosWriterCmdEmd.getRotuloTipoDispositivo(disp, CmdEmdUtil.isSequenciaPlural(sequencia));
        return iniciarComMaiuscula ? primeiraLetraMaiuscula(rotulo) : rotulo;
    }
    static getRotuloTipoDispositivo(disp, plural) {
        // TODO Verificar melhor forma de identificar que não deve ser impresso o rótulo
        // do tipo do dispositivo antes do parágrafo único e do artigo único.
        if (disp.getNumeracaoParaComandoEmenda(disp).indexOf('único') >= 0) {
            return '';
        }
        if (plural) {
            // Plural
            if (isArtigo(disp)) {
                return 'arts.';
            }
            else if (isParagrafo(disp)) {
                return '§§';
            }
            return String(disp.descricaoPlural).toLocaleLowerCase();
        }
        // Singular
        if (isArtigo(disp)) {
            if (disp.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO && !CmdEmdUtil.isAlteracaoIntegral(disp)) {
                return 'caput do art.';
            }
            return 'art.';
        }
        else if (isParagrafo(disp)) {
            return '§';
        }
        return String(disp.descricao).toLowerCase();
    }
    getRotuloPaisSequencia(sequencia) {
        return this.getRotuloPais(sequencia.getPrimeiroDispositivo(), sequencia.localizarEmAgrupador);
    }
    getRotuloPais(disp, localizarEmAgrupador) {
        var _a;
        let pai;
        const dispOrig = disp;
        if (isAgrupador(disp)) {
            return DispositivosWriterCmdEmd.getRotuloPaisAgrupador(disp);
        }
        const sb = new StringBuilder();
        while (!isDispositivoRaiz(disp)) {
            pai = disp.pai;
            if (pai && isArticulacaoAlteracao(pai)) {
                if (disp.tipo === TipoDispositivo.omissis.tipo) {
                    const anterior = CmdEmdUtil.getDispositivoAnteriorDireto(disp);
                    if (anterior.tipo !== TipoDispositivo.alteracao.tipo) {
                        sb.append('após ');
                        sb.append(anterior.artigoDefinidoSingular);
                        sb.append(anterior.getNumeracaoComRotuloParaComandoEmenda(anterior));
                        sb.append(this.getRotuloPais(anterior, localizarEmAgrupador));
                        return sb.toString();
                    }
                }
                break;
            }
            if (pai && !isDispositivoRaiz(pai) && (!isAgrupador(pai) || (isArtigo(dispOrig) && localizarEmAgrupador))) {
                const dispAlteracao = isDispositivoAlteracao(disp);
                const dispositivoNovoForaDeAlteracao = !dispAlteracao && disp.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO;
                const dispositivoNovoEmAlteracao = dispAlteracao &&
                    !CmdEmdUtil.isTextoOmitido(disp) &&
                    disp.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO &&
                    !DispositivoEmendaUtil.existeNaNormaAlterada(disp);
                // TODO Tratar diferentes situações na norma vigente
                // && StringUtils
                //         .defaultString(disp.getSituacaoNaNormaVigente())
                //         .equals(Dispositivo.ACRESCIMO);
                if (dispositivoNovoForaDeAlteracao || dispositivoNovoEmAlteracao) {
                    sb.append(pai.artigoDefinidoPrecedidoPreposicaoASingular);
                }
                else if (isOmissis(disp)) {
                    const anterior = CmdEmdUtil.getDispositivoAnteriorDireto(disp);
                    const posterior = CmdEmdUtil.getDispositivoPosteriorDireto(disp);
                    if (anterior === pai && posterior && posterior.pai === pai) {
                        // Entre pai e irmão
                        const refIrmao = posterior.pronomePossessivoSingular + ' ' + ((_a = posterior.descricao) === null || _a === void 0 ? void 0 : _a.toLowerCase()) + ' ' + posterior.getNumeracaoParaComandoEmenda(posterior);
                        sb.append('antes ' + refIrmao);
                        sb.append(pai.pronomePossessivoSingular);
                    }
                    else if (!(isArticulacao(anterior) && anterior.pai)) {
                        sb.append('após ');
                        sb.append(anterior.artigoDefinidoSingular);
                        sb.append(anterior.getNumeracaoComRotuloParaComandoEmenda(anterior));
                        sb.append(this.getRotuloPais(anterior, localizarEmAgrupador));
                        return sb.toString();
                    }
                }
                else {
                    sb.append(pai.pronomePossessivoSingular);
                }
                sb.append(pai.getNumeracaoComRotuloParaComandoEmenda(pai));
            }
            else if (isArtigo(disp) && isDispositivoRaiz(pai) && localizarEmAgrupador) {
                const agrupador = CmdEmdUtil.getProximoAgrupador(disp);
                if (agrupador) {
                    sb.append(' antes ');
                    sb.append(agrupador.pronomePossessivoSingular);
                    sb.append(agrupador.getNumeracaoComRotuloParaComandoEmenda(agrupador));
                }
            }
            if (!pai)
                break;
            disp = pai;
        }
        return sb.toString();
    }
    static getRotuloPaisAgrupador(disp) {
        const sb = new StringBuilder();
        let pai = disp.pai;
        while (pai && !isDispositivoRaiz(pai) && !isArticulacao(pai)) {
            sb.append(' ');
            sb.append(pai.pronomePossessivoSingular);
            sb.append(' ');
            sb.append(pai.getNumeracaoComRotuloParaComandoEmenda(pai));
            pai = pai.pai;
        }
        return sb.toString();
    }
    static getLocalizacaoAgrupadores(ranges) {
        const ultimoAgrupador = ranges[ranges.length - 1].getUltimo();
        const dispositivoSeguinte = getDispositivoPosteriorNaSequenciaDeLeitura(ultimoAgrupador, d => d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO && !isCaput(d) && !isArticulacaoAlteracao(d));
        const sb = new StringBuilder();
        sb.append(' ');
        if (dispositivoSeguinte) {
            sb.append('antes ');
            sb.append(dispositivoSeguinte.pronomePossessivoSingular);
            sb.append(' ');
            sb.append(dispositivoSeguinte.getNumeracaoComRotuloParaComandoEmenda(dispositivoSeguinte));
            if (isAgrupadorNaoArticulacao(dispositivoSeguinte)) {
                sb.append(DispositivosWriterCmdEmd.getRotuloPaisAgrupador(dispositivoSeguinte));
            }
        }
        else {
            const primeiroAgrupador = ranges[0].getPrimeiro();
            const dispositvoAnterior = getDispositivoAnteriorNaSequenciaDeLeitura(primeiroAgrupador, d => isArtigo(d) || isAgrupadorNaoArticulacao(d));
            if (dispositvoAnterior) {
                sb.append('após ');
                sb.append(dispositvoAnterior.artigoDefinido);
                sb.append(' ');
                sb.append(dispositvoAnterior.getNumeracaoComRotuloParaComandoEmenda(dispositvoAnterior));
                if (isAgrupadorNaoArticulacao(dispositvoAnterior)) {
                    sb.append(DispositivosWriterCmdEmd.getRotuloPaisAgrupador(dispositvoAnterior));
                }
            }
            else {
                sb.append('!!! localização não encontrada !!!');
            }
        }
        return sb.toString();
    }
}

class CmdEmdAdicaoANormaVigente extends CmdEmdCombinavel {
    constructor(dispositivos, generoNormaAlterada, textoTodos) {
        super(dispositivos);
        this.dispositivos = dispositivos;
        this.generoNormaAlterada = generoNormaAlterada;
        this.textoTodos = textoTodos;
    }
    getTexto(refGenericaProjeto, isPrimeiro, isUltimo) {
        const sb = new StringBuilder();
        const agrupador = new AgrupadorDispositivosCmdEmd();
        const sequencias = agrupador.getSequencias(this.dispositivos);
        // Prefixo
        const plural = this.dispositivos.length > 1;
        if (isPrimeiro) {
            sb.append(plural ? 'Acrescentem-se ' : 'Acrescente-se ');
        }
        else {
            sb.append(isUltimo ? '; e ' : '; ');
            sb.append(plural ? 'acrescentem-se ' : 'acrescente-se ');
        }
        // Dispositivos
        const dispositivosWriter = new DispositivosWriterCmdEmd();
        sb.append(dispositivosWriter.getTexto(sequencias));
        if (isUltimo) {
            const ultimaSequencia = sequencias[sequencias.length - 1];
            const primeiroDaUltimaSequencia = ultimaSequencia.getPrimeiroDispositivo();
            if (isArtigo(primeiroDaUltimaSequencia) || isAgrupadorNaoArticulacao(primeiroDaUltimaSequencia)) {
                sb.append(this.generoNormaAlterada.artigoDefinidoPrecedidoPreposicaoASingular);
            }
            else {
                if (this.textoTodos !== '') {
                    sb.append(this.textoTodos);
                }
                sb.append(' ');
                sb.append(this.generoNormaAlterada.pronomePossessivoSingular);
            }
            sb.append(' ');
        }
        return sb.toString();
    }
}

class CmdEmdModificacaoDeNormaVigente extends CmdEmdCombinavel {
    constructor(dispositivos, generoNormaAlterada, textoTodos) {
        super(dispositivos);
        this.dispositivos = dispositivos;
        this.generoNormaAlterada = generoNormaAlterada;
        this.textoTodos = textoTodos;
    }
    getTexto(refGenericaProjeto, isPrimeiro, isUltimo) {
        // parágrafo único ao art. 15-A da
        const sb = new StringBuilder();
        const agrupador = new AgrupadorDispositivosCmdEmd();
        const sequencias = agrupador.separaDispositivosSeguidosDeOmissis(agrupador.getSequencias(this.dispositivos));
        // Prefixo
        if (isPrimeiro) {
            sb.append('Dê-se nova redação ');
        }
        else {
            sb.append(isUltimo ? '; e ' : '; ');
            sb.append('dê-se nova redação ');
        }
        // Dispositivos
        const dispositivosWriter = new DispositivosWriterCmdEmd();
        dispositivosWriter.artigoAntesDispositivo = ArtigoAntesDispositivo.DEFINIDO_COM_PREPOSICAO_A;
        dispositivosWriter.tipoReferenciaAgrupador = TipoReferenciaAgrupador.DENOMINACAO_DO_AGRUPADOR;
        sb.append(dispositivosWriter.getTexto(sequencias));
        if (isUltimo) {
            if (this.textoTodos !== '') {
                sb.append(this.textoTodos);
            }
            sb.append(' ');
            sb.append(this.generoNormaAlterada.pronomePossessivoSingular);
            sb.append(' ');
        }
        return sb.toString();
    }
}

class CmdEmdSupressaoDeNormaVigente extends CmdEmdCombinavel {
    constructor(dispositivos, alteracao, urnNormaAlterada, generoNormaAlterada, textoTodos) {
        super(dispositivos);
        this.dispositivos = dispositivos;
        this.alteracao = alteracao;
        this.urnNormaAlterada = urnNormaAlterada;
        this.generoNormaAlterada = generoNormaAlterada;
        this.textoTodos = textoTodos;
    }
    getTexto(refGenericaProjeto, isPrimeiro, isUltimo) {
        const sb = new StringBuilder();
        const agrupador = new AgrupadorDispositivosCmdEmd();
        const sequencias = agrupador.getSequencias(this.dispositivos);
        // Prefixo
        const plural = CmdEmdUtil.isSequenciasPlural(sequencias);
        if (isPrimeiro) {
            sb.append(plural ? 'Suprimam-se ' : 'Suprima-se ');
        }
        else {
            if (!isPrimeiro) {
                sb.append(isUltimo ? '; e ' : '; ');
            }
            sb.append(plural ? 'suprimam-se ' : 'suprima-se ');
        }
        // Dispositivos
        const dispositivosWriter = new DispositivosWriterCmdEmd();
        dispositivosWriter.artigoAntesDispositivo = ArtigoAntesDispositivo.DEFINIDO;
        dispositivosWriter.tipoReferenciaAgrupador = TipoReferenciaAgrupador.O_AGRUPADOR;
        sb.append(dispositivosWriter.getTexto(sequencias));
        if (isUltimo) {
            if (this.textoTodos !== '') {
                sb.append(this.textoTodos);
            }
            sb.append(' ');
            sb.append(this.generoNormaAlterada.pronomePossessivoSingular);
            sb.append(' ');
        }
        return sb.toString();
    }
    escreveDispositivoAlterado(sb, d) {
        sb.append(d.pronomePossessivoSingular);
        sb.append(DispositivosWriterCmdEmd.getRotuloTipoDispositivo(d, false));
        sb.append(' ');
        sb.append(d.getNumeracaoParaComandoEmenda(d));
        sb.append(CmdEmdUtil.getRotuloPais(d));
    }
}

/**
 * Comando de emenda que trata comandos de alteração de norma vigente.
 */
class CmdEmdDispNormaVigente {
    constructor(alteracao) {
        this.alteracao = alteracao;
    }
    getTexto(refGenericaProjeto) {
        const sb = new StringBuilder();
        const dispositivos = CmdEmdUtil.getDispositivosNaAlteracaoParaComando(this.alteracao);
        const urnNormaAlterada = this.alteracao.base;
        if (!urnNormaAlterada) {
            return 'Não foi possível gerar o comando de emenda porque a norma alterada não foi informada.';
        }
        const generoNormaAlterada = getGeneroUrnNorma(urnNormaAlterada);
        // let imprimirPrefixoESufixo = false;
        // Combinar comandos
        const comandos = new Array();
        const dispositivosSuprimidos = dispositivos.filter(d => d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO);
        // Consideramos modificados os dispositivos já existentes na proposição e os que foram
        // adicionados pela emenda, mas que já existiam na norma vigente.
        const dispositivosModificados = dispositivos.filter(d => CmdEmdUtil.getDescricaoSituacaoParaComandoEmenda(d) === DescricaoSituacao.DISPOSITIVO_MODIFICADO);
        // Consideramos adicionados os dispositivos adicionados pela emenda e que não existiam na
        // norma vigente
        const dispositivosAdicionados = dispositivos.filter(d => CmdEmdUtil.getDescricaoSituacaoParaComandoEmenda(d) === DescricaoSituacao.DISPOSITIVO_ADICIONADO);
        const dispositivosReferenciados = dispositivosSuprimidos.concat(dispositivosModificados).concat(dispositivosAdicionados);
        const qtdDispositivos = dispositivosReferenciados.length;
        const temDispositivoMasculino = dispositivosReferenciados.reduce((tem, d) => tem || d.tipoGenero === 'masculino', false);
        let textoTodos = '';
        if (qtdDispositivos === 2) {
            textoTodos = temDispositivoMasculino ? ', ambos' : ', ambas';
        }
        else if (qtdDispositivos > 2) {
            textoTodos = temDispositivoMasculino ? ', todos' : ', todas';
        }
        if (dispositivosSuprimidos.length) {
            comandos.push(new CmdEmdSupressaoDeNormaVigente(dispositivosSuprimidos, this.alteracao, urnNormaAlterada, generoNormaAlterada, textoTodos));
        }
        if (dispositivosModificados.length) {
            comandos.push(new CmdEmdModificacaoDeNormaVigente(dispositivosModificados, generoNormaAlterada, textoTodos));
        }
        if (dispositivosAdicionados.length) {
            comandos.push(new CmdEmdAdicaoANormaVigente(dispositivosAdicionados, generoNormaAlterada, textoTodos));
        }
        comandos.sort(CmdEmdCombinavel.compare);
        let i = 0;
        const iUltimo = comandos.length - 1;
        comandos.forEach(cmd => {
            sb.append(cmd.getTexto(refGenericaProjeto, i === 0, i === iUltimo));
            i++;
        });
        // da/à Lei nº 11.340, de 7 de agosto de 2006
        this.escreveLei(sb, urnNormaAlterada);
        const temDispositivoNovo = dispositivos.reduce((tem, d) => tem || d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO, false);
        if (temDispositivoNovo) {
            // , na forma proposta pelo art. 6º do Projeto
            if (textoTodos !== '' && !sb.toString().includes(textoTodos)) {
                sb.append(textoTodos);
            }
            else {
                sb.append(',');
            }
            sb.append(' na forma proposta ');
        }
        else {
            // , como propost(o/a)(s)
            sb.append(', como ');
            this.escreveProposto(sb, dispositivos.filter(d => !CmdEmdUtil.isTextoOmitido(d) || hasFilhos(d)));
        }
        // pelo art. 6º do Projeto
        sb.append(' ');
        this.escreveDispositivoAlterado(sb, this.alteracao.pai);
        sb.append(' ');
        sb.append(refGenericaProjeto.genero.pronomePossessivoSingular);
        sb.append(' ');
        sb.append(refGenericaProjeto.nome);
        if (this.temCitacao(dispositivosModificados, dispositivosAdicionados)) {
            sb.append(', nos termos a seguir:');
        }
        else {
            sb.append('.');
        }
        return CmdEmdUtil.normalizaCabecalhoComandoEmenda(sb.toString());
    }
    temCitacao(dispositivosModificados, dispositivosAdicionados) {
        if (dispositivosModificados.length) {
            return true;
        }
        return !!dispositivosAdicionados.find(d => !isOmissis(d));
    }
    escreveDispositivoAlterado(sb, d) {
        sb.append('pel' + d.artigoDefinidoSingular.trim());
        sb.append(' ');
        sb.append(DispositivosWriterCmdEmd.getRotuloTipoDispositivo(d, false));
        sb.append(' ');
        sb.append(d.getNumeracaoParaComandoEmenda(d));
        sb.append(CmdEmdUtil.getRotuloPais(d));
    }
    escreveLei(sb, urn) {
        sb.append(getNomeExtensoComDataExtenso(urn));
    }
    escreveProposto(sb, dispositivos) {
        const plural = dispositivos.length > 1;
        const feminino = dispositivos.filter(d => d.tipoGenero === generoFeminino.tipoGenero).length === dispositivos.length;
        sb.append('propost' + (feminino ? 'a' : 'o') + (plural ? 's' : ''));
    }
}

class CmdEmdAdicao extends CmdEmdCombinavel {
    constructor(dispositivos) {
        dispositivos = CmdEmdUtil.retiraPrimeirosFilhosAdicionadosAgrupador(dispositivos);
        super(dispositivos);
        this.dispositivos = dispositivos;
    }
    getTexto(refGenericaProjeto, isPrimeiro, isUltimo) {
        // Acrescente-se art. 7º-A ao Capítulo II do Projeto, com a seguinte redação:
        // Acrescentem-se arts. 7º-A e 7º-B ao Capítulo II do Projeto, com a seguinte redação:
        // Acrescente-se art. 2º-A antes do Capítulo I do Projeto, com a seguinte redação:
        // Acrescentem-se art. 2º-A antes do Capítulo I e art. 2º-B ao Capítulo I do Projeto, com a
        // seguinte redação:
        // Acrescentem-se parágrafo único ao art. 1º e parágrafo único ao art. 2º do Projeto, com a
        // seguinte redação:
        // Acrescentem-se §§ 1º e 2º ao art. 1º e §§ 1º e 2º ao art. 2º do Projeto, com a seguinte
        // redação:
        // Acrescentem-se § 0 ao art. 9º, alínea “a” inciso I do § 4º do art. 9º e § 8º ao art. 9º
        // do Projeto, com a seguinte redação:
        // Agrupadores de artigo
        // Acrescentem-se, antes do art. 3º da Medida Provisória, os seguintes Capítulos II e III:
        const sb = new StringBuilder();
        const agrupador = new AgrupadorDispositivosCmdEmd();
        let sequencias = agrupador.getSequencias(this.dispositivos);
        sequencias = this.trataLocalizacaoEmAgrupador(sequencias);
        if (isPrimeiro && isUltimo && this.trataComandoUnicoDeAcrescimoDeAgrupadoresConsecutivos(sb, refGenericaProjeto, sequencias)) {
            return sb.toString();
        }
        // Prefixo
        const plural = CmdEmdUtil.isSequenciasPlural(sequencias);
        if (isPrimeiro) {
            sb.append(plural ? 'Acrescentem-se ' : 'Acrescente-se ');
        }
        else {
            sb.append(isUltimo ? '; e ' : '; ');
            sb.append(plural ? 'acrescentem-se ' : 'acrescente-se ');
        }
        // Dispositivos
        const dispositivosWriter = new DispositivosWriterCmdEmd();
        dispositivosWriter.tipoReferenciaAgrupador = TipoReferenciaAgrupador.ADICAO;
        sb.append(dispositivosWriter.getTexto(sequencias));
        // Sufixo
        if (isUltimo) {
            const ultimaSequencia = sequencias[sequencias.length - 1];
            const primeiroDosUltimos = ultimaSequencia.getPrimeiroDispositivo();
            if (!isArtigo(primeiroDosUltimos) || ultimaSequencia.localizarEmAgrupador) {
                sb.append(refGenericaProjeto.genero.pronomePossessivoSingular);
            }
            else {
                sb.append(refGenericaProjeto.genero.artigoDefinidoPrecedidoPreposicaoASingular);
            }
            sb.append(refGenericaProjeto.nome);
            sb.append(isPrimeiro ? ', com a seguinte redação:' : ', nos termos a seguir:');
        }
        return sb.toString();
    }
    trataLocalizacaoEmAgrupador(sequencias) {
        const ret = new Array();
        for (const sequencia of sequencias) {
            const primeiro = sequencia.getPrimeiroDispositivo();
            if (isArtigo(primeiro)) {
                ret.push(...this.trataLocalizacaoEmAgrupadorSequencia(sequencia));
            }
            else {
                ret.push(sequencia);
            }
        }
        return ret;
    }
    trataLocalizacaoEmAgrupadorSequencia(sequencia) {
        const sequencias = new Array();
        // Junta todos os artigos/agrupadores dos ranges da sequencia em uma única lista
        const dispositivos = new Array();
        for (const range of sequencia.getRanges()) {
            dispositivos.push(...range.getDispositivos());
        }
        // Verifica a necessidade de reagrupar
        let reagrupar = false;
        for (const disp of dispositivos) {
            if (this.isInclusaoDeArtigoProximoAAgrupador(disp)) {
                reagrupar = true;
                break;
            }
        }
        // Se não for necessário repassa a sequência como veio
        if (!reagrupar) {
            sequencias.push(sequencia);
            return sequencias;
        }
        // Vamos reagrupá-los em ranges dentro do mesmo pai
        let s = new SequenciaRangeDispositivos(); // Nova sequência
        s.localizarEmAgrupador = true;
        sequencias.push(s);
        let r = new RangeDispositivos(); // Novo range
        s.add(r);
        let artAnterior = undefined;
        for (const disp of dispositivos) {
            if (!r.isVazio()) {
                if (disp.pai !== artAnterior.pai) {
                    s = new SequenciaRangeDispositivos();
                    s.localizarEmAgrupador = true;
                    sequencias.push(s);
                    r = new RangeDispositivos();
                    s.add(r);
                }
                else if (CmdEmdUtil.getDispositivoIrmaoPosterior(artAnterior) !== disp) {
                    r = new RangeDispositivos();
                    s.add(r);
                }
            }
            r.add(disp);
            artAnterior = disp;
        }
        // Quebra ranges com 2 dispositivos em duas
        for (const s2 of sequencias) {
            s2.setRanges(AgrupadorDispositivosCmdEmd.separaRangesDeDoisDispositivos(s2.getRanges()));
        }
        return sequencias;
    }
    isInclusaoDeArtigoProximoAAgrupador(artigo) {
        return this.isInclusaoNoInicioDeAgrupador(artigo) || this.isInclusaoImediatamenteAntesDeAgrupador(artigo);
    }
    isInclusaoNoInicioDeAgrupador(artigo) {
        // Dentro de agrupador de artigo
        const pai = artigo.pai;
        if (isDispositivoRaiz(pai) || !isAgrupador(pai)) {
            return false;
        }
        // Verifica se ele é o primeiro artigo do pai
        return pai.filhos.indexOf(artigo) === 0;
    }
    isInclusaoImediatamenteAntesDeAgrupador(disp) {
        // TODO Testar também último artigo do projeto seguido de agrupador
        // Verifica se o próximo artigo está no mesmo agrupador
        const pai = disp.pai;
        const irmao = CmdEmdUtil.getDispositivoIrmaoPosterior(disp);
        // Se existe próximo artigo com outro pai, é porque existe um agrupador entre eles
        return !!irmao && pai !== irmao.pai;
    }
    /*
    Caso de acréscimo apenas de agrupadores consecutivos:
  
    Acrescente-se, antes do art. 3º da Medida Provisória, o seguinte Capítulo II:
    Acrescentem-se, antes do art. 3º da Medida Provisória, os seguintes Capítulos II e III:
    Acrescentem-se, antes do art. 3º da Medida Provisória, os seguintes Capítulos II a IV:
    */
    trataComandoUnicoDeAcrescimoDeAgrupadoresConsecutivos(sb, refGenericaProjeto, sequencias) {
        // console.log(sequencias);
        const sequencia = sequencias[0];
        const dispositivo = sequencia.getPrimeiroDispositivo();
        if (sequencias.length === 1 && isAgrupadorNaoArticulacao(dispositivo)) {
            // Verifica apenas uma range ou duas ranges de um dispositivo sequenciais.
            const ranges = sequencia.getRanges();
            if (ranges.length === 1 ||
                (ranges.length === 2 &&
                    ranges[0].getDispositivos().length === 1 &&
                    ranges[1].getDispositivos().length === 1 &&
                    CmdEmdUtil.verificaAgrupadoresAdicionadosEmSequencia(ranges[0].getPrimeiro(), ranges[1].getPrimeiro()))) {
                const plural = CmdEmdUtil.isSequenciasPlural(sequencias);
                sb.append(plural ? 'Acrescentem-se,' : 'Acrescente-se,');
                sb.append(DispositivosWriterCmdEmd.getLocalizacaoAgrupadores(ranges));
                sb.append(refGenericaProjeto.genero.pronomePossessivoSingular);
                sb.append(' ');
                sb.append(refGenericaProjeto.nome);
                sb.append(', ');
                sb.append(dispositivo.artigoDefinido);
                sb.append(plural ? 's seguintes ' : ' seguinte ');
                const dispositivosWriter = new DispositivosWriterCmdEmd();
                sb.append(dispositivosWriter.getTexto(sequencias, false));
                sb.append(':');
                return true;
            }
        }
        return false;
    }
}

class CmdEmdAdicaoDispositivosOndeCouber {
    constructor(dispositivos) {
        this.dispositivos = dispositivos;
    }
    getTexto(refGenericaProjeto) {
        // "Acrescente-se, onde couber, no Projeto o seguinte artigo:"
        // "Acrescentem-se, onde couber, no Projeto os seguintes artigos:"
        var _a, _b, _c, _d;
        if (!this.dispositivos.length) {
            return '';
        }
        const strRefProjeto = refGenericaProjeto.genero.contracaoEmArtigoDefinidoSingular + ' ' + refGenericaProjeto.nome;
        const qtdArtigos = this.dispositivos.filter(d => isArtigo(d) && !isAgrupadorNaoArticulacao(d.pai)).length;
        const qtdAgrupadores = this.dispositivos.filter(d => isAgrupadorNaoArticulacao(d)).length;
        const sb = new StringBuilder();
        const pluralTodos = qtdArtigos + qtdAgrupadores > 1;
        if (pluralTodos) {
            sb.append('Acrescentem-se, onde couber, ' + strRefProjeto + ' '); //os seguintes artigos:';
        }
        else {
            sb.append('Acrescente-se, onde couber, ' + strRefProjeto + ' ');
        }
        const temArtigos = qtdArtigos > 0;
        if (temArtigos) {
            sb.append(pluralTodos ? 'os seguintes ' : 'o seguinte ');
            sb.append(qtdArtigos > 1 ? 'artigos' : 'artigo');
        }
        if (qtdAgrupadores > 0) {
            const agrupador = this.dispositivos.find(d => isAgrupadorNaoArticulacao(d));
            if (temArtigos) {
                sb.append(' e ');
                sb.append(qtdAgrupadores > 1 ? (_a = agrupador.descricaoPlural) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase() : (_b = agrupador.descricao) === null || _b === void 0 ? void 0 : _b.toLocaleLowerCase());
            }
            else if (qtdAgrupadores > 1) {
                sb.append(agrupador.artigoDefinidoPlural + ' seguintes ' + ((_c = agrupador.descricaoPlural) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()));
            }
            else {
                sb.append(agrupador.artigoDefinido + ' seguinte ' + ((_d = agrupador.descricao) === null || _d === void 0 ? void 0 : _d.toLocaleLowerCase()));
            }
        }
        sb.append(':');
        return removeEspacosDuplicados(sb.toString());
    }
}

class CmdEmdModificacao extends CmdEmdCombinavel {
    constructor(dispositivos) {
        super(dispositivos);
        this.dispositivos = dispositivos;
    }
    getTexto(refGenericaProjeto, isPrimeiro, isUltimo) {
        // Dê-se ao art. 7º-A do Capítulo II do Projeto a seguinte redação:
        const sb = new StringBuilder();
        const agrupador = new AgrupadorDispositivosCmdEmd();
        const sequencias = agrupador.getSequencias(this.dispositivos);
        // Prefixo
        if (isPrimeiro) {
            sb.append('Dê-se ');
            if (!isUltimo) {
                sb.append('nova redação ');
            }
        }
        else {
            sb.append(isUltimo ? '; e ' : '; ');
            sb.append('dê-se nova redação ');
        }
        // Dispositivos
        const dispositivosWriter = new DispositivosWriterCmdEmd();
        dispositivosWriter.artigoAntesDispositivo = ArtigoAntesDispositivo.DEFINIDO_COM_PREPOSICAO_A;
        dispositivosWriter.tipoReferenciaAgrupador = TipoReferenciaAgrupador.DENOMINACAO_DO_AGRUPADOR;
        sb.append(dispositivosWriter.getTexto(sequencias).trim());
        // Sufixo
        if (isUltimo) {
            sb.append(' ' + refGenericaProjeto.genero.pronomePossessivoSingular + ' ' + refGenericaProjeto.nome);
            sb.append(isPrimeiro ? ' a seguinte redação:' : ', nos termos a seguir:');
        }
        return sb.toString();
    }
}

class CmdEmdSupressao extends CmdEmdCombinavel {
    constructor(dispositivos) {
        super(dispositivos);
        this.dispositivos = dispositivos;
    }
    getTexto(refGenericaProjeto, isPrimeiro, isUltimo) {
        // Suprima-se o § 1º do art. 9º do Projeto.
        // Suprima-se o inciso I do § 6º do art. 9º do Projeto.
        // Suprimam-se os §§ 1º e 2º do art. 9º do Projeto.
        // Suprimam-se os §§ 1º, 3º e 5º do art. 9º do Projeto.
        // Suprimam-se os §§ 1º a 3º do art. 9º do Projeto.
        // Suprimam-se os §§ 3º, 4º e 7º do art. 9º do Projeto.
        // Suprimam-se os §§ 1º, 3º a 5º e 7º do art. 9º do Projeto.
        // Suprima-se o parágrafo único do art. 8º do Projeto.
        // Suprimam-se os §§ 1º, 3º a 5º e o inciso I do § 6º do art. 9º do Projeto.
        // Suprimam-se o inciso IX do caput do art. 2º, o art. 3º, o parágrafo único do art. 8º e o
        // art. 9º do Projeto.
        const sb = new StringBuilder();
        const agrupador = new AgrupadorDispositivosCmdEmd();
        const sequencias = agrupador.getSequencias(this.dispositivos);
        // Prefixo
        const plural = CmdEmdUtil.isSequenciasPlural(sequencias);
        if (isPrimeiro) {
            sb.append(plural ? 'Suprimam-se ' : 'Suprima-se ');
        }
        else {
            sb.append(isUltimo ? '; e ' : '; ');
            sb.append(plural ? 'suprimam-se ' : 'suprima-se ');
        }
        // Dispositivos
        const dispositivosWriter = new DispositivosWriterCmdEmd();
        dispositivosWriter.artigoAntesDispositivo = ArtigoAntesDispositivo.DEFINIDO;
        dispositivosWriter.tipoReferenciaAgrupador = TipoReferenciaAgrupador.TODO_AGRUPADOR;
        sb.append(dispositivosWriter.getTexto(sequencias));
        // Sufixo
        if (isUltimo) {
            sb.append(' ' + refGenericaProjeto.genero.pronomePossessivoSingular + ' ' + refGenericaProjeto.nome);
            sb.append(isPrimeiro ? '.' : ', nos termos a seguir:');
        }
        return sb.toString();
    }
}

/**
 * Comando de emenda que trata supressão, modificação e adição de dispositivos do projeto.
 */
class CmdEmdDispPrj {
    constructor(dispositivosEmenda) {
        this.dispositivosEmenda = dispositivosEmenda;
    }
    getTexto(refGenericaProjeto) {
        let texto = '';
        const dispositivos = CmdEmdUtil.getDispositivosComando(this.dispositivosEmenda);
        const artigosOndeCouber = dispositivos.filter(d => {
            return d.situacao instanceof DispositivoAdicionado && d.situacao.tipoEmenda === ClassificacaoDocumento.EMENDA_ARTIGO_ONDE_COUBER;
        });
        // Se for caso de artigos onde couber, não pode ter outro tipo de alteração
        if (artigosOndeCouber.length) {
            if (artigosOndeCouber.length < dispositivos.length) {
                throw new Error('Adição de artigos onde couber e outras alterações na mesma emenda.');
            }
            const cmd = new CmdEmdAdicaoDispositivosOndeCouber(artigosOndeCouber);
            return cmd.getTexto(refGenericaProjeto);
        }
        // Combinar comandos
        const comandos = [];
        const dispositivosSuprimidos = dispositivos.filter(d => d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO);
        if (dispositivosSuprimidos.length) {
            comandos.push(new CmdEmdSupressao(dispositivosSuprimidos));
        }
        const dispositivosModificados = dispositivos.filter(d => d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO);
        if (dispositivosModificados.length) {
            comandos.push(new CmdEmdModificacao(dispositivosModificados));
        }
        const dispositivosAdicionados = dispositivos.filter(d => d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO);
        if (dispositivosAdicionados.length) {
            comandos.push(new CmdEmdAdicao(dispositivosAdicionados));
        }
        comandos.sort(CmdEmdCombinavel.compare);
        let i = 0;
        const iUltimo = comandos.length - 1;
        comandos.forEach(cmd => {
            texto += cmd.getTexto(refGenericaProjeto, i === 0, i === iUltimo);
            i++;
        });
        return CmdEmdUtil.normalizaCabecalhoComandoEmenda(texto);
    }
}

class ComandoEmendaBuilder {
    constructor(urn, articulacao) {
        this.urn = urn;
        this.articulacao = articulacao;
    }
    getComandoEmenda() {
        const ret = new ComandoEmenda();
        const dispositivosEmenda = CmdEmdUtil.getDispositivosNaoOriginais(this.articulacao);
        const list = this.getDispositivosRepresentativosDeCadaComando(dispositivosEmenda);
        list.sort(DispositivoComparator.compare);
        if (!list.length) {
            return ret;
        }
        const refProjeto = getRefGenericaProjeto(this.urn);
        list.forEach(d => {
            let cabecalho;
            let citacao;
            let complemento = undefined;
            if (isArticulacao(d)) {
                const cmd = new CmdEmdDispNormaVigente(d);
                cabecalho = cmd.getTexto(refProjeto);
                const cit = new CitacaoComandoDeNormaVigente();
                citacao = cit.getTexto(d);
                complemento = this.getTextoComplementoDispAlteracao(d);
            }
            else {
                const cmd = new CmdEmdDispPrj(dispositivosEmenda);
                cabecalho = cmd.getTexto(refProjeto);
                const cit = new CitacaoComandoDispPrj(this.articulacao);
                citacao = cit.getTexto();
                complemento = this.getTextoComplementoDispProposicao(dispositivosEmenda);
            }
            const item = new ItemComandoEmenda(cabecalho, citacao);
            if (complemento) {
                item.complemento = complemento;
            }
            ret.comandos.push(item);
        });
        if (ret.comandos.length > 1) {
            ret.cabecalhoComum = this.montaCabecalhoComum(refProjeto, ret.comandos.length);
            ret.comandos.forEach((c, i) => {
                c.rotulo = `Item ${i + 1} –`;
            });
        }
        return ret;
    }
    getDispositivosRepresentativosDeCadaComando(dispositivosEmenda) {
        const ret = [];
        let temDispositivoDeProjeto = false;
        dispositivosEmenda.forEach(d => {
            const articulacao = getArticulacao(d);
            // Separa alterações
            if (articulacao && isArticulacaoAlteracao(articulacao)) {
                if (!ret.includes(articulacao) &&
                    articulacao.pai.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO &&
                    articulacao.pai.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_SUPRIMIDO) {
                    ret.push(articulacao);
                }
            }
            else if (!temDispositivoDeProjeto) {
                temDispositivoDeProjeto = true;
                ret.push(d);
            }
        });
        return ret;
    }
    montaCabecalhoComum(refProjeto, qtdItens) {
        return `Dê-se nova redação ${refProjeto.genero.artigoDefinidoPrecedidoPreposicaoASingular} ${refProjeto.nome} nos termos dos itens ${this.listarItens(qtdItens)} a seguir.`;
    }
    listarItens(qtdItens) {
        return Array(qtdItens)
            .fill(0)
            .map((_, i) => i + 1)
            .join(', ')
            .replace(/, (\d+?)$/, ' e $1');
    }
    getTextoComplementoDispProposicao(dispositivosNaoOriginais) {
        // Complemento renumeração
        const adicionadosProposicao = dispositivosNaoOriginais.filter(d => !isDispositivoAlteracao(d) &&
            d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO &&
            d.situacao.tipoEmenda !== ClassificacaoDocumento.EMENDA_ARTIGO_ONDE_COUBER &&
            d.pai.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO);
        if (adicionadosProposicao.length && CmdEmdUtil.verificaNecessidadeRenumeracaoRedacaoFinal(adicionadosProposicao)) {
            return 'Os dispositivos acima propostos e adjacentes deverão ser devidamente renumerados no momento da consolidação das emendas ao texto da proposição pela Redação Final.';
        }
        return undefined;
    }
    getTextoComplementoDispAlteracao(articulacao) {
        // Complemento supressão de agrupador em bloco de alteração
        const temAgrupadorSuprimido = buscaNaHierarquiaDispositivos(articulacao, d => {
            return isAgrupadorNaoArticulacao(d) && d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO;
        });
        if (temAgrupadorSuprimido) {
            return 'O comando de supressão do agrupador não se refere aos dispositivos a ele subordinados.';
        }
        return undefined;
    }
}

class DispositivosEmendaBuilder {
    constructor(tipoEmenda, urn, articulacao) {
        this.tipoEmenda = tipoEmenda;
        this.urn = urn;
        this.articulacao = articulacao;
    }
    getDispositivosEmenda() {
        const dispositivos = new DispositivosEmenda();
        this.preencheDispositivos(dispositivos);
        return dispositivos;
    }
    preencheDispositivos(dispositivosEmenda) {
        const dispositivos = CmdEmdUtil.getDispositivosNaoOriginais(this.articulacao);
        const dispositivosSuprimidos = dispositivos.filter(d => d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_SUPRIMIDO && d.pai.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_SUPRIMIDO);
        if (dispositivosSuprimidos.length) {
            for (const d of dispositivosSuprimidos) {
                const ds = new DispositivoEmendaSuprimido();
                ds.tipo = this.getTipoDispositivoParaEmenda(d);
                ds.id = d.id;
                ds.rotulo = d.rotulo;
                this.addUrnNormaAlteradaSeNecessario(d, ds);
                dispositivosEmenda.dispositivosSuprimidos.push(ds);
            }
        }
        const dispositivosModificados = dispositivos.filter(d => d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_MODIFICADO);
        if (dispositivosModificados.length) {
            for (const d of dispositivosModificados) {
                const dm = new DispositivoEmendaModificado();
                if (isArtigo(d)) {
                    const caput = d.caput;
                    dm.tipo = this.getTipoDispositivoParaEmenda(caput);
                    dm.id = caput.id;
                    dm.texto = this.trataTexto(caput.texto);
                }
                else {
                    dm.tipo = this.getTipoDispositivoParaEmenda(d);
                    dm.id = d.id;
                    dm.texto = this.trataTexto(d.texto);
                }
                dm.rotulo = d.rotulo;
                if (d.isDispositivoAlteracao) {
                    this.preencheAtributosAlteracao(d, dm);
                }
                this.addUrnNormaAlteradaSeNecessario(d, dm);
                dispositivosEmenda.dispositivosModificados.push(dm);
            }
        }
        const dispositivosAdicionados = this.separaAgrupadores(dispositivos.filter(d => d.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO && !this.isDispositivoFilhoDeAdicionado(d)));
        if (dispositivosAdicionados.length) {
            for (const d of dispositivosAdicionados) {
                const da = this.criaDispositivoEmendaAdicionado(d);
                this.addUrnNormaAlteradaSeNecessario(d, da);
                dispositivosEmenda.dispositivosAdicionados.push(da);
            }
        }
    }
    separaAgrupadores(disps) {
        const fSeparacao = (d) => {
            if (d.situacao.descricaoSituacao !== DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                return [];
            }
            if (isAgrupadorNaoArticulacao(d)) {
                return [d, ...d.filhos.flatMap(f => fSeparacao(f))];
            }
            return [d];
        };
        return disps.flatMap(d => fSeparacao(d));
    }
    isDispositivoFilhoDeAdicionado(d) {
        return !!(d.pai.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO ||
            (isCaput(d.pai) && d.pai.pai.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) ||
            (d.isDispositivoAlteracao && isArtigo(d) && d.pai.pai.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO));
    }
    criaDispositivoEmendaAdicionado(d, posicionar = true) {
        var _a, _b, _c;
        const da = new DispositivoEmendaAdicionado();
        da.tipo = this.getTipoDispositivoParaEmenda(d);
        if (!d.id) {
            d.id = buildId(d);
        }
        da.id = d.id;
        if (!isCaput(d) && !isArticulacaoAlteracao(d) && !isOmissis(d)) {
            da.rotulo = d.rotulo;
        }
        if (!isArtigo(d) && !isArticulacaoAlteracao(d)) {
            da.texto = this.trataTexto(d.texto);
        }
        if (posicionar) {
            if (isCaput(d) || isArticulacaoAlteracao(d)) {
                da.idPai = (_a = d.pai) === null || _a === void 0 ? void 0 : _a.id;
            }
            else if (isAgrupadorNaoArticulacao(d)) {
                da.idPosicaoAgrupador = this.calculaPosicaoAgrupador(d);
            }
            else {
                const irmaos = CmdEmdUtil.getFilhosEstiloLexML(d.pai);
                if (d !== irmaos[0]) {
                    da.idIrmaoAnterior = irmaos[irmaos.indexOf(d) - 1].id;
                }
                else if (!isDispositivoRaiz(d.pai)) {
                    da.idPai = (_b = d.pai) === null || _b === void 0 ? void 0 : _b.id;
                }
            }
        }
        if (isArticulacaoAlteracao(d)) {
            const base = d.base;
            if (base) {
                da.urnNormaAlterada = base;
            }
        }
        else if (d.isDispositivoAlteracao) {
            da.existeNaNormaAlterada = (_c = d.situacao) === null || _c === void 0 ? void 0 : _c.existeNaNormaAlterada;
            this.preencheAtributosAlteracao(d, da);
        }
        if (!isAgrupadorNaoArticulacao(d)) {
            // Adiciona filhos
            const filhos = CmdEmdUtil.getFilhosEstiloLexML(d);
            // TODO - As alterações deveriam estar listadas nos getFilhosEstiloLexML (tem que rever todo o código que usa esse método)
            if (isCaput(d) && d.pai.alteracoes) {
                filhos.push(d.pai.alteracoes);
            }
            if (filhos.length) {
                da.filhos = [];
                filhos.forEach(f => {
                    // Pode ocorrer do filho nao ser um dispositivo adicionado no caso de filho de agrupador de artigo.
                    if (isCaput(f) || isArticulacaoAlteracao(f) || f.situacao.descricaoSituacao === DescricaoSituacao.DISPOSITIVO_ADICIONADO) {
                        da.filhos.push(this.criaDispositivoEmendaAdicionado(f, false));
                    }
                });
            }
        }
        return da;
    }
    calculaPosicaoAgrupador(d) {
        const dPos = getDispositivoAnteriorDireto(d);
        if (!dPos || isDispositivoRaiz(dPos)) {
            return undefined;
        }
        if (isAgrupadorNaoArticulacao(dPos) || isArtigo(dPos)) {
            return dPos.id;
        }
        return getArtigo(dPos).id;
    }
    getTipoDispositivoParaEmenda(d) {
        return isArticulacao(d) ? 'Alteracao' : d.tipo;
    }
    preencheAtributosAlteracao(d, dm) {
        if (!isOmissis(d) && dm.texto && dm.texto.indexOf(TEXTO_OMISSIS) >= 0) {
            dm.textoOmitido = true;
        }
        if (isDispositivoCabecaAlteracao(d)) {
            dm.abreAspas = true;
        }
        if (isUltimaAlteracao(d)) {
            dm.fechaAspas = true;
            const cabecaAlteracao = getDispositivoCabecaAlteracao(d);
            dm.notaAlteracao = cabecaAlteracao.notaAlteracao;
        }
    }
    trataTexto(str) {
        if (str.indexOf(TEXTO_OMISSIS) >= 0) {
            return TEXTO_OMISSIS;
        }
        return str.trim();
    }
    addUrnNormaAlteradaSeNecessario(d, de) {
        var _a, _b, _c;
        if (isDispositivoAlteracao(d)) {
            const base = (_c = (_b = (_a = getArticulacao(d)) === null || _a === void 0 ? void 0 : _a.pai) === null || _b === void 0 ? void 0 : _b.alteracoes) === null || _c === void 0 ? void 0 : _c.base;
            if (base) {
                de.urnNormaAlterada = base;
            }
        }
    }
}

const buildJsonixArticulacaoFromProjetoNorma = (articulacaoProjetoNorma) => {
    const articulacao = {
        TYPE_NAME: 'br_gov_lexml__1.Articulacao',
        lXhier: buildTree(articulacaoProjetoNorma, { articulacao: {} }),
    };
    return articulacao;
};
const buildTree = (dispositivo, obj) => {
    var _a;
    let tree;
    if (isAgrupador(dispositivo)) {
        tree = obj.lXhier = [];
    }
    else {
        tree = obj.lXcontainersOmissis = [];
    }
    if (isArtigo(dispositivo)) {
        const node = buildNode(dispositivo.caput);
        buildAlteracaoSeNecessario(dispositivo, node.value);
        tree.push(node);
        buildFilhos((_a = dispositivo.filhos) === null || _a === void 0 ? void 0 : _a.filter(f => !isCaput(f.pai)), tree);
        buildTree(dispositivo.caput, node.value);
    }
    else {
        buildFilhos(dispositivo.filhos, tree);
    }
    return tree;
};
const buildAlteracaoSeNecessario = (dispositivo, node) => {
    var _a, _b, _c;
    if (dispositivo.hasAlteracao()) {
        node['alteracao'] = {
            TYPE_NAME: 'br_gov_lexml__1.Alteracao',
            base: '',
            id: '',
            content: [],
        };
        node.alteracao.base = (_b = (_a = dispositivo.alteracoes) === null || _a === void 0 ? void 0 : _a.base) !== null && _b !== void 0 ? _b : '';
        node.alteracao.id = buildIdAlteracao(dispositivo.caput);
        (_c = dispositivo.alteracoes.filhos) === null || _c === void 0 ? void 0 : _c.forEach(filho => {
            const n = buildNode(filho);
            node.alteracao.content.push(n);
            buildTree(filho, n.value);
        });
    }
};
const buildFilhos = (filhos, tree) => {
    filhos === null || filhos === void 0 ? void 0 : filhos.forEach(filho => {
        const node = buildNode(filho);
        tree.push(node);
        buildTree(filho, node.value);
    });
};
const buildNode = (dispositivo) => {
    const node = {
        name: {
            namespaceURI: 'http://www.lexml.gov.br/1.0',
            localPart: dispositivo.tipo,
            prefix: '',
            key: `{http://www.lexml.gov.br/1.0}${dispositivo.tipo}`,
            string: `{http://www.lexml.gov.br/1.0}${dispositivo.tipo}`,
        },
        value: {
            TYPE_NAME: 'br_gov_lexml__1.DispositivoType',
        },
    };
    buildDispositivo(dispositivo, node.value);
    return node;
};
const buildDispositivo = (dispositivo, value) => {
    value['href'] = isCaput(dispositivo) ? buildHref(dispositivo.pai) + '_' + buildHref(dispositivo) : buildHref(dispositivo);
    value['id'] = buildId(dispositivo);
    if (isDispositivoCabecaAlteracao(dispositivo)) {
        value['abreAspas'] = 's';
        value.rotulo = dispositivo.rotulo;
    }
    else if (!isCaput(dispositivo) && !isOmissis(dispositivo)) {
        value.rotulo = dispositivo.rotulo;
    }
    const dispositivoTemp = isCaput(dispositivo) ? dispositivo.pai : dispositivo;
    if (isDispositivoAlteracao(dispositivoTemp) && isUltimaAlteracao(dispositivoTemp)) {
        value['fechaAspas'] = 's';
        const cabecaAlteracao = getDispositivoCabecaAlteracao(dispositivoTemp);
        value['notaAlteracao'] = cabecaAlteracao.notaAlteracao || 'NR';
    }
    if (isAgrupador(dispositivo)) {
        value.nomeAgrupador = {
            TYPE_NAME: 'br_gov_lexml__1.GenInline',
            content: buildContent(dispositivo),
        };
    }
    else if (!isArtigo(dispositivo)) {
        if (dispositivo.texto === TEXTO_OMISSIS) {
            value['textoOmitido'] = 's';
        }
        else {
            value['p'] = [{ TYPE_NAME: 'br_gov_lexml__1.GenInline', content: buildContent(dispositivo) }];
        }
    }
};
const buildContent = (dispositivo) => {
    const regex = /<a[^>]+href="(.*?)"[^>]*>(.*?)<\/a>/gi;
    const result = [];
    const ocorrencias = dispositivo.texto.match(regex);
    if (!ocorrencias) {
        const fim = dispositivo.texto.indexOf('” (NR)');
        result.push(dispositivo.texto.substring(0, fim === -1 ? undefined : fim));
    }
    else if (!dispositivo.texto.startsWith(ocorrencias[0])) {
        result.push(dispositivo.texto.substring(0, dispositivo.texto.indexOf(ocorrencias[0])));
    }
    ocorrencias === null || ocorrencias === void 0 ? void 0 : ocorrencias.forEach((m, i) => {
        var _a, _b;
        const http = m.match(regex) ? m : '';
        result.push(buildSpan(http !== null && http !== void 0 ? http : ''));
        const from = ((_a = dispositivo.texto) === null || _a === void 0 ? void 0 : _a.indexOf(m)) + m.length;
        if (from < dispositivo.texto.length - 1) {
            const to = ocorrencias[i + 1] ? dispositivo.texto.indexOf(ocorrencias[i + 1]) : dispositivo.texto.length;
            result.push((_b = dispositivo.texto
                .substring(from, to)) === null || _b === void 0 ? void 0 : _b.replace(/strong>/gi, 'b>').replace(/em>/gi, 'i>'));
        }
    });
    return result;
};
const buildSpan = (m) => {
    var _a;
    const resultHref = m.match(/href="(.*?)"*>/i);
    const href = resultHref && resultHref[1] ? resultHref[1] : '';
    const contentHref = m.match(/<a[^>]+href=".*?"[^>]*>(.*?)<\/a>/);
    const content = contentHref && contentHref[1] ? [(_a = contentHref[1]) === null || _a === void 0 ? void 0 : _a.trim()] : [''];
    return {
        name: {
            namespaceURI: 'http://www.lexml.gov.br/1.0',
            localPart: 'span',
            prefix: '',
            key: '{http://www.lexml.gov.br/1.0}span',
            string: '{http://www.lexml.gov.br/1.0}span',
        },
        value: {
            TYPE_NAME: 'br_gov_lexml__1.GenInline',
            href,
            content,
        },
    };
};

const DOCUMENTO_PADRAO = {
    name: {
        namespaceURI: 'http://www.lexml.gov.br/1.0',
        localPart: 'LexML',
        prefix: '',
        key: '{http://www.lexml.gov.br/1.0}LexML',
        string: '{http://www.lexml.gov.br/1.0}LexML',
    },
    value: {
        TYPE_NAME: 'br_gov_lexml__1.LexML',
        metadado: {
            TYPE_NAME: 'br_gov_lexml__1.Metadado',
            identificacao: {
                TYPE_NAME: 'br_gov_lexml__1.Identificacao',
                urn: '',
            },
        },
        projetoNorma: {
            TYPE_NAME: 'br_gov_lexml__1.ProjetoNorma',
            norma: {
                TYPE_NAME: 'br_gov_lexml__1.HierarchicalStructure',
                parteInicial: {
                    TYPE_NAME: 'br_gov_lexml__1.ParteInicial',
                    epigrafe: {
                        TYPE_NAME: 'br_gov_lexml__1.GenInline',
                        id: 'epigrafe',
                        content: [''],
                    },
                    ementa: {
                        TYPE_NAME: 'br_gov_lexml__1.GenInline',
                        id: 'ementa',
                        content: [''],
                    },
                    preambulo: {
                        TYPE_NAME: 'br_gov_lexml__1.TextoType',
                        id: 'preambulo',
                        p: [
                            {
                                TYPE_NAME: 'br_gov_lexml__1.GenInline',
                                content: [''],
                            },
                        ],
                    },
                },
                articulacao: {
                    TYPE_NAME: 'br_gov_lexml__1.Articulacao',
                    lXhier: [
                        {
                            name: {
                                namespaceURI: 'http://www.lexml.gov.br/1.0',
                                localPart: 'Artigo',
                                prefix: '',
                                key: '{http://www.lexml.gov.br/1.0}Artigo',
                                string: '{http://www.lexml.gov.br/1.0}Artigo',
                            },
                            value: {
                                TYPE_NAME: 'br_gov_lexml__1.DispositivoType',
                                id: 'art1',
                                rotulo: 'Art. 1º',
                                lXcontainersOmissis: [
                                    {
                                        name: {
                                            namespaceURI: 'http://www.lexml.gov.br/1.0',
                                            localPart: 'Caput',
                                            prefix: '',
                                            key: '{http://www.lexml.gov.br/1.0}Caput',
                                            string: '{http://www.lexml.gov.br/1.0}Caput',
                                        },
                                        value: {
                                            TYPE_NAME: 'br_gov_lexml__1.DispositivoType',
                                            id: 'art1_cpt',
                                            p: [
                                                {
                                                    TYPE_NAME: 'br_gov_lexml__1.GenInline',
                                                    content: [''],
                                                },
                                            ],
                                        },
                                    },
                                ],
                            },
                        },
                    ],
                },
            },
        },
    },
};

let LexmlEtaComponent = class LexmlEtaComponent extends connect(rootStore)(s) {
    constructor() {
        super(...arguments);
        this.lexmlEtaConfig = new LexmlEmendaConfig();
        this.modo = '';
        this.urn = '';
        this._timerLoadEmenda = 0;
    }
    createRenderRoot() {
        return this;
    }
    inicializarEdicao(modo, urn, projetoNorma, preparaAberturaEmenda = false) {
        this.modo = modo;
        this.urn = urn;
        if (projetoNorma) {
            this.projetoNorma = projetoNorma;
        }
        this.loadProjetoNorma(preparaAberturaEmenda);
        document.querySelector('lexml-eta-articulacao')['style'].display = 'block';
    }
    getDispositivosEmenda() {
        if (this.modo !== ClassificacaoDocumento.EMENDA && this.modo !== ClassificacaoDocumento.EMENDA_ARTIGO_ONDE_COUBER) {
            return undefined;
        }
        const articulacao = rootStore.getState().elementoReducer.articulacao;
        return new DispositivosEmendaBuilder(this.modo, this.urn, articulacao).getDispositivosEmenda();
    }
    setDispositivosERevisoesEmenda(dispositivosEmenda, revisoes) {
        this.revisoes = revisoes;
        if (dispositivosEmenda) {
            this.dispositivosEmenda = dispositivosEmenda;
            this.loadEmenda();
        }
    }
    getComandoEmenda() {
        const articulacao = rootStore.getState().elementoReducer.articulacao;
        return new ComandoEmendaBuilder(this.urn, articulacao).getComandoEmenda();
    }
    getProjetoAtualizado() {
        const out = { ...this.projetoNorma };
        const articulacaoAtualizada = buildJsonixArticulacaoFromProjetoNorma(rootStore.getState().elementoReducer.articulacao);
        out.value.projetoNorma[out.value.projetoNorma.norma ? 'norma' : 'projeto'].articulacao.lXhier = articulacaoAtualizada.lXhier;
        return out;
    }
    loadProjetoNorma(preparaAberturaEmenda) {
        var _a, _b;
        let documento;
        if (!this.projetoNorma) {
            this.projetoNorma = DOCUMENTO_PADRAO;
        }
        if (this.modo === ModoEdicaoEmenda.EMENDA_ARTIGO_ONDE_COUBER) {
            documento = buildProjetoNormaFromJsonix(DOCUMENTO_PADRAO, true);
            const artigo = documento.articulacao.artigos[0];
            artigo.rotulo = 'Art.';
            artigo.numero = '1';
            artigo.id = 'art1';
            const situacao = new DispositivoAdicionado();
            situacao.tipoEmenda = ClassificacaoDocumento.EMENDA_ARTIGO_ONDE_COUBER;
            artigo.situacao = situacao;
            // Se estiver abrindo emenda, remove artigo inicial do documento padrão
            if (preparaAberturaEmenda) {
                documento.articulacao.removeFilho(documento.articulacao.filhos[0]);
            }
        }
        else {
            documento = buildProjetoNormaFromJsonix(this.projetoNorma, this.modo === ClassificacaoDocumento.EMENDA);
        }
        documento.urn = this.urn;
        (_b = (_a = document.querySelector('lexml-emenda')) === null || _a === void 0 ? void 0 : _a.querySelector('sl-tab')) === null || _b === void 0 ? void 0 : _b.click();
        rootStore.dispatch(openArticulacaoAction(documento.articulacao, this.modo));
    }
    loadEmenda() {
        if (this.dispositivosEmenda) {
            clearInterval(this._timerLoadEmenda);
            this._timerLoadEmenda = window.setTimeout(() => {
                rootStore.dispatch(aplicarAlteracoesEmendaAction.execute(this.dispositivosEmenda, this.revisoes));
            }, 1000);
        }
    }
    render() {
        return $ `
      ${shoelaceLightThemeStyles}
      <style>
        #gtx-trans {
          display: block;
        }

        lexml-eta-articulacao {
          display: none;
          height: 100%;
        }

        lexml-eta-articulacao:focus {
          outline: 0;
          border: 0px solid #f1f1f1;
          -webkit-box-shadow: 0px;
          box-shadow: none;
        }
      </style>
      <lexml-eta-articulacao .lexmlEtaConfig=${this.lexmlEtaConfig}></lexml-eta-articulacao>
    `;
    }
};
__decorate([
    e$3({ type: Object })
], LexmlEtaComponent.prototype, "lexmlEtaConfig", void 0);
LexmlEtaComponent = __decorate([
    n$1('lexml-eta')
], LexmlEtaComponent);

const incluirParlamentar = (parlamentares, parlamentar) => {
    const novoArray = [...parlamentares];
    novoArray.push(parlamentar);
    return novoArray;
};
const excluirParlamentar = (parlamentares, index) => {
    const novoArray = [...parlamentares];
    novoArray.splice(index, 1);
    return novoArray;
};
const moverParlamentar = (parlamentares, index, deslocamento) => {
    const newIndex = index + deslocamento;
    if (newIndex < 0 || newIndex >= parlamentares.length) {
        return parlamentares;
    }
    const novoArray = [...parlamentares];
    novoArray.splice(newIndex, 0, novoArray.splice(index, 1)[0]);
    return novoArray;
};

const autoriaCss = r$2 `
  sl-radio-group::part(base) {
    background-color: var(--sl-color-gray-100);
    box-shadow: var(--sl-shadow-x-large);
    padding: 20px 20px;
  }
  sl-radio-group::part(label) {
    background-color: var(--sl-color-gray-200);
    font-weight: bold;
    border-radius: 5px;
    border: 1px solid var(--sl-color-gray-300);
    padding: 2px 5px;
    box-shadow: var(--sl-shadow-small);
  }

  legend {
    font-weight: normal;
  }

  .lexml-autoria {
    display: block;
    font-size: var(--sl-font-size-small);
    font-family: var(--sl-font-sans);
    max-width: 700px;
  }

  .lexml-autocomplete {
    width: 100%;
  }

  .grid-autoria {
    display: grid;
    grid-template-columns: 3fr 2fr 250px;
  }

  .autoria-grid {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    width: 100%;
    padding: 0 0 4px 0;
    flex-wrap: wrap;
  }

  .autoria-grid--col1 {
    flex: none;
    order: 0;
    flex-grow: 1;
  }

  .autoria-grid--col2 {
    flex: none;
    order: 1;
    flex-grow: 1;
  }

  .autoria-grid--col3 {
    flex: none;
    order: 2;
    flex-grow: 1;
  }

  [class^='autoria-grid--'] {
    margin: 0px 2px;
  }

  .autoria-grid:first-child {
    padding: 0 0 2px 0;
  }

  .autoria-header {
    width: 180px;
    padding: 0px 2px;
  }

  .autoria-buttons {
    width: 124px;
    text-align: right;
  }

  .autoria-input {
    width: 100%;
    margin: 0px;
  }

  .autoria-button {
    background-color: white;
    border: 1px solid #555;
    border-radius: 2px;
    padding: 2px 4px;
    cursor: pointer;
  }

  .autoria-label {
    display: none;
  }

  .autoria-icon {
    background-color: #555;
  }

  .icon-up {
    display: block;
    width: 24px;
    height: 24px;
    -webkit-mask-position-y: 1px;
    -webkit-mask-image: url("data:image/svg+xml;utf8, <svg xmlns='http://www.w3.org/2000/svg' class='autoria-iccm' viewBox='0 0 16 16'><path d='m7.247 4.86-4.796 5.481c-.566.647-.106 1.659.753 1.659h9.592a1 1 0 0 0 .753-1.659l-4.796-5.48a1 1 0 0 0-1.506 0z'/></svg>");
    mask-image: url("data:image/svg+xml;utf8, <svg xmlns='http://www.w3.org/2000/svg' class='autoria-iccm' viewBox='0 0 16 16'><path d='m7.247 4.86-4.796 5.481c-.566.647-.106 1.659.753 1.659h9.592a1 1 0 0 0 .753-1.659l-4.796-5.48a1 1 0 0 0-1.506 0z'/></svg>");
  }

  .icon-down {
    display: block;
    width: 24px;
    height: 24px;
    -webkit-mask-position-y: 1px;
    -webkit-mask-image: url("data:image/svg+xml;utf8, <svg xmlns='http://www.w3.org/2000/svg' class='autoria-iccm' viewBox='0 0 16 16'><path d='M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/></svg>");
    mask-image: url("data:image/svg+xml;utf8, <svg xmlns='http://www.w3.org/2000/svg' class='autoria-iccm' viewBox='0 0 16 16'><path d='M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/></svg>");
  }

  .icon-delete {
    display: block;
    width: 24px;
    height: 24px;
    -webkit-mask-position-y: 1px;
    -webkit-mask-image: url("data:image/svg+xml;utf8, <svg xmlns='http://www.w3.org/2000/svg' class='autoria-iccm' viewBox='0 0 16 16'><path d='M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z'/><path fill-rule='evenodd' d='M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z'/></svg>");
    mask-image: url("data:image/svg+xml;utf8, <svg xmlns='http://www.w3.org/2000/svg' class='autoria-iccm' viewBox='0 0 16 16'><path d='M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z'/><path fill-rule='evenodd' d='M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z'/></svg>");
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }

  .assinaturas-adicionais {
    padding-top: 10px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    vertical-align: center;
    gap: 10px;
  }

  .assinaturas-adicionais div {
    padding-top: 5px;
  }

  .assinaturas-adicionais .autoria-input {
    display: block;
    max-width: 400px;
  }

  @media (max-width: 576px) {
    .autoria-grid {
      flex-direction: column;
    }

    .autoria-labels {
      display: none;
    }
    .autoria-label {
      display: block;
    }

    .autoria-buttons {
      width: calc(100% - 3px);
    }

    .autoria-input {
      width: calc(100% - 2px);
    }

    [class^='autoria-grid--'] {
      width: 100%;
      padding: 2px 0;
    }
  }
`;

const parlamentarVazio = new Parlamentar();
// Decorator para aguardar fim da validação para executar um método
function executarAposValidacao(interval = 200) {
    return function (_target, key, descriptor) {
        return {
            get() {
                const wrapperFn = (...args) => {
                    let timer = 0;
                    const executarMetodo = () => {
                        clearInterval(timer);
                        if (this['_isProcessandoValidacao']) {
                            timer = window.setTimeout(() => executarMetodo(), interval);
                            return;
                        }
                        descriptor.value.apply(this, args);
                    };
                    executarMetodo();
                };
                Object.defineProperty(this, key, { value: wrapperFn, configurable: true, writable: true });
                return wrapperFn;
            },
        };
    };
}
let AutoriaComponent = class AutoriaComponent extends s {
    constructor() {
        super(...arguments);
        this._nomesAutocomplete = [];
        this._podeIncluirParlamentar = true;
        this._parlamentaresAutocomplete = [];
        this._exibirTemplateTipoAutoria = false; // variável temporária
        this._timerValidacao = 0;
        this._isProcessandoValidacao = false;
        this.timerEmitirEventoOnChange = 0;
        this._isProcessandoMovimentacao = false;
        this._lastIndexAutoCompleted = -1;
    }
    set parlamentares(value) {
        const oldValue = this._parlamentaresAutocomplete;
        this._parlamentaresAutocomplete = value;
        this._nomesAutocomplete = value.map(p => p.nome);
        this.requestUpdate('parlamentares', oldValue);
    }
    get parlamentares() {
        return this._parlamentaresAutocomplete;
    }
    set autoria(value) {
        const oldValue = this._autoriaOriginal;
        this._autoriaOriginal = value;
        this._autoria = value ? { ...value, parlamentares: [...value.parlamentares] } : new Autoria();
        if (!this._autoria.parlamentares.length) {
            this._autoria.parlamentares = [{ ...parlamentarVazio }];
        }
        this._podeIncluirParlamentar = this._isAllAutoresOk();
        this.requestUpdate('autoria', oldValue);
    }
    get autoria() {
        return this._autoriaOriginal;
    }
    getAutoriaAtualizada() {
        return { ...this._autoria, parlamentares: this._autoria.parlamentares.filter(p => p.identificacao) };
    }
    render() {
        var _a, _b;
        return $ `
      <sl-radio-group label="Autoria" fieldset class="lexml-autoria">
        ${this._getTipoAutoriaTemplate()}
        <div class="autoria-list">${this._getParlamentaresTemplate()}</div>
        <sl-button id="btnNovoParlamentar" variant="primary" @click=${this._incluirNovoParlamentar} ?disabled=${!this._podeIncluirParlamentar}>
          Incluir ${((_a = this._autoria) === null || _a === void 0 ? void 0 : _a.parlamentares.length) ? 'outro' : ''} parlamentar
        </sl-button>

        ${this._getAssinaturasAdicionaisTemplate()}

        <div class="assinaturas-adicionais">
          <label>
            <input type="checkbox" id="chk-exibir-partido-uf" ?checked=${(_b = this._autoria) === null || _b === void 0 ? void 0 : _b.imprimirPartidoUF} @input=${(ev) => this._atualizarExibirPartidoUF(ev)} />
            Imprimir partido e UF para os signatários
          </label>
        </div>
      </sl-radio-group>
    `;
    }
    _getTipoAutoriaTemplate() {
        var _a, _b;
        return !this._exibirTemplateTipoAutoria
            ? $ `<div></div>`
            : $ `
          <fieldset class="autoria-label--tipo-autoria">
            <legend>Tipo de autoria</legend>
            <div class="control">
              <label class="radio">
                <input type="radio" id="opt-parlamentar" name="tipoAutoria" value="Parlamentar" ?checked=${((_a = this._autoria) === null || _a === void 0 ? void 0 : _a.tipo) === 'Parlamentar'} />
                Parlamentar
              </label>
              <label class="radio">
                <input type="radio" id="opt-comissao" name="tipoAutoria" value="Comissão" ?checked=${((_b = this._autoria) === null || _b === void 0 ? void 0 : _b.tipo) === 'Comissão'} />
                Comissão
              </label>
            </div>
          </fieldset>
        `;
    }
    _getParlamentaresTemplate() {
        var _a;
        return $ `
      <div class="autoria-grid autoria-labels">
        <div class="autoria-grid--col1"><div class="autoria-header">Parlamentar</div></div>
        <div class="autoria-grid--col2"><div class="autoria-header">Cargo</div></div>
        <div class="autoria-grid--col3"><div class="autoria-buttons"></div></div>
      </div>
      ${(_a = this._autoria) === null || _a === void 0 ? void 0 : _a.parlamentares.map((_, index) => this._getParlamentarAutocompleteTemplate(index))}
    `;
    }
    _getParlamentarAutocompleteTemplate(index) {
        var _a;
        return $ `
      <div class="autoria-grid">
        <div class="autoria-grid--col1">
          <label for="defaultInput" class="autoria-label">Parlamentar</label>
          <lexml-autocomplete
            class="lexml-autocomplete"
            .items=${this._nomesAutocomplete}
            value=${this._autoria.parlamentares[index].nome}
            @input=${(ev) => this._validarNomeParlamentar(ev, index)}
            @blur=${(ev) => this._validarNomeParlamentar(ev, index)}
            @autocomplete=${(ev) => this._atualizarParlamentar(ev, index)}
            @keyup=${(ev) => this._handleKeyUp(ev, index)}
            @click=${this._handleClickAutoComplete}
          ></lexml-autocomplete>
        </div>

        <div class="autoria-grid--col2">
          <label for="tex-cargo" class="autoria-label">Cargo</label>
          <sl-input
            type="text"
            id="tex-cargo"
            placeholder="ex: Presidente da Comissão ..., Líder do ..."
            class="autoria-input"
            aria-label="Cargo"
            size="small"
            .value=${(_a = this._autoria.parlamentares[index].cargo) !== null && _a !== void 0 ? _a : ''}
            @input=${(ev) => this._atualizarCargo(ev, index)}
            @keyup=${(ev) => this._handleKeyUp(ev, index)}
          ></sl-input>
        </div>

        <div class="autoria-grid--col3">
          <div class="autoria-buttons">
            <sl-button
              id="paraBaixo"
              size="small"
              aria-label="Para baixo"
              title="Para baixo"
              @click=${() => this._moverParlamentar(index, 1)}
              .disabled=${index === this._autoria.parlamentares.length - 1 ? true : false}
            >
              <sl-icon name="arrow-down"></sl-icon>
            </sl-button>
            <sl-button
              id="paraCima"
              size="small"
              aria-label="Para cima"
              title="Para cima"
              @click=${() => this._moverParlamentar(index, -1)}
              .disabled=${index === 0 ? true : false}
            >
              <sl-icon name="arrow-up"></sl-icon>
            </sl-button>
            <sl-button
              id="excluir"
              size="small"
              aria-label="Excluir"
              title="Excluir"
              @click=${() => this._excluirParlamentar(index)}
              .disabled=${this._autoria.parlamentares.length === 1 ? true : false}
            >
              <sl-icon name="trash"></sl-icon>
            </sl-button>
          </div>
        </div>
      </div>
    `;
    }
    _getAssinaturasAdicionaisTemplate() {
        var _a, _b, _c, _d;
        return $ `
      <div class="assinaturas-adicionais">
        <sl-input
          label="Quantidade de assinaturas adicionais de Senadores"
          type="number"
          id="num-assinaturas-adicionais-senadores"
          class="autoria-input"
          aria-label="Assinaturas Adicionais Senadores"
          size="small"
          .value=${(_b = (_a = this._autoria) === null || _a === void 0 ? void 0 : _a.quantidadeAssinaturasAdicionaisSenadores.toString()) !== null && _b !== void 0 ? _b : '0'}
          @input=${(ev) => this._atualizarQtdAssinaturasAdicionaisSenadores(ev)}
        ></sl-input>
        <sl-input
          label="Quantidade de assinaturas adicionais de Deputados Federais"
          type="number"
          id="num-assinaturas-adicionais-deputados"
          class="autoria-input"
          aria-label="Assinaturas Adicionais deputados"
          size="small"
          .value=${(_d = (_c = this._autoria) === null || _c === void 0 ? void 0 : _c.quantidadeAssinaturasAdicionaisDeputados.toString()) !== null && _d !== void 0 ? _d : '0'}
          @input=${(ev) => this._atualizarQtdAssinaturasAdicionaisDeputados(ev)}
        ></sl-input>
      </div>
    `;
    }
    updated() {
        this._isProcessandoMovimentacao = false;
    }
    _isAllAutoresOk() {
        return this._autoria.parlamentares.every(p => p.identificacao);
    }
    _incluirNovoParlamentar() {
        this._autoria.parlamentares = incluirParlamentar(this._autoria.parlamentares, { ...parlamentarVazio });
        this._podeIncluirParlamentar = false;
        setTimeout(() => this._autocompletes[this._autoria.parlamentares.length - 1].focus(), 200);
    }
    _moverParlamentar(index, deslocamento) {
        this._autoria.parlamentares = moverParlamentar(this._autoria.parlamentares, index, deslocamento);
        this.agendarEmissaoEventoOnChange('moverAutor');
        this.requestUpdate();
    }
    _excluirParlamentar(index) {
        this._autoria.parlamentares = excluirParlamentar(this._autoria.parlamentares, index);
        if (!this._autoria.parlamentares.length) {
            this._autoria.parlamentares = [{ ...parlamentarVazio }];
        }
        this._podeIncluirParlamentar = this._isAllAutoresOk();
        this.agendarEmissaoEventoOnChange('excluirAutor');
        this.requestUpdate();
    }
    _validarNomeParlamentar(ev, index) {
        this._isProcessandoValidacao = true;
        const isBlur = ev.type === 'blur';
        if (!isBlur) {
            clearInterval(this._timerValidacao);
        }
        // O trecho abaixo está dentro de um setTimeout por dois motivos:
        // 1 - Debounce quando ev.type é "input"
        // 2 - O clique de um nome na lista do autocomplete dispara o evento "blur"
        //     e é preciso dar tempo do @autocomplete ser executado e preencher o input com o nome selecionado antes da validação
        this._timerValidacao = window.setTimeout(() => {
            var _a;
            const auxValorPodeIncluirOriginal = this._podeIncluirParlamentar;
            const elLexmlAutocomplete = this._autocompletes[index];
            const cargoAtual = this._autoria.parlamentares[index].cargo;
            const nomeAtual = (_a = elLexmlAutocomplete.value) !== null && _a !== void 0 ? _a : '';
            const regex = new RegExp('^' + nomeAtual.normalize('NFD').replace(REGEX_ACCENTS, '') + '$', 'i');
            const parlamentar = this.parlamentares.find(p => p.nome
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .match(regex)) || { ...parlamentarVazio, nome: isBlur ? '' : nomeAtual };
            const parlamentarEhValido = !!parlamentar.identificacao;
            parlamentar.cargo = isBlur && !parlamentarEhValido ? '' : cargoAtual;
            this._autoria.parlamentares[index] = { ...parlamentar };
            this._podeIncluirParlamentar = parlamentarEhValido && this._isAllAutoresOk();
            if (isBlur && !parlamentarEhValido) {
                elLexmlAutocomplete.value = '';
            }
            this._isProcessandoValidacao = false;
            if (auxValorPodeIncluirOriginal !== this._podeIncluirParlamentar) {
                this.agendarEmissaoEventoOnChange('atualizarAutor');
            }
        }, ev.type === 'blur' ? 200 : 0);
    }
    _atualizarParlamentar(ev, index) {
        const parlamentarAutocomplete = this.parlamentares.find(p => p.nome === ev.detail.value);
        if (parlamentarAutocomplete) {
            const { cargo } = this._autoria.parlamentares[index];
            this._autoria.parlamentares[index] = {
                ...parlamentarAutocomplete,
                cargo,
            };
        }
        this._podeIncluirParlamentar = !!parlamentarAutocomplete && this._isAllAutoresOk();
        ev.target.focus();
        this._lastIndexAutoCompleted = index;
        this.agendarEmissaoEventoOnChange('atualizarAutor');
        this.requestUpdate();
    }
    _atualizarCargo(ev, index) {
        const cargoAtual = this._autoria.parlamentares[index].cargo;
        const newValue = ev.target.value;
        this._autoria.parlamentares[index].cargo = newValue;
        if (cargoAtual !== newValue) {
            this.agendarEmissaoEventoOnChange('atualizarAutor');
        }
    }
    _atualizarQtdAssinaturasAdicionaisSenadores(ev) {
        this._autoria.quantidadeAssinaturasAdicionaisSenadores = Number(ev.target.value);
    }
    _atualizarQtdAssinaturasAdicionaisDeputados(ev) {
        this._autoria.quantidadeAssinaturasAdicionaisDeputados = Number(ev.target.value);
    }
    _atualizarExibirPartidoUF(ev) {
        this._autoria.imprimirPartidoUF = ev.target.checked;
    }
    _handleKeyUp(ev, index) {
        if (!ev.ctrlKey && !ev.altKey && !ev.shiftKey) {
            if (ev.key === 'Enter' && this._podeIncluirParlamentar && index !== this._lastIndexAutoCompleted) {
                this._btnNovoParlamentar.click();
                this._lastIndexAutoCompleted = -1;
            }
            else if (['ArrowUp', 'ArrowDown'].includes(ev.key) && this._autoria.parlamentares[index].identificacao) {
                this._focarAutocompleteOuCargo(ev.target, index, ev.key === 'ArrowUp' ? -1 : 1);
            }
        }
        else if (ev.ctrlKey && !ev.altKey && !ev.shiftKey) {
            if (ev.key === 'ArrowUp') {
                if (!this._isProcessandoMovimentacao) {
                    this._isProcessandoMovimentacao = true;
                    this._moverParlamentar(index, -1);
                    this._focarAutocompleteOuCargo(ev.target, index, -1);
                }
            }
            else if (ev.key === 'ArrowDown') {
                if (!this._isProcessandoMovimentacao) {
                    this._isProcessandoMovimentacao = true;
                    this._moverParlamentar(index, 1);
                    this._focarAutocompleteOuCargo(ev.target, index, 1);
                }
            }
        }
    }
    _focarAutocompleteOuCargo(el, index, deslocamento) {
        const nodes = el.tagName === 'LEXML-AUTOCOMPLETE' ? this._autocompletes : this._inputCargos;
        const newIndex = index + deslocamento;
        if (newIndex < 0 || newIndex >= nodes.length) {
            return;
        }
        setTimeout(() => nodes[newIndex].focus(), 0);
    }
    _handleClickAutoComplete() {
        window.setTimeout(() => (this._lastIndexAutoCompleted = -1), 0);
    }
    agendarEmissaoEventoOnChange(origemEvento) {
        clearInterval(this.timerEmitirEventoOnChange);
        this.timerEmitirEventoOnChange = window.setTimeout(() => this.emitirEventoOnChange(origemEvento), 500);
    }
    emitirEventoOnChange(origemEvento) {
        this.dispatchEvent(new CustomEvent('onchange', {
            bubbles: true,
            composed: true,
            detail: {
                origemEvento,
            },
        }));
    }
};
AutoriaComponent.styles = [autoriaCss];
__decorate([
    i$1('#btnNovoParlamentar')
], AutoriaComponent.prototype, "_btnNovoParlamentar", void 0);
__decorate([
    e$2('input#tex-cargo')
], AutoriaComponent.prototype, "_inputCargos", void 0);
__decorate([
    e$2('lexml-autocomplete')
], AutoriaComponent.prototype, "_autocompletes", void 0);
__decorate([
    t$1()
], AutoriaComponent.prototype, "_nomesAutocomplete", void 0);
__decorate([
    t$1()
], AutoriaComponent.prototype, "_podeIncluirParlamentar", void 0);
__decorate([
    e$3({ type: Array })
], AutoriaComponent.prototype, "parlamentares", null);
__decorate([
    e$3({ type: Object })
], AutoriaComponent.prototype, "autoria", null);
__decorate([
    executarAposValidacao()
], AutoriaComponent.prototype, "_moverParlamentar", null);
__decorate([
    executarAposValidacao()
], AutoriaComponent.prototype, "_excluirParlamentar", null);
AutoriaComponent = __decorate([
    n$1('lexml-autoria')
], AutoriaComponent);

let LexmlAutocomplete = class LexmlAutocomplete extends s {
    constructor() {
        super(...arguments);
        this.items = [];
        this.opened = false;
        this.maxSuggestions = 10;
        this._suggestions = [];
        this._bound = {};
        this._blur = false;
        this._mouseEnter = false;
    }
    render() {
        return $ `
      <style>
        .suggest-container {
          position: relative;
        }

        ul {
          position: absolute;
          display: block;
          list-style-type: none;
          margin: 0;
          padding: 0;
          z-index: 10000;
          border: 1px solid grey;
          background: white;
        }
        li {
          padding: 4px;
          cursor: pointer;
        }
        li.active {
          background: whitesmoke;
        }
        [hidden] {
          display: none;
        }

        .lexml-autocomplete-input {
          width: 100%;
        }

        @media (max-width: 576px) {
          .lexml-autocomplete-label {
            width: calc(100% - 2px);
            display: block;
          }
          .lexml-autocomplete-input {
            width: calc(100% - 2px);
          }
        }
      </style>
      <slot id="dropdown-input">
        <!-- <input id="defaultInput" class="lexml-autocomplete-input" type="text" placeholder="Parlamentar" .value=${this.value || ''} /> -->
        <sl-input id="defaultInput" class="lexml-autocomplete-input" type="text" placeholder="Parlamentar" size="small" .value=${this.value || ''}></sl-input>
      </slot>
      <div class="suggest-container">
        <ul id="suggestions" ?hidden=${!this.opened} @mouseenter=${this._handleItemMouseEnter} @mouseleave=${this._handleItemMouseLeave}>
          ${this._suggestions.map(item => $ `<li @click=${() => this.autocomplete(item)}>${item}</li>`)}
        </ul>
      </div>
    `;
    }
    /**
     * Input element getter
     */
    get contentElement() {
        if (this._inputEl)
            return this._inputEl; // Cache
        if (!this.hasUpdated)
            return undefined; // No shadow root, no element to use
        const slotElement = this.shadowRoot.getElementById('dropdown-input');
        const slotInputList = slotElement.assignedElements();
        this._inputEl = slotInputList.length ? slotInputList[0] : this.shadowRoot.getElementById('defaultInput');
        return this._inputEl;
    }
    /**
     * Value getter from input element.
     */
    get value() {
        return this.contentElement && this.contentElement.value;
    }
    /**
     * Value setter to input element.
     */
    set value(value) {
        if (!this.contentElement) {
            this._tempValue = value;
            return;
        }
        this.contentElement.value = value;
    }
    firstUpdated() {
        this._suggestionEl = this.shadowRoot.getElementById('suggestions');
        this._suggestionEl.style.width = `${this.contentElement.getBoundingClientRect().width}px`;
        this._bound.onKeyDown = this._handleKeyDown.bind(this);
        this._bound.onKeyUp = this._handleKeyUp.bind(this);
        this._bound.onFocus = this._handleFocus.bind(this);
        this._bound.onBlur = this._handleBlur.bind(this);
        this.contentElement.addEventListener('keydown', this._bound.onKeyDown);
        this.contentElement.addEventListener('keyup', this._bound.onKeyUp);
        this.contentElement.addEventListener('focus', this._bound.onFocus);
        this.contentElement.addEventListener('blur', this._bound.onBlur);
        if (this._tempValue !== undefined) {
            this.contentElement.value = this._tempValue;
        }
    }
    disconnectedCallback() {
        if (!this.contentElement)
            return; // no events to remove
        this.contentElement.removeEventListener('keydown', this._bound.onKeyDown);
        this.contentElement.removeEventListener('keyup', this._bound.onKeyUp);
        this.contentElement.removeEventListener('focus', this._bound.onFocus);
        this.contentElement.removeEventListener('blur', this._bound.onBlur);
    }
    focus(options) {
        if (this.contentElement) {
            this.contentElement.focus(options);
        }
    }
    updated(changed) {
        if (changed.has('opened') && this.opened && this._suggestionEl.childElementCount) {
            // Highlight the first when there are suggestions
            // eslint-disable-next-line prefer-destructuring
            this._highlightedEl = this._suggestionEl.children[0];
            this._highlightedEl.classList.add('active');
        }
    }
    /**
     * Open suggestions.
     */
    open() {
        if (this._suggestionEl.style.width === '0px') {
            this._suggestionEl.style.width = `${this.contentElement.getBoundingClientRect().width}px`;
        }
        if (this._suggestions.length) {
            this.opened = true;
        }
    }
    /**
     * Close suggestions.
     */
    close() {
        this.opened = false;
        this._highlightedEl = null;
    }
    /**
     * Suggest autocomplete items.
     * @param {Array<String>} suggestions
     */
    suggest(suggestions) {
        this._suggestions = suggestions || [];
        // eslint-disable-next-line no-unused-expressions
        this._suggestions.length > 1 || (this._suggestions.length === 1 && this._suggestions[0] !== this.contentElement.value) ? this.open() : this.close();
        this.requestUpdate();
    }
    /**
     * Autocomplete input with `value`.
     * @param {String} value
     */
    autocomplete(value) {
        this.contentElement.value = value;
        this.close();
        this.dispatchEvent(new CustomEvent('autocomplete', {
            detail: { value },
            composed: true,
            bubbles: true,
        }));
    }
    _highlightPrev() {
        if (!this._highlightedEl || !this._highlightedEl.previousElementSibling)
            return;
        this._highlightedEl.classList.remove('active');
        this._highlightedEl = this._highlightedEl.previousElementSibling;
        this._highlightedEl.classList.add('active');
    }
    _highlightNext() {
        if (!this._highlightedEl || !this._highlightedEl.nextElementSibling)
            return;
        this._highlightedEl.classList.remove('active');
        this._highlightedEl = this._highlightedEl.nextElementSibling;
        this._highlightedEl.classList.add('active');
    }
    // eslint-disable-next-line class-methods-use-this
    _handleKeyDown(ev) {
        // Prevent up and down from behaving as home and end on some browsers
        if (ev.key === 'ArrowUp' || ev.key === 'ArrowDown') {
            ev.preventDefault();
            ev.stopPropagation();
        }
    }
    _handleKeyUp(ev) {
        var _a, _b;
        switch (ev.key) {
            case 'ArrowUp':
                if ((_a = this._highlightedEl) === null || _a === void 0 ? void 0 : _a.previousElementSibling) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    this._highlightPrev();
                }
                break;
            case 'ArrowDown':
                if ((_b = this._highlightedEl) === null || _b === void 0 ? void 0 : _b.nextElementSibling) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    this._highlightNext();
                }
                break;
            case 'Enter':
                // Select
                // eslint-disable-next-line no-unused-expressions
                this._highlightedEl && this._highlightedEl.click();
                break;
            default:
                // TODO debounce
                if (this.items.length) {
                    const { value } = this.contentElement;
                    const normalizedValue = value.normalize('NFD').replace(REGEX_ACCENTS, '');
                    this.suggest(this._findSuggetions(normalizedValue));
                }
        }
    }
    _findSuggetions(value, nItemsResult = this.maxSuggestions) {
        if (!value) {
            return [];
        }
        let suggestions = this._filterStartWith(value, nItemsResult);
        if (suggestions.length < this.maxSuggestions) {
            suggestions = [...suggestions, ...this._filterContains(value, this.maxSuggestions - suggestions.length).filter(item => !suggestions.includes(item))];
        }
        return suggestions;
    }
    _filterStartWith(value, itemsResult = this.maxSuggestions) {
        const regexStartWith = new RegExp('^' + value, 'gi');
        return ((value &&
            this.items
                .filter(item => item
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .match(regexStartWith))
                .slice(0, itemsResult)) ||
            []);
    }
    _filterContains(value, itemsResult = this.maxSuggestions) {
        const regexContains = new RegExp(value, 'gi');
        return ((value &&
            this.items
                .filter(item => item
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .match(regexContains))
                .slice(0, itemsResult)) ||
            []);
    }
    _handleFocus() {
        this._blur = false;
        // eslint-disable-next-line no-unused-expressions
        this._suggestions.length > 1 && this.open();
    }
    _handleBlur() {
        this._blur = true;
        // eslint-disable-next-line no-unused-expressions
        // !this._mouseEnter && this.close();
        setTimeout(() => this.close(), 200);
        this._suggestions = [];
    }
    // Handle mouse change focus to suggestions
    _handleItemMouseEnter() {
        this._mouseEnter = true;
    }
    _handleItemMouseLeave() {
        this._mouseEnter = false;
        // eslint-disable-next-line no-unused-expressions
        this._blur && setTimeout(() => this.close(), 500); // Give user some slack before closing
    }
};
__decorate([
    e$3({ type: Array })
], LexmlAutocomplete.prototype, "items", void 0);
__decorate([
    e$3({ type: Boolean, reflect: true })
], LexmlAutocomplete.prototype, "opened", void 0);
__decorate([
    e$3({ type: Number })
], LexmlAutocomplete.prototype, "maxSuggestions", void 0);
__decorate([
    e$3({ type: String })
], LexmlAutocomplete.prototype, "value", null);
LexmlAutocomplete = __decorate([
    n$1('lexml-autocomplete')
], LexmlAutocomplete);

let DataComponent = class DataComponent extends s {
    constructor() {
        super(...arguments);
        // @query('#opt-data')
        // optData!: HTMLInputElement;
        this.data = '';
        this.timerOnChange = 0;
    }
    updated() {
        this.inputData.value = this.data || this.inputData.value || new Date().toISOString().replace(/T.+$/, '');
        if (!this.data && !this.optionNaoInformarData.checked) {
            this.optionNaoInformarData.checked = true;
        }
    }
    render() {
        return $ `
      <style>
        sl-radio-group::part(base) {
          display: flex;
          flex-direction: row;
          align-items: center;
          gap: 10px;
          background-color: var(--sl-color-gray-100);
          box-shadow: var(--sl-shadow-x-large);
          flex-wrap: wrap;
          padding: 20px 20px;
        }
        sl-radio-group::part(label) {
          background-color: var(--sl-color-gray-200);
          font-weight: bold;
          border-radius: 5px;
          border: 1px solid var(--sl-color-gray-300);
          padding: 2px 5px;
          box-shadow: var(--sl-shadow-small);
        }
        sl-radio-group > sl-radio:first-child {
          display: inline-flex;
          padding: 0 20px 0 0;
        }
        sl-input::part(form-control) {
          display: flex;
          flex-direction: row;
          gap: 10px;
          align-items: center;
          flex-wrap: wrap;
        }
        sl-input::part(base) {
          max-width: 190px;
        }
        @media (max-width: 480px) {
          sl-input::part(base) {
            max-width: 150px;
          }
        }
      </style>
      <div class="lexml-data">
        <sl-radio-group label="Data" fieldset>
          <sl-radio name="data" value="2" ?checked=${!!this.data} @click=${this.setDate}>
            <sl-input id="input-data" label="Data" type="date" ?disabled=${!this.data} @input=${this.setDate}></sl-input>
          </sl-radio>
          <sl-radio name="data" id="no-date" value="1" ?checked=${!this.data} @click=${this.resetDate}>Não informar</sl-radio>
        </sl-radio-group>
      </div>
    `;
    }
    getCurrentDate() {
        return new Date().toLocaleDateString().split('/').reverse().join('-');
    }
    resetDate() {
        const original = this.data;
        this.data = '';
        if (original !== this.data) {
            this.agendarEmissaoEventoOnChange();
        }
    }
    setDate() {
        if (this.inputData) {
            const original = this.data;
            this.data = this.inputData.value;
            if (original !== this.data) {
                this.agendarEmissaoEventoOnChange();
            }
        }
    }
    agendarEmissaoEventoOnChange() {
        clearTimeout(this.timerOnChange);
        this.timerOnChange = window.setTimeout(() => this.emitirEventoOnChange(), 1000);
    }
    emitirEventoOnChange() {
        this.dispatchEvent(new CustomEvent('onchange', {
            bubbles: true,
            composed: true,
            detail: {
                origemEvento: 'data',
            },
        }));
    }
};
DataComponent.styles = r$2 `
    .lexml-data {
      display: block;
      font-size: 1em;
      max-width: 700px;
    }
  `;
__decorate([
    i$1('#input-data')
], DataComponent.prototype, "inputData", void 0);
__decorate([
    i$1('#no-date')
], DataComponent.prototype, "optionNaoInformarData", void 0);
__decorate([
    e$3({ type: String })
], DataComponent.prototype, "data", void 0);
DataComponent = __decorate([
    n$1('lexml-data')
], DataComponent);

class Usuario {
    constructor(nome, id, sigla) {
        this.nome = 'Anônimo';
        this.nome = nome || 'Anônimo';
        this.id = id;
        this.sigla = sigla;
    }
}

// src/components/badge/badge.styles.ts
var badge_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: inline-flex;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: var(--sl-font-size-x-small);
    font-weight: var(--sl-font-weight-semibold);
    letter-spacing: var(--sl-letter-spacing-normal);
    line-height: 1;
    border-radius: var(--sl-border-radius-small);
    border: solid 1px var(--sl-color-neutral-0);
    white-space: nowrap;
    padding: 3px 6px;
    user-select: none;
    cursor: inherit;
  }

  /* Variant modifiers */
  .badge--primary {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--success {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--neutral {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--warning {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--danger {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /* Pill modifier */
  .badge--pill {
    border-radius: var(--sl-border-radius-pill);
  }

  /* Pulse modifier */
  .badge--pulse {
    animation: pulse 1.5s infinite;
  }

  .badge--pulse.badge--primary {
    --pulse-color: var(--sl-color-primary-600);
  }

  .badge--pulse.badge--success {
    --pulse-color: var(--sl-color-success-600);
  }

  .badge--pulse.badge--neutral {
    --pulse-color: var(--sl-color-neutral-600);
  }

  .badge--pulse.badge--warning {
    --pulse-color: var(--sl-color-warning-600);
  }

  .badge--pulse.badge--danger {
    --pulse-color: var(--sl-color-danger-600);
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--pulse-color);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }
`;

// src/components/badge/badge.ts
var SlBadge = class extends s4 {
  constructor() {
    super(...arguments);
    this.variant = "primary";
    this.pill = false;
    this.pulse = false;
  }
  render() {
    return $$1`
      <span
        part="base"
        class=${o$7({
      badge: true,
      "badge--primary": this.variant === "primary",
      "badge--success": this.variant === "success",
      "badge--neutral": this.variant === "neutral",
      "badge--warning": this.variant === "warning",
      "badge--danger": this.variant === "danger",
      "badge--pill": this.pill,
      "badge--pulse": this.pulse
    })}
        role="status"
      >
        <slot></slot>
      </span>
    `;
  }
};
SlBadge.styles = badge_styles_default;
__decorateClass([
  e$7({ reflect: true })
], SlBadge.prototype, "variant", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlBadge.prototype, "pill", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlBadge.prototype, "pulse", 2);
SlBadge = __decorateClass([
  n$6("sl-badge")
], SlBadge);

// src/components/tab-group/tab-group.styles.ts
var tab_group_styles_default = r$5`
  ${component_styles_default}

  :host {
    --track-color: var(--sl-color-neutral-200);
    --indicator-color: var(--sl-color-primary-600);

    display: block;
  }

  .tab-group {
    display: flex;
    border: solid 1px transparent;
    border-radius: 0;
  }

  .tab-group .tab-group__tabs {
    display: flex;
    position: relative;
  }

  .tab-group .tab-group__indicator {
    position: absolute;
    left: 0;
    transition: var(--sl-transition-fast) transform ease, var(--sl-transition-fast) width ease;
  }

  .tab-group--has-scroll-controls .tab-group__nav-container {
    position: relative;
    padding: 0 var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    bottom: 0;
    width: var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button--start {
    left: 0;
  }

  .tab-group__scroll-button--end {
    right: 0;
  }

  /*
   * Top
   */

  .tab-group--top {
    flex-direction: column;
  }

  .tab-group--top .tab-group__nav-container {
    order: 1;
  }

  .tab-group--top .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--top .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--top .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-bottom: solid 2px var(--track-color);
  }

  .tab-group--top .tab-group__indicator {
    bottom: -2px;
    border-bottom: solid 2px var(--indicator-color);
  }

  .tab-group--top .tab-group__body {
    order: 2;
  }

  .tab-group--top ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Bottom
   */

  .tab-group--bottom {
    flex-direction: column;
  }

  .tab-group--bottom .tab-group__nav-container {
    order: 2;
  }

  .tab-group--bottom .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--bottom .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--bottom .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-top: solid 2px var(--track-color);
  }

  .tab-group--bottom .tab-group__indicator {
    top: calc(-1 * 2px);
    border-top: solid 2px var(--indicator-color);
  }

  .tab-group--bottom .tab-group__body {
    order: 1;
  }

  .tab-group--bottom ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Start
   */

  .tab-group--start {
    flex-direction: row;
  }

  .tab-group--start .tab-group__nav-container {
    order: 1;
  }

  .tab-group--start .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-right: solid 2px var(--track-color);
  }

  .tab-group--start .tab-group__indicator {
    right: calc(-1 * 2px);
    border-right: solid 2px var(--indicator-color);
  }

  .tab-group--start .tab-group__body {
    flex: 1 1 auto;
    order: 2;
  }

  .tab-group--start ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }

  /*
   * End
   */

  .tab-group--end {
    flex-direction: row;
  }

  .tab-group--end .tab-group__nav-container {
    order: 2;
  }

  .tab-group--end .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-left: solid 2px var(--track-color);
  }

  .tab-group--end .tab-group__indicator {
    left: calc(-1 * 2px);
    border-left: solid 2px var(--indicator-color);
  }

  .tab-group--end .tab-group__body {
    flex: 1 1 auto;
    order: 1;
  }

  .tab-group--end ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }
`;

// src/components/tab-group/tab-group.ts
var SlTabGroup = class extends s4 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.tabs = [];
    this.panels = [];
    this.hasScrollControls = false;
    this.placement = "top";
    this.activation = "auto";
    this.noScrollControls = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => {
      this.preventIndicatorTransition();
      this.repositionIndicator();
      this.updateScrollControls();
    });
    this.mutationObserver = new MutationObserver((mutations) => {
      if (mutations.some((m) => !["aria-labelledby", "aria-controls"].includes(m.attributeName))) {
        setTimeout(() => this.setAriaLabels());
      }
      if (mutations.some((m) => m.attributeName === "disabled")) {
        this.syncTabsAndPanels();
      }
    });
    this.updateComplete.then(() => {
      this.syncTabsAndPanels();
      this.mutationObserver.observe(this, { attributes: true, childList: true, subtree: true });
      this.resizeObserver.observe(this.nav);
      const intersectionObserver = new IntersectionObserver((entries, observer) => {
        var _a;
        if (entries[0].intersectionRatio > 0) {
          this.setAriaLabels();
          this.setActiveTab((_a = this.getActiveTab()) != null ? _a : this.tabs[0], { emitEvents: false });
          observer.unobserve(entries[0].target);
        }
      });
      intersectionObserver.observe(this.tabGroup);
    });
  }
  disconnectedCallback() {
    this.mutationObserver.disconnect();
    this.resizeObserver.unobserve(this.nav);
  }
  show(panel) {
    const tab = this.tabs.find((el) => el.panel === panel);
    if (tab) {
      this.setActiveTab(tab, { scrollBehavior: "smooth" });
    }
  }
  getAllTabs(includeDisabled = false) {
    const slot = this.shadowRoot.querySelector('slot[name="nav"]');
    return [...slot.assignedElements()].filter((el) => {
      return includeDisabled ? el.tagName.toLowerCase() === "sl-tab" : el.tagName.toLowerCase() === "sl-tab" && !el.disabled;
    });
  }
  getAllPanels() {
    const slot = this.body.querySelector("slot");
    return [...slot.assignedElements()].filter((el) => el.tagName.toLowerCase() === "sl-tab-panel");
  }
  getActiveTab() {
    return this.tabs.find((el) => el.active);
  }
  handleClick(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (tab !== null) {
      this.setActiveTab(tab, { scrollBehavior: "smooth" });
    }
  }
  handleKeyDown(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (["Enter", " "].includes(event.key)) {
      if (tab !== null) {
        this.setActiveTab(tab, { scrollBehavior: "smooth" });
        event.preventDefault();
      }
    }
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
      const activeEl = document.activeElement;
      if ((activeEl == null ? void 0 : activeEl.tagName.toLowerCase()) === "sl-tab") {
        let index = this.tabs.indexOf(activeEl);
        if (event.key === "Home") {
          index = 0;
        } else if (event.key === "End") {
          index = this.tabs.length - 1;
        } else if (["top", "bottom"].includes(this.placement) && event.key === "ArrowLeft" || ["start", "end"].includes(this.placement) && event.key === "ArrowUp") {
          index--;
        } else if (["top", "bottom"].includes(this.placement) && event.key === "ArrowRight" || ["start", "end"].includes(this.placement) && event.key === "ArrowDown") {
          index++;
        }
        if (index < 0) {
          index = this.tabs.length - 1;
        }
        if (index > this.tabs.length - 1) {
          index = 0;
        }
        this.tabs[index].focus({ preventScroll: true });
        if (this.activation === "auto") {
          this.setActiveTab(this.tabs[index], { scrollBehavior: "smooth" });
        }
        if (["top", "bottom"].includes(this.placement)) {
          scrollIntoView(this.tabs[index], this.nav, "horizontal");
        }
        event.preventDefault();
      }
    }
  }
  handleScrollToStart() {
    this.nav.scroll({
      left: this.nav.scrollLeft - this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  handleScrollToEnd() {
    this.nav.scroll({
      left: this.nav.scrollLeft + this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  updateScrollControls() {
    if (this.noScrollControls) {
      this.hasScrollControls = false;
    } else {
      this.hasScrollControls = ["top", "bottom"].includes(this.placement) && this.nav.scrollWidth > this.nav.clientWidth;
    }
  }
  setActiveTab(tab, options) {
    options = __spreadValues({
      emitEvents: true,
      scrollBehavior: "auto"
    }, options);
    if (tab !== this.activeTab && !tab.disabled) {
      const previousTab = this.activeTab;
      this.activeTab = tab;
      this.tabs.map((el) => el.active = el === this.activeTab);
      this.panels.map((el) => {
        var _a;
        return el.active = el.name === ((_a = this.activeTab) == null ? void 0 : _a.panel);
      });
      this.syncIndicator();
      if (["top", "bottom"].includes(this.placement)) {
        scrollIntoView(this.activeTab, this.nav, "horizontal", options.scrollBehavior);
      }
      if (options.emitEvents) {
        if (previousTab) {
          emit(this, "sl-tab-hide", { detail: { name: previousTab.panel } });
        }
        emit(this, "sl-tab-show", { detail: { name: this.activeTab.panel } });
      }
    }
  }
  setAriaLabels() {
    this.tabs.forEach((tab) => {
      const panel = this.panels.find((el) => el.name === tab.panel);
      if (panel) {
        tab.setAttribute("aria-controls", panel.getAttribute("id"));
        panel.setAttribute("aria-labelledby", tab.getAttribute("id"));
      }
    });
  }
  syncIndicator() {
    const tab = this.getActiveTab();
    if (tab) {
      this.indicator.style.display = "block";
      this.repositionIndicator();
    } else {
      this.indicator.style.display = "none";
    }
  }
  repositionIndicator() {
    const currentTab = this.getActiveTab();
    if (!currentTab) {
      return;
    }
    const width = currentTab.clientWidth;
    const height = currentTab.clientHeight;
    const allTabs = this.getAllTabs(true);
    const precedingTabs = allTabs.slice(0, allTabs.indexOf(currentTab));
    const offset = precedingTabs.reduce((previous, current) => ({
      left: previous.left + current.clientWidth,
      top: previous.top + current.clientHeight
    }), { left: 0, top: 0 });
    switch (this.placement) {
      case "top":
      case "bottom":
        this.indicator.style.width = `${width}px`;
        this.indicator.style.height = "auto";
        this.indicator.style.transform = `translateX(${offset.left}px)`;
        break;
      case "start":
      case "end":
        this.indicator.style.width = "auto";
        this.indicator.style.height = `${height}px`;
        this.indicator.style.transform = `translateY(${offset.top}px)`;
        break;
    }
  }
  preventIndicatorTransition() {
    const transitionValue = this.indicator.style.transition;
    this.indicator.style.transition = "none";
    requestAnimationFrame(() => {
      this.indicator.style.transition = transitionValue;
    });
  }
  syncTabsAndPanels() {
    this.tabs = this.getAllTabs();
    this.panels = this.getAllPanels();
    this.syncIndicator();
  }
  render() {
    return $$1`
      <div
        part="base"
        class=${o$7({
      "tab-group": true,
      "tab-group--top": this.placement === "top",
      "tab-group--bottom": this.placement === "bottom",
      "tab-group--start": this.placement === "start",
      "tab-group--end": this.placement === "end",
      "tab-group--has-scroll-controls": this.hasScrollControls
    })}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
      >
        <div class="tab-group__nav-container" part="nav">
          ${this.hasScrollControls ? $$1`
                <sl-icon-button
                  part="scroll-button scroll-button--start"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--start"
                  name="chevron-left"
                  library="system"
                  label=${this.localize.term("scrollToStart")}
                  @click=${this.handleScrollToStart}
                ></sl-icon-button>
              ` : ""}

          <div class="tab-group__nav">
            <div part="tabs" class="tab-group__tabs" role="tablist">
              <div part="active-tab-indicator" class="tab-group__indicator"></div>
              <slot name="nav" @slotchange=${this.syncTabsAndPanels}></slot>
            </div>
          </div>

          ${this.hasScrollControls ? $$1`
                <sl-icon-button
                  part="scroll-button scroll-button--end"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--end"
                  name="chevron-right"
                  library="system"
                  label=${this.localize.term("scrollToEnd")}
                  @click=${this.handleScrollToEnd}
                ></sl-icon-button>
              ` : ""}
        </div>

        <div part="body" class="tab-group__body">
          <slot @slotchange=${this.syncTabsAndPanels}></slot>
        </div>
      </div>
    `;
  }
};
SlTabGroup.styles = tab_group_styles_default;
__decorateClass([
  i2(".tab-group")
], SlTabGroup.prototype, "tabGroup", 2);
__decorateClass([
  i2(".tab-group__body")
], SlTabGroup.prototype, "body", 2);
__decorateClass([
  i2(".tab-group__nav")
], SlTabGroup.prototype, "nav", 2);
__decorateClass([
  i2(".tab-group__indicator")
], SlTabGroup.prototype, "indicator", 2);
__decorateClass([
  t$4()
], SlTabGroup.prototype, "hasScrollControls", 2);
__decorateClass([
  e$7()
], SlTabGroup.prototype, "placement", 2);
__decorateClass([
  e$7()
], SlTabGroup.prototype, "activation", 2);
__decorateClass([
  e$7({ attribute: "no-scroll-controls", type: Boolean })
], SlTabGroup.prototype, "noScrollControls", 2);
__decorateClass([
  e$7()
], SlTabGroup.prototype, "lang", 2);
__decorateClass([
  watch("noScrollControls", { waitUntilFirstUpdate: true })
], SlTabGroup.prototype, "updateScrollControls", 1);
__decorateClass([
  watch("placement", { waitUntilFirstUpdate: true })
], SlTabGroup.prototype, "syncIndicator", 1);
SlTabGroup = __decorateClass([
  n$6("sl-tab-group")
], SlTabGroup);

// src/components/tab-panel/tab-panel.styles.ts
var tab_panel_styles_default = r$5`
  ${component_styles_default}

  :host {
    --padding: 0;

    display: block;
  }

  .tab-panel {
    border: solid 1px transparent;
    padding: var(--padding);
  }
`;

// src/internal/auto-increment.ts
var id = 0;
function autoIncrement() {
  return ++id;
}

// src/components/tab-panel/tab-panel.ts
var SlTabPanel = class extends s4 {
  constructor() {
    super(...arguments);
    this.attrId = autoIncrement();
    this.componentId = `sl-tab-panel-${this.attrId}`;
    this.name = "";
    this.active = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.id = this.id.length > 0 ? this.id : this.componentId;
  }
  render() {
    this.style.display = this.active ? "block" : "none";
    return $$1`
      <div part="base" class="tab-panel" role="tabpanel" aria-hidden=${this.active ? "false" : "true"}>
        <slot></slot>
      </div>
    `;
  }
};
SlTabPanel.styles = tab_panel_styles_default;
__decorateClass([
  e$7({ reflect: true })
], SlTabPanel.prototype, "name", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlTabPanel.prototype, "active", 2);
SlTabPanel = __decorateClass([
  n$6("sl-tab-panel")
], SlTabPanel);

// src/components/tab/tab.styles.ts
var tab_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .tab {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    border-radius: var(--sl-border-radius-medium);
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-medium) var(--sl-spacing-large);
    white-space: nowrap;
    user-select: none;
    cursor: pointer;
    transition: var(--transition-speed) box-shadow, var(--transition-speed) color;
  }

  .tab:hover:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus {
    outline: none;
  }

  .tab${focusVisibleSelector}:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
    box-shadow: inset var(--sl-focus-ring);
  }

  .tab.tab--active:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab.tab--closable {
    padding-right: var(--sl-spacing-small);
  }

  .tab.tab--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tab__close-button {
    font-size: var(--sl-font-size-large);
    margin-left: var(--sl-spacing-2x-small);
  }

  .tab__close-button::part(base) {
    padding: var(--sl-spacing-3x-small);
  }
`;

// src/components/tab/tab.ts
var SlTab = class extends s4 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.attrId = autoIncrement();
    this.componentId = `sl-tab-${this.attrId}`;
    this.panel = "";
    this.active = false;
    this.closable = false;
    this.disabled = false;
  }
  focus(options) {
    this.tab.focus(options);
  }
  blur() {
    this.tab.blur();
  }
  handleCloseClick() {
    emit(this, "sl-close");
  }
  render() {
    this.id = this.id.length > 0 ? this.id : this.componentId;
    return $$1`
      <div
        part="base"
        class=${o$7({
      tab: true,
      "tab--active": this.active,
      "tab--closable": this.closable,
      "tab--disabled": this.disabled
    })}
        role="tab"
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-selected=${this.active ? "true" : "false"}
        tabindex=${this.disabled || !this.active ? "-1" : "0"}
      >
        <slot></slot>
        ${this.closable ? $$1`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                name="x"
                library="system"
                label=${this.localize.term("close")}
                class="tab__close-button"
                @click=${this.handleCloseClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
SlTab.styles = tab_styles_default;
__decorateClass([
  i2(".tab")
], SlTab.prototype, "tab", 2);
__decorateClass([
  e$7({ reflect: true })
], SlTab.prototype, "panel", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlTab.prototype, "active", 2);
__decorateClass([
  e$7({ type: Boolean })
], SlTab.prototype, "closable", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlTab.prototype, "disabled", 2);
__decorateClass([
  e$7()
], SlTab.prototype, "lang", 2);
SlTab = __decorateClass([
  n$6("sl-tab")
], SlTab);

// Foi utilizado TemplateResult porque o editor.component.ts não usa ShadowDom
const editorStyles = $ `
  <style>
    :root {
      --elemento-padding-factor: 20;
      --eta-font-serif: 'Times New Roman', Times, serif;
    }

    #lx-eta-box {
      /* display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: 42px calc(100% - 30px); */
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* #lx-eta-box .ql-toolbar.ql-snow {
      border: 1px solid #ccc;
      box-sizing: border-box;
      padding: 3px 10px 3px 10px;
    } */

    .ql-toolbar.ql-snow {
      border: 1px solid #ccc;
      box-sizing: border-box;
      font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
      /* padding: 8px; */
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      min-height: 55px;
    }
    #lx-eta-box .ql-snow.ql-toolbar button,
    .ql-snow .ql-toolbar button {
      /* height: 20px !important;
      padding: 0px !important;
      width: 24px !important;
      margin: 0px !important; */
      background: none;
      border: none;
      cursor: pointer;
      display: inline-block;
      float: left;
      height: 24px;
      padding: 3px 5px;
      width: 28px;
    }

    #lx-eta-barra-ferramenta button:focus {
      outline: 0;
      border: 0px solid #f1f1f1;
      -webkit-box-shadow: 0px;
      box-shadow: none;
    }

    #lx-eta-barra-ferramenta .lx-eta-ql-button {
      font-size: 1.1em;
      color: #444444;
    }

    .lx-eta-rebate-180-graus {
      -moz-transform: scaleX(-1);
      -o-transform: scaleX(-1);
      -webkit-transform: scaleX(-1);
      transform: scaleX(-1);
    }

    #lx-eta-editor {
      overflow-y: hidden;
    }

    #lx-eta-editor .ql-editor {
      /* font-family: sans-serif, 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
        'Noto Color Emoji'; */
      font-family: var(--eta-font-serif);
      font-size: 18px;
      line-height: 1.42;
      color: #646260;
      text-transform: none !important;
      padding: 0 10px 0 8px;
      min-height: 250px;
      overflow-x: hidden;
    }

    #lx-eta-editor .ql-editor *:focus {
      outline: 0;
      border: 0px solid #f1f1f1;
      -webkit-box-shadow: 0px;
      box-shadow: none;
    }

    #lx-eta-editor .ql-editor label:before {
      /* content: attr(data-rotulo) ' '; */
    }

    #toast-msg {
      padding: 1em;
      font-size: 1.1em;
    }

    .lx-eta-dropbtn {
      background-color: transparent;
      color: #444444;
      width: 26px;
      font-weight: bold;
      vertical-align: middle;
      border: none;
      cursor: pointer;
      text-align: center;
    }

    .container__menu sl-button::part(base) {
      position: absolute;
      margin: -13px 0 0 -15px;
      background-color: #e1e1e1;
      line-height: 20px;
      height: 23px;
      color: black;
      font-weight: bold;
      font-size: 15px;
    }

    .container__menu sl-menu-item::part(suffix) {
      font-size: 14px;
      padding-left: 20px;
    }

    .container__menu sl-menu-item:hover .lx-eta-dropbtn {
      background-color: #e1e1e1;
    }

    .lx-eta-btn-desfazer {
      margin-left: 10px;
    }

    .icon-undo-redo {
      width: 19px;
      height: 16px !important;
    }

    .icon-undo-redo:hover {
      fill: #0066cc;
    }

    .icon-negrito {
      fill: #444;
    }

    .icon-negrito:hover {
      fill: #0066cc;
    }

    .icon-sublinhado {
      fill: #444;
    }

    .icon-sublinhado:hover {
      fill: #0066cc;
    }

    .lx-eta-dropdown-content-right {
      right: 0;
    }

    .ql-snow .ql-hidden {
      display: none;
    }

    .ql-snow .ql-tooltip::before {
      content: 'Acesse a norma:';
    }

    .ql-snow .ql-tooltip a.ql-action::after {
      display: none;
    }

    .ql-snow .ql-tooltip a.ql-remove::before {
      display: none;
    }

    .ql-snow .ql-tooltip a.ql-preview {
      max-width: 300px;
    }

    .btn--artigoOndeCouber {
    }

    .container__linha {
      display: flex;
      width: 100%;
    }

    .container__linha--reverse {
      flex-direction: row-reverse;
    }

    .container__texto {
      flex: 1;
      white-space: pre-wrap;
    }

    .container_elemento--omissis .container__texto {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
    }

    .container_elemento--omissis .container__texto--mensagem {
      flex: 1;
      display: inline-block;
    }

    .container_elemento--omissis .texto__rotulo {
      box-sizing: border-box;
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      flex: none;
      order: 0;
      flex-grow: 0;
    }

    .container_elemento--omissis .texto__dispositivo {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      padding: 0px;
      flex-grow: 1;
    }

    .container_elemento--omissis .texto__omissis {
      display: -webkit-box;
      -webkit-line-clamp: 1;
      -webkit-box-orient: vertical;
      overflow: hidden;
      flex-grow: 1;
      width: 50px;
      white-space: nowrap;
    }

    .elemento-tipo-capitulo .texto__dispositivo,
    .elemento-tipo-titulo .texto__dispositivo,
    .elemento-tipo-livro .texto__dispositivo,
    .elemento-tipo-parte .texto__dispositivo {
      text-transform: uppercase;
    }

    .elemento-tipo-secao .texto__dispositivo,
    .elemento-tipo-subsecao .texto__dispositivo {
      font-weight: bold;
    }

    .container__menu {
      width: 30px;
      vertical-align: top;
      text-align: center;
    }

    .container__elemento--padrao {
      width: 100%;
      min-height: 26px;
      border: 3px solid #ffffff;
      line-height: 1.42;
      margin: 0;
      padding: 0 5px 0 0;
    }

    .container__elemento--articulacao {
      width: 100%;
      min-height: 1px;
      line-height: 0.42;
      margin: 1px;
    }

    .agrupador {
      text-align: center;
    }

    label[pode-informar-numeracao='true'] {
      cursor: pointer;
      /* border-bottom: 1px dashed; */
      -webkit-box-shadow: 0px -1px 0px green inset;
      -moz-box-shadow: 0px -1px 0px green inset;
      box-shadow: 0px -1px 0px green inset;
    }

    /* [existenanormaalterada] label:after, */
    .existencia {
      font-family: var(--sl-font-sans);
      position: relative;
      left: 5px;
      top: -1px;
      margin-right: 5px;
      border: 1px solid green;
      padding: 0 4px;
      font-weight: normal;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      border-radius: 4px;
      font-size: 12px;
    }

    .existencia {
      margin-left: -10px;
      margin-right: 15px;
    }

    .existencia:hover {
      cursor: pointer;
    }

    /* [existenanormaalterada='true'] label:after {
      content: 'Existente';
    }

    [existenanormaalterada='false'] label:after {
      content: 'Novo';
    } */

    .texto__rotulo {
      color: black;
      font-weight: 600;
    }

    .texto__rotulo--padrao {
      display: inline-block;
      padding-right: 10px; /* Manter padding em vez de margin para evitar problema de layout ao apagar todo o texto do dispositivo.
        Fica um sublinhado a mais, mas é melhor que a alternativa.
      */
    }

    .texto__rotulo--omissis,
    .tipo-omissis {
      font-family: var(--sl-font-sans);
      box-shadow: none;
    }

    .texto__rotulo--omissis:before,
    .tipo-omissis {
      position: relative;
      left: 0;
      top: -1px;
      margin-right: 5px;
      border: 1px solid green;
      padding: 0 4px;
      font-weight: normal;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      display: none;
    }

    .agrupador .blot-tipo-omissis {
      display: block;
    }

    /* .container__texto[tipo-omissis='inciso-caput'] .texto__rotulo--omissis:before {
      content: ' Incisos omitidos ';
    }

    .container__texto[tipo-omissis='inciso-paragrafo'] .texto__rotulo--omissis:before {
      content: ' Incisos omitidos ';
    }

    .container__texto[tipo-omissis='paragrafo'] .texto__rotulo--omissis:before {
      content: ' Parágrafos omitidos ';
    }

    .container__texto[tipo-omissis='alinea'] .texto__rotulo--omissis:before {
      content: ' Alíneas omitidas ';
    }

    .container__texto[tipo-omissis='item'] .texto__rotulo--omissis:before {
      content: ' Itens omitidos ';
    } */

    .Omissis {
      word-break: break-all;
      word-break: break-word;
      -webkit-hyphens: auto;
      -moz-hyphens: auto;
      -ms-hyphens: auto;
      hyphens: auto;
    }

    .agrupador .existencia {
      margin-left: 0;
      margin-right: 0;
    }

    .dispositivo--adicionado {
      color: green;
    }

    .dispositivo--modificado {
      color: blue;
    }

    .dispositivo--suprimido {
      color: red;
    }

    .dispositivo--suprimido .texto__dispositivo {
      text-decoration: line-through;
    }

    /* .texto--suprimido {
      text-decoration: line-through;
    } */

    .ementa {
      margin-bottom: 30px;
    }

    .ementa .container__texto {
      margin-left: 35%;
    }

    .texto__rotulo--ementa {
      display: none;
    }

    .container__elemento--ativo {
      border: 3px solid #24d421;
      border-radius: 4px;
    }

    .mensagem {
      font-family: var(--sl-font-sans);
      font-size: 0.8em;
      font-weight: normal;
      border: 1px solid;
      padding: 4px 10px;
      margin: 2px;
      display: inline-block;
      border-radius: 2px;
    }

    .mensagem--success {
      color: #155724;
      background-color: #d4edda;
      border-color: #c3e6cb;
    }

    .mensagem--info {
      color: #0c5460;
      background-color: #d1ecf1;
      border-color: #bee5eb;
    }

    .mensagem--warning {
      color: #856404;
      background-color: #fff3cd;
      border-color: #ffeeba;
    }

    .mensagem--danger {
      color: #721c24;
      background-color: #f8d7da;
      border-color: #f5c6cb;
    }
    .mensagem__fix {
      color: blue;
      text-decoration: underline;
      cursor: pointer;
    }

    #lx-eta-buffer {
      display: none;
      height: 0px;
    }

    /* [fecha-aspas]::after {
      content: '” (' attr(nota-alteracao) ')';
      font-weight: bold;
    }

    [abre-aspas]::before {
      content: '“';
      font-weight: bold;
    } */

    .nota-alteracao,
    .abre-aspas,
    .fecha-aspas {
      font-weight: bold;
    }

    .nota-alteracao-editavel {
      text-decoration: underline;
      cursor: pointer;
    }

    .texto__dispositivo {
      display: inline;
      /* background-color: lightblue; */
    }

    @-moz-document url-prefix() {
      .agrupador .texto__dispositivo {
        display: inline-block;
        min-height: 1rem;
      }
    }

    .blot-existencia br,
    .blot-tipo-omissis br,
    .agrupador.dispositivo-alteracao p[fecha-aspas] br,
    .h-artigo br {
      display: inline; /* faz o BR não pular linha em texto__dispositivo vazio */
      content: ''; /* descola cursor do rótulo e remove quebra de linha quando "(NR) */
    }

    .mobile-buttons {
      float: right;
      /* margin-right: 30px; */
      width: auto !important;
      display: none !important;
    }

    .mobile-button {
      margin-right: 2px;
      width: auto !important;
    }

    .mobile-button sl-icon {
      font-size: 18px;
    }

    .mobile-button span {
      vertical-align: 4px;
    }

    @media (max-width: 768px) {
      .mobile-buttons {
        display: inline-block !important;
      }
      #chk-em-revisao span {
        display: none;
      }
      .button-navegacao-marca {
        display: none;
      }
    }

    @media (max-width: 640px) {
      .mobile-button span {
        display: none;
      }
      .mobile-button:last-child {
        display: none !important;
      }
    }

    .revisao-ativa {
      background-color: #add8e6 !important;
    }

    [em-revisao='true'] {
      background-color: var(--sl-color-blue-100);
    }

    [excluido='true'] .texto__dispositivo {
      text-decoration: line-through;
      /* background-color: #d3d3d3; */
    }

    .blot__revisao {
      padding: 3px 7px;
      border: 1px solid white;
      border-radius: 1rem;
      background-color: rgb(217, 119, 6);
      color: white;
      cursor: pointer;
      position: relative;
      top: -1px;
    }

    .blot__revisao_aceitar {
      padding: 5px;
      border: 1px solid black;
      border-radius: 1rem;
      background-color: rgb(217, 119, 6);
      color: white;
      cursor: pointer;
      position: relative;
      width: 1.3rem;
      height: 1.3rem;
      top: -1px;
      background: url('assets/icons/check-lg.svg') no-repeat center, white;
      background-size: 1rem;
    }

    .blot__revisao_aceitar:hover {
      filter: invert(100%);
    }

    .blot__opcoes_diff {
      padding: 5px;
      border: 1px solid black;
      border-radius: 1rem;
      background-color: rgb(217, 119, 6);
      color: white;
      cursor: pointer;
      position: relative;
      width: 1.3rem;
      height: 1.3rem;
      top: -1px;
      background: url('assets/icons/plus-minus.svg') no-repeat center, white;
      background-size: 0.8rem;
      margin-right: 1.2px;
    }

    .blot__opcoes_diff:hover {
      filter: invert(100%);
    }

    .blot__revisao_recusar {
      padding: 5px;
      border: 1px solid black;
      border-radius: 1rem;
      background-color: rgb(217, 119, 6);
      color: white;
      cursor: pointer;
      position: relative;
      width: 1.3rem;
      height: 1.3rem;
      top: -1px;
      background: url('assets/icons/x.svg') no-repeat center, white;
      background-size: 1rem;
    }

    .blot__revisao_recusar:hover {
      filter: invert(100%);
    }

    .blot__revisao_aceitar:focus,
    .blot__opcoes_diff:focus .blot__revisao_recusar:focus {
      outline: 1px solid #000;
      border: 1px solid #000;
    }

    #chk-em-revisao {
      border: 1px solid #ccc !important;
      padding: 5px 10px !important;
      border-radius: 20px !important;
      margin-left: auto;
      margin-right: 5px;
      font-weight: bold;
      background-color: #eee;
    }
    #chk-em-revisao[checked] {
      background-color: var(--sl-color-blue-100);
    }

    .container__revisao {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 0.1rem;
      @media (max-width: 768px) {
        flex-direction: column;
      }
    }

    .container__opcoes {
      display: flex;
      flex-direction: row;
      align-items: center;
      margin-left: 0.1rem;
      gap: 0.1rem;
      @media (max-width: 768px) {
        flex-direction: column;
      }
    }

    @media (max-width: 480px) {
      .lx-eta-btn-desfazer {
        margin-left: 0px;
      }
    }

    @media (max-width: 398px) {
      .btn-dicas {
        display: none !important;
      }
    }
  </style>
`;

// Foi utilizado TemplateResult porque o editor.component.ts não usa ShadowDom
const quillSnowStyles = $ `
  <style>
    /*!
    * Quill Editor v1.3.7
    * https://quilljs.com/
    * Copyright (c) 2014, Jason Chen
    * Copyright (c) 2013, salesforce.com
    */
    .ql-container {
      box-sizing: border-box;
      /* font-family: Helvetica, Arial, sans-serif; */
      font-family: var(--eta-font-serif);
      font-size: 13px;
      height: 100%;
      margin: 0px;
      position: relative;
    }
    .ql-container.ql-disabled .ql-tooltip {
      visibility: hidden;
    }
    .ql-container.ql-disabled .ql-editor ul[data-checked] > li::before {
      pointer-events: none;
    }
    .ql-clipboard {
      left: -100000px;
      height: 1px;
      overflow-y: hidden;
      position: absolute;
      top: 50%;
    }
    .ql-clipboard p {
      margin: 0;
      padding: 0;
    }
    .ql-editor {
      box-sizing: border-box;
      line-height: 1.42;
      height: 100%;
      outline: none;
      overflow-y: auto;
      padding: 12px 15px;
      tab-size: 4;
      -moz-tab-size: 4;
      text-align: left;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .ql-editor > * {
      cursor: text;
    }
    .ql-editor p,
    .ql-editor ol,
    .ql-editor ul,
    .ql-editor pre,
    .ql-editor blockquote,
    .ql-editor h1,
    .ql-editor h2,
    .ql-editor h3,
    .ql-editor h4,
    .ql-editor h5,
    .ql-editor h6 {
      margin: 0;
      padding: 0;
      counter-reset: list-1 list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;
    }
    .ql-editor p {
      line-height: 1.42;
      font-size: 18px;
    }
    .ql-editor ol,
    .ql-editor ul {
      padding-left: 1.5em;
    }
    .ql-editor ol > li,
    .ql-editor ul > li {
      list-style-type: none;
    }
    .ql-editor ul > li::before {
      content: '\\2022';
    }
    .ql-editor ul[data-checked='true'],
    .ql-editor ul[data-checked='false'] {
      pointer-events: none;
    }
    .ql-editor ul[data-checked='true'] > li *,
    .ql-editor ul[data-checked='false'] > li * {
      pointer-events: all;
    }
    .ql-editor ul[data-checked='true'] > li::before,
    .ql-editor ul[data-checked='false'] > li::before {
      color: #777;
      cursor: pointer;
      pointer-events: all;
    }
    .ql-editor ul[data-checked='true'] > li::before {
      content: '\\2611';
    }
    .ql-editor ul[data-checked='false'] > li::before {
      content: '\\2610';
    }
    .ql-editor li::before {
      display: inline-block;
      white-space: nowrap;
      width: 1.2em;
    }
    .ql-editor li:not(.ql-direction-rtl)::before {
      margin-left: -1.5em;
      margin-right: 0.3em;
      text-align: right;
    }
    .ql-editor li.ql-direction-rtl::before {
      margin-left: 0.3em;
      margin-right: -1.5em;
    }
    .ql-editor ol li:not(.ql-direction-rtl),
    .ql-editor ul li:not(.ql-direction-rtl) {
      padding-left: 1.5em;
    }
    .ql-editor ol li.ql-direction-rtl,
    .ql-editor ul li.ql-direction-rtl {
      padding-right: 1.5em;
    }
    .ql-editor ol li {
      counter-reset: list-1 list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;
      counter-increment: list-0;
    }
    .ql-editor ol li:before {
      content: counter(list-0, decimal) '. ';
    }
    .ql-editor ol li.ql-indent-1 {
      counter-increment: list-1;
    }
    .ql-editor ol li.ql-indent-1:before {
      content: counter(list-1, lower-alpha) '. ';
    }
    .ql-editor ol li.ql-indent-1 {
      counter-reset: list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;
    }
    .ql-editor ol li.ql-indent-2 {
      counter-increment: list-2;
    }
    .ql-editor ol li.ql-indent-2:before {
      content: counter(list-2, lower-roman) '. ';
    }
    .ql-editor ol li.ql-indent-2 {
      counter-reset: list-3 list-4 list-5 list-6 list-7 list-8 list-9;
    }
    .ql-editor ol li.ql-indent-3 {
      counter-increment: list-3;
    }
    .ql-editor ol li.ql-indent-3:before {
      content: counter(list-3, decimal) '. ';
    }
    .ql-editor ol li.ql-indent-3 {
      counter-reset: list-4 list-5 list-6 list-7 list-8 list-9;
    }
    .ql-editor ol li.ql-indent-4 {
      counter-increment: list-4;
    }
    .ql-editor ol li.ql-indent-4:before {
      content: counter(list-4, lower-alpha) '. ';
    }
    .ql-editor ol li.ql-indent-4 {
      counter-reset: list-5 list-6 list-7 list-8 list-9;
    }
    .ql-editor ol li.ql-indent-5 {
      counter-increment: list-5;
    }
    .ql-editor ol li.ql-indent-5:before {
      content: counter(list-5, lower-roman) '. ';
    }
    .ql-editor ol li.ql-indent-5 {
      counter-reset: list-6 list-7 list-8 list-9;
    }
    .ql-editor ol li.ql-indent-6 {
      counter-increment: list-6;
    }
    .ql-editor ol li.ql-indent-6:before {
      content: counter(list-6, decimal) '. ';
    }
    .ql-editor ol li.ql-indent-6 {
      counter-reset: list-7 list-8 list-9;
    }
    .ql-editor ol li.ql-indent-7 {
      counter-increment: list-7;
    }
    .ql-editor ol li.ql-indent-7:before {
      content: counter(list-7, lower-alpha) '. ';
    }
    .ql-editor ol li.ql-indent-7 {
      counter-reset: list-8 list-9;
    }
    .ql-editor ol li.ql-indent-8 {
      counter-increment: list-8;
    }
    .ql-editor ol li.ql-indent-8:before {
      content: counter(list-8, lower-roman) '. ';
    }
    .ql-editor ol li.ql-indent-8 {
      counter-reset: list-9;
    }
    .ql-editor ol li.ql-indent-9 {
      counter-increment: list-9;
    }
    .ql-editor ol li.ql-indent-9:before {
      content: counter(list-9, decimal) '. ';
    }
    .ql-editor .ql-indent-1:not(.ql-direction-rtl) {
      padding-left: 3em;
    }
    .ql-editor li.ql-indent-1:not(.ql-direction-rtl) {
      padding-left: 4.5em;
    }
    .ql-editor .ql-indent-1.ql-direction-rtl.ql-align-right {
      padding-right: 3em;
    }
    .ql-editor li.ql-indent-1.ql-direction-rtl.ql-align-right {
      padding-right: 4.5em;
    }
    .ql-editor .ql-indent-2:not(.ql-direction-rtl) {
      padding-left: 6em;
    }
    .ql-editor li.ql-indent-2:not(.ql-direction-rtl) {
      padding-left: 7.5em;
    }
    .ql-editor .ql-indent-2.ql-direction-rtl.ql-align-right {
      padding-right: 6em;
    }
    .ql-editor li.ql-indent-2.ql-direction-rtl.ql-align-right {
      padding-right: 7.5em;
    }
    .ql-editor .ql-indent-3:not(.ql-direction-rtl) {
      padding-left: 9em;
    }
    .ql-editor li.ql-indent-3:not(.ql-direction-rtl) {
      padding-left: 10.5em;
    }
    .ql-editor .ql-indent-3.ql-direction-rtl.ql-align-right {
      padding-right: 9em;
    }
    .ql-editor li.ql-indent-3.ql-direction-rtl.ql-align-right {
      padding-right: 10.5em;
    }
    .ql-editor .ql-indent-4:not(.ql-direction-rtl) {
      padding-left: 12em;
    }
    .ql-editor li.ql-indent-4:not(.ql-direction-rtl) {
      padding-left: 13.5em;
    }
    .ql-editor .ql-indent-4.ql-direction-rtl.ql-align-right {
      padding-right: 12em;
    }
    .ql-editor li.ql-indent-4.ql-direction-rtl.ql-align-right {
      padding-right: 13.5em;
    }
    .ql-editor .ql-indent-5:not(.ql-direction-rtl) {
      padding-left: 15em;
    }
    .ql-editor li.ql-indent-5:not(.ql-direction-rtl) {
      padding-left: 16.5em;
    }
    .ql-editor .ql-indent-5.ql-direction-rtl.ql-align-right {
      padding-right: 15em;
    }
    .ql-editor li.ql-indent-5.ql-direction-rtl.ql-align-right {
      padding-right: 16.5em;
    }
    .ql-editor .ql-indent-6:not(.ql-direction-rtl) {
      padding-left: 18em;
    }
    .ql-editor li.ql-indent-6:not(.ql-direction-rtl) {
      padding-left: 19.5em;
    }
    .ql-editor .ql-indent-6.ql-direction-rtl.ql-align-right {
      padding-right: 18em;
    }
    .ql-editor li.ql-indent-6.ql-direction-rtl.ql-align-right {
      padding-right: 19.5em;
    }
    .ql-editor .ql-indent-7:not(.ql-direction-rtl) {
      padding-left: 21em;
    }
    .ql-editor li.ql-indent-7:not(.ql-direction-rtl) {
      padding-left: 22.5em;
    }
    .ql-editor .ql-indent-7.ql-direction-rtl.ql-align-right {
      padding-right: 21em;
    }
    .ql-editor li.ql-indent-7.ql-direction-rtl.ql-align-right {
      padding-right: 22.5em;
    }
    .ql-editor .ql-indent-8:not(.ql-direction-rtl) {
      padding-left: 24em;
    }
    .ql-editor li.ql-indent-8:not(.ql-direction-rtl) {
      padding-left: 25.5em;
    }
    .ql-editor .ql-indent-8.ql-direction-rtl.ql-align-right {
      padding-right: 24em;
    }
    .ql-editor li.ql-indent-8.ql-direction-rtl.ql-align-right {
      padding-right: 25.5em;
    }
    .ql-editor .ql-indent-9:not(.ql-direction-rtl) {
      padding-left: 27em;
    }
    .ql-editor li.ql-indent-9:not(.ql-direction-rtl) {
      padding-left: 28.5em;
    }
    .ql-editor .ql-indent-9.ql-direction-rtl.ql-align-right {
      padding-right: 27em;
    }
    .ql-editor li.ql-indent-9.ql-direction-rtl.ql-align-right {
      padding-right: 28.5em;
    }
    .ql-editor .ql-video {
      display: block;
      max-width: 100%;
    }
    .ql-editor .ql-video.ql-align-center {
      margin: 0 auto;
    }
    .ql-editor .ql-video.ql-align-right {
      margin: 0 0 0 auto;
    }
    .ql-editor .ql-bg-black {
      background-color: #000;
    }
    .ql-editor .ql-bg-red {
      background-color: #e60000;
    }
    .ql-editor .ql-bg-orange {
      background-color: #f90;
    }
    .ql-editor .ql-bg-yellow {
      background-color: #ff0;
    }
    .ql-editor .ql-bg-green {
      background-color: #008a00;
    }
    .ql-editor .ql-bg-blue {
      background-color: #06c;
    }
    .ql-editor .ql-bg-purple {
      background-color: #93f;
    }
    .ql-editor .ql-color-white {
      color: #fff;
    }
    .ql-editor .ql-color-red {
      color: #e60000;
    }
    .ql-editor .ql-color-orange {
      color: #f90;
    }
    .ql-editor .ql-color-yellow {
      color: #ff0;
    }
    .ql-editor .ql-color-green {
      color: #008a00;
    }
    .ql-editor .ql-color-blue {
      color: #06c;
    }
    .ql-editor .ql-color-purple {
      color: #93f;
    }
    .ql-editor .ql-font-serif {
      font-family: Georgia, Times New Roman, serif;
    }
    .ql-editor .ql-font-monospace {
      font-family: Monaco, Courier New, monospace;
    }
    .ql-editor .ql-size-small {
      font-size: 0.75em;
    }
    .ql-editor .ql-size-large {
      font-size: 1.5em;
    }
    .ql-editor .ql-size-huge {
      font-size: 2.5em;
    }
    .ql-editor .ql-direction-rtl {
      direction: rtl;
      text-align: inherit;
    }
    .ql-editor .ql-align-center {
      text-align: center;
    }
    .ql-editor .ql-align-justify {
      text-align: justify;
    }
    .ql-editor .ql-align-right {
      text-align: right;
    }
    .ql-editor.ql-blank::before {
      color: rgba(0, 0, 0, 0.6);
      content: attr(data-placeholder);
      font-style: italic;
      left: 15px;
      pointer-events: none;
      position: absolute;
      right: 15px;
    }
    .ql-snow.ql-toolbar:after,
    .ql-snow .ql-toolbar:after {
      clear: both;
      content: '';
      display: table;
    }
    .ql-snow.ql-toolbar button,
    .ql-snow .ql-toolbar button {
      background: none;
      border: none;
      cursor: pointer;
      display: inline-block;
      float: left;
      height: 24px;
      padding: 3px 5px;
      width: 28px;
    }
    .ql-snow.ql-toolbar button svg,
    .ql-snow .ql-toolbar button svg {
      float: left;
      height: 100%;
    }
    .ql-snow.ql-toolbar button:active:hover,
    .ql-snow .ql-toolbar button:active:hover {
      outline: none;
    }
    .ql-snow.ql-toolbar input.ql-image[type='file'],
    .ql-snow .ql-toolbar input.ql-image[type='file'] {
      display: none;
    }
    .ql-snow.ql-toolbar button:hover,
    .ql-snow .ql-toolbar button:hover,
    .ql-snow.ql-toolbar button:focus,
    .ql-snow .ql-toolbar button:focus,
    .ql-snow.ql-toolbar button.ql-active,
    .ql-snow .ql-toolbar button.ql-active,
    .ql-snow.ql-toolbar .ql-picker-label:hover,
    .ql-snow .ql-toolbar .ql-picker-label:hover,
    .ql-snow.ql-toolbar .ql-picker-label.ql-active,
    .ql-snow .ql-toolbar .ql-picker-label.ql-active,
    .ql-snow.ql-toolbar .ql-picker-item:hover,
    .ql-snow .ql-toolbar .ql-picker-item:hover,
    .ql-snow.ql-toolbar .ql-picker-item.ql-selected,
    .ql-snow .ql-toolbar .ql-picker-item.ql-selected {
      color: #06c;
    }
    .ql-snow.ql-toolbar button:hover .ql-fill,
    .ql-snow .ql-toolbar button:hover .ql-fill,
    .ql-snow.ql-toolbar button:focus .ql-fill,
    .ql-snow .ql-toolbar button:focus .ql-fill,
    .ql-snow.ql-toolbar button.ql-active .ql-fill,
    .ql-snow .ql-toolbar button.ql-active .ql-fill,
    .ql-snow.ql-toolbar .ql-picker-label:hover .ql-fill,
    .ql-snow .ql-toolbar .ql-picker-label:hover .ql-fill,
    .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-fill,
    .ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-fill,
    .ql-snow.ql-toolbar .ql-picker-item:hover .ql-fill,
    .ql-snow .ql-toolbar .ql-picker-item:hover .ql-fill,
    .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-fill,
    .ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-fill,
    .ql-snow.ql-toolbar button:hover .ql-stroke.ql-fill,
    .ql-snow .ql-toolbar button:hover .ql-stroke.ql-fill,
    .ql-snow.ql-toolbar button:focus .ql-stroke.ql-fill,
    .ql-snow .ql-toolbar button:focus .ql-stroke.ql-fill,
    .ql-snow.ql-toolbar button.ql-active .ql-stroke.ql-fill,
    .ql-snow .ql-toolbar button.ql-active .ql-stroke.ql-fill,
    .ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke.ql-fill,
    .ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke.ql-fill,
    .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke.ql-fill,
    .ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke.ql-fill,
    .ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke.ql-fill,
    .ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke.ql-fill,
    .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke.ql-fill,
    .ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke.ql-fill {
      fill: #06c;
    }
    .ql-snow.ql-toolbar button:hover .ql-stroke,
    .ql-snow .ql-toolbar button:hover .ql-stroke,
    .ql-snow.ql-toolbar button:focus .ql-stroke,
    .ql-snow .ql-toolbar button:focus .ql-stroke,
    .ql-snow.ql-toolbar button.ql-active .ql-stroke,
    .ql-snow .ql-toolbar button.ql-active .ql-stroke,
    .ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke,
    .ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke,
    .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke,
    .ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke,
    .ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke,
    .ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke,
    .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke,
    .ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke,
    .ql-snow.ql-toolbar button:hover .ql-stroke-miter,
    .ql-snow .ql-toolbar button:hover .ql-stroke-miter,
    .ql-snow.ql-toolbar button:focus .ql-stroke-miter,
    .ql-snow .ql-toolbar button:focus .ql-stroke-miter,
    .ql-snow.ql-toolbar button.ql-active .ql-stroke-miter,
    .ql-snow .ql-toolbar button.ql-active .ql-stroke-miter,
    .ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke-miter,
    .ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke-miter,
    .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke-miter,
    .ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke-miter,
    .ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke-miter,
    .ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke-miter,
    .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke-miter,
    .ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke-miter {
      stroke: #06c;
    }
    @media (pointer: coarse) {
      .ql-snow.ql-toolbar button:hover:not(.ql-active),
      .ql-snow .ql-toolbar button:hover:not(.ql-active) {
        color: #444;
      }
      .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-fill,
      .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-fill,
      .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke.ql-fill,
      .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke.ql-fill {
        fill: #444;
      }
      .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke,
      .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke,
      .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke-miter,
      .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke-miter {
        stroke: #444;
      }
    }
    .ql-snow {
      box-sizing: border-box;
    }
    .ql-snow * {
      box-sizing: border-box;
    }
    .ql-snow .ql-hidden {
      display: none;
    }
    .ql-snow .ql-out-bottom,
    .ql-snow .ql-out-top {
      visibility: hidden;
    }
    .ql-snow .ql-tooltip {
      position: absolute;
      transform: translateY(10px);
    }
    .ql-snow .ql-tooltip a {
      cursor: pointer;
      text-decoration: none;
    }
    .ql-snow .ql-tooltip.ql-flip {
      transform: translateY(-10px);
    }
    .ql-snow .ql-formats {
      display: inline-block;
      vertical-align: middle;
    }
    .ql-snow .ql-formats:after {
      clear: both;
      content: '';
      display: table;
    }
    .ql-snow .ql-stroke {
      fill: none;
      stroke: #444;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-width: 2;
    }
    .ql-snow .ql-stroke-miter {
      fill: none;
      stroke: #444;
      stroke-miterlimit: 10;
      stroke-width: 2;
    }
    .ql-snow .ql-fill,
    .ql-snow .ql-stroke.ql-fill {
      fill: #444;
    }
    .ql-snow .ql-empty {
      fill: none;
    }
    .ql-snow .ql-even {
      fill-rule: evenodd;
    }
    .ql-snow .ql-thin,
    .ql-snow .ql-stroke.ql-thin {
      stroke-width: 1;
    }
    .ql-snow .ql-transparent {
      opacity: 0.4;
    }
    .ql-snow .ql-direction svg:last-child {
      display: none;
    }
    .ql-snow .ql-direction.ql-active svg:last-child {
      display: inline;
    }
    .ql-snow .ql-direction.ql-active svg:first-child {
      display: none;
    }
    .ql-snow .ql-editor h1 {
      font-size: 2em;
    }
    .ql-snow .ql-editor h2 {
      font-size: 1.5em;
    }
    .ql-snow .ql-editor h3 {
      font-size: 1.17em;
    }
    .ql-snow .ql-editor h4 {
      font-size: 1em;
    }
    .ql-snow .ql-editor h5 {
      font-size: 0.83em;
    }
    .ql-snow .ql-editor h6 {
      font-size: 0.67em;
    }
    .ql-snow .ql-editor a {
      text-decoration: underline;
    }
    .ql-snow .ql-editor blockquote {
      border-left: 4px solid #ccc;
      margin-bottom: 5px;
      margin-top: 5px;
      padding-left: 16px;
    }
    .ql-snow .ql-editor code,
    .ql-snow .ql-editor pre {
      background-color: #f0f0f0;
      border-radius: 3px;
    }
    .ql-snow .ql-editor pre {
      white-space: pre-wrap;
      margin-bottom: 5px;
      margin-top: 5px;
      padding: 5px 10px;
    }
    .ql-snow .ql-editor code {
      font-size: 85%;
      padding: 2px 4px;
    }
    .ql-snow .ql-editor pre.ql-syntax {
      background-color: #23241f;
      color: #f8f8f2;
      overflow: visible;
    }
    .ql-snow .ql-editor img {
      max-width: 100%;
    }
    .ql-snow .ql-picker {
      color: #444;
      display: inline-block;
      float: left;
      font-size: 14px;
      font-weight: 500;
      height: 24px;
      position: relative;
      vertical-align: middle;
    }
    .ql-snow .ql-picker-label {
      cursor: pointer;
      display: inline-block;
      height: 100%;
      padding-left: 8px;
      padding-right: 2px;
      position: relative;
      width: 100%;
    }
    .ql-snow .ql-picker-label::before {
      display: inline-block;
      line-height: 22px;
    }
    .ql-snow .ql-picker-options {
      background-color: #fff;
      display: none;
      min-width: 100%;
      padding: 4px 8px;
      position: absolute;
      white-space: nowrap;
    }
    .ql-snow .ql-picker-options .ql-picker-item {
      cursor: pointer;
      display: block;
      padding-bottom: 5px;
      padding-top: 5px;
    }
    .ql-snow .ql-picker.ql-expanded .ql-picker-label {
      color: #ccc;
      z-index: 2;
    }
    .ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-fill {
      fill: #ccc;
    }
    .ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-stroke {
      stroke: #ccc;
    }
    .ql-snow .ql-picker.ql-expanded .ql-picker-options {
      display: block;
      margin-top: -1px;
      top: 100%;
      z-index: 1;
    }
    .ql-snow .ql-color-picker,
    .ql-snow .ql-icon-picker {
      width: 28px;
    }
    .ql-snow .ql-color-picker .ql-picker-label,
    .ql-snow .ql-icon-picker .ql-picker-label {
      padding: 2px 4px;
    }
    .ql-snow .ql-color-picker .ql-picker-label svg,
    .ql-snow .ql-icon-picker .ql-picker-label svg {
      right: 4px;
    }
    .ql-snow .ql-icon-picker .ql-picker-options {
      padding: 4px 0px;
    }
    .ql-snow .ql-icon-picker .ql-picker-item {
      height: 24px;
      width: 24px;
      padding: 2px 4px;
    }
    .ql-snow .ql-color-picker .ql-picker-options {
      padding: 3px 5px;
      width: 152px;
    }
    .ql-snow .ql-color-picker .ql-picker-item {
      border: 1px solid transparent;
      float: left;
      height: 16px;
      margin: 2px;
      padding: 0px;
      width: 16px;
    }
    .ql-snow .ql-picker:not(.ql-color-picker):not(.ql-icon-picker) svg {
      position: absolute;
      margin-top: -9px;
      right: 0;
      top: 50%;
      width: 18px;
    }
    .ql-snow .ql-picker.ql-header .ql-picker-label[data-label]:not([data-label=''])::before,
    .ql-snow .ql-picker.ql-font .ql-picker-label[data-label]:not([data-label=''])::before,
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-label]:not([data-label=''])::before,
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-label]:not([data-label=''])::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item[data-label]:not([data-label=''])::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-label]:not([data-label=''])::before {
      content: attr(data-label);
    }
    .ql-snow .ql-picker.ql-header {
      width: 98px;
    }
    .ql-snow .ql-picker.ql-header .ql-picker-label::before,
    .ql-snow .ql-picker.ql-header .ql-picker-item::before {
      content: 'Normal';
    }
    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='1']::before,
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='1']::before {
      content: 'Heading 1';
    }
    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='2']::before,
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='2']::before {
      content: 'Heading 2';
    }
    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='3']::before,
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='3']::before {
      content: 'Heading 3';
    }
    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='4']::before,
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='4']::before {
      content: 'Heading 4';
    }
    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='5']::before,
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='5']::before {
      content: 'Heading 5';
    }
    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='6']::before,
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='6']::before {
      content: 'Heading 6';
    }
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='1']::before {
      font-size: 2em;
    }
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='2']::before {
      font-size: 1.5em;
    }
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='3']::before {
      font-size: 1.17em;
    }
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='4']::before {
      font-size: 1em;
    }
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='5']::before {
      font-size: 0.83em;
    }
    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='6']::before {
      font-size: 0.67em;
    }
    .ql-snow .ql-picker.ql-font {
      width: 108px;
    }
    .ql-snow .ql-picker.ql-font .ql-picker-label::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item::before {
      content: 'Sans Serif';
    }
    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value='serif']::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value='serif']::before {
      content: 'Serif';
    }
    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value='monospace']::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value='monospace']::before {
      content: 'Monospace';
    }
    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value='serif']::before {
      font-family: Georgia, Times New Roman, serif;
    }
    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value='monospace']::before {
      font-family: Monaco, Courier New, monospace;
    }
    .ql-snow .ql-picker.ql-size {
      width: 98px;
    }
    .ql-snow .ql-picker.ql-size .ql-picker-label::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item::before {
      content: 'Normal';
    }
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value='small']::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='small']::before {
      content: 'Small';
    }
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value='large']::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='large']::before {
      content: 'Large';
    }
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value='huge']::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='huge']::before {
      content: 'Huge';
    }
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='small']::before {
      font-size: 10px;
    }
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='large']::before {
      font-size: 18px;
    }
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='huge']::before {
      font-size: 32px;
    }
    .ql-snow .ql-color-picker.ql-background .ql-picker-item {
      background-color: #fff;
    }
    .ql-snow .ql-color-picker.ql-color .ql-picker-item {
      background-color: #000;
    }
    .ql-toolbar.ql-snow {
      border: 1px solid #ccc;
      box-sizing: border-box;
      font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
      padding: 8px;
    }
    .ql-toolbar.ql-snow .ql-formats {
      margin-right: 15px;
    }
    .ql-toolbar.ql-snow .ql-picker-label {
      border: 1px solid transparent;
    }
    .ql-toolbar.ql-snow .ql-picker-options {
      border: 1px solid transparent;
      box-shadow: rgba(0, 0, 0, 0.2) 0 2px 8px;
    }
    .ql-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-label {
      border-color: #ccc;
    }
    .ql-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options {
      border-color: #ccc;
    }
    .ql-toolbar.ql-snow .ql-color-picker .ql-picker-item.ql-selected,
    .ql-toolbar.ql-snow .ql-color-picker .ql-picker-item:hover {
      border-color: #000;
    }
    .ql-toolbar.ql-snow + .ql-container.ql-snow {
      border-top: 0px;
    }
    .ql-snow .ql-tooltip {
      background-color: #fff;
      border: 1px solid #ccc;
      box-shadow: 0px 0px 5px #ddd;
      color: #444;
      padding: 5px 12px;
      white-space: nowrap;
    }
    .ql-snow .ql-tooltip::before {
      content: 'Visit URL:';
      line-height: 26px;
      margin-right: 8px;
    }
    .ql-snow .ql-tooltip input[type='text'] {
      display: none;
      border: 1px solid #ccc;
      font-size: 13px;
      height: 26px;
      margin: 0px;
      padding: 3px 5px;
      width: 170px;
    }
    .ql-snow .ql-tooltip a.ql-preview {
      display: inline-block;
      max-width: 200px;
      overflow-x: hidden;
      text-overflow: ellipsis;
      vertical-align: top;
    }
    .ql-snow .ql-tooltip a.ql-action::after {
      border-right: 1px solid #ccc;
      content: 'Edit';
      margin-left: 16px;
      padding-right: 8px;
    }
    .ql-snow .ql-tooltip a.ql-remove::before {
      content: 'Remove';
      margin-left: 8px;
    }
    .ql-snow .ql-tooltip a {
      line-height: 26px;
    }
    .ql-snow .ql-tooltip.ql-editing a.ql-preview,
    .ql-snow .ql-tooltip.ql-editing a.ql-remove {
      display: none;
    }
    .ql-snow .ql-tooltip.ql-editing input[type='text'] {
      display: inline-block;
    }
    .ql-snow .ql-tooltip.ql-editing a.ql-action::after {
      border-right: 0px;
      content: 'Save';
      padding-right: 0px;
    }
    .ql-snow .ql-tooltip[data-mode='link']::before {
      content: 'Enter link:';
    }
    .ql-snow .ql-tooltip[data-mode='formula']::before {
      content: 'Enter formula:';
    }
    .ql-snow .ql-tooltip[data-mode='video']::before {
      content: 'Enter video:';
    }
    .ql-snow a {
      color: #06c;
    }
    .ql-container.ql-snow {
      border: 1px solid #ccc;
    }
  </style>
`;

/**
 * Parâmetros de inicialização de edição de documento
 */
class LexmlEmendaParametrosEdicao {
    constructor() {
        this.modo = 'Emenda';
        // Preenchido automaticamente se for informada a emenda ou o projetoNorma
        this.ementa = '';
        // Motivo de uma nova emenda de texto livre
        // Preenchido automaticamente se for informada a emenda
        this.motivo = '';
    }
}
let LexmlEmendaComponent = class LexmlEmendaComponent extends connect(rootStore)(s) {
    constructor() {
        super();
        this.existeObserverEmenda = false;
        this.totalAlertas = 0;
        this.exibirAjuda = true;
        this.parlamentares = [];
        this.lexmlEmendaConfig = new LexmlEmendaConfig();
        this.modo = ClassificacaoDocumento.EMENDA;
        this.urn = '';
        this.ementa = '';
        this.motivo = '';
        this.autoria = new Autoria();
        this.desativarMarcaRevisao = () => {
            if (rootStore.getState().elementoReducer.emRevisao) {
                rootStore.dispatch(ativarDesativarRevisaoAction.execute());
            }
        };
        this.MOBILE_WIDTH = 768;
        this.splitPanelPosition = 68;
        this.sizeMode = '';
        this.handleResize = () => {
            this.updateLayoutSplitPanel();
            this.ajustarAltura();
        };
    }
    async getParlamentares() {
        try {
            const _response = await fetch(this.lexmlEmendaConfig.urlConsultaParlamentares);
            const _parlamentares = await _response.json();
            return _parlamentares.map(p => ({
                identificacao: p.id + '',
                nome: p.nome,
                sexo: p.sexo,
                siglaPartido: p.siglaPartido,
                siglaUF: p.siglaUF,
                siglaCasaLegislativa: p.siglaCasa,
            }));
        }
        catch (err) {
            console.log('Erro inesperado ao carregar lista de parlamentares');
            console.log(err);
        }
        return Promise.resolve([]);
    }
    atualizaListaParlamentares() {
        this.getParlamentares().then(parlamentares => (this.parlamentares = parlamentares));
    }
    montarColegiadoApreciador(sigla, numero, ano) {
        if (sigla.toUpperCase() === 'MPV') {
            return {
                siglaCasaLegislativa: 'CN',
                tipoColegiado: 'Comissão',
                siglaComissao: `CMMPV ${numero}/${ano}`,
            };
        }
        // Inicialmente registra destino plenário do SF para demais matérias
        return {
            siglaCasaLegislativa: 'SF',
            tipoColegiado: 'Plenário',
        };
    }
    montarLocalFromColegiadoApreciador(colegiado) {
        return colegiado.tipoColegiado === 'Comissão' ? 'Sala da comissão' : 'Sala das sessões';
    }
    montarEmendaBasica() {
        const emenda = new Emenda();
        emenda.modoEdicao = this.modo;
        emenda.componentes[0].urn = this.urn;
        if (this.urn) {
            emenda.proposicao = {
                urn: this.urn,
                sigla: getSigla(this.urn),
                numero: getNumero(this.urn),
                ano: getAno(this.urn),
                ementa: this.ementa,
                identificacaoTexto: 'Texto inicial',
            };
        }
        return emenda;
    }
    getEmenda() {
        // Para evitar erros de referência nula quando chamado antes da inicialização do componente
        if (!this.urn) {
            return new Emenda();
        }
        const emenda = this.montarEmendaBasica();
        const numeroProposicao = emenda.proposicao.numero.replace(/^0+/, '');
        if (!this.isEmendaTextoLivre()) {
            emenda.componentes[0].dispositivos = this._lexmlEta.getDispositivosEmenda();
            emenda.comandoEmenda = this._lexmlEta.getComandoEmenda();
            emenda.comandoEmendaTextoLivre.motivo = undefined;
            emenda.comandoEmendaTextoLivre.texto = undefined;
        }
        else {
            emenda.comandoEmendaTextoLivre.motivo = this.motivo;
            emenda.comandoEmendaTextoLivre.texto = this._lexmlEmendaTextoRico.texto;
            emenda.anexos = this._lexmlEmendaTextoRico.anexos;
        }
        emenda.justificativa = this._lexmlJustificativa.texto;
        emenda.autoria = this._lexmlAutoria.getAutoriaAtualizada();
        emenda.data = this._lexmlData.data || undefined;
        emenda.opcoesImpressao = this._lexmlOpcoesImpressao.opcoesImpressao;
        emenda.colegiadoApreciador = this.montarColegiadoApreciador(emenda.proposicao.sigla, numeroProposicao, emenda.proposicao.ano);
        emenda.epigrafe = new Epigrafe();
        emenda.epigrafe.texto = 'EMENDA Nº         ';
        if (emenda.colegiadoApreciador.siglaComissao) {
            emenda.epigrafe.texto += `- ${emenda.colegiadoApreciador.siglaComissao}`;
        }
        const generoProposicao = generoFromLetra(getTipo$1(emenda.proposicao.urn).genero);
        emenda.epigrafe.complemento = `(${generoProposicao.artigoDefinidoPrecedidoPreposicaoASingular.trim()} ${emenda.proposicao.sigla} ${numeroProposicao}/${emenda.proposicao.ano})`;
        emenda.local = this.montarLocalFromColegiadoApreciador(emenda.colegiadoApreciador);
        emenda.revisoes = this.getRevisoes();
        return emenda;
    }
    getRevisoes() {
        const revisoes = ordernarRevisoes([...rootStore.getState().elementoReducer.revisoes]);
        revisoes.filter(isRevisaoElemento).forEach(r => {
            const re = r;
            removeAtributosDoElemento(re.elementoAposRevisao);
            re.elementoAntesRevisao && removeAtributosDoElemento(re.elementoAntesRevisao);
        });
        return revisoes;
    }
    inicializarEdicao(params) {
        var _a, _b, _c;
        this._lexmlEmendaComando.emenda = [];
        this.modo = params.modo;
        this.projetoNorma = params.projetoNorma;
        this.inicializaProposicao(params);
        this.motivo = params.motivo;
        if (this.isEmendaTextoLivre() && params.emenda) {
            this.motivo = params.emenda.comandoEmendaTextoLivre.motivo || 'Motivo não informado na emenda';
        }
        if (!this.isEmendaTextoLivre()) {
            this._lexmlEta.inicializarEdicao(this.modo, this.urn, params.projetoNorma, !!params.emenda);
        }
        if (params.emenda) {
            this.setEmenda(params.emenda);
        }
        else {
            this.resetaEmenda(this.modo);
        }
        this.limparAlertas();
        if (this.isEmendaTextoLivre() && !this._lexmlEmendaTextoRico.texto) {
            this.showAlertaEmendaTextoLivre();
        }
        this.setUsuario((_a = params.usuario) !== null && _a !== void 0 ? _a : rootStore.getState().elementoReducer.usuario);
        setTimeout(this.handleResize, 0);
        if (!((_c = (_b = params.emenda) === null || _b === void 0 ? void 0 : _b.revisoes) === null || _c === void 0 ? void 0 : _c.length)) {
            this.desativarMarcaRevisao();
        }
        this._tabsEsquerda.show('lexml-eta');
        if (this.modo.startsWith('emenda') && !this.isEmendaTextoLivre()) {
            this._tabsDireita.show('comando');
        }
        this.updateView();
    }
    inicializaProposicao(params) {
        if (params.proposicao) {
            // Preferência para a proposição informada
            this.urn = buildFakeUrn(params.proposicao.sigla, params.proposicao.numero, params.proposicao.ano);
            this.ementa = params.proposicao.ementa; // Preferência para a ementa informada
        }
        // Se não forem informados, utilizar da Emenda
        if (params.emenda) {
            if (!this.urn) {
                this.urn = params.emenda.proposicao.urn;
            }
            if (!this.ementa) {
                this.ementa = params.emenda.proposicao.ementa;
            }
        }
        // Por último do ProjetoNorma
        if (this.projetoNorma) {
            if (!this.urn) {
                this.urn = getUrn(this.projetoNorma);
            }
            if (!this.ementa) {
                this.ementa = this.getEmentaFromProjetoNorma(this.projetoNorma);
            }
        }
    }
    getEmentaFromProjetoNorma(projetoNorma) {
        var _a, _b, _c, _d;
        return buildContent$1((_d = (_c = (_b = (_a = projetoNorma.value) === null || _a === void 0 ? void 0 : _a.projetoNorma) === null || _b === void 0 ? void 0 : _b.norma) === null || _c === void 0 ? void 0 : _c.parteInicial) === null || _d === void 0 ? void 0 : _d.ementa.content);
    }
    stateChanged(state) {
        var _a, _b, _c, _d, _e, _f;
        const revisaoAtivada = (_c = (_b = (_a = state === null || state === void 0 ? void 0 : state.elementoReducer) === null || _a === void 0 ? void 0 : _a.ui) === null || _b === void 0 ? void 0 : _b.events) === null || _c === void 0 ? void 0 : _c.some((ev) => ev.stateType === StateType.RevisaoAtivada);
        const revisaoDesativada = (_f = (_e = (_d = state === null || state === void 0 ? void 0 : state.elementoReducer) === null || _d === void 0 ? void 0 : _d.ui) === null || _e === void 0 ? void 0 : _e.events) === null || _f === void 0 ? void 0 : _f.some((ev) => ev.stateType === StateType.RevisaoDesativada);
        revisaoAtivada && this.mostrarDialogDisclaimerRevisao();
        if (revisaoAtivada || revisaoDesativada) {
            this.emitiEventoOnRevisao(rootStore.getState().elementoReducer.emRevisao);
        }
    }
    emitiEventoOnRevisao(emRevisao) {
        this.dispatchEvent(new CustomEvent('onrevisao', {
            bubbles: true,
            composed: true,
            detail: {
                emRevisao,
            },
        }));
    }
    setUsuario(usuario = new Usuario()) {
        rootStore.dispatch(atualizarUsuarioAction.execute(usuario));
    }
    setEmenda(emenda) {
        if (!this.isEmendaTextoLivre()) {
            this._lexmlEta.setDispositivosERevisoesEmenda(emenda.componentes[0].dispositivos, emenda.revisoes);
        }
        this._lexmlAutoria.autoria = emenda.autoria;
        this._lexmlOpcoesImpressao.opcoesImpressao = emenda.opcoesImpressao;
        this._lexmlJustificativa.setContent(emenda.justificativa);
        if (this.isEmendaTextoLivre()) {
            this._lexmlEmendaTextoRico.setContent((emenda === null || emenda === void 0 ? void 0 : emenda.comandoEmendaTextoLivre.texto) || '');
            this._lexmlEmendaTextoRico.anexos = emenda.anexos || [];
            rootStore.dispatch(aplicarAlteracoesEmendaAction.execute(emenda.componentes[0].dispositivos, emenda.revisoes));
        }
        this._lexmlData.data = emenda.data;
    }
    resetaEmenda(modoEdicao = ModoEdicaoEmenda.EMENDA) {
        const emenda = new Emenda();
        emenda.modoEdicao = modoEdicao;
        this._lexmlEmendaComando.emenda = {};
        this.setEmenda(emenda);
        rootStore.dispatch(limparRevisaoAction.execute());
    }
    createRenderRoot() {
        return this;
    }
    updateLayoutSplitPanel(forceUpdate = false) {
        if (this.modo.startsWith('emenda') && !this.isEmendaTextoLivre()) {
            if (this.sizeMode === 'desktop') {
                this.slSplitPanel.position = this.splitPanelPosition;
            }
            if (window.innerWidth <= this.MOBILE_WIDTH && (this.sizeMode !== 'mobile' || forceUpdate)) {
                this.sizeMode = 'mobile';
                this.slSplitPanel.position = 100;
                this.slSplitPanel.setAttribute('disabled', 'true');
            }
            else if (window.innerWidth > this.MOBILE_WIDTH && (this.sizeMode !== 'desktop' || forceUpdate)) {
                this.sizeMode = 'desktop';
                this.slSplitPanel.position = this.splitPanelPosition;
                this.slSplitPanel.removeAttribute('disabled');
            }
        }
        else {
            this.slSplitPanel.position = 100;
        }
    }
    // Documentação de tratamento de eventos no Lit
    // https://lit.dev/docs/components/events/
    connectedCallback() {
        super.connectedCallback();
        window.addEventListener('resize', this.handleResize);
    }
    disconnectedCallback() {
        window.removeEventListener('resize', this.handleResize);
        super.disconnectedCallback();
    }
    firstUpdated() {
        var _a, _b, _c;
        setTimeout(() => this.atualizaListaParlamentares(), 5000);
        (_a = this._tabsEsquerda) === null || _a === void 0 ? void 0 : _a.addEventListener('sl-tab-show', (event) => {
            const tabName = event.detail.name;
            if (tabName === 'avisos') {
                const badge = event.target.querySelector('sl-badge');
                if (badge) {
                    badge.pulse = false;
                }
            }
            else if (tabName === 'autoria') {
                this.parlamentares.length === 0 && this.atualizaListaParlamentares();
            }
        });
        this.slSplitPanel.addEventListener('sl-reposition', () => {
            this.ajustarAltura();
        });
        const badgeAtalhos = (_b = this._tabsDireita) === null || _b === void 0 ? void 0 : _b.querySelector('#badgeAtalhos');
        if (badgeAtalhos) {
            const naoPulsarBadgeAtalhos = localStorage.getItem('naoPulsarBadgeAtalhos');
            if (!naoPulsarBadgeAtalhos) {
                badgeAtalhos.pulse = true;
                badgeAtalhos.setAttribute('variant', 'warning');
            }
        }
        (_c = this._tabsDireita) === null || _c === void 0 ? void 0 : _c.addEventListener('sl-tab-show', (event) => {
            const tabName = event.detail.name;
            if (tabName === 'atalhos') {
                const badge = event.target.querySelector('sl-badge');
                if (badge) {
                    badge.pulse = false;
                    badge.setAttribute('variant', 'primmay');
                }
                localStorage.setItem('naoPulsarBadgeAtalhos', 'true');
            }
        });
    }
    updated() {
        if (this.modo.startsWith('emenda') && !this.isEmendaTextoLivre()) {
            this.slSplitPanel.removeAttribute('disabled');
            this.slSplitPanel.position = this.splitPanelPosition;
        }
        else {
            this.slSplitPanel.setAttribute('disabled', 'true');
            this.slSplitPanel.position = 100;
        }
    }
    pesquisarAlturaParentElement(elemento) {
        if (elemento.parentElement === null) {
            // chegou no HTML e não encontrou altura
            return 0;
        }
        else {
            const minHeight = getComputedStyle(this).getPropertyValue('--min-height').replace('px', '');
            if (elemento.clientHeight >= minHeight) {
                return elemento.clientHeight;
            }
            else {
                return this.pesquisarAlturaParentElement(elemento.parentElement);
            }
        }
    }
    ajustarAltura(altura) {
        var _a, _b;
        const alturaElementoBase = altura !== null && altura !== void 0 ? altura : this.pesquisarAlturaParentElement(this);
        const lexmlEtaTabs = (_b = (_a = document.querySelector('sl-tab-group')) === null || _a === void 0 ? void 0 : _a.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector('.tab-group__nav-container');
        const alturaLexmlEtaTabs = lexmlEtaTabs === null || lexmlEtaTabs === void 0 ? void 0 : lexmlEtaTabs.clientHeight;
        if (!alturaLexmlEtaTabs)
            return false;
        const alturaElemento = alturaElementoBase - alturaLexmlEtaTabs - 12;
        if (alturaElemento <= 0)
            return false;
        const getElement = (selector) => document.querySelector(selector);
        const justificativaTabPanel = getElement('sl-tab-panel[name="justificativa"]');
        const emendaTabPanel = getElement('sl-tab-panel[name="lexml-eta"]');
        const qlToolbarJustificativa = getElement('#editor-texto-rico-justificativa .ql-toolbar');
        const qlToolbarEmenda = getElement('#lx-eta-barra-ferramenta');
        const estilosOriginais = {
            justificativa: {
                display: justificativaTabPanel.style.display,
                opacity: justificativaTabPanel.style.opacity,
                pointerEvents: justificativaTabPanel.style.pointerEvents,
            },
            emenda: {
                display: emendaTabPanel.style.display,
                opacity: emendaTabPanel.style.opacity,
                pointerEvents: emendaTabPanel.style.pointerEvents,
            },
        };
        const setTabPanelStyles = (tabPanel, estilos, isTemporary = false) => {
            if (isTemporary) {
                tabPanel.style.opacity = '0';
                tabPanel.style.pointerEvents = 'none';
                tabPanel.style.display = 'block';
            }
            else {
                tabPanel.style.opacity = estilos.opacity;
                tabPanel.style.pointerEvents = estilos.pointerEvents;
                tabPanel.style.display = estilos.display;
            }
        };
        if (estilosOriginais.justificativa.display === 'none') {
            setTabPanelStyles(justificativaTabPanel, estilosOriginais.justificativa, true);
        }
        if (estilosOriginais.emenda.display === 'none') {
            setTabPanelStyles(emendaTabPanel, estilosOriginais.emenda, true);
        }
        const alturaToolBarJustificativa = (qlToolbarJustificativa === null || qlToolbarJustificativa === void 0 ? void 0 : qlToolbarJustificativa.clientHeight) + 10;
        const alturaToolBarEmenda = (qlToolbarEmenda === null || qlToolbarEmenda === void 0 ? void 0 : qlToolbarEmenda.clientHeight) + 10;
        setTabPanelStyles(justificativaTabPanel, estilosOriginais.justificativa);
        setTabPanelStyles(emendaTabPanel, estilosOriginais.emenda);
        this.style.setProperty('--heightJustificativa', `${alturaElemento - alturaToolBarJustificativa}px`);
        this.style.setProperty('--heightEmenda', `${alturaElemento - alturaToolBarEmenda}px`);
        this.style.setProperty('--height', `${alturaElemento}px`);
        this.style.setProperty('--overflow', 'hidden');
        return true;
    }
    onChange() {
        var _a;
        if (this.modo.startsWith('emenda') && !this.isEmendaTextoLivre()) {
            const comandoEmenda = this._lexmlEta.getComandoEmenda();
            this._lexmlEmendaComando.emenda = comandoEmenda;
            this._lexmlEmendaComandoModal.atualizarComandoEmenda(comandoEmenda);
            if (((_a = comandoEmenda.comandos) === null || _a === void 0 ? void 0 : _a.length) > 0 && !this._lexmlJustificativa.texto) {
                const alerta = {
                    id: 'alerta-global-justificativa',
                    tipo: 'error',
                    mensagem: 'A emenda não possui uma justificação',
                    podeFechar: false,
                };
                rootStore.dispatch(adicionarAlerta$1(alerta));
            }
            else {
                rootStore.dispatch(removerAlerta('alerta-global-justificativa'));
            }
        }
        else if (this.isEmendaTextoLivre()) {
            if (!this._lexmlEmendaTextoRico.texto) {
                this.showAlertaEmendaTextoLivre();
            }
            else {
                rootStore.dispatch(removerAlerta('alerta-global-emenda-texto-livre'));
            }
        }
    }
    limparAlertas() {
        rootStore.dispatch(limparAlertas$1());
    }
    showAlertaEmendaTextoLivre() {
        const alerta = {
            id: 'alerta-global-emenda-texto-livre',
            tipo: 'error',
            mensagem: 'O comando de emenda deve ser preenchido.',
            podeFechar: false,
        };
        rootStore.dispatch(adicionarAlerta$1(alerta));
    }
    mostrarDialogDisclaimerRevisao() {
        mostrarDialogDisclaimerRevisao();
    }
    isEmendaTextoLivre() {
        return this.modo && this.modo === 'emendaTextoLivre';
    }
    updateView() {
        this.updateState = new Date();
    }
    render() {
        return $ `
      ${shoelaceLightThemeStyles} ${quillSnowStyles} ${editorStyles}
      <style>
        :root {
          --height: 100%;
          --overflow: visible;
          --min-height: 300px;
          --heightJustificativa: 100%;
          --heightEmenda: 100%;
        }
        sl-tab-panel {
          --padding: 0px;
        }
        sl-tab-panel::part(base) {
          height: var(--height);
        }
        sl-tab-panel.overflow-hidden::part(base) {
          overflow-y: auto;
        }
        lexml-emenda-comando {
          font-family: var(--eta-font-serif);
          display: ${this.modo.startsWith('emenda') && !this.isEmendaTextoLivre() ? 'block' : 'none'};
          height: 100%;
        }
        lexml-eta {
          font-family: var(--eta-font-serif);
          text-align: left;
        }
        /* #editor-texto-rico-justificativa #editor-texto-rico {
          height: calc(var(--height) - 44px);
          overflow: var(--overflow);
        } */

        #editor-texto-rico-emenda-inner {
          height: calc(var(--heightJustificativa));
          overflow: var(--overflow);
        }
        #editor-texto-rico-justificativa-inner {
          height: calc(var(--heightJustificativa));
          overflow: var(--overflow);
        }
        .badge-pulse {
          margin-left: 7px;
          height: 16px;
          margin-top: -4px;
        }

        #badgeAtalhos::part(base) {
          height: 16px;
          margin-top: 2px;
          font-size: var(--sl-font-size-small);
          background-color: transparent;
          color: var(--sl-color-neutral-600);
        }
        sl-tab[panel='atalhos'][active] #badgeAtalhos::part(base) {
          color: var(--sl-color-primary-600);
        }

        sl-split-panel {
          --divider-width: ${this.modo.startsWith('emenda') && !this.isEmendaTextoLivre() ? '15px' : '0px'};
        }
        sl-tab sl-icon {
          margin-right: 5px;
          font-size: 18px;
        }
        .tab-autoria__container {
          padding: 10px;
        }
        @media (max-width: 768px) {
          sl-split-panel {
            --divider-width: 0px;
          }
        }
      </style>

      <sl-split-panel>
        <sl-icon slot="handle" name="grip-vertical"></sl-icon>
        <div slot="start">
          <sl-tab-group id="tabs-esquerda">
            <sl-tab slot="nav" panel="lexml-eta">Texto</sl-tab>
            <sl-tab slot="nav" panel="justificativa">Justificação</sl-tab>
            <sl-tab slot="nav" panel="autoria">Data, Autoria e Impressão</sl-tab>
            <sl-tab slot="nav" panel="avisos">
              Avisos
              <div class="badge-pulse" id="contadorAvisos">${this.totalAlertas > 0 ? $ ` <sl-badge variant="danger" pill pulse>${this.totalAlertas}</sl-badge> ` : ''}</div>
            </sl-tab>
            <sl-tab-panel name="lexml-eta" class="overflow-hidden">
              <lexml-eta
                style="display: ${!this.isEmendaTextoLivre() ? 'block' : 'none'}"
                id="lexmlEta"
                .lexmlEtaConfig=${this.lexmlEmendaConfig}
                @onchange=${this.onChange}
              ></lexml-eta>
              <editor-texto-rico
                style="display: ${this.isEmendaTextoLivre() ? 'block' : 'none'}"
                modo="textoLivre"
                id="editor-texto-rico-emenda"
                registroEvento="justificativa"
                @onchange=${this.onChange}
              ></editor-texto-rico>
            </sl-tab-panel>
            <sl-tab-panel name="justificativa" class="overflow-hidden">
              <editor-texto-rico modo="justificativa" id="editor-texto-rico-justificativa" registroEvento="justificativa" @onchange=${this.onChange}></editor-texto-rico>
            </sl-tab-panel>
            <sl-tab-panel name="autoria" class="overflow-hidden">
              <div class="tab-autoria__container">
                <lexml-data></lexml-data>
                <br />
                <lexml-autoria .parlamentares=${this.parlamentares}></lexml-autoria>
                <lexml-opcoes-impressao></lexml-opcoes-impressao>
              </div>
            </sl-tab-panel>
            <sl-tab-panel name="avisos" class="overflow-hidden">
              <lexml-eta-alertas></lexml-eta-alertas>
            </sl-tab-panel>
          </sl-tab-group>
        </div>
        <div slot="end">
          <sl-tab-group id="tabs-direita">
            <sl-tab slot="nav" panel="comando">
              <sl-icon name="code"></sl-icon>
              Comando
            </sl-tab>
            <sl-tab slot="nav" panel="dicas">
              <sl-icon name="lightbulb"></sl-icon>
              Dicas
            </sl-tab>
            <sl-tab slot="nav" panel="atalhos">
              <sl-badge variant="primary" id="badgeAtalhos" pill>
                <sl-icon name="keyboard"></sl-icon>
                Atalhos
              </sl-badge>
            </sl-tab>
            <sl-tab-panel name="comando" class="overflow-hidden">
              <lexml-emenda-comando></lexml-emenda-comando>
            </sl-tab-panel>
            <sl-tab-panel name="dicas" class="overflow-hidden">
              <lexml-ajuda></lexml-ajuda>
            </sl-tab-panel>
            <sl-tab-panel name="atalhos" class="overflow-hidden">
              <lexml-eta-atalhos></lexml-eta-atalhos>
            </sl-tab-panel>
          </sl-tab-group>
        </div>
      </sl-split-panel>
    `;
    }
};
__decorate([
    e$3({ type: Boolean })
], LexmlEmendaComponent.prototype, "existeObserverEmenda", void 0);
__decorate([
    e$3({ type: Number })
], LexmlEmendaComponent.prototype, "totalAlertas", void 0);
__decorate([
    e$3({ type: Boolean })
], LexmlEmendaComponent.prototype, "exibirAjuda", void 0);
__decorate([
    e$3({ type: Array })
], LexmlEmendaComponent.prototype, "parlamentares", void 0);
__decorate([
    e$3({ type: Object })
], LexmlEmendaComponent.prototype, "lexmlEmendaConfig", void 0);
__decorate([
    t$1()
], LexmlEmendaComponent.prototype, "updateState", void 0);
__decorate([
    t$1()
], LexmlEmendaComponent.prototype, "autoria", void 0);
__decorate([
    i$1('lexml-eta')
], LexmlEmendaComponent.prototype, "_lexmlEta", void 0);
__decorate([
    i$1('#editor-texto-rico-emenda')
], LexmlEmendaComponent.prototype, "_lexmlEmendaTextoRico", void 0);
__decorate([
    i$1('#editor-texto-rico-justificativa')
], LexmlEmendaComponent.prototype, "_lexmlJustificativa", void 0);
__decorate([
    i$1('lexml-autoria')
], LexmlEmendaComponent.prototype, "_lexmlAutoria", void 0);
__decorate([
    i$1('lexml-data')
], LexmlEmendaComponent.prototype, "_lexmlData", void 0);
__decorate([
    i$1('lexml-opcoes-impressao')
], LexmlEmendaComponent.prototype, "_lexmlOpcoesImpressao", void 0);
__decorate([
    i$1('#tabs-esquerda')
], LexmlEmendaComponent.prototype, "_tabsEsquerda", void 0);
__decorate([
    i$1('#tabs-direita')
], LexmlEmendaComponent.prototype, "_tabsDireita", void 0);
__decorate([
    i$1('lexml-emenda-comando')
], LexmlEmendaComponent.prototype, "_lexmlEmendaComando", void 0);
__decorate([
    i$1('lexml-emenda-comando-modal')
], LexmlEmendaComponent.prototype, "_lexmlEmendaComandoModal", void 0);
__decorate([
    i$1('sl-split-panel')
], LexmlEmendaComponent.prototype, "slSplitPanel", void 0);
LexmlEmendaComponent = __decorate([
    n$1('lexml-emenda')
], LexmlEmendaComponent);

// src/components/alert/alert.styles.ts
var alert_styles_default = r$5`
  ${component_styles_default}

  :host {
    display: contents;

    /* For better DX, we'll reset the margin here so the base part can inherit it */
    margin: 0;
  }

  .alert {
    position: relative;
    display: flex;
    align-items: stretch;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-top-width: calc(var(--sl-panel-border-width) * 3);
    border-radius: var(--sl-border-radius-medium);
    box-shadow: var(--box-shadow);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-normal);
    line-height: 1.6;
    color: var(--sl-color-neutral-700);
    margin: inherit;
  }

  .alert:not(.alert--has-icon) .alert__icon,
  .alert:not(.alert--closable) .alert__close-button {
    display: none;
  }

  .alert__icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-large);
    padding-left: var(--sl-spacing-large);
  }

  .alert--primary {
    border-top-color: var(--sl-color-primary-600);
  }

  .alert--primary .alert__icon {
    color: var(--sl-color-primary-600);
  }

  .alert--success {
    border-top-color: var(--sl-color-success-600);
  }

  .alert--success .alert__icon {
    color: var(--sl-color-success-600);
  }

  .alert--neutral {
    border-top-color: var(--sl-color-neutral-600);
  }

  .alert--neutral .alert__icon {
    color: var(--sl-color-neutral-600);
  }

  .alert--warning {
    border-top-color: var(--sl-color-warning-600);
  }

  .alert--warning .alert__icon {
    color: var(--sl-color-warning-600);
  }

  .alert--danger {
    border-top-color: var(--sl-color-danger-600);
  }

  .alert--danger .alert__icon {
    color: var(--sl-color-danger-600);
  }

  .alert__message {
    flex: 1 1 auto;
    padding: var(--sl-spacing-large);
    overflow: hidden;
  }

  .alert__close-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-large);
    padding-right: var(--sl-spacing-medium);
  }
`;

// src/components/alert/alert.ts
var toastStack = Object.assign(document.createElement("div"), { className: "sl-toast-stack" });
var SlAlert = class extends s4 {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "icon", "suffix");
    this.open = false;
    this.closable = false;
    this.variant = "primary";
    this.duration = Infinity;
  }
  firstUpdated() {
    this.base.hidden = !this.open;
  }
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  async toast() {
    return new Promise((resolve) => {
      if (toastStack.parentElement === null) {
        document.body.append(toastStack);
      }
      toastStack.appendChild(this);
      requestAnimationFrame(() => {
        this.clientWidth;
        this.show();
      });
      this.addEventListener("sl-after-hide", () => {
        toastStack.removeChild(this);
        resolve();
        if (toastStack.querySelector("sl-alert") === null) {
          toastStack.remove();
        }
      }, { once: true });
    });
  }
  restartAutoHide() {
    clearTimeout(this.autoHideTimeout);
    if (this.open && this.duration < Infinity) {
      this.autoHideTimeout = window.setTimeout(() => this.hide(), this.duration);
    }
  }
  handleCloseClick() {
    this.hide();
  }
  handleMouseMove() {
    this.restartAutoHide();
  }
  async handleOpenChange() {
    if (this.open) {
      emit(this, "sl-show");
      if (this.duration < Infinity) {
        this.restartAutoHide();
      }
      await stopAnimations(this.base);
      this.base.hidden = false;
      const { keyframes, options } = getAnimation(this, "alert.show");
      await animateTo(this.base, keyframes, options);
      emit(this, "sl-after-show");
    } else {
      emit(this, "sl-hide");
      clearTimeout(this.autoHideTimeout);
      await stopAnimations(this.base);
      const { keyframes, options } = getAnimation(this, "alert.hide");
      await animateTo(this.base, keyframes, options);
      this.base.hidden = true;
      emit(this, "sl-after-hide");
    }
  }
  handleDurationChange() {
    this.restartAutoHide();
  }
  render() {
    return $$1`
      <div
        part="base"
        class=${o$7({
      alert: true,
      "alert--open": this.open,
      "alert--closable": this.closable,
      "alert--has-icon": this.hasSlotController.test("icon"),
      "alert--primary": this.variant === "primary",
      "alert--success": this.variant === "success",
      "alert--neutral": this.variant === "neutral",
      "alert--warning": this.variant === "warning",
      "alert--danger": this.variant === "danger"
    })}
        role="alert"
        aria-live="assertive"
        aria-atomic="true"
        aria-hidden=${this.open ? "false" : "true"}
        @mousemove=${this.handleMouseMove}
      >
        <span part="icon" class="alert__icon">
          <slot name="icon"></slot>
        </span>

        <span part="message" class="alert__message">
          <slot></slot>
        </span>

        ${this.closable ? $$1`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                class="alert__close-button"
                name="x"
                library="system"
                @click=${this.handleCloseClick}
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
SlAlert.styles = alert_styles_default;
__decorateClass([
  i2('[part="base"]')
], SlAlert.prototype, "base", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlAlert.prototype, "open", 2);
__decorateClass([
  e$7({ type: Boolean, reflect: true })
], SlAlert.prototype, "closable", 2);
__decorateClass([
  e$7({ reflect: true })
], SlAlert.prototype, "variant", 2);
__decorateClass([
  e$7({ type: Number })
], SlAlert.prototype, "duration", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlAlert.prototype, "handleOpenChange", 1);
__decorateClass([
  watch("duration")
], SlAlert.prototype, "handleDurationChange", 1);
SlAlert = __decorateClass([
  n$6("sl-alert")
], SlAlert);
setDefaultAnimation("alert.show", {
  keyframes: [
    { opacity: 0, transform: "scale(0.8)" },
    { opacity: 1, transform: "scale(1)" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("alert.hide", {
  keyframes: [
    { opacity: 1, transform: "scale(1)" },
    { opacity: 0, transform: "scale(0.8)" }
  ],
  options: { duration: 250, easing: "ease" }
});

let AlertasComponent = class AlertasComponent extends connect(rootStore)(s) {
    constructor() {
        super(...arguments);
        this.alertas = [];
    }
    stateChanged(state) {
        var _a;
        this.alertas = ((_a = state.elementoReducer.ui) === null || _a === void 0 ? void 0 : _a.alertas) || [];
    }
    getAlertIcon(tipo) {
        if (tipo === 'success') {
            return $ `<sl-icon slot="icon" name="check2-circle"></sl-icon>`;
        }
        else if (tipo === 'warning') {
            return $ `<sl-icon slot="icon" name="exclamation-triangle"></sl-icon>`;
        }
        else if (tipo === 'danger') {
            return $ `<sl-icon slot="icon" name="exclamation-octagon"></sl-icon>`;
        }
        else {
            return $ `<sl-icon slot="icon" name="info-circle"></sl-icon>`;
        }
    }
    limparAlertas() {
        // limpa o array de alertas para do state.ui.alertas
        rootStore.dispatch(limparAlertas$1());
    }
    removeAlertaById(id) {
        rootStore.dispatch(removerAlerta(id));
    }
    updated(changedProperties) {
        var _a, _b, _c;
        if (changedProperties.has('alertas')) {
            (_a = this.alertas) === null || _a === void 0 ? void 0 : _a.forEach(alerta => {
                var _a, _b;
                (_b = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById(alerta.id)) === null || _b === void 0 ? void 0 : _b.addEventListener('click', event => {
                    event.stopImmediatePropagation();
                    this.removeAlertaById(event.target.id);
                });
            });
            const lexmlEmenda = document.querySelector('lexml-emenda');
            lexmlEmenda.totalAlertas = this.alertas.length;
            const oldValue = ((_b = changedProperties.get('alertas')) === null || _b === void 0 ? void 0 : _b.length) || 0;
            if (lexmlEmenda.totalAlertas > oldValue) {
                const badge = (_c = document.querySelector('#contadorAvisos')) === null || _c === void 0 ? void 0 : _c.querySelector('sl-badge');
                if (badge) {
                    badge.pulse = true;
                }
            }
        }
    }
    render() {
        return $ `
      ${this.alertas.map(alerta => $ ` ${alerta.podeFechar
            ? $ `
                <sl-alert variant="${alerta.tipo}" open>
                  <sl-icon-button name="x" class="alert__close-button" id="${alerta.id}" label="fechar"></sl-icon-button>
                  ${this.getAlertIcon(alerta.tipo)} ${alerta.mensagem}
                </sl-alert>
              `
            : $ ` <sl-alert variant="${alerta.tipo}" open> ${this.getAlertIcon(alerta.tipo)} ${alerta.mensagem} </sl-alert> `}`)}
    `;
    }
};
AlertasComponent.styles = r$2 `
    sl-alert {
      --box-shadow: var(--sl-shadow-x-large);
      margin: 20px;
    }
    .alert__close-button {
      font-size: 1.25rem;
      float: right;
    }
  `;
__decorate([
    e$3({ type: Array })
], AlertasComponent.prototype, "alertas", void 0);
AlertasComponent = __decorate([
    n$1('lexml-eta-alertas')
], AlertasComponent);

let AjudaComponent = class AjudaComponent extends connect(rootStore)(s) {
    constructor() {
        super(...arguments);
        this.acoesMenu = [];
    }
    stateChanged(state) {
        var _a, _b;
        if (((_a = state.elementoReducer.ui) === null || _a === void 0 ? void 0 : _a.events) && ((_b = state.elementoReducer.ui.events[0]) === null || _b === void 0 ? void 0 : _b.stateType) !== 'AtualizacaoAlertas') {
            this.processarStateEvents(state.elementoReducer.ui.events);
        }
    }
    processarStateEvents(events) {
        events === null || events === void 0 ? void 0 : events.forEach((event) => {
            switch (event.stateType) {
                case StateType.ElementoSelecionado:
                case StateType.ElementoMarcado:
                    if (events[events.length - 1] === event && event.elementos) {
                        this.atualizarAjuda(event.elementos[0]);
                    }
                    break;
            }
        });
    }
    atualizarAjuda(elemento) {
        var _a;
        this.elementoSelecionado = elemento;
        this.acoesMenu = ((_a = elemento.acoesPossiveis) !== null && _a !== void 0 ? _a : []).filter((acao) => isAcaoMenu(acao));
    }
    render() {
        return !this.elementoSelecionado || !this.acoesMenu.length
            ? $ ``
            : $ `
          <p>O que você pode fazer com o dispositivo selecionado:</p>
          <ul>
            <li>Sugerir uma nova redação para o dispositivo. Para isso basta alterar o texto do dispositivo selecionado.</li>
            <li>
              Adicionar um novo dispositivo após o dispositivo atual. Para isso vá para o final do texto e pressione a tecla
              <span class="badge">enter</span>.
            </li>
          </ul>

          <p>
            Além disso, clicando no menu de ações
            <span class="badge"><strong>⋮</strong></span> que fica à esquerda do dispositivo selecionado você também pode:
          </p>
          <ul>
            ${this.acoesMenu.map(am => $ ` <li>${am.descricao}</li> `)}
          </ul>
        `;
    }
};
AjudaComponent.styles = r$2 `
    :host {
      padding: 0 10px;
      display: block;
      font-family: var(--sl-font-sans);
      font-size: var(--sl-font-size-small);
      font-weight: var(--sl-font-weight-normal);
    }
  `;
__decorate([
    t$1()
], AjudaComponent.prototype, "elementoSelecionado", void 0);
__decorate([
    t$1()
], AjudaComponent.prototype, "acoesMenu", void 0);
AjudaComponent = __decorate([
    n$1('lexml-ajuda')
], AjudaComponent);

let AjudaModalComponent = class AjudaModalComponent extends s {
    show() {
        this.slDialog.show();
    }
    render() {
        return $ `
      <style>
        :host {
          font-family: var(--sl-font-sans);
        }
      </style>
      <sl-dialog label="Dicas">
        <lexml-ajuda></lexml-ajuda>
        <sl-button slot="footer" variant="primary" @click=${() => this.slDialog.hide()}>Fechar</sl-button>
      </sl-dialog>
    `;
    }
};
__decorate([
    i$1('sl-dialog')
], AjudaModalComponent.prototype, "slDialog", void 0);
AjudaModalComponent = __decorate([
    n$1('lexml-ajuda-modal')
], AjudaModalComponent);

let ComandoEmendaModalComponent = class ComandoEmendaModalComponent extends s {
    atualizarComandoEmenda(comandoEmenda) {
        this.lexmlComandoEmenda.emenda = comandoEmenda;
    }
    show() {
        this.slDialog.show();
    }
    render() {
        return $ `
      <style>
        :host {
          font-family: var(--sl-font-sans);
        }
      </style>
      <sl-dialog label="Comando">
        <lexml-emenda-comando id="comando-emenda-modal" .emenda=${this.comandoEmenda}></lexml-emenda-comando>
        <sl-button slot="footer" variant="primary" @click=${() => this.slDialog.hide()}>Fechar</sl-button>
      </sl-dialog>
    `;
    }
};
__decorate([
    i$1('sl-dialog')
], ComandoEmendaModalComponent.prototype, "slDialog", void 0);
__decorate([
    i$1('#comando-emenda-modal')
], ComandoEmendaModalComponent.prototype, "lexmlComandoEmenda", void 0);
__decorate([
    e$3({ type: Object })
], ComandoEmendaModalComponent.prototype, "comandoEmenda", void 0);
ComandoEmendaModalComponent = __decorate([
    n$1('lexml-emenda-comando-modal')
], ComandoEmendaModalComponent);

let AtalhosModalComponent = class AtalhosModalComponent extends s {
    show() {
        this.slDialog.show();
    }
    render() {
        return $ `
      <style>
        :host {
          font-family: var(--sl-font-sans);
        }
      </style>
      <sl-dialog label="Atalhos">
        <lexml-eta-atalhos></lexml-eta-atalhos>
        <sl-button slot="footer" variant="primary" @click=${() => this.slDialog.hide()}>Fechar</sl-button>
      </sl-dialog>
    `;
    }
};
__decorate([
    i$1('sl-dialog')
], AtalhosModalComponent.prototype, "slDialog", void 0);
AtalhosModalComponent = __decorate([
    n$1('lexml-atalhos-modal')
], AtalhosModalComponent);

let OpcoesImpressaoComponent = class OpcoesImpressaoComponent extends s {
    constructor() {
        super(...arguments);
        this.timerEmitirEventoOnChange = 0;
    }
    set opcoesImpressao(value) {
        this._opcoesImpressao = value ? value : new OpcoesImpressao();
        this.requestUpdate();
    }
    get opcoesImpressao() {
        return this._opcoesImpressao;
    }
    firstUpdated() {
        this.tamanhoFonte.addEventListener('sl-change', (ev) => this._atualizarTamanhoFonte(ev));
    }
    render() {
        var _a, _b, _c, _d;
        return $ `
      <style>
        sl-radio-group::part(base) {
          display: flex;
          flex-direction: column;
          gap: 20px;
          background-color: var(--sl-color-gray-100);
          box-shadow: var(--sl-shadow-x-large);
          flex-wrap: wrap;
          padding: 20px 20px;
        }
        sl-radio-group::part(label) {
          background-color: var(--sl-color-gray-200);
          font-weight: bold;
          border-radius: 5px;
          border: 1px solid var(--sl-color-gray-300);
          padding: 2px 5px;
          box-shadow: var(--sl-shadow-small);
        }

        sl-input::part(form-control) {
        }
        sl-input::part(base) {
        }
        @media (max-width: 480px) {
          sl-input::part(base) {
          }
        }
        sl-select {
          max-width: 400px;
        }
      </style>

      <sl-radio-group label="Opções de impressão" fieldset class="lexml-opcoes-impressao">
        <div>
          <input type="checkbox" id="chk-imprimir-brasao" ?checked=${(_a = this._opcoesImpressao) === null || _a === void 0 ? void 0 : _a.imprimirBrasao} @input=${(ev) => this._atualizarImprimirBrasao(ev)} />
          <label for="chk-imprimir-brasao">Imprimir brasão</label>
        </div>
        <sl-input
          type="text"
          id="input-cabecalho"
          name="textoCabecalho"
          label="Texto do cabeçalho"
          value=${(_b = this._opcoesImpressao) === null || _b === void 0 ? void 0 : _b.textoCabecalho}
          @input=${(ev) => this._atualizarTextoCabecalho(ev)}
        ></sl-input>
        <div>
          <sl-select id="select-tamanho-fonte" label="Tamanho da letra" size="small" value=${(_c = this._opcoesImpressao) === null || _c === void 0 ? void 0 : _c.tamanhoFonte}>
            <sl-menu-item value="14">14</sl-menu-item>
            <sl-menu-item value="16">16</sl-menu-item>
            <sl-menu-item value="18">18</sl-menu-item>
          </sl-select>
        </div>
        <div>
          <input
            type="checkbox"
            id="chk-reduzir-espaco"
            ?checked=${(_d = this._opcoesImpressao) === null || _d === void 0 ? void 0 : _d.reduzirEspacoEntreLinhas}
            @input=${(ev) => this._atualizarReduzirEspacoEntreLinhas(ev)}
          />
          <label for="chk-reduzir-espaco">Reduzir espaço entre linhas</label>
        </div>
      </sl-radio-group>
    `;
    }
    _atualizarTextoCabecalho(ev) {
        this._opcoesImpressao.textoCabecalho = ev.target.value;
    }
    _atualizarImprimirBrasao(ev) {
        this._opcoesImpressao.imprimirBrasao = ev.target.checked;
    }
    _atualizarTamanhoFonte(ev) {
        const valorFonte = parseInt(ev.target.value);
        this._opcoesImpressao.tamanhoFonte = valorFonte;
    }
    _atualizarReduzirEspacoEntreLinhas(ev) {
        this._opcoesImpressao.reduzirEspacoEntreLinhas = ev.target.checked;
    }
    agendarEmissaoEventoOnChange(origemEvento) {
        clearInterval(this.timerEmitirEventoOnChange);
        this.timerEmitirEventoOnChange = window.setTimeout(() => this.emitirEventoOnChange(origemEvento), 500);
    }
    emitirEventoOnChange(origemEvento) {
        this.dispatchEvent(new CustomEvent('onchange', {
            bubbles: true,
            composed: true,
            detail: {
                origemEvento,
            },
        }));
    }
};
OpcoesImpressaoComponent.styles = r$2 `
    .lexml-opcoes-impressao {
      display: block;
      margin: 20px 0 80px 0;
      font-size: 1em;
      max-width: 700px;
    }
  `;
__decorate([
    i$1('#chk-imprimir-brasao')
], OpcoesImpressaoComponent.prototype, "imprimirBrasao", void 0);
__decorate([
    i$1('#input-cabecalho')
], OpcoesImpressaoComponent.prototype, "textoCabecalho", void 0);
__decorate([
    i$1('#chk-reduzir-espaco')
], OpcoesImpressaoComponent.prototype, "reduzirEspacoEntreLinhas", void 0);
__decorate([
    i$1('#select-tamanho-fonte')
], OpcoesImpressaoComponent.prototype, "tamanhoFonte", void 0);
__decorate([
    e$3({ type: Object })
], OpcoesImpressaoComponent.prototype, "opcoesImpressao", null);
OpcoesImpressaoComponent = __decorate([
    n$1('lexml-opcoes-impressao')
], OpcoesImpressaoComponent);

let SwitchRevisaoComponent = class SwitchRevisaoComponent extends connect(rootStore)(s) {
    constructor() {
        super();
        this.quantidadeRevisao = 0;
        this.nomeSwitch = '';
        this.nomeBadgeQuantidadeRevisao = '';
        this.checkedRevisao = false;
        this.modo = '';
        this.onChange = new Observable();
        this.checkedSwitchMarcaAlteracao = () => {
            const switchMarcaAlteracaoView = document.getElementById(this.nomeSwitch);
            setCheckedElement(switchMarcaAlteracaoView, rootStore.getState().elementoReducer.emRevisao);
        };
        this.atualizaQuantidadeRevisao = () => {
            atualizaQuantidadeRevisao(rootStore.getState().elementoReducer.revisoes, document.getElementById(this.nomeBadgeQuantidadeRevisao), this.modo);
        };
    }
    update(changedProperties) {
        super.update(changedProperties);
    }
    createRenderRoot() {
        return this;
    }
    stateChanged(state) {
        var _a;
        if (state.elementoReducer.ui) {
            if (state.elementoReducer.ui.events) {
                if (state.elementoReducer.ui.message && ((_a = state.elementoReducer.ui.events[0]) === null || _a === void 0 ? void 0 : _a.stateType) === 'AtualizacaoAlertas') {
                    alertarInfo(state.elementoReducer.ui.message.descricao);
                }
                this.processarStateEvents(state.elementoReducer.ui.events);
            }
        }
    }
    processarStateEvents(events) {
        events === null || events === void 0 ? void 0 : events.forEach((event) => {
            switch (event.stateType) {
                case StateType.RevisaoAtivada:
                case StateType.RevisaoDesativada:
                    this.checkedSwitchMarcaAlteracao();
                    break;
            }
            this.atualizaQuantidadeRevisao();
            // this.atualiazaRevisaoJusutificativaIcon();
        });
    }
    render() {
        return $ `
      <style>
        #revisoes-justificativa-icon sl-icon {
          border: 1px solid #ccc !important;
          padding: 0.4rem 0.4rem !important;
          border-radius: 15px !important;
          font-weight: bold;
          background-color: #eee;
          cursor: pointer;
        }

        #revisoes-texto-livre-icon sl-icon {
          border: 1px solid #ccc !important;
          padding: 0.4rem 0.4rem !important;
          border-radius: 15px !important;
          font-weight: bold;
          background-color: #eee;
          cursor: pointer;
        }
        #chk-em-revisao {
          border: 1px solid #ccc !important;
          padding: 5px 10px !important;
          border-radius: 20px !important;
          margin-left: auto;
          margin-right: 5px;
          font-weight: bold;
          background-color: #eee;
        }
        #chk-em-revisao[checked] {
          background-color: var(--sl-color-blue-100);
        }
        .revisao-container {
          margin-left: auto;
        }
        .sl-toast-stack sl-alert::part(base) {
          background-color: var(--sl-color-danger-100);
        }
        @media (max-width: 992px) {
          .mobile-buttons {
            display: inline-block !important;
          }
          #chk-em-revisao span {
            display: none;
          }
        }
      </style>
      <div id="toolbar">
        <sl-switch id="${this.nomeSwitch}" size="small" @sl-change=${() => this.ativarDesativarMarcaDeRevisao()}>
          <span>Marcas de revisão</span>
          <sl-badge id="${this.nomeBadgeQuantidadeRevisao}" variant="warning" pill>0</sl-badge>
        </sl-switch>
      </div>
    `;
    }
    ativarDesativarMarcaDeRevisao() {
        ativarDesativarMarcaDeRevisao(rootStore);
        this.checkedSwitchMarcaAlteracao();
    }
};
__decorate([
    e$3({ type: Number })
], SwitchRevisaoComponent.prototype, "quantidadeRevisao", void 0);
__decorate([
    e$3({ type: String })
], SwitchRevisaoComponent.prototype, "nomeSwitch", void 0);
__decorate([
    e$3({ type: String })
], SwitchRevisaoComponent.prototype, "nomeBadgeQuantidadeRevisao", void 0);
__decorate([
    e$3({ type: Boolean, reflect: true })
], SwitchRevisaoComponent.prototype, "checkedRevisao", void 0);
__decorate([
    e$3({ type: String })
], SwitchRevisaoComponent.prototype, "modo", void 0);
SwitchRevisaoComponent = __decorate([
    n$1('lexml-switch-revisao')
], SwitchRevisaoComponent);

// ---------------------------------------------------
Quill.register('modules/aspasCurvas', ModuloAspasCurvas, true);

export { AjudaComponent, AjudaModalComponent, AlertasComponent, ArticulacaoComponent, AtalhosModalComponent, AutoriaComponent, ComandoEmendaComponent, ComandoEmendaModalComponent, DataComponent, EditorComponent, EditorTextoRicoComponent, ElementoComponent, AtalhosComponent as HelpComponent, LexmlAutocomplete, LexmlEmendaComponent, LexmlEmendaConfig, LexmlEmendaParametrosEdicao, LexmlEtaComponent, OpcoesImpressaoComponent, SwitchRevisaoComponent, Usuario };
//# sourceMappingURL=index.js.map
